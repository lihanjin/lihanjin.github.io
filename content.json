{"meta":{"title":"_sUper.LEE的个人空间","subtitle":null,"description":"LEE Blog","author":"_sUper.LEE","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-03-29T14:20:18.358Z","updated":"2018-03-29T10:23:38.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"links: name: 前端路径link: https://zhuanlan.zhihu.com/p/21935921 name: 前端开发笔记link: https://www.gitbook.com/book/li-xinyang/frontend-notebook name: 前端开发手册link: https://dwqs.gitbooks.io/frontenddevhandbook/content/learning/react.html name: 稀土区（大量模板）link: https://xituqu.com/ name: 前端工具集合link: http://www.fefork.com/fetool/ name: 各种前端资源集合link: https://github.com/nicejade/Front-end-tutorial name: 常用的框架库link: http://html5ify.com/fks/#index_前端书籍推荐 name: 前端书籍推荐link: https://github.com/icepy/Front-End-Develop-Guide#fed_library name: angular和ionic教程link: https://github.com/IonicChina/Mobile-front-end-tutorial works_name: jQueryworks_url: http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html works_name: AngularJSworks_url: https://angular.cn/ works_name: Bootstrapworks_url: http://www.bootcss.com/ works_name: Reactworks_url: https://facebook.github.io/react/ works_name: Vue.jsworks_url: https://www.vuejs.com/ works_name: animate.cssworks_url: http://daneden.github.io/animate.css works_name: semantic-uiworks_url: https://semantic-ui.com/collections/menu.html"},{"title":"tools","date":"2018-03-29T14:20:18.361Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"tools/index.html","permalink":"http://yoursite.com/tools/index.html","excerpt":"","text":"name: 前端路径 link: https://zhuanlan.zhihu.com/p/21935921 name: 前端开发笔记 link: https://www.gitbook.com/book/li-xinyang/frontend-notebook name: 前端开发手册 link: https://dwqs.gitbooks.io/frontenddevhandbook/content/learning/react.html name: 稀土区（大量模板） link: https://xituqu.com/ name: 前端工具集合 link: http://www.fefork.com/fetool/ name: 各种前端资源集合 link: https://github.com/nicejade/Front-end-tutorial name: 常用的框架库 link: http://html5ify.com/fks/#index_前端书籍推荐 name: 前端书籍推荐 link: https://github.com/icepy/Front-End-Develop-Guide#fed_library name: angular和ionic教程 link: https://github.com/IonicChina/Mobile-front-end-tutorial works_name: jQuery works_url: http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html works_name: AngularJS works_url: https://angular.cn/ works_name: Bootstrap works_url: http://www.bootcss.com/ works_name: React works_url: https://facebook.github.io/react/ works_name: Vue.js works_url: https://www.vuejs.com/ works_name: animate.css works_url: http://daneden.github.io/animate.css works_name: semantic-ui works_url: https://semantic-ui.com/collections/menu.html"},{"title":"","date":"2018-03-29T14:20:18.359Z","updated":"2018-03-29T10:23:38.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实现数据的双向绑定mvvm-剖析Vue的原理","slug":"vue-mvvm","date":"2018-02-25T09:12:32.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2018/02/25/vue-mvvm/","link":"","permalink":"http://yoursite.com/2018/02/25/vue-mvvm/","excerpt":"","text":"完成的效果 1234567891011121314151617181920212223&lt;div id=\"mvvm-app\"&gt; &lt;input type=\"text\" v-model=\"word\"&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"sayHi\"&gt;change model&lt;/button&gt;&lt;/div&gt;&lt;script src=\"observer.js\"&gt;&lt;/script&gt;&lt;script src=\"watcher.js\"&gt;&lt;/script&gt;&lt;script src=\"compile.js\"&gt;&lt;/script&gt;&lt;script src=\"mvvm.js\"&gt;&lt;/script&gt;&lt;script&gt;var vm = new MVVM(&#123; el: '#mvvm-app', data: &#123; word: 'Hello World!' &#125;, methods: &#123; sayHi: function() &#123; this.word = 'Hi, everybody!'; &#125; &#125; &#125;);&lt;/script&gt; 一、几种实现双向绑定的做法 目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 发布者-订阅者模式（backbone.js） 脏值检查（angular.js） 数据劫持（vue.js） 1.1 发布者-订阅者模式 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(&#39;property&#39;, value)，这里有篇文章讲的比较详细 这种方式现在毕竟太low了，我们更希望通过 vm.property = value这种方式更新数据，同时自动更新视图，于是有了下面两种方式 1.2 脏值检查 angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 1.3 数据劫持 vue.js则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 二、实现思路 已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里 要实现mvvm的双向绑定，就必须要实现以下几点 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 mvvm入口函数，整合以上三者 上述流程如图所示： 2.1 实现Observer 我们知道可以利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。相关代码可以是这样 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; 完整代码 https://github.com/poetries/mvvm/blob/master/observer.js 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样 1234567891011121314151617181920212223242526272829// ... 省略function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; // ... 省略 set: function(newVal) &#123; if (val === newVal) return; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 &#125; &#125;);&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;; 那么问题来了，谁是订阅者，怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚： 12345678910111213141516171819// Observer.js// ...省略Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);// Watcher.jsWatcher.prototype = &#123; get: function(key) &#123; Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; &#125;&#125; 这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能。那么接下来就是实现Compile了 2.2 实现Compile compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图 并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作 解析完成，再将fragment添加回原来的真实dom节点中 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Compile.prototype = &#123; // ... 省略 compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; // 遍历编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125;, compile: function(node) &#123; var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text=\"content\"&gt;&lt;/span&gt; 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) &#123; var exp = attr.value; // content var dir = attrName.substring(2); // text if (me.isEventDirective(dir)) &#123; // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); &#125; else &#123; // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; &#125; &#125;); &#125;&#125;;// 指令处理集合var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, // ...省略 bind: function(node, vm, exp, dir) &#123; var updaterFn = updater[dir + 'Updater']; // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) &#123; // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;&#125;;// 更新函数var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value; &#125; // ...省略&#125;; 完整代码 https://github.com/poetries/mvvm/blob/master/compile.js 这里通过递归遍历保证了每个节点及子节点都会解析编译到 指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=&quot;content&quot;中v-text便是指令 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知 至此，一个简单的Compile就完成了。接下来要看看Watcher这个订阅者的具体实现了 2.3 实现Watcher Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是 在自身实例化时往属性订阅器dep里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 123456789101112131415161718192021222324252627282930313233343536373839404142function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); &#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);Dep.prototype = &#123; notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); // 调用订阅者的update方法，通知变化 &#125;); &#125;&#125;; 完整代码 https://github.com/poetries/mvvm/blob/master/watcher.js 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。 最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了 三、实现MVVM MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 一个简单的MVVM构造器是这样子： 123456function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125; 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: &#39;kindeng&#39;}}); vm._data.name = &#39;dmq&#39;;这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：var vm = new MVVM({data: {name: &#39;kindeng&#39;}}); vm.name = &#39;dmq&#39;; 所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下： 1234567891011121314151617181920212223242526function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; _proxy: function(key) &#123; var me = this; Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;&#125; 完整代码 https://github.com/poetries/mvvm/blob/master/mvvm.js 这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"http://yoursite.com/tags/MVVM/"}]},{"title":"eslint 常用配置","slug":"eslint","date":"2018-01-27T14:41:24.000Z","updated":"2018-03-29T15:13:49.728Z","comments":true,"path":"2018/01/27/eslint/","link":"","permalink":"http://yoursite.com/2018/01/27/eslint/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536'rules': &#123; // no-var 'no-var': 'error', // 要求或禁止 var 声明中的初始化 'init-declarations': 2, // 强制使用单引号 'quotes': ['error', 'single'], // 要求或禁止使用分号而不是 ASI 'semi': ['error', 'never'], // 禁止不必要的分号 'no-extra-semi': 'error', // 强制使用一致的换行风格 'linebreak-style': ['error', 'unix'], // 空格2个 'indent': ['error', 2, &#123;'SwitchCase': 1&#125;], // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 'array-bracket-spacing': [2, 'never'], // 在块级作用域外访问块内定义的变量是否报错提示 'block-scoped-var': 0, // if while function 后面的&#123;必须与if在同一行，java风格。 'brace-style': [2, '1tbs', &#123;'allowSingleLine': true&#125;], // 双峰驼命名格式 'camelcase': 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， 'comma-dangle': [2, 'never'], // 控制逗号前后的空格 'comma-spacing': [2, &#123;'before': false, 'after': true&#125;], // 控制逗号在行尾出现还是在行首出现 'comma-style': [2, 'last'], // 圈复杂度 'complexity': [2, 9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always 'computed-property-spacing': [2, 'never'], // TODO 关闭 强制方法必须返回值，TypeScript强类型，不配置 // 'consistent-return': 0 &#125; 更多配置规则说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174\"no-alert\": 0,//禁止使用alert confirm prompt\"no-array-constructor\": 2,//禁止使用数组构造器\"no-bitwise\": 0,//禁止使用按位运算符\"no-caller\": 1,//禁止使用arguments.caller或arguments.callee\"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名\"no-class-assign\": 2,//禁止给类赋值\"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句\"no-console\": 2,//禁止使用console\"no-const-assign\": 2,//禁止修改const声明的变量\"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1)\"no-continue\": 0,//禁止使用continue\"no-control-regex\": 2,//禁止在正则表达式中使用控制字符\"no-debugger\": 2,//禁止使用debugger\"no-delete-var\": 2,//不能对var声明的变量使用delete操作符\"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/\"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;\"no-dupe-args\": 2,//函数参数不能重复\"no-duplicate-case\": 2,//switch中的case标签不能重复\"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句\"no-empty\": 2,//块语句中的内容不能为空\"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空\"no-empty-label\": 2,//禁止使用空label\"no-eq-null\": 2,//禁止对null使用==或!=运算符\"no-eval\": 1,//禁止使用eval\"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值\"no-extend-native\": 2,//禁止扩展native对象\"no-extra-bind\": 2,//禁止不必要的函数绑定\"no-extra-boolean-cast\": 2,//禁止不必要的bool转换\"no-extra-parens\": 2,//禁止非必要的括号\"no-extra-semi\": 2,//禁止多余的冒号\"no-fallthrough\": 1,//禁止switch穿透\"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3.\"no-func-assign\": 2,//禁止重复的函数声明\"no-implicit-coercion\": 1,//禁止隐式转换\"no-implied-eval\": 2,//禁止使用隐式eval\"no-inline-comments\": 0,//禁止行内备注\"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数）\"no-invalid-regexp\": 2,//禁止无效的正则表达式\"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量\"no-irregular-whitespace\": 2,//不能有不规则的空格\"no-iterator\": 2,//禁止使用__iterator__ 属性\"no-label-var\": 2,//label名不能与var声明的变量名相同\"no-labels\": 2,//禁止标签声明\"no-lone-blocks\": 2,//禁止不必要的嵌套块\"no-lonely-if\": 2,//禁止else语句内只有if语句\"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\"no-mixed-requires\": [0, false],//声明时不能混用声明类型\"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格\"linebreak-style\": [0, \"windows\"],//换行风格\"no-multi-spaces\": 1,//不能用多余的空格\"no-multi-str\": 2,//字符串不能用\\换行\"no-multiple-empty-lines\": [1, &#123;\"max\": 2&#125;],//空行最多不能超过2行\"no-native-reassign\": 2,//不能重写native对象\"no-negated-in-lhs\": 2,//in 操作符的左边不能有!\"no-nested-ternary\": 0,//禁止使用嵌套的三目运算\"no-new\": 1,//禁止在使用new构造一个实例后不赋值\"no-new-func\": 1,//禁止使用new Function\"no-new-object\": 2,//禁止使用new Object()\"no-new-require\": 2,//禁止使用new require\"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number\"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON()\"no-octal\": 2,//禁止使用八进制数字\"no-octal-escape\": 2,//禁止使用八进制转义序列\"no-param-reassign\": 2,//禁止给参数重新赋值\"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接\"no-plusplus\": 0,//禁止使用++，--\"no-process-env\": 0,//禁止使用process.env\"no-process-exit\": 0,//禁止使用process.exit()\"no-proto\": 2,//禁止使用__proto__属性\"no-redeclare\": 2,//禁止重复声明变量\"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错\"no-return-assign\": 1,//return 语句中不能有赋值表达式\"no-script-url\": 0,//禁止使用javascript:void(0)\"no-self-compare\": 2,//不能比较自身\"no-sequences\": 0,//禁止使用逗号运算符\"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格\"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2]\"no-sync\": 0,//nodejs 禁止同步方法\"no-ternary\": 0,//禁止使用三目运算符\"no-trailing-spaces\": 1,//一行结束后面不要有空格\"no-this-before-super\": 0,//在调用super()之前不能使用this或super\"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\";\"no-undef\": 1,//不能有未定义的变量\"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined\"no-undefined\": 2,//不能使用undefined\"no-unexpected-multiline\": 2,//避免多行表达式\"no-underscore-dangle\": 1,//标识符不能以_开头或结尾\"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\"no-unreachable\": 2,//不能有无法执行的代码\"no-unused-expressions\": 2,//禁止无用的表达式\"no-unused-vars\": [2, &#123;\"vars\": \"all\", \"args\": \"after-used\"&#125;],//不能有声明后未被使用的变量或参数\"no-use-before-define\": 2,//未定义前不能使用\"no-useless-call\": 2,//禁止不必要的call和apply\"no-void\": 2,//禁用void操作符\"no-var\": 0,//禁用var，用let和const代替\"no-warning-comments\": [1, &#123; \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" &#125;],//不能有警告备注\"no-with\": 2,//禁用with\"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格\"arrow-parens\": 0,//箭头函数用小括号括起来\"arrow-spacing\": 0,//=&gt;的前/后括号\"accessor-pairs\": 0,//在对象中使用getter/setter\"block-scoped-var\": 0,//块语句中使用var\"brace-style\": [1, \"1tbs\"],//大括号风格\"callback-return\": 1,//避免多次调用回调什么的\"camelcase\": 2,//强制驼峰法命名\"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号\"comma-spacing\": 0,//逗号前后的空格\"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾\"complexity\": [0, 11],//循环复杂度\"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的\"consistent-return\": 0,//return 后面是否允许省略\"consistent-this\": [2, \"that\"],//this别名\"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super\"curly\": [2, \"all\"],//必须使用 if()&#123;&#125; 中的&#123;&#125;\"default-case\": 2,//switch语句最后必须有default\"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾\"dot-notation\": [0, &#123; \"allowKeywords\": true &#125;],//避免不必要的方括号\"eol-last\": 0,//文件以单一的换行符结束\"eqeqeq\": 2,//必须使用全等\"func-names\": 0,//函数表达式必须有名字\"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式\"generator-star-spacing\": 0,//生成器函数*的前后空格\"guard-for-in\": 0,//for in循环要用if语句过滤\"handle-callback-err\": 0,//nodejs 处理错误\"id-length\": 0,//变量名长度\"indent\": [2, 4],//缩进风格\"init-declarations\": 0,//声明时必须赋初值\"key-spacing\": [0, &#123; \"beforeColon\": false, \"afterColon\": true &#125;],//对象字面量中冒号的前后空格\"lines-around-comment\": 0,//行前/行后备注\"max-depth\": [0, 4],//嵌套块深度\"max-len\": [0, 80, 4],//字符串最大长度\"max-nested-callbacks\": [0, 2],//回调嵌套深度\"max-params\": [0, 3],//函数最多只能有3个参数\"max-statements\": [0, 10],//函数内最多有几个声明\"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\"new-parens\": 2,//new时必须加小括号\"newline-after-var\": 2,//变量声明后是否需要空一行\"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格\"object-shorthand\": 0,//强制对象字面量缩写语法\"one-var\": 1,//连续声明\"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的\"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首\"padded-blocks\": 0,//块语句内行首行尾是否要空行\"prefer-const\": 0,//首选const\"prefer-spread\": 0,//首选展开运算\"prefer-reflect\": 0,//首选Reflect的方法\"quotes\": [1, \"single\"],//引号类型 `` \"\" ''\"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号\"radix\": 2,//parseInt必须指定第二个参数\"id-match\": 0,//命名检测\"require-yield\": 0,//生成器函数必须有yield\"semi\": [2, \"always\"],//语句强制分号结尾\"semi-spacing\": [0, &#123;\"before\": false, \"after\": true&#125;],//分号前后空格\"sort-vars\": 0,//变量声明时排序\"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格\"space-before-blocks\": [0, \"always\"],//不以新行开始的块&#123;前面要不要有空格\"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格\"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格\"space-infix-ops\": 0,//中缀操作符周围要不要有空格\"space-return-throw-case\": 2,//return throw case后面要不要加空格\"space-unary-ops\": [0, &#123; \"words\": true, \"nonwords\": false &#125;],//一元运算符的前/后要不要加空格\"spaced-comment\": 0,//注释风格要不要有空格什么的\"strict\": 2,//使用严格模式\"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN()\"valid-jsdoc\": 0,//jsdoc规则\"valid-typeof\": 2,//必须使用合法的typeof的值\"vars-on-top\": 2,//var必须放在作用域顶部\"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格\"wrap-regex\": 0,//正则表达式字面量用小括号包起来\"yoda\": [2, \"never\"]//禁止尤达条件","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://yoursite.com/tags/规范/"},{"name":"eslint","slug":"eslint","permalink":"http://yoursite.com/tags/eslint/"}]},{"title":"RXJS","slug":"RX.js","date":"2018-01-13T13:23:08.000Z","updated":"2018-03-29T15:07:24.407Z","comments":true,"path":"2018/01/13/RX.js/","link":"","permalink":"http://yoursite.com/2018/01/13/RX.js/","excerpt":"","text":"##RX.js ##一、函数式编程-通用函数式 1.ForEach12var arr = [&apos;111&apos;,&apos;222&apos;];arr.forEacj(item =&gt; console.log(item)); 2.map1234567Array.prototype.map = function(callback) &#123; var result; this.forEach((element,index) =&gt; &#123; result.push(callback(element,index)) &#125;); return result;&#125; 3.filter123456789Array.prototype.filter = function(callback) &#123; var result = []; this.forEach((ele,index) =&gt; &#123; if(callback(ele)&#123; result.push(ele) &#125;) &#125;) return result;&#125; 4.concatAll 合并二维数组12345678910Array.prototype.concatAll = function() &#123; var result = []; this.forEach((array) =&gt; &#123; result.push.apply(result,array); //result.push(...array) es6写法 //result.push.call(result,...array) &#125;); return result; &#125; ##二、Observable的基本建立 create of from fromEvent fromPromise never empty throw interval timer 以上为Observable的实例方法creation operator 1.create create是Observable的基本建立方法123456789101112131415161718192021var observable = Rx.Observable .create((observer) =&gt; &#123; observer.next(&apos;111&apos;); observer.next(&apos;222); setTimeout(function () &#123; observer.next(&apos;333&apos;); &#125;) &#125;); console.log(&apos;start&apos;) observable.subscribe(function (val) &#123; console.log(val); &#125;); console.log(&apos;end&apos;) //Observable 相当于推送事件可以同时推送同步和异步时间并且可以暂停 //上面代码会输出: start 111 222 end 333 compelte 2.of 当同步传值时候可以直接使用of更方便简洁1234567891011var observable = Rx.Observable .of(&apos;111&apos;,&apos;222); observable.subscribe(&#123; value =&gt; console.log(vale); error =&gt; console.log(error); () =&gt; console.log(&apos;compelte)&apos; &#125;) //以上程序打印出： 111 222 compelte 3.from from 和of差不多from参数为数组, set, WeakSet, Iterator 12345678910111213141516171819202122232425262728293031323334var arr = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;];var source = Rx.Observable.from(arr); observable.subscribe(&#123; value =&gt; console.log(vale); error =&gt; console.log(error); () =&gt; console.log(&apos;compelte)&apos; &#125;) //以上程序打印出： 111 222 compelte //**from也可以接受字符串，例如&quot;你好&quot;会打印出：&quot;你&quot;,&quot;好&quot;,&quot;compelte&quot;** //也可以传入promise var source = Rx.Observable .from(new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;Hello RxJS!&apos;); &#125;,3000) &#125;)) source.subscribe(&#123; next: function(value) &#123; console.log(value) &#125;, complete: function() &#123; console.log(&apos;complete!&apos;); &#125;, error: function(error) &#123; console.log(error) &#125;&#125;);// Hello RxJS!// complete! 如果promise 返回的是resolve则执行next，如果返回reject执行error，这里使用formPromise返回的结果也是一样的 4.fromEvent12345678910111213var source= Rx.observable.fromEvent(document.body,&apos;click&apos;);source.subscribe(&#123; next: function(value) &#123; console.log(value) &#125;, complete: function() &#123; console.log(&apos;complete!&apos;); &#125;, error: function(error) &#123; console.log(error) &#125;&#125;);//打印出mouseEvent() fromEvent传入的第一个参数为dom，第二个参数为需要监听事件的名称 补充：fromEventPattern 要用Event来建立Observable实例还有另一个方法fromEventPattern，这个方法是给类事件使用。所谓的类事件就是指其行为跟事件相像，同时具有注册监听及移除监听两种行为，就像DOM Event有addEventListener及removeEventListener一样！123456789101112131415161718192021222324252627282930313233343536373839class Producer &#123; constructor() &#123; this.listenList = []; &#125; addListener(listener) &#123; if(typeof listenner === &apos;function&apos;) &#123; this.listenList.push(listenner); &#125; else &#123; console.log(&apos;listenner 必须是方法&apos;) &#125; &#125; removeListener(listener) &#123; this.listerList.splice(this.listerList.indexOf(listener),1) &#125; norify(message) &#123; this.listenList.forEach(listener=&gt; &#123; console.log(message) &#125;) &#125;&#125;//var egghead = new Producer();var souce = Rx.Observable.formEventPattern(&#123; (handle) =&gt; egghead.addListener(handle); (handle) =&gt; eegghead.removeListenner(handle);&#125;);source.subscribe(&#123; next: function(value) &#123; console.log(value) &#125;, complete: function() &#123; console.log(&apos;complete!&apos;); &#125;, error: function(error) &#123; console.log(error) &#125;&#125;);egghandle.notify(&apos;can i listener u&apos;)//can i listener u 这里要注意不要直接将方法传入，避免this出错！也可以用bind来写。 123456Rx.Observable .fromEventPattern( egghead.addListener.bind(egghead), egghead.removeListener.bind(egghead) ) .subscribe(console.log) 5.empty Observable可以订阅一个空的事件，不会返回任何东西会立即返回complete 6.never Observable也可以订阅一个无穷的事件，不会返回任何东西但是会一直存在不会complete 7.thorw 此方法只会抛出错误12345678910111213var source = Rx.Observable.thorw(&quot;thow&quot;);source.subscribe(&#123; next: function(value) &#123; console.log(value) &#125;, complete: function() &#123; console.log(&apos;complete!&apos;); &#125;, error: function(error) &#123; console.log(&apos;Throw Error: &apos; + error) &#125;&#125;);// Throw Error: thow! 8.interval interval必须有一个number数值，代表发出的时间间隔 123456789101112131415var source = Rx.Observable.interval(1000);source.subscribe(&#123; next: function(value) &#123; console.log(value) &#125;, complete: function() &#123; console.log(&apos;complete!&apos;); &#125;, error: function(error) &#123; console.log(&apos;Throw Error: &apos; + error) &#125;&#125;);// 0// 1// 2 9.timer当timer有两个参数时，第一个参数代表要发出第一个值的等待时间(ms)，第二个参数代表第一次之后发送值的间隔时间，所以上面这段程式码会先等一秒送出1之后每五秒送出2, 3, 4, 5…。 timer 第一个参数除了可以是数值(Number)之外，也可以是日期(Date)，就会等到指定的时间在发送第一个值。 另外timer也可以只接收一个参数10.unsubscribe 停止订阅 ###三、Observer观察者 observer分别拥有三个方法 next error complete 观察者的三个方法(method)： next：每当Observable 发送出新的值，next 方法就会被呼叫。 complete：在Observable 没有其他的资料可以取得时，complete 方法就会被呼叫，在complete 被呼叫之后，next 方法就不会再起作用。 error：每当Observable 内发生错误时，error 方法就会被呼叫。 12345678910111213141516171819202122232425var observable = Rx.Observable .create((observer) =&gt; &#123; observer.next(&apos;111&apos;); observer.next(&apos;222); observer.compelte() setTimeout(function () &#123; observer.next(&apos;333&apos;); &#125;) &#125;);var observer = &#123; next: (value) =&gt; &#123; console.log(value) &#125;, error: (error) =&gt; &#123; console.log(value) &#125;, complete: () =&gt; &#123; console.log(&apos;compelte&apos;) &#125;&#125;observable.subscribe(observer); //上面代码会输出: 111 222 //可以看出当compelte执行完之后的next会失效 ###三、Observable的Operators方法 转换（transformation） 过滤（filter） 合并（combination）1.map123var source = Rx.Observable.interval(1000);var newest = source.map(x = x+1);newest.subscribe(console.log()) 珠宝图 Marble diagrams123source: -----0-----1-----2-----3--... map(x =&gt; x + 1)newest: -----1-----2-----3-----4--... 2.mapTo mapTo可以吧传进来的值改成指定的值1234567var source = Rx.Observable.interval(1000);var newest = source.mapTo(2);newest.subscribe(console.log);//222 珠宝图Marble diagrams 123source: -----0-----1-----2-----3--... mapTo(2)newest: -----2-----2-----2-----2--... 3.filter 12345678var source = Rx.Observable.interval(1000);var newest = source.filter(x =&gt; x % 2 === 0); newest.subscribe(console.log);// 0// 2// 4// 6.. 珠宝图Marble diagrams 123source: -----0-----1-----2-----3-----4-... filter(x =&gt; x % 2 === 0)newest: -----0-----------2-----------4-... 4.take take表示取前几个就结束123456789101112var source = Rx.Observable.interval(1000);var example = source.take(3);example.subscribe(&#123; next:(val) =&gt; &#123;console.log(val)&#125;; error: (err) =&gt; &#123;console.log(err)&#125;; complete: () =&gt; &#123;console.log(complete)&#125;;&#125;)//012complete 珠宝图Marble diagrams123source : -----0-----1-----2-----3--.. take(3)example: -----0-----1-----2| 5.first 和take差不多取第一个就结束 1234567891011var source = Rx.Observable.interval(1000);var example = source.first();example.subscribe(&#123; next:(val) =&gt; &#123;console.log(val)&#125;; error: (err) =&gt; &#123;console.log(err)&#125;; complete: () =&gt; &#123;console.log(complete)&#125;;&#125;)//0complete 珠宝图Marble diagrams123source : -----0-----1-----2-----3--.. first()example: -----0| 6.takeUntil 直到某个事件发生以后才结束发出compelte1234567891011121314var source = Rx.Observable.interval(1000);var click = Rx.Observable.fromEvent(document.body, &apos;click&apos;);var example = source.takeUntil(click); example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;, complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;&#125;);// 0// 1// 2// 3// complete (點擊body了 珠宝图Marble diagrams1234source : -----0-----1-----2------3--click : ----------------------c---- takeUntil(click)example: -----0-----1-----2----| 7.concatAll 相当于把二维数组转换成一维数组123456789var click = Rx.Observable.fromEvent(document.body, &apos;click&apos;);var source = click.map(e =&gt; Rx.Observable.of(1,2,3));var example = source.concatAll();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;, complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;&#125;); 珠宝图Marble diagrams1234567891011click : ------c------------c-------- map(e =&gt; Rx.Observable.of(1,2,3))source : ------o------------o-------- \\ \\ (123)| (123)| concatAll()example: ------(123)--------(123)------------ 这里可以看到sourceobservable内部每次发送的值也是observable，这时我们用concatAll就可以把source摊平成example。 这里需要注意的是concatAll会处理source先发出来的observable，必须等到这个observable结束，才会再处理下一个source发出来的observable，让我们用下面这个范例说明。 12345678910111213141516171819202122var obs1 = Rx.Observable.interval(1000).take(5);var obs2 = Rx.Observable.interval(500).take(2);var obs3 = Rx.Observable.interval(2000).take(1);var source = Rx.Observable.of(obs1, obs2, obs3);var example = source.concatAll();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;, complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;&#125;);// 0// 1// 2// 3// 4// 0// 1// 0// complete 8.skip 省略前几个发送的元素 1234567891011var source = Rx.Observable.interval(1000);var example = source.skip(3);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;, complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;&#125;);// 3// 4// 5... 珠宝图123source : ----0----1----2----3----4----5--.... skip(3)example: -------------------3----4----5--... 9.takeLast 取最后第几个值 1234567891011var source = Rx.Observable.interval(1000).take(6);var example = source.takeLast(2);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;, complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;&#125;);// 4// 5// complete 珠宝图123source : ----0----1----2----3----4----5| takeLast(2)example: ------------------------------(45)| 10.last 去最后一个元素12345678910var source = Rx.Observable.interval(1000).take(6);var example = source.last();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log(&apos;Error: &apos; + err); &#125;, complete: () =&gt; &#123; console.log(&apos;complete&apos;); &#125;&#125;);// 5// complete 珠宝图123456source : ----0----1----2----3----4----5| last()example: ------------------------------(5)|``` 11.concat&gt;把多个实例合并成一个 var source = Rx.Observable.interval(1000).take(3);var source2 = Rx.Observable.of(3)var source3 = Rx.Observable.of(4,5,6)var example = source.concat(source2, source3); example.subscribe({ next: (value) =&gt; { console.log(value); }, error: (err) =&gt; { console.log(‘Error: ‘ + err); }, complete: () =&gt; { console.log(‘complete’); }});// 0// 1// 2// 3// 4// 5// 6// complete1珠宝图 source : —-0—-1—-2|source2: (3)|source3: (456)| concat()example: —-0—-1—-2(3456)|1212.startWith&gt;表示一开始要发送的元素可以在前面插入 var source = Rx.Observable.interval(1000);var example = source.startWith(0); example.subscribe({ next: (value) =&gt; { console.log(value); }, error: (err) =&gt; { console.log(‘Error: ‘ + err); }, complete: () =&gt; { console.log(‘complete’); }});// 0// 0// 1// 2// 3…1珠宝图 source : —-0—-1—-2—-3–… startWith(0)example: (0)—-0—-1—-2—-3–…1213.merge&gt;合并多个实例 var source = Rx.Observable.interval(500).take(3);var source2 = Rx.Observable.interval(300).take(6);var example = source.merge(source2); example.subscribe({ next: (value) =&gt; { console.log(value); }, error: (err) =&gt; { console.log(‘Error: ‘ + err); }, complete: () =&gt; { console.log(‘complete’); }});// 0// 0// 1// 2// 1// 3// 2// 4// 5// complete1珠宝图 source : —-0—-1—-2|source2: –0–1–2–3–4–5| merge()example: –0-01–21-3–(24)–5|123merge 的邏輯有點像是 OR(||)，就是當兩個 observable 其中一個被觸發時都可以被處理，這很常用在一個以上的按鈕具有部分相同的行為。例如一個影片播放器有兩個按鈕，一個是暫停(II)，另一個是結束播放(口)。這兩個按鈕都具有相同的行為就是影片會被停止，只是結束播放會讓影片回到 00 秒，這時我們就可以把這兩個按鈕的事件 merge 起來處理影片暫停這件事。 var stopVideo = Rx.Observable.merge(stopButton, endButton); stopVideo.subscribe(() =&gt; { // 暫停播放影片})123https://ithelp.ithome.com.tw/articles/1018763814.combineLatest&gt;首先我們要介紹的是 combineLatest，它會取得各個 observable 最後送出的值，再輸出成一個值，我們直接看範例會比較好解釋。 var source = Rx.Observable.interval(500).take(3);var newest = Rx.Observable.interval(300).take(6); var example = source.combineLatest(newest, (x, y) =&gt; x + y); example.subscribe({ next: (value) =&gt; { console.log(value); }, error: (err) =&gt; { console.log(‘Error: ‘ + err); }, complete: () =&gt; { console.log(‘complete’); }});// 0// 1// 2// 3// 4// 5// 6// 7// complete1珠宝图 source : —-0—-1—-2|newest : –0–1–2–3–4–5| combineLatest(newest, (x, y) =&gt; x + y); example: —-01–23-4–(56)–7|1234567891011121314151617181920首先combineLatest可以接收多个observable，最后一个参数是callback function，这个callback function接收的参数数量跟合并的observable数量相同，依照范例来说，因为我们这里合并了两个observable所以后面的callback function就接收x, y两个参数，x会接收从source发送出来的值，y会接收从newest发送出来的值。最后一个重点就是一定会等两个observable都曾有送值出来才会呼叫我们传入的callback，所以这段程式是这样运行的- newest送出了0，但此时source并没有送出过任何值，所以不会执行callback- source送出了0，此时newest最后一次送出的值为0，把这两个数传入callback得到0。- newest送出了1，此时source最后一次送出的值为0，把这两个数传入callback得到1。- newest送出了2，此时source最后一次送出的值为0，把这两个数传入callback得到2。- source送出了1，此时newest最后一次送出的值为2，把这两个数传入callback得到3。- newest送出了3，此时source最后一次送出的值为1，把这两个数传入callback得到4。- source送出了2，此时newest最后一次送出的值为3，把这两个数传入callback得到5。- source 结束，但newest 还没结束，所以example 还不会结束。- newest送出了4，此时source最后一次送出的值为2，把这两个数传入callback得到6。- newest送出了5，此时source最后一次送出的值为2，把这两个数传入callback得到7。- newest 结束，因为source 也结束了，所以example 结束。不管是source 还是newest 送出值来，只要另一方曾有送出过值(有最后的值)，就会执行callback 并送出新的值，这就是combineLatest。combineLatest 很常用在运算多个因子的结果，例如最常见的BMI 计算，我们身高变动时就拿上一次的体重计算新的BMI，当体重变动时则拿上一次的身高计算BMI，这就很适合用combineLatest 来处理！15.zip&gt;在讲withLatestFrom 之前，先让我们先来看一下zip 是怎么运作的，zip 会取每个observable 相同顺位的元素并传入callback，也就是说每个observable 的第n 个元素会一起被传入callback ，这里我们同样直接用范例讲解会比较清楚 var source = Rx.Observable.interval(500).take(3);var newest = Rx.Observable.interval(300).take(6); var example = source.zip(newest, (x, y) =&gt; x + y); example.subscribe({ next: (value) =&gt; { console.log(value); }, error: (err) =&gt; { console.log(‘Error: ‘ + err); }, complete: () =&gt; { console.log(‘complete’); }});// 0// 2// 4// complete1珠宝图 source : —-0—-1—-2|newest : –0–1–2–3–4–5| zip(newest, (x, y) =&gt; x + y)example: —-0—-2—-4|1234567891011以我们的范例来说，zip会等到source跟newest 都送出了第一个元素，再传入callback，下次则等到source跟newest 都送出了第二个元素再一起传入callback，所以运行的步骤如下：- newest送出了第一个值0，但此时source并没有送出第一个值，所以不会执行callback。- source送出了第一个值0，newest之前送出的第一个值为0，把这两个数传入callback得到0。- newest送出了第二个值1，但此时source并没有送出第二个值，所以不会执行callback。- newest送出了第三个值2，但此时source并没有送出第三个值，所以不会执行callback。- source送出了第二个值1，newest之前送出的第二个值为1，把这两个数传入callback得到2。- newest送出了第四个值3，但此时source并没有送出第四个值，所以不会执行callback。- source送出了第三个值2，newest之前送出的第三个值为2，把这两个数传入callback得到4。- source 结束example 就直接结束，因为source 跟newest 不会再有对应顺位的值zip 会把各个observable 相同顺位送出的值传入callback，这很常拿来做demo 使用，比如我们想要间隔100ms 送出&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;，就可以这么做 var source = Rx.Observable.from(‘hello’);var source2 = Rx.Observable.interval(100); var example = source.zip(source2, (x, y) =&gt; x);12这里的Marble Diagram 就很简单 source : (hello)|source2: -0-1-2-3-4-… zip(source2, (x, y) =&gt; x)example: -h-e-l-l-o|123456这里我们利用zip 来达到原本只能同步送出的资料变成了非同步的，很适合用在建立示范用的资料。建议大家平常没事不要乱用zip，除非真的需要。因为zip 必须cache 住还没处理的元素，当我们两个observable 一个很快一个很慢时，就会cache 非常多的元素，等待比较慢的那个observable。这很有可能造成记忆体相关的问题！16.withLatestFrom&gt;withLatestFrom 运作方式跟combineLatest 有点像，只是他有主从的关系，只有在主要的observable 送出新的值时，才会执行callback，附随的observable 只是在背景下运作。让我们看一个例子 var main = Rx.Observable.from(‘hello’).zip(Rx.Observable.interval(500), (x, y) =&gt; x);var some = Rx.Observable.from([0,1,0,0,0,1]).zip(Rx.Observable.interval(300), (x, y) =&gt; x); var example = main.withLatestFrom(some, (x, y) =&gt; { return y === 1 ? x.toUpperCase() : x;}); example.subscribe({ next: (value) =&gt; { console.log(value); }, error: (err) =&gt; { console.log(‘Error: ‘ + err); }, complete: () =&gt; { console.log(‘complete’); }});1珠宝图Marble diagrams main : —-h—-e—-l—-l—-o|some : –0–1–0–0–0–1| withLatestFrom(some, (x, y) =&gt; y === 1 ? x.toUpperCase() : x); example: —-h—-e—-l—-L—-O|1234567891011withLatestFrom 会在main 送出值的时候执行callback，但请注意如果main 送出值时some 之前没有送出过任何值callback 仍然不会执行！这里我们在main 送出值时，去判断some 最后一次送的值是不是1 来决定是否要切换大小写，执行步骤如下- main送出了h，此时some上一次送出的值为0，把这两个参数传入callback得到h。- main送出了e，此时some上一次送出的值为0，把这两个参数传入callback得到e。- main送出了l，此时some上一次送出的值为0，把这两个参数传入callback得到l。- main送出了l，此时some上一次送出的值为1，把这两个参数传入callback得到L。- main送出了o，此时some上一次送出的值为1，把这两个参数传入callback得到O。withLatestFrom 很常用在一些checkbox 型的功能，例如说一个编辑器，我们开启粗体后，打出来的字就都要变粗体，粗体就像是some observable，而我们打字就是main ###四、实战实现简易拖拉 const dragDOM = document.getElementById(‘drag’);const body = document.body; const mouseDown = Rx.Observable.fromEvent(dragDOM, ‘mousedown’);const mouseUp = Rx.Observable.fromEvent(body, ‘mouseup’);const mouseMove = Rx.Observable.fromEvent(body, ‘mousemove’); mouseDown .map(event =&gt; mouseMove.takeUntil(mouseUp)) .concatAll() .map(event =&gt; ({ x: event.clientX, y: event.clientY })) .subscribe(pos =&gt; { dragDOM.style.left = pos.x + ‘px’; dragDOM.style.top = pos.y + ‘px’; })`","categories":[{"name":"RXJS","slug":"RXJS","permalink":"http://yoursite.com/categories/RXJS/"}],"tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://yoursite.com/tags/RXJS/"}]},{"title":"React之Immutable学习记录（十二）","slug":"react-study-Immutable","date":"2017-11-20T12:10:24.000Z","updated":"2018-03-29T15:27:25.985Z","comments":true,"path":"2017/11/20/react-study-Immutable/","link":"","permalink":"http://yoursite.com/2017/11/20/react-study-Immutable/","excerpt":"","text":"整理于互联网 一、前言 从问题说起：熟悉 React 组件生命周期的话都知道：调用 setState 方法总是会触发 render 方法从而进行 vdom re-render 相关逻辑，哪怕实际上你没有更改到 Component.state 12this.state = &#123;count: 0&#125;this.setState(&#123;count: 0&#125;);// 组件 state 并未被改变，但仍会触发 render 方法 为了避免这种性能上的浪费，React 提供了一个 shouldComponentUpdate 来控制触发 vdom re-render 逻辑的条件。于是 PureRenderMixin 作为一种优化技巧被使用。它仅仅是浅比较对象，深层次的数据结构根本不管用 js中的Immutable Data 在javascript中我们可以通过deep clone来模拟Immutable Data，就是每次对数据进行操作，新对数据进行deep clone出一个新数据 deep clone 当然你或许意识到了，这样非常的慢 1234567891011121314151617181920212223'use strict'; var cloneDeep = require('lodash.clonedeep');var data = &#123; id: 'data', author: &#123; name: 'mdemo', github: 'https://github.com/demohi' &#125;&#125;;var data1 = cloneDeep(data);console.log('equal:', data1===data); //falsedata1.id = 'data1'; data1.author.name = 'demohi';console.log(data.id);// data console.log(data1.id);// data1console.log(data.author.name);//mdemo console.log(data1.author.name);//demohi 这时候 immutableJS 就派得上用场了 123var map1 = Immutable.fromJS(&#123;a:1, b:1, c:&#123;b:&#123;c:&#123;d:&#123;e:7&#125;&#125;&#125;&#125;&#125;);var map2 = Immutable.fromJS(&#123;a:1, b:1, c:&#123;b:&#123;c:&#123;d:&#123;e:7&#125;&#125;&#125;&#125;&#125;);Immutable.is(map1, map2); // true 遍历对象不再用for-in，可以这样: 1Immutable.fromJS(&#123;a:1, b:2, c:3&#125;).map(function(value, key) &#123; /* do some thing */&#125;); 二、什么是 Immutable Data Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象 Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变 同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing····（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。 打印immutableJS看看有什么东西 image.png 一个说明不可变的例子 12345678910111213141516171819202122232425262728293031// 原生对象let a1 = &#123; b: 1, c: &#123; c1: 123 &#125;&#125;;let b1 = a1;b1.b = 2;console.log(a1.b, b1.b); // 2, 2console.log(a1 === b1); // trueconsole.log(a1.c === b1.c); // true// immutable.js 的Maplet a2 = Immutable.fromJS(&#123; b: 1, c: &#123; c1: 123 &#125;&#125;);let b2 = a2.set('b', 2);// 对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象console.log(a2.get('b'), b2.get('b')); // 1, 2 对象 a2 的 b 值并没有变成2。console.log(a2 === b2); // false//如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。console.log(a2.get('c') === b2.get('c')); //true 三、为什么要在React.js中使用Immutable 它是一个完全独立的库，无论基于什么框架都可以用它。意义在于它弥补了Javascript 没有不可变数据结构的问题 由于是不可变的，可以放心的对对象进行任意操作。在React开发中，频繁操作state对象或是store，配合immutableJS快、安全、方便 熟悉React.js的都应该知道，React.js是一个UI = f(states)的框架，为了解决更新的问题，React.js使用了virtual dom，virtual dom通过diff修改dom，来实现高效的dom更新。 但是有一个问题。当state更新时，如果数据没变，你也会去做virtual dom的diff，这就产生了浪费。这种情况其实很常见 当然你可能会说，你可以使用PureRenderMixin来解决呀，PureRenderMixin是个好东西，我们可以用它来解决一部分的上述问题 但PureRenderMixin只是简单的浅比较，不使用于多层比较。那怎么办？自己去做复杂比较的话，性能又会非常差 方案就是使用immutable.js可以解决这个问题。因为每一次state更新只要有数据改变，那么PureRenderMixin可以立刻判断出数据改变，可以大大提升性能 Immutable 优点 Immutable 降低了 Mutable 带来的复杂度 可变（Mutable）数据耦合了 Time和 Value 的概念，造成了数据很难被回溯 节省内存 Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收 123456789import &#123; Map&#125; from 'immutable';let a = Map(&#123; select: 'users', filter: Map(&#123; name: 'Cam' &#125;)&#125;)let b = a.set('select', 'people');a === b; // falsea.get('filter') === b.get('filter'); // true Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 并发安全 传统的并发非常难做，因为要处理各种数据不一致问题，因此『聪明人』发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不需要了。 拥抱函数式编程 Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。 Immutable 缺点 需要学习新的 API 增加了资源文件大小 容易与原生对象混淆 四、Immutable 的几种数据类型 List: 有序索引集，类似JavaScript中的Array。 Map: 无序索引集，类似JavaScript中的Object。 OrderedMap: 有序的Map，根据数据的set()进行排序。 Set: 没有重复值的集合。 OrderedSet: 有序的Set，根据数据的add进行排序。 Stack: 有序集合，支持使用unshift（）和shift（）添加和删除。 Range(): 返回一个Seq.Indexed类型的集合，这个方法有三个参数，start表示开始值，默认值为0，end表示结束值，默认为无穷大，step代表每次增大的数值，默认为1.如果start = end,则返回空集合。 Repeat(): 返回一个vSeq.Indexe类型的集合，这个方法有两个参数，value代表需要重复的值，times代表要重复的次数，默认为无穷大。 Record: 一个用于生成Record实例的类。类似于JavaScript的Object，但是只接收特定字符串为key，具有默认值。 Seq: 序列，但是可能不能由具体的数据结构支持。 Collection: 是构建所有数据结构的基类，不可以直接构建 上面那么多常用的也就是 List和Map 五、几个重要的API1、fromJS() fromJS() 是最最最常用的将原生JS数据转换为ImmutableJS数据的转换方法。使用方式类似于 JSON.parse()，接收两个参数：json 数据和 reviver函数 在不传递reviver函数的情况下，默认将原生JS的Array转为List，Object转为Map 1234567891011121314// 常见const t1 = Immutable.fromJS(&#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;);console.log(t1);// 不常用const t2 = Immutable.fromJS(&#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;, function(key, value) &#123; // 定制转换方式，下这种就是将Array转换为List，Object转换为Map const isIndexed = Immutable.Iterable.isIndexed(value); return isIndexed ? value.toList() : value.toOrderedMap(); // true, \"b\", &#123;b: [10, 20, 30]&#125; // false, \"a\", &#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125; // false, \"\", &#123;\"\": &#123;a: &#123;b: [10, 20, 30]&#125;, c: 40&#125;&#125;&#125;);console.log(t2); 2、is() 先来看官网的一段话: immutable数据应该被当作值而不是对象，值是表示该事件在特定时刻的状态。这个原则对理解不可变数据的适当使用是最重要的。为了将Immutable.js数据视为值，就必须使用Immutable.is()函数或.equals()方法来确定值相等，而不是确定对象引用标识的 === 操作符 所以is()就是用来对两个immutable对象进行值比较的。使用方式类似于 Object.is(obj1, obj2)，接收两个参数 12345678910111213141516const map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);const map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);// 两个不同的对象console.log(map1 === map2); // false// 进行值比较console.log(Immutable.is(map1, map2)); // true// 不仅仅只能比较ImmutableJS的类型的数据console.log(Immutable.is(undefined, undefined)); // trueconsole.log(Immutable.is(null, undefined)); // falseconsole.log(Immutable.is(null, null)); // trueconsole.log(Immutable.is(NaN, NaN)); // true// 区别于 Object.isconsole.log(Object.is(0, -0) ,Immutable.is(-0, 0)); // false , true 3、Map Map 数据类型，对应原生 Object 数组。最最常用的 数据结构之一，循环时无序(orderedMap有序)，对象的 key 可以是任意值。具体看下面的例子 1234console.log(Map().set(List.of(1), 'list-of-one').get(List.of(1)));console.log(Map().set(NaN, 'NaN').get(NaN));console.log(Map().set(undefined, 'undefined').get(undefined));console.log(Map().set(null, 'null').get(null)); 简单介绍 OrderedMap OrderedMap 是 Map 的变体，它除了具有 Map 的特性外，还具有顺序性，当开发者遍历 OrderedMap 的实例时，遍历顺序为该实例中元素的声明、添加顺序。OrderedMap比非有序Map更昂贵，并且可能消耗更多的内存。如果真要求遍历有序，请使用List 4、List List 数据类型，对应原生 Array数组。和原生数组，最大区别不存在’空位’。[, , , , ] 1console.log(List([,,,,]).toJS());// [undefined, undefined, undefined, undefined] 六、API 我们主要介绍Map和 List 创建1、通过构造函数 Map() 构造函数不常用，一般都是通过Immutable.fromJS()将一个JS原生对象转换为一个Immutable对象 2、Map() 123456789101112/* Map&lt;K, V&gt;(): Map&lt;K, V&gt; Map&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): Map&lt;K, V&gt; Map&lt;K, V&gt;(iter: Iterable&lt;any, Array&lt;any&gt;&gt;): Map&lt;K, V&gt; Map&lt;K, V&gt;(obj: Array&lt;Array&lt;any&gt;&gt;): Map&lt;K, V&gt; Map&lt;V&gt;(obj: &#123;[key: string]: V&#125;): Map&lt;string, V&gt; Map&lt;K, V&gt;(iterator: Iterator&lt;Array&lt;any&gt;&gt;): Map&lt;K, V&gt; Map&lt;K, V&gt;(iterable: Object): Map&lt;K, V&gt; */console.log(Map().toJS()); // &#123;&#125;console.log(Map(&#123;key: \"value\"&#125;).toJS()); // &#123;key: \"value\"&#125; 同Key覆盖问题 12//最后的&#123;key: value2&#125; 覆盖了前面的 &#123;key: value&#125;console.log(Map([[\"key\", \"value\"], [\"key\", \"value2\"], [\"key1\", \"value1\"]]).toJS());// &#123;key: \"value2\", key1: \"value1\"&#125; 3、List() 123456789101112/* List&lt;T&gt;(): List&lt;T&gt; List&lt;T&gt;(iter: Iterable.Indexed&lt;T&gt;): List&lt;T&gt; List&lt;T&gt;(iter: Iterable.Set&lt;T&gt;): List&lt;T&gt; List&lt;K, V&gt;(iter: Iterable.Keyed&lt;K, V&gt;): List&lt;any&gt; List&lt;T&gt;(array: Array&lt;T&gt;): List&lt;T&gt; List&lt;T&gt;(iterator: Iterator&lt;T&gt;): List&lt;T&gt; List&lt;T&gt;(iterable: Object): List&lt;T&gt; */console.log(List().toJS()); // []console.log(List([1,2,3,4,&#123;a:123&#125;]).toJS()); // [ 1, 2, 3, 4, &#123;a: 123&#125;] 4、另一种方式 Map.of() 1console.log(Map.of('key1','value1','key2','value2','key3','value3').toJS()); // &#123;key1: \"value1\", key2: \"value2\", key3: \"value3\"&#125; List.of() 1console.log(List.of(&#123;x:1&#125;, 2, [3], 4).toJS()); // [&#123;x:1&#125;, 2, [3], 4] 判断是否是一个Map或者List1、Map判断 判断是否是一个Map , 对原生Object不生效 12console.log(Map.isMap(&#123;&#125;)); // falseconsole.log(Map.isMap(Map(&#123;&#125;))); // true 2、List判断 判断是否是一个List , 对原生Array不生效 12console.log(List.isList([])); // falseconsole.log(List.isList(List([]))); // true 获取大小1、size 1234567// listconsole.log(List([1,2,3,4]).size);// 4console.log(List.of(1, 2, 3, 4).size);// 4// mapconsole.log(Map(&#123;key: \"value2\", key1: \"value1\"&#125;).size);// 2console.log(Map.of(&#123;x:1&#125;, 2, [3], 4).size);// 2 count() 12345678910111213// mapconsole.log(Immutable.fromJS(&#123;key: \"value2\", key1: \"value1\"&#125;).count());// 4// 可以定制条件，来确定大小console.log(Immutable.fromJS(&#123;key: 1, key1: 34&#125;).count((value, key, obj) =&gt; &#123; return value &gt; 3;&#125;));// 1 value大于3的有两个// listconsole.log(Immutable.fromJS([1, 2, 5, 6]).count());// 4// 可以制定条件，来确定 大小console.log(Immutable.fromJS([1, 2, 5, 6]).count((value, index, array) =&gt; &#123; return value &gt; 3;&#125;));// 2 大于3的有两个 countBy() countBy()和count()的区别就是它的返回值是一个对象。 123456789// Mapconsole.log(Immutable.fromJS(&#123;key: 1, key1: 34&#125;).countBy((value, key, obj) =&gt; &#123; return value &gt; 3;&#125;).toJS());// &#123;false: 1, true: 1&#125;// listconsole.log(Immutable.fromJS([1, 2, 5, 6]).countBy((value, index, array) =&gt; &#123; return value &gt; 3;&#125;).toJS());// &#123;false: 2, true: 2&#125; 添加元素1、Set 1234567891011// Map// 将 key 位置的元素替换为 valueconst $obj1 = Map(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;);console.log($obj1.set('a', 0).toJS()); // &#123;a: 0, b: 2, c: 3, d: 444&#125;console.log($obj1.set('e', 99).toJS()); // &#123;a: 1, b: 2, c: 3, d: 444, e: 99&#125;// List// 将 index 位置的元素替换为 value，即使索引越界也是安全的, 空位 undefinedconst $arr1 = List([1, 2, 3]);console.log($arr1.set(-1, 0).toJS()); // [1, 2, 0] 注意-1 等效于 $arr1.set($arr1.size + -1, 0)console.log($arr1.set(4, 0).toJS()); // [ 1, 2, 3, undefined, 0 ] 空位置为了undefined 2、setIn 12345// Mapconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 45, b: 64&#125;]).setIn(['3', 'a'], 1000).toJS());//[1, 2, 3, &#123;a: 1000, b: 64&#125;]// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 45, b: 64&#125;]).setIn(['3', 'a'], 1000).toJS());//[1, 2, 3, &#123;a: 1000, b: 64&#125;] List 特有的添加元素1、插入元素 123// insert(index: number, value: T)// 向 index 位置插入 valueconsole.log(Immutable.fromJS([1, 2, 3]).insert(1, 1.5).toJS()); // [ 1, 1.5, 2, 3 ] 2、设置size 默认值undefined 1console.log(List([]).setSize(2).toJS()); // [undefined, undefined] 3、pop、push、shift、unshift List数据类型也拥有pop、push、shift、unshift这四种操作方法，和原生Array的四种方法使用方式一致，但唯一区别就是返回新的List，并且不改变原来的数组本身，而原生则是会改变元素本身 123456// ImmutableJS：返回新的List，并且不改变元素本身const $test = List([1, 2, 3, 4]);console.log($test.pop().toJS(), $test.toJS()); // [1, 2, 3] [1, 2, 3, 4]// 原生：返回被改变的值，改变元素本身const test = [1, 2, 3, 4];console.log(test.pop(), test); // 4 [1, 2, 3] 4、花样插入 1234567891011121314151617// interpose// 插入xxx之间console.log(Immutable.fromJS([1, 2, 5, 6]).interpose(5555).toJS()); // [1, 5555, 2, 5555, 5, 5555, 6]// interleave// 被操作的两个数组，每个的第一项、第二项、第三项... 组成新的数组。console.log(Immutable.fromJS([1, 2, 5, 6]).interleave(Immutable.fromJS([555, 666])).toJS()); // [1, 555, 2, 666]// zip// 被操作的两个数组，抽离第一项和第二项组成新的子数组，放入到一个大数组中，形成二维数组。console.log(Immutable.fromJS([1, 2, 5, 6]).zip(Immutable.fromJS([555, 666]).toJS())); // [ [1, 555], [2, 666]]// 自定义插入规则。// zipWithconsole.log(Immutable.fromJS([1, 2, 5, 6]).zipWith((a, b) =&gt; &#123; return a + b;&#125;, Immutable.fromJS([555, 666]).toJS())); // [ 556, 668] 删除元素1、delete(key) 123456789// List// delete(index: number)// 删除 index 位置的元素console.log(Immutable.fromJS([1, 2, 3]).delete(1).toJS(), $arr1.toJS());// [ 1, 3 ] [ 1, 2, 3]console.log(Immutable.fromJS([1, 2, 3]).delete(77).toJS(), $arr1.toJS(), '超过范围不会强制报错');// [ 1, 2, 3] [ 1, 2, 3] 超过范围不会强制报错// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).delete('c').toJS(), $obj1.toJS());// &#123;a: 1, b: 2, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125;console.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).delete('asdfasfd').toJS(), $obj1.toJS());// &#123;a: 1, b: 2, c: 3, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125; 2、deleteIn 和 setIn使用方式一致 3、清空元素 lear() 12345// Listconsole.log(Immutable.fromJS([1, 2, 3]).clear().toJS());// []// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).clear().toJS());// &#123;&#125; 修改元素 修改某一个元素 1、set setIn 上面已经介绍过 2、update update(key: K, notSetValue: V, updater: (value: V) =&gt; V): Map&lt;K, V&gt; 123456789101112131415161718192021222324252627// Listconst $arr1 = Immutable.fromJS([1, 2, 3]);console.log($arr1.update('2', (value)=&gt; &#123; return value * 2;&#125;).toJS(), $arr1.toJS());// [1, 2, 6] [1, 2, 3]console.log($arr1.update('6', 1, (value)=&gt; &#123; return value * 2;&#125;).toJS(), $arr1.toJS());// [1, 2, 3, undefined, undefined, undefined, 2] [1, 2, 3]console.log($arr1.update('6', 0, (value)=&gt; &#123; // 默认值必须大于0 感觉有BUG，所以还是不要用了。 return value * 2;&#125;).toJS(), $arr1.toJS());// [1, 2, 3] [1, 2, 3]// Mapconst $obj1 = Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;);console.log($obj1.update('a', (value)=&gt; &#123; return value * 2;&#125;).toJS(), $obj1.toJS());// &#123;a: 2, b: 2, c: 3, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125;console.log($obj1.update('e', 1, (value)=&gt; &#123; return value * 2;&#125;).toJS(), $obj1.toJS());// &#123;a: 1, b: 2, c: 3, d: 444, e: 2&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125;console.log($obj1.update('e', 0, (value)=&gt; &#123; // 默认值入手是number必须大于0 感觉有BUG，所以还是不要用了。 return value * 2;&#125;).toJS(), $obj1.toJS());// &#123;a: 1, b: 2, c: 6, d: 444&#125; &#123;a: 1, b: 2, c: 3, d: 444&#125; 3、updateIn 使用方式和setIn一样。 获取某个元素值1、get getIn 使用方式：get(key: number, notSetValue?: T) 123456789101112131415161718192021222324// Listconst $test = Immutable.fromJS([1111111, 22222, &#123;a: 888123&#125;]);console.log($test.get(0)); // 1111111// 只有数组可以用 number 类型 的keyconsole.log(Immutable.fromJS(&#123;1: 'abc'&#125;).get(1), Immutable.fromJS(&#123;1: 'abc'&#125;).get('1'));// undefined \"abc\" | 只有数组可以用 number 类型 的key// notSetValue 默认值，了解console.log($test.get(11, 'no have value')); // no have value// getInconsole.log($test.getIn(['2', 'a'], 'child no have value')); // 888123console.log($test.getIn(['2', 'b'], 'child no have value')); // child no have value// Mapconst $test = Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;);console.log($test.get('a')); // 1111111// notSetValue 默认值，了解console.log($test.get('v', 'no have value')); // no have value// getInconsole.log($test.getIn(['a', 'a1'], 'child no have value')); // 222console.log($test.getIn(['d', 'b1'], 'child no have value')); // child no have value 2、获取头、尾元素 123456789// Listconst $arr1 = Immutable.fromJS([1, 2, 3]);console.log($arr1.first());// 1console.log($arr1.last());// 3// MapImmutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;);console.log($obj1.first());// &#123;a1: 34&#125;console.log($obj1.last());// 444 查找某个元素1、find() findLast() find()、findLast()返回 value 123456789// Listconsole.log(Immutable.fromJS([1, 2, 56, &#123;a: &#123;b: 111&#125;&#125;]).find((value, index, array) =&gt; &#123; return index === 3;&#125;).toJS());// &#123;a: &#123;b: 111&#125;&#125;// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).find((value, key, obj) =&gt; &#123; return value === 3;&#125;));// 3 2、findKey() findLastKey() findKey()、findLastKey() 返回 key 123456789// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).findKey((value, index, array) =&gt; &#123; return index === 3;&#125;));// 3// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).findKey((value, key, obj) =&gt; &#123; return value === 3;&#125;));// c 3、findEntry() findLastEntry() findEntry()、findLastEntry() 返回 key:value 123456789// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).findEntry((value, index, array) =&gt; &#123; return index === 3;&#125;));// [3, Map]// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).findEntry((value, key, obj) =&gt; &#123; return Immutable.is(value, Immutable.fromJS(&#123;a1: 222&#125;));&#125;));// [\"a\", Map] 4、keyOf() lastKeyOf() keyOf()、lastKeyOf() 根据 value 返回key。 1234567/ Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).keyOf(Immutable.fromJS(&#123;a: &#123;b: 111&#125;&#125;))); // 3console.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).keyOf(2)); // 1// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).keyOf(Immutable.fromJS(&#123;a1: 222&#125;))); // aconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).keyOf(2)); // b List 特有查找某个元素1、indexOf() lastIndexOf() 12// 找不到 返回 -1console.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).indexOf(Immutable.fromJS(&#123;a: &#123;b: 111&#125;&#125;))); // 3 2、findIndex() findLastIndex() 123console.log(Immutable.fromJS([1, 2, 3, &#123;a: &#123;b: 111&#125;&#125;]).findIndex((value, index, array) =&gt; &#123; return value/3 === 1;&#125;)); // 2 查找最大、最小元素 max()、maxBy()默认比较规则为&gt;，min()、minBy()默认比较规则为&gt; 1、max() 123456789101112131415// Listconsole.log(Immutable.fromJS([1, 2, 301, 88]).max()); // 301// 自定义比较规则console.log(Immutable.fromJS([1, 2, 301, 88]).max((valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;)); // 301// Mapconsole.log(Immutable.fromJS(&#123;a: 8888, b: 2, c: 3, d: 444&#125;).max()); // 8888// 自定义比较规则console.log(Immutable.fromJS(&#123;a: 8888, b: 2, c: 3, d: 444&#125;).max((valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;)); // 8888 2、maxBy() 12345678910111213141516171819202122232425// List// 自定义比较的元素console.log(Immutable.fromJS([&#123;a: 2&#125;, &#123;a: 1&#125;, &#123;a: 2301&#125;, &#123;a: 222&#125;]).maxBy((value, index, array) =&gt; &#123; return value.get('a');&#125;).toJS());// &#123;a: 2301&#125;// 自定义比较的元素，和比较规则console.log(Immutable.fromJS([&#123;a: 2&#125;, &#123;a: 1&#125;, &#123;a: 2301&#125;, &#123;a: 222&#125;]).maxBy((value, index, array) =&gt; &#123; return value.get('a');&#125;, (valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;).toJS());// &#123;a: 2301&#125;// Map// 自定义比较的元素console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: &#123;a1: 11&#125;, c: &#123;a1: 33&#125;, d: &#123;a1: 54654&#125;&#125;).maxBy((value, key, obj) =&gt; &#123; return value.get('a1');&#125;).toJS());// &#123;a1: 54654&#125;// 自定义比较的元素，和比较规则console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: &#123;a1: 11&#125;, c: &#123;a1: 33&#125;, d: &#123;a1: 54654&#125;&#125;).maxBy((value, key, obj) =&gt; &#123; return value.get('a1');&#125;, (valueA, valueB) =&gt; &#123; return valueA &gt; valueB;&#125;).toJS());// &#123;a1: 54654&#125; 3、min() 同max() 4、minBy() 同maxBy() 5、keys() values() entries() 获取ES6 Iterable 迭代器 12345678910111213141516171819202122232425262728293031323334// Listconst $test = List([11, 22, 33, 44]);const keys = $test.keys();for (let i of keys) &#123; console.log(i);&#125;const values = $test.values();for (let i of values) &#123; console.log(i);&#125;const entries = $test.entries();for (let i of entries) &#123; console.log(i);&#125;// Mapconst $test = Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;);const keys = $test.keys();for (let i of keys) &#123; console.log(i); // a b c d&#125;const values = $test.values();for (let i of values) &#123; console.log(i); // &#123;a1: 222&#125; 2 3 444&#125;const entries = $test.entries();for (let i of entries) &#123; console.log(i);// [\"a\", Map] [\"b\", 2] [\"c\", 3] [\"d\", 444]&#125; 截取1、slice() 和原生Array slice()用法一致 123456// Listconsole.log(Immutable.fromJS([1, 2, 3]).slice(0).toJS());// [1, 2, 3]// Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).slice(0).toJS());// &#123;a: Object, b: 2, c: 3, d: 444&#125;console.log(Immutable.fromJS(&#123;a: &#123;a1: 34&#125;, b: 2, c: 3, d: 444&#125;).slice(1).toJS());// &#123;b: 2, c: 3, d: 444&#125; 2、rest() butLast() 1234567891011/ List// rest() 返回删除第一个元素后的 Listconsole.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).rest().rest().toJS()); // [&#123;a: 1&#125;, 3, 4, 5, 6]// butLast() 返回删除最后一个元素后的 Listconsole.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).butLast().toJS()); // [1, &#123;a: 1&#125;, 3, 4, 5]// Map// rest() 返回删除第一个元素后的 Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).rest().rest().toJS()); // &#123;c: 3, d: 444&#125;// butLast() 返回删除最后一个元素后的 Mapconsole.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).butLast().toJS()); // &#123;a: &#123;a1: 222&#125;, b: 2, c: 3&#125; 3、skip() skipLast() skipWhile() skipUntil() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// List// skip(number)// 从头按照条件抛出number个元素，对剩余元素进行截取// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).skip(2).toJS()); // [3, 4, 5, 6]// skipLast(number)// 从尾部按照条件抛出number个元素，对剩余元素进行截取// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).skipLast(2).toJS()); // [1, &#123;a: 1&#125;, 3, 4]// skipWhile()// 从头开始循环，抛出满足 return 条件===true 的元素。console.log(Immutable.fromJS([111, 33 , 22, 44, 55, 66]).skipWhile((value, index, array) =&gt; &#123; return value &gt; 31;&#125;).toJS()); // [22, 44, 55, 66]// skipUntil()// 从头开始循环，抛出满足 return 条件===false 的元素。console.log(Immutable.fromJS([32, 33 , 40, 44, 55, 66]).skipWhile((value, index, array) =&gt; &#123; return value &lt; 39;// 抛出直到小于39的元素。&#125;).toJS()); // [40, 44, 55, 66]// Map// skip(number)// 从头开始循环，抛出满足 return 条件===true 的元素。// 参数 数量console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).skip(2).toJS()); // &#123;c: 3, d: 444&#125;// skipLast(number)// 从尾部按照条件抛出number个元素，对剩余元素进行截取// 参数 数量console.log(Immutable.fromJS(&#123;a: &#123;a1: 222&#125;, b: 2, c: 3, d: 444&#125;).skipLast(2).toJS()); // &#123;a: &#123;a1: 222&#125;, b: 2&#125;// skipWhile()// 从头开始循环，抛出满足 return 条件===true 的元素。console.log(Immutable.fromJS(&#123;a: 1, b: 2, c: 3, d: 444&#125;).skipWhile((value, key, obj) =&gt; &#123; return value === 1;&#125;).toJS()); // &#123;b: 2, c: 3, d: 444&#125;// skipUntil()// 从头开始循环，抛出满足 return 条件===false 的元素。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).skipWhile((value, key, obj) =&gt; &#123; return value &lt; 39;// 抛出直到小于39的元素。&#125;).toJS()); // &#123;d: 444&#125; 4、take() takeLast() takeWhile() takeUntil() 123456789101112131415161718192021222324252627282930313233343536373839404142434445// List// take(number)// 从头获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).take(2).toJS()); // [1, &#123;a: 1&#125;]// takeLast(number)// 从尾部获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS([1, &#123;a: 1&#125;, 3, 4, 5, 6]).takeLast(2).toJS()); // [5, 6]// takeWhile()// 从头开始循环，获取满足 return 条件===true 的元素。console.log(Immutable.fromJS([111, 33 , 22, 44, 55, 66]).takeWhile((value, index, array) =&gt; &#123; return value &gt; 31;&#125;).toJS()); //[111, 33]// takeUntil()// 从头开始循环，获取满足 return 条件===false 的元素。console.log(Immutable.fromJS([32, 33 , 40, 44, 55, 66]).takeUntil((value, index, array) =&gt; &#123; return value &gt; 41;&#125;).toJS()); //[32, 33 , 40]// Map// take(number)// 从头获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).take(2).toJS()); // &#123;a: 5, b: 2&#125;// takeLast(number)// 从尾部获取几个复合条件的元素// 参数 数量console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).takeLast(2).toJS()); // &#123;c: 3, d: 444&#125;// takeWhile()// 从头开始循环，获取满足 return 条件===true 的元素。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).takeWhile((value, key, obj) =&gt; &#123; return value &gt; 2;&#125;).toJS()); //&#123;a: 5&#125;// takeUntil()// 从头开始循环，获取满足 return 条件===false 的元素。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).takeUntil((value, key, obj) =&gt; &#123; return value &gt; 39;&#125;).toJS()); //&#123;a: 5, b: 2, c: 3&#125; 循环遍历1、map() filter() every() some() forEach() reduce() reduceRight() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// List//1. map()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).map((value, index, array)=&gt;&#123; return value * 2;&#125;).toJS()); // [2, 4, 6, 8, 10]//2. filter()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).filter((value, index, array)=&gt;&#123; return value % 2 === 0;&#125;).toJS()); // [2, 4]// filterNot() ...这个没有什么卵用//3. every()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).every((value, index, array)=&gt;&#123; return value &gt; 2;&#125;)); // false//4. some()console.log(Immutable.fromJS([1, 2, 3, 4, 5]).some((value, index, array)=&gt;&#123; return value &gt; 2;&#125;)); // true//5. forEach() 返回迭代的条目数（包括返回false的最后一个迭代）// 与Array 的 forEach不同，如果sideEffect的任何调用返回false，迭代将停止。 返回迭代的条目数（包括返回false的最后一个迭代）。console.log(Immutable.fromJS([1, 2, 3, 4, 5, &#123;a: 123&#125;]).forEach((value, index, array)=&gt;&#123; console.log(value, index, array.toJS(), 'forEach'); return value &lt; 5;&#125;)); // 5//6. reduce()// 同原生用法//7. reduceRight()// 同原生用法// Map//1. map()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).map((value, key, obj)=&gt;&#123; return value * 2;&#125;).toJS()); // &#123;a: 10, b: 4, c: 6, d: 888&#125;//2. filter()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).filter((value, key, obj)=&gt;&#123; return value % 2 === 0;&#125;).toJS()); // &#123;b: 2, d: 444&#125;// filterNot() ...这个没有什么卵用//3. every()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).every((value, key, obj)=&gt;&#123; return value &gt; 2;&#125;)); // false//4. some()console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).some((value, key, obj)=&gt;&#123; return value &gt; 2;&#125;)); // true//5. forEach() 返回迭代的条目数（包括返回false的最后一个迭代）// 与Array 的 forEach不同，如果sideEffect的任何调用返回false，迭代将停止。 返回迭代的条目数（包括返回false的最后一个迭代）。console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).forEach((value, key, obj)=&gt;&#123; return value &lt; 444;&#125;)); // 4//6. reduce()// 同原List用法//7. reduceRight()// 同List用法 Map 特有 mapKeys() mapEntries() 对Map元素进行处理，返回处理后的对象 12345678910//mapKeys() 返回对象console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).mapKeys((key)=&gt;&#123; return key + 'hhh';&#125;).toJS());// &#123;ahhh: 5, bhhh: 2, chhh: 3, dhhh: 444&#125;//mapEntries() 返回对象console.log(Immutable.fromJS(&#123;a: 5, b: 2, c: 3, d: 444&#125;).mapEntries(([key, value])=&gt;&#123; return [key + 'aaa', value+'hhhh'];&#125;).toJS());// &#123;aaaa: \"5hhhh\", baaa: \"2hhhh\", caaa: \"3hhhh\", daaa: \"444hhhh\"&#125; mergemerge() mergeDeep() mergeWith() mergeDeepWith() 12345678910111213141516171819202122232425262728293031323334353637383940414243// Listconst $test = Immutable.fromJS([1, 2, 3, 7, &#123;a: &#123;b: 55, c: 66&#125;&#125;]);const $test1 = Immutable.fromJS([1, 2, 3, 6, &#123;a: &#123;b: 333, d: 67&#125;&#125;]);// 浅mergeconsole.log($test.merge($test1).toJS(), $test.toJS());// $test1 -&gt; $test [1, 2, 3, 6, &#123;b: 333, d: 67&#125;] [1, 2, 3, 7, &#123;a: &#123;b: 55, c: 66&#125;&#125;]// 深mergeconsole.log($test.mergeDeep($test1).toJS(), $test.toJS());// $test1 -&gt; $test [1, 2, 3, 6, &#123;b: 333, c: 66, d: 67&#125;] [1, 2, 3, 7, &#123;a: &#123;b: 55, c: 66&#125;&#125;]// 浅merge自定义merge规则console.log($test.mergeWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS());// 深merge自定义merge规则console.log($test.mergeDeepWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS());// Mapconst $test = Immutable.fromJS(&#123;a: &#123;a1: 222, a3: 456&#125;, b: 2, c: 3, d: 444&#125;);const $test1 = Immutable.fromJS(&#123;a: &#123;a1: 222, a2: 234&#125;, b: 2, c: 3, d: 444&#125;);// 浅mergeconsole.log($test.merge($test1).toJS(), $test.toJS());// $test1 -&gt; $test &#123;a: &#123;a1: 222, a2: 234&#125;, b: 2, c: 3, d: 444&#125; &#123;a: &#123;a1: 222, a3: 456&#125;, b: 2, c: 3, d: 444&#125;// 深mergeconsole.log($test.mergeDeep($test1).toJS(), $test.toJS());// $test1 -&gt; $test &#123;a: &#123;a1: 222, a2: 234, a3: 456&#125;, b: 2, c: 3, d: 444&#125; &#123;a: &#123;a1: 222, a3: 456&#125;, b: 2, c: 3, d: 444&#125;// 浅merge自定义merge规则console.log($test.mergeWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS());// 深merge自定义merge规则console.log($test.mergeDeepWith((prev, next)=&gt; &#123; // 自定义转换 return prev;&#125;, $test1).toJS(), $test1.toJS()); jonin() 转换为字符串 使用方式和原生Array的join()一样 1234// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 123, b: 321&#125;]).join()); // 1,2,3,Map &#123; \"a\": 123, \"b\": 321 &#125;// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 444&#125;).join()); // 2,Map &#123; \"a1\": 222, \"a3\": 456 &#125;,3,444 isEmpty() 判空1234// 判断空Listconsole.log(Immutable.fromJS([]).isEmpty()); // true// 判断Map是否为空 比原生方便console.log(Immutable.fromJS(&#123;&#125;).isEmpty()); // true has() hasIn() 检查是否有某个key1234567// Listconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 123, b: 321&#125;]).has('0')); // trueconsole.log(Immutable.fromJS([1, 2, 3, &#123;a: 123, b: 321&#125;]).hasIn([3, 'b'])); // true// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 444&#125;).has('a')); // trueconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 444&#125;).hasIn(['a', 'a3'])); // true includes() 是否包含某些元素 includes()、contains()这俩等效 1234567891011// List// 对象是否包含某个元素，对Immutable元素使用Immutable.is 进行比较console.log(Immutable.fromJS([6, 5, 4, 3, 2, 1, 89]).includes('89'));// 数组没有字符89，所以返回 falseconsole.log(Immutable.fromJS([6, 5, 4, 3, 2, 1, '89']).contains('89'));// trueconsole.log(Immutable.fromJS([6, 5, 4, 3, 2, 1, Immutable.fromJS([6, 5, 4])]).contains(Immutable.fromJS([6, 5, 4])));// true// Map// 对象是否包含某个元素，对Immutable元素使用Immutable.is 进行比较console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 89&#125;).includes('89'));// 数组没有字符89，所以返回 falseconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: '89'&#125;).contains('89'));// trueconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: Immutable.fromJS([6, 5, 4])&#125;).contains(Immutable.fromJS([6, 5, 4])));// true isSubset() 子集判断1234567891011// List// isSubset()console.log(Immutable.fromJS([6, 5, 1, [6, 5, 4]]).isSubset(Immutable.fromJS([[6, 5, 4], 6, 5, 4, 3, 2, 1, '89'])));// true// isSuperset 就是 isSubset 参数掉个个儿console.log(Immutable.fromJS([[6, 5, 4], 6, 5, 4, 3, 2, 1, '89']).isSuperset(Immutable.fromJS([6, 5, 1, [6, 5, 4]])));// true// Map// isSubset()console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;&#125;).isSubset(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 5&#125;)));// true// isSuperset 就是 isSubset 参数掉个个儿console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 5&#125;).isSuperset(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;&#125;)));// true reverse() 反转123456// Listconsole.log(Immutable.fromJS([1, 2, 3, 4, 5, 6]).reverse().toJS());// [6, 5, 4, 3, 2, 1]// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: 222, a3: 456&#125;, c: 3, d: 5&#125;).reverse().toJS());// &#123;d: 5, c: 3, a: &#123;a1: 222, a3: 456&#125;, b: 2&#125; 排序 sort()和sortBy() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// List// sort(comparator?: (valueA: V, valueB: V) =&gt; number): Iterable&lt;K, V&gt;console.log(Immutable.fromJS([6, 5, 4, 3, 2, 1]).sort().toJS());// 传入比较函数console.log(Immutable.fromJS([1, 2, 3, 4, 5, 6]).sort((a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// sortBy/* sortBy&lt;C&gt;( comparatorValueMapper: (value: T, key: number, iter: Iterable&lt;number, T&gt;) =&gt; C, comparator?: (valueA: C, valueB: C) =&gt; number ): Iterable&lt;number, T&gt; */console.log(Immutable.fromJS([&#123;a: 1, b: &#123;c: 22&#125;&#125;, &#123;a: 2, b: &#123;c: 22&#125;&#125;, &#123;a: 1, b: &#123;c: 22&#125;&#125;, &#123;a: 3, b: &#123;c: 22&#125;&#125;, &#123;a: 10, b: &#123;c: 22&#125;&#125;, &#123;a: 9, b: &#123;c: 22&#125;&#125;]).sortBy((value, index, array)=&gt; &#123; return value.get('a')&#125;,(a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: 88, c: 3, d: 5&#125;).sort().toJS());// &#123;b: 2, c: 3, d: 5, a: 88&#125;// 传入比较函数console.log(Immutable.fromJS(&#123;b: 2, a: 88, c: 3, d: 5&#125;).sort((a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// &#123;b: 2, c: 3, d: 5, a: 88&#125;// sortBy/*sortBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: Iterable&lt;number, T&gt;) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): Iterable&lt;number, T&gt;*/console.log(Immutable.fromJS(&#123;b: &#123;a: 2&#125;, a: &#123;a: 88&#125;, c: &#123;a: 3&#125;, d: &#123;a: 5&#125;&#125;).sortBy((value, key, obj)=&gt; &#123; return value.get('a')&#125;,(a, b) =&gt; &#123; if (a &lt; b) &#123; return -1; &#125; if (a &gt; b) &#123; return 1; &#125; if (a === b) &#123; return 0; &#125;&#125;).toJS());// &#123;b: &#123;a: 2&#125;, c: &#123;a: 3&#125;, d: &#123;a: 5&#125;, a: &#123;a: 88&#125;&#125; flatten() 平铺 参数默认情况下，false 深度平铺，true 浅度平铺1层 1234567891011// Listconsole.log(Immutable.fromJS([1, 2, 3, 4, [1, 11, 111, 12344], &#123;a: 1234, b: &#123;bb: [777, 888]&#125;&#125;, 5, 6]).flatten().toJS());// [1, 2, 3, 4, 1, 11, 111, 12344, 1234, 777, 888, 5, 6]console.log(Immutable.fromJS([1, 2, 3, 4, [1, 11, 111, 12344], &#123;a: 1234, b: &#123;bb: [777, 888]&#125;&#125;, 5, 6]).flatten(true).toJS());// [1, 2, 3, 4, 1, 11, 111, 12344, 1234, Object, 5, 6]// Mapconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).flatten().toJS());// &#123;0: 1, 1: 2, 2: 3, b: 2, a5: 333, c: 3, d: 5&#125;console.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).flatten(true).toJS());// &#123;b: 2, a1: Object, a3: Array[3], c: 3, d: 5&#125; groupBy() 分组 返回值是OrderedMap 1234567891011// Listconsole.log(Immutable.fromJS([&#123;v: 0, a: 111&#125;, &#123;v: 1, a: &#123;b: [1, 2, 3]&#125;&#125;, &#123;v: 1, a: 333&#125;, &#123;v: 0, a: &#123;b: [1, 2, 3]&#125;&#125;, &#123;v: 1, a: 333&#125;]).groupBy((value) =&gt; &#123; return value.get('a')&#125;).toJS());// OrderedMap &#123;111: Array[1], 333: Array[2], Map &#123; \"b\": List [ 1, 2, 3 ] &#125;: Array[2]&#125;// Mapconsole.log(Immutable.fromJS(&#123;b: &#123;a5: 333&#125;, a: &#123;a5: 333&#125;, c: &#123;a5: 334&#125;, d: &#123;a5: 334&#125;&#125;).groupBy((value) =&gt; &#123; return value.get('a5')&#125;).toJS());// OrderedMap &#123;333: &#123;b: &#123;a5: 333&#125;, a: &#123;a5: 333&#125;&#125;, 334: &#123;c: &#123;a5: 334&#125;, d: &#123;a5: 334&#125;&#125;&#125; flip() Map 特有翻转1console.log(Immutable.fromJS(&#123;b: 'b1', a: 'a1', c: 'c1', d: 'd1'&#125;).flip().toJS()); // &#123;b1: \"b\", a1: \"a\", c1: \"c\", d1: \"d\"&#125; 连接 concat()1234567891011// Listconst $test1 = Immutable.fromJS([1, 2, 3, 4, 5, 6]);const $test2 = Immutable.fromJS([111, 222, 333, 444, 555, 666]);console.log($test1.concat($test2).toJS()); //[1, 2, 3, 4, 5, 6, 111, 222, 333, 444, 555, 666]console.log($test1.toJS(), $test2.toJS()); //[1, 2, 3, 4, 5, 6] [111, 222, 333, 444, 555, 666]// Mapconst $test1 = Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;);const $test2 = Immutable.fromJS(&#123;b1: 22, b: 34&#125;);console.log($test1.concat($test2).toJS()); //&#123;b: 34, a: Object, c: 3, d: 5, b1: 22&#125; 属性 b 被覆盖console.log($test1.toJS(), $test2.toJS()); //&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, c: 3, d: 5&#125; b1: 22, b: 34&#125; 类型转换1、转换为原生类型 123456789101112131415161718192021// List// 浅层// toArrayconsole.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, &#123;a: &#123;b: [1234, 22]&#125;&#125;]).toArray());// [1, 2, 3, 4, 5, 6, Map]console.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, [1234, 22]]).toArray());// [1, 2, 3, 4, 5, 6, List]// toObjectconsole.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, &#123;a: &#123;b: [1234, 22]&#125;&#125;]).toObject());// &#123;0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: Map&#125;console.log(Immutable.fromJS([1, 2, 3, 4, 5, 6, [1234, 22]]).toObject());// &#123;0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: List&#125;//深层// 就是一直在用的 toJS(); 不到万不得已，尽量不用。// Map// 浅层// toArrayconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).toArray());// [2, Map, 3, 5]console.log(Immutable.fromJS(&#123;b: 2, a: [1, 2, 2], c: 3, d: 5&#125;).toArray());// [2, List, 3, 5]// toObjectconsole.log(Immutable.fromJS(&#123;b: 2, a: &#123;a1: &#123;a5: 333&#125;, a3: [1,2,3]&#125;, c: 3, d: 5&#125;).toObject());// &#123;b: 2, a: Map, c: 3, d: 5&#125;console.log(Immutable.fromJS(&#123;b: 2, a: [1, 2, 2]&#125;).toObject());// &#123;b: 2, a: List&#125;//深层// 就是一直在用的 toJS(); 不到万不得已，尽量不用。 2、转换为其他ImmutableJS数据类型 123456// toMap()// toOrderedMap()// toSet()// toOrderedSet()// toList()// toStack() 七、和React Redux 架构的结合 利用 immutable.js 不可变的特性，可以极大的优化React render的冗余执行。React 官方提供的PureRenderMixin是浅比较 1、immutable-pure-render-decorator 专门针对immutable的PureRenderMixin，用来装饰React组件 12345678910111213141516171819202122232425import &#123;React&#125; from 'base';import pureRenderDecorator from '../../../widgets/libs/immutable-pure-render-decorator';@pureRenderDecoratorexport default class PartA extends React.Component &#123; constructor(props) &#123; super(props); // 舍弃React.addons.PureRenderMixin // this.shouldComponentUpdate = React.addons.PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; console.log('组件PartA，render执行了'); const data = this.props.data; return ( &lt;section&gt; &lt;div&gt; &lt;p&gt;我是组件PartA&lt;/p&gt; &lt;p&gt;&#123;data.toJSON ? JSON.stringify(data.toJSON()) : data&#125;&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; ) &#125;&#125; 2、优化shouldComponentUpdate() 我们都知道官方提供的React.addons.PureRenderMixin提供的shouldComponentUpdate()，只能进行浅比较，对于引用类型Object、Array比较无力，而如果使用Immutable的Map和List替换Object、Array，则可以使用Immutable.is()来比较两个引用类型，从而补充了React.addons.PureRenderMixin的漏洞。 3、高阶组件封装 对于使用immutable.js的项目，在应用公共组件的时候，由于公共组件的内部实现一定是原生JS数据，所以我们只能传递原生JS数据到公共组件，但是如果转换成了原生JS数据，就又会出现&quot;React.addons.PureRenderMixin提供的shouldComponentUpdate()`是浅比较”问题，对此可以使用下面的高阶组件进行封装 12345678910111213141516import &#123;React&#125; from 'base';// 通过Immutable.is 封装过的 shouldComponentUpdateimport &#123;shouldComponentUpdate&#125; from '../immutable-pure-render-decorator';export default ComposedComponent =&gt; &#123; return class extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = shouldComponentUpdate.bind(this); &#125; render() &#123; const props = this.props.toJS ? this.props.toJS() : this.props; return &lt;ComposedComponent &#123;...this.props&#125; &#123;...props&#125; /&gt;; &#125; &#125;&#125;; 3、Demo 12345678910111213141516171819202122232425262728import &#123;React&#125; from 'base';import &#123; connect &#125; from 'react-redux';import highComponent from '../../../../widgets/libs/utils/highComponent';import actions from '../../actions';// 公共组件import Dialog from '@alife/dialog';// import Immutable from 'immutable';function mapStateToProps(state) &#123; return &#123; open: state.getIn(['dialog', 'open']), title: state.getIn(['dialog', 'title']) &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onPrimaryTouchTap: ()=&gt; &#123; dispatch(actions.toggleDialog(false)); &#125;, onSecondaryTouchTap: ()=&gt; &#123; dispatch(actions.toggleDialog(false)); &#125; &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(highComponent(Dialog))//通过高阶组件封装 八、思维导图总结API https://www.processon.com/view/link/5a12c0ede4b0d53d979b33da 九、更多参考 facebook.github.io/immutable-js/docs/","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"Immutable","slug":"Immutable","permalink":"http://yoursite.com/tags/Immutable/"}]},{"title":"React之React Router 4（十一）","slug":"react-study-router-4-xx","date":"2017-11-19T16:06:10.000Z","updated":"2018-03-29T15:27:26.058Z","comments":true,"path":"2017/11/20/react-study-router-4-xx/","link":"","permalink":"http://yoursite.com/2017/11/20/react-study-router-4-xx/","excerpt":"","text":"一、React-router V4版本修改内容及一些坑1、所有组件更改为从react-router-dom导入 12345678//v2import &#123;Router,Route,hashHistory&#125; from 'react-router';// 4.xx写法//v4import &#123;Route,BrowserRouter as Router, Switch&#125; from 'react-router-dom';// 如果搭配redux，你还需要使用react-router-redux 2、将所有替换为 123456//v2 &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;PCIndex&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/details/:uniqueky\" component=&#123;PCNewsDetails&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/usercenter\" component=&#123;PCUserCenter&#125;&gt;&lt;/Route&gt; &lt;/Router&gt; 现在需要更改为BrowserRouter 这里的代码不仅仅是将Router替换为BrowserRouter,而且还把所有的Route中用Switch包裹起来. 12345678//v4&lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;MobileIndex&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/details/:uniqueky\" component=&#123;MobileNewsDetails&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/usercenter\" component=&#123;MobileUserCenter&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; 3、只能有一个子节点 &lt;BroserRouter&gt;只能有一个子节点,所以官网建议的是使用&lt;Switch&gt;进行包裹 123456// v3&lt;Route path='/' component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path='about' component=&#123;About&#125; /&gt; &lt;Route path='contact' component=&#123;Contact&#125; /&gt;&lt;/Route&gt; 12345678// v4const App = () =&gt; ( &lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125; /&gt; &lt;Route path='/about' component=&#123;About&#125; /&gt; &lt;Route path='/contact' component=&#123;Contact&#125; /&gt; &lt;/Switch&gt;) 4、最坑的地方:在当前目录下的文件路径不再使用./, 而是直接用/. 在进行文件引用的时候 ,./src/js的写法需要更改文’/src/js‘, 这是更改之后最坑的地方 二、安装 react-router-dom暴露出react-router中暴露的对象与方法，因此你只需要安装并引用react-router-dom即可 1npm install --save react-router-dom 三、路由器(Router) 在你开始项目前，你需要决定你使用的路由器的类型。对于网页项目，存在&lt;BrowserRouter&gt;与&lt;HashRouter&gt;两种组件。当存在服务器来管理动态请求时，需要使用&lt;BrowserRouter&gt;组件，而&lt;HashRouter&gt;被用于静态网站。通常，我们更倾向选择&lt;BrowserRouter&gt;，但如果你的网站仅用来呈现静态文件，那么&lt;HashRouter&gt;将会是一个好选择 四、历史(History) 每个路由器都会创建一个history对象并用其保持追踪当前location[注1]并且在有变化时对网站进行重新渲染。这个history对象保证了React Router提供的其他组件的可用性，所以其他组件必须在router内部渲染。一个React Router组件如果向父级上追溯却找不到router组件，那么这个组件将无法正常工作 五、渲染 路由器组件无法接受两个及以上的子元素。基于这种限制的存在，创建一个&lt;App&gt;组件来渲染应用其余部分是一个有效的方法 123456import &#123; BrowserRouter &#125; from 'react-router-dom'ReactDOM.render(( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;), document.getElementById('root')) 六、&lt;App&gt; 应用通过&lt;App&gt;组件定义。简化一下，我们将应用拆分成两个部分。&lt;Header&gt;组件包含网站的导航链接。&lt;Main&gt;组件则呈现其余内容 123456const App = () =&gt; ( &lt;div&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;/div&gt;) 七、路由(Route) &lt;Route&gt;组件是React Router中主要的结构单元。在任意位置只要匹配了URL的路径名(pathname)你就可以创建&lt;Route&gt;元素进行渲染 1、路径(Path) &lt;Route&gt;接受一个数为string类型的path，该值路由匹配的路径名的类型。例如：&lt;Route path=&#39;/roster&#39;/&gt;会匹配以/roster开头的路径名。在当前path参数与当前location的路径相匹配时，路由就会开始渲染React元素。若不匹配，路由不会进行任何操作 123456&lt;Route path='/roster'/&gt;// 当路径名为'/'时, path不匹配// 当路径名为'/roster'或'/roster/2'时, path匹配// 当你只想匹配'/roster'时，你需要使用\"exact\"参数// 则路由仅匹配'/roster'而不会匹配'/roster/2'&lt;Route exact path='/roster'/&gt; 注意：在匹配路由时，React Router只关注location的路径名。当URL如下时 1http://www.example.com/my-projects/one?extra=false React Router去匹配的只是&#39;/my-projects/one&#39;这一部分 2、匹配路径 path-to-regexp包用来决定route元素的path参数与当前location是否匹配。它将路径字符串编译成正则表达式，并与当前location的路径名进行匹配比较 当路由地址匹配成功后，会创建一个含有以下属性的match对象： url ：与当前location路径名所匹配部分 path：路由的地址 isExact ：path 是否等于 pathname params：从path-to-regexp获取的路径中取出的值都被包含在这个对象中 使用route tester这款工具来对路由与URL进行检验 3、创建你的路由 可以在路由器(router)组件中的任意位置创建多个&lt;Route&gt;，但通常我们会把它们放在同一个位置。使用&lt;Switch&gt;组件来包裹一组&lt;Route&gt;。&lt;Switch&gt;会遍历自身的子元素（即路由）并对第一个匹配当前路径的元素进行渲染 我们希望匹配一下路径 /：主页 /roster： 团体列表 /roster/:number：运动员页面，使用运动员的编号作为标识 /schedule：团队的赛程表 为了在应用中能匹配路径，在创建&lt;Route&gt;元素时必须带有需要匹配的path作为参数 123456&lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125;/&gt; &#123;/* both /roster and /roster/:number begin with /roster */&#125; &lt;Route path='/roster' component=&#123;Roster&#125;/&gt; &lt;Route path='/schedule' component=&#123;Schedule&#125;/&gt;&lt;/Switch&gt; 4、&lt;Route&gt;是如何渲染的？ 当一个路由的path匹配成功后，路由用来确定渲染结果的参数有三种。只需要提供其中一个即可 component ： 一个React组件。当带有component参数的route匹配成功后，route会返回一个新的元素，其为component参数所对应的React组件（使用React.createElement创建）。 render ： 一个返回React element的函数。当匹配成功后调用该函数。该过程与传入component参数类似，并且对于行级渲染与需要向元素传入额外参数的操作会更有用。 children ： 一个返回React element的函数。与上述两个参数不同，无论route是否匹配当前location，其都会被渲染 12345678910&lt;Route path='/page' component=&#123;Page&#125; /&gt;const extraProps = &#123; color: 'red' &#125;&lt;Route path='/page' render=&#123;(props) =&gt; ( &lt;Page &#123;...props&#125; data=&#123;extraProps&#125;/&gt;)&#125;/&gt;&lt;Route path='/page' children=&#123;(props) =&gt; ( props.match ? &lt;Page &#123;...props&#125;/&gt; : &lt;EmptyPage &#123;...props&#125;/&gt;)&#125;/&gt; 通常component参数与render参数被更经常地使用。children参数偶尔会被使用，它更常用在path无法匹配时呈现的’空’状态。在本例中并不会有额外的状态，所以我们将使用&lt;Route&gt;的component参数 通过&lt;Route&gt;渲染的元素会被传入一些参数。分别是match对象，当前location对象以及history对象（由router创建） 5、&lt;Main&gt; 现在我们清楚了根路由的结构，我们需要实际渲染我们的路由。对于这个应用，我们将会在&lt;Main&gt;组件中渲染&lt;Switch&gt;与&lt;Route&gt;，这一过程会将route匹配生成的HTML放在&lt;main&gt;节点中 12345678910import &#123; Switch, Route &#125; from 'react-router-dom'const Main = () =&gt; ( &lt;main&gt; &lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125;/&gt; &lt;Route path='/roster' component=&#123;Roster&#125;/&gt; &lt;Route path='/schedule' component=&#123;Schedule&#125;/&gt; &lt;/Switch&gt; &lt;/main&gt;) 注意：主页路由包含额外参数。该参数用来保证路由能准确匹配path 6、嵌套路由 123456789101112131415161718192021222324252627282930313233// v3import React from \"react\";import &#123; render &#125; from \"react-dom\";import &#123; Router, Route, IndexRoute, Link, browserHistory &#125; from \"react-router\";const PrimaryLayout = props =&gt; &lt;div className=\"primary-layout\"&gt; &lt;header&gt;Our React Router 3 App&lt;/header&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/user\"&gt;User&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;main&gt; &#123;props.children&#125; &lt;/main&gt; &lt;/div&gt;;const HomePage = () =&gt; &lt;h1&gt;Home Page&lt;/h1&gt;;const UsersPage = () =&gt; &lt;h1&gt;User Page&lt;/h1&gt;;const App = () =&gt; &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;PrimaryLayout&#125;&gt; &lt;IndexRoute component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UsersPage&#125; /&gt; &lt;/Route&gt; &lt;/Router&gt;;render(&lt;App /&gt;, document.getElementById(\"root\")); 上面代码中有几个关键的点在 V4 中就不复存在了 集中式 router 通过 &lt;Route&gt; 嵌套，实现Layout 和 page 嵌套 Layout 和 page组件 是作为 router 的一部分 12345678910111213141516171819202122232425262728293031// v4import React from \"react\";import &#123; render &#125; from \"react-dom\";import &#123; BrowserRouter, Route, Link &#125; from \"react-router-dom\";const PrimaryLayout = () =&gt; &lt;div className=\"primary-layout\"&gt; &lt;header&gt;Our React Router 4 App&lt;/header&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/User\"&gt;User&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;main&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;;const HomePage = () =&gt; &lt;h1&gt;Home Page&lt;/h1&gt;;const UsersPage = () =&gt; &lt;h1&gt;User Page&lt;/h1&gt;;const App = () =&gt; &lt;BrowserRouter&gt; &lt;PrimaryLayout /&gt; &lt;/BrowserRouter&gt;;render(&lt;App /&gt;, document.getElementById(\"root\")); 首先，V3 中的 router 不在了，在 V3 中，我们是将整个庞大的router 直接丢给 DOM，而在 V4 中，除了 BrowserRouter， 我们丢给 DOM 的是我们的应用程序本身 V4中，我们不再使用 {props.children} 来嵌套组件了，替代的 &lt;Route&gt;，当 route匹配时，子组件会被渲染到 &lt;Route&gt;书写的地方 基本使用 react-router 4.0 对于接受参数采用 { this.props.match.params.id } 如下例子：&lt;Route path=&quot;list/:id&quot;&gt;&lt;/Router&gt;、 &lt;Link to=&quot;list/123456&quot;&gt;&lt;/Link&gt; 一个完整的嵌套路由的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// import &#123; Router, Route, Link, Switch &#125; from ‘react-router‘;import &#123; HashRouter, Route, Link, Switch&#125; from ‘react-router-dom‘;class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/inbox\"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;const About = () =&gt; ( &lt;div&gt; &lt;h3&gt;About&lt;/h3&gt; &lt;/div&gt;)const Home = () =&gt; ( &lt;div&gt; &lt;h3&gt;Home&lt;/h3&gt; &lt;/div&gt;)const Message = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h3&gt;new messages&lt;/h3&gt; &lt;h3&gt;&#123;match.params.id&#125;&lt;/h3&gt; &lt;/div&gt;)const Inbox = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;Route path=&#123;`$&#123;match.url&#125;/messages/:id`&#125; component=&#123;Message&#125;/&gt; &lt;/div&gt;) ReactDOM.render( (&lt;HashRouter&gt; &lt;App&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/inbox\" component=&#123;Inbox&#125; /&gt; &lt;/App&gt; &lt;/HashRouter&gt;), document.getElementById(‘root‘)); 嵌套布局 方式一 1234567891011121314151617const PrimaryLayout = props =&gt; &#123; return ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/user/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;Route path=\"/products\" exact component=&#123;BrowseProductsPage&#125; /&gt; &lt;Route path=\"/products/:productId\" component=&#123;ProductProfilePage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; );&#125;; userId 通过 props.match.params 获取 props.match 赋予给了 &lt;Route&gt; 中的任何组件。 除此之外，如果组件不通过&lt;Route&gt; 来渲染，要访问 props.match，可以使用 withRouter()高阶组件来实现 方式二 解决了第一种方式中的生命周期，重复渲染的问题 123456789101112131415const PrimaryLayout = props =&gt; &#123; return ( &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UserSubLayout&#125; /&gt; &lt;Route path=\"/products\" component=&#123;ProductSubLayout&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt; );&#125;; 我们用 2个 routes 替换之前的 4个routes 注意，这里我们没有再使用 exact，因为，我们希望 /user 可以匹配任何以 /user 开始的 route，products 同理 使用这种策略，子布局也开始承担起了渲染 routes 的责任，现在，UserSubLayout 长这样 123456789101112const UserSubLayout = () =&gt; &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=\"/user\" exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=\"/user/:userId\" component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;; 但有一点值得注意的是，routes 需要识别它的完整路径才能匹配，为了减少我们的重复输入，我们可以使用 props.match.path来代替 123456789101112131415const UserSubLayout = props =&gt; &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=&#123;props.match.path&#125; exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;props.match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;; 7、路径参数 有时路径名中存在我们需要获取的参数。例如，在运动员界面，我们需要获取运动员的编号。我们可以向route的路径字符串中添加path参数 如&#39;/roster/:number&#39;中:number这种写法意味着/roster/后的路径名将会被获取并存在match.params.number中。例如，路径名&#39;/roster/6&#39;会获取到一个对象 1&#123; number: '6' &#125; // 注获取的值是字符串类型的 &lt;Player&gt;组件可以使用props.match.params对象来确定需要被渲染的运动员的数据 123456789101112131415// 返回运动员对象的APIimport PlayerAPI from './PlayerAPI'const Player = (props) =&gt; &#123; const player = PlayerAPI.get( parseInt(props.match.params.number, 10) ) if (!player) &#123; return &lt;div&gt;Sorry, but the player was not found&lt;/div&gt; &#125; return ( &lt;div&gt; &lt;h1&gt;&#123;player.name&#125; (#&#123;player.number&#125;)&lt;/h1&gt; &lt;h2&gt;&#123;player.position&#125;&lt;/h2&gt; &lt;/div&gt;) 除了&lt;Player&gt;组件，我们的页面还包含&lt;FullRoster&gt;, &lt;Schedule&gt;以及 &lt;Home&gt;组件 123456789101112131415161718192021222324252627const FullRoster = () =&gt; ( &lt;div&gt; &lt;ul&gt; &#123; PlayerAPI.all().map(p =&gt; ( &lt;li key=&#123;p.number&#125;&gt; &lt;Link to=&#123;`/roster/$&#123;p.number&#125;`&#125;&gt;&#123;p.name&#125;&lt;/Link&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt;)const Schedule = () =&gt; ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;6/5 @ Evergreens&lt;/li&gt; &lt;li&gt;6/8 vs Kickers&lt;/li&gt; &lt;li&gt;6/14 @ United&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;)const Home = () =&gt; ( &lt;div&gt; &lt;h1&gt;Welcome to the Tornadoes Website!&lt;/h1&gt; &lt;/div&gt;) 八、inclusive routing 当访问 /user 时，两个组价都会被渲染 1234567891011const PrimaryLayout = () =&gt; &lt;div className=&quot;primary-layout&quot;&gt; &lt;header&gt; Our React Router 4 App &lt;Route path=&quot;/user&quot; component=&#123;UsersMenu&#125; /&gt; &lt;/header&gt; &lt;main&gt; &lt;Route path=&quot;/&quot; exact component=&#123;HomePage&#125; /&gt; &lt;Route path=&quot;/user&quot; component=&#123;UsersPage&#125; /&gt; &lt;/main&gt; &lt;/div&gt;; 九、Exclusive Routing 如果你只想匹配一个 route，那么你也可以使用 &lt;Switch&gt; 来 exclusive routing 123456789101112const PrimaryLayout = () =&gt; &lt;div className=\"primary-layout\"&gt; &lt;PrimaryHeader /&gt; &lt;main&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/user/add\" component=&#123;UserAddPage&#125; /&gt; &lt;Route path=\"/user\" component=&#123;UsersPage&#125; /&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Switch&gt; &lt;/main&gt; &lt;/div&gt;; 在 &lt;Switch&gt; 中只有一个 &lt;Route&gt; 会被渲染，另外，我们还是要给 HomePage所在 &lt;Route&gt;添加 exact，否则，在访问 /user 或 /user/add的时候还是会匹配到 /，从而，只渲染 HomePage 我们将 /user/add放在 /user 前面是保证正确匹配的很有策略性的一步，因为，/user/add会同时匹配 /user和 /user/add 如果我们给每一个 &lt;Route&gt;都添加一个 exact，那就不用考虑上面的 策略 了，但不管怎样，现在至少知道了我们还有其它选择 &lt;Redirect&gt;组件不用多说，执行浏览器重定向，但它在 &lt;Switch&gt; 中时，&lt;Redirect&gt;组件只会在 routes 匹配不成功的情况下渲染 十、Index Routes” 和 “Not Found” V4 中也没有 &lt;IndexRoute&gt;，但 &lt;Route exact&gt;可以实现相同的功能，或者 &lt;Switch&gt;和 &lt;Redirect&gt; 重定向到默认的有效路径，甚至一个找不到的页面 十一、Link 现在，我们应用需要在各个页面间切换。如果使用锚点元素（就是）实现，在每次点击时页面将被重新加载。React Router提供了&lt;Link&gt;组件用来避免这种状况的发生。当你点击&lt;Link&gt;时，URL会更新，组件会被重新渲染，但是页面不会重新加载 123456789101112import &#123; Link &#125; from 'react-router-dom'const Header = () =&gt; ( &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/roster'&gt;Roster&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/schedule'&gt;Schedule&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt;) &lt;Link&gt;使用&#39;to&#39;参数来描述需要定位的页面。它的值即可是字符串也可是location对象（包含pathname，search，hash与state属性）。如果其值为字符床将会被转换为location对象。 1&lt;Link to=&#123;&#123; pathname: '/roster/7' &#125;&#125;&gt;Player #7&lt;/Link&gt; 十二、Match 正如我们上面看到的那样，props.match 可以帮我们获取 userId 和 routes match 对象为我们提供了 match.params，match.path，和 match.url 等属性 1、match.path vs match.url 最开始，可能觉得这两者的区别并不明显，控制台经常出现相同的输出，比如，访问 /user 1234567891011121314151617const UserSubLayout = (&#123; match &#125;) =&gt; &#123; console.log(match.url) // output: \"/user\" console.log(match.path) // output: \"/user\" return ( &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route path=&#123;match.path&#125; exact component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt; )&#125; match 在组件的参数中被解构，意思就是我们可以使用 match.path 代替 props.match.path 虽然我们看不到什么明显的差异，但需要明白的是 match.url 是浏览器 URL 的一部分，match.path 是我们为 router 书写的路径 2、如何选择 如果我们是构建 route 路径，那么肯定使用 match.path 12345678910111213141516const UserComments = (&#123; match &#125;) =&gt; &lt;div&gt; UserId: &#123;match.params.userId&#125; &lt;/div&gt;;const UserSettings = (&#123; match &#125;) =&gt; &lt;div&gt; UserId: &#123;match.params.userId&#125; &lt;/div&gt;;const UserProfilePage = (&#123; match &#125;) =&gt; &lt;div&gt; User Profile: &lt;Route path=&#123;`$&#123;match.url&#125;/comments`&#125; component=&#123;UserComments&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/settings`&#125; component=&#123;UserSettings&#125; /&gt; &lt;/div&gt;; 然后，我们按下面方式来访问 12/user/5/comments/user/5/settings 实践后，我们发现，访问 comments 返回 undefined，访问 settings 返回 5 3、避免 Match 冲突 1234567891011121314const UserSubLayou = (&#123; match &#125;) =&gt; &lt;div className=\"user-sub-layout\"&gt; &lt;aside&gt; &lt;UserNav /&gt; &lt;/aside&gt; &lt;div className=\"primary-content\"&gt; &lt;Switch&gt; &lt;Route exact path=&#123;match.path&#125; component=&#123;BrowseUsersPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/add`&#125; component=&#123;AddUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId/edit`&#125; component=&#123;EditUserPage&#125; /&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:userId`&#125; component=&#123;UserProfilePage&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt; &lt;/div&gt;; 我们使用 ${match.path}/:userId(\\\\d+)作为 UserProfilePage 对应的 path，保证 :userId 是一个数字，可以避免与 /users/add的冲突，这样，将其所在的 &lt;Route&gt; 丢到最前面去也能正常访问 add 页面 十三、Authorized Route 在应用程序中限制未登录的用户访问某些路由是非常常见的，还有对于授权和未授权的用户 UI 也可能大不一样，为了解决这样的需求，我们可以考虑为应用程序设置一个主入口 1234567891011121314class App extends React.Component &#123; render() &#123;return ( &lt;Provider store=&#123;store&#125;&gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=\"/auth\" component=&#123;UnauthorizedLayout&#125; /&gt; &lt;AuthorizedRoute path=\"/app\" component=&#123;PrimaryLayout&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ) &#125;&#125; 现在，我们首先会去选择应用程序在哪个顶级布局中，比如，/auth/login 和 /auth/forgot-password 肯定在 UnauthorizedLayout 中，另外，当用户登陆时，我们将判断所有的路径都有一个 /app 前缀以确保是否登录。如果用户访问 /app 开头的页面但并没有登录，我们将会重定向到登录页面 十四、&lt;Link&gt; 和之前版本没太大区别，重点看下组件属性 to（string/object）：要跳转的路径或地址； replace（bool）：为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为false 123456789101112131415// Link组件示例// to为string&lt;Link to=\"/about\"&gt;关于&lt;/Link&gt;// to为obj&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt;// replace &lt;Link to=\"/courses\" replace /&gt; &lt;NavLink&gt; &lt;NavLink&gt;是&lt;Link&gt; 的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数，组件属性 activeClassName（string）：设置选中样式，默认值为active； activeStyle（object）：当元素被选中时, 为此元素添加样式； exact（bool）：为 true 时, 只有当地址完全匹配 class 和 style 才会应用； strict（bool）：为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 - pathname 后的斜线； isActive（func）：判断链接是否激活的额外逻辑的功能 123456789101112131415161718192021222324252627282930// 用法// activeClassName选中时样式为selected&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt;FAQs&lt;/NavLink&gt;// 选中时样式为activeStyle的样式设置&lt;NavLink to=\"/faq\" activeStyle=&#123;&#123; fontWeight: 'bold', color: 'red' &#125;&#125;&gt;FAQs&lt;/NavLink&gt;// 当event id为奇数的时候，激活链接const oddEvent = (match, location) =&gt; &#123; if (!match) &#123; return false &#125; const eventID = parseInt(match.params.eventID) return !isNaN(eventID) &amp;&amp; eventID % 2 === 1&#125;&lt;NavLink to=\"/events/123\" isActive=&#123;oddEvent&#125;&gt;Event 123&lt;/NavLink&gt; 十五、&lt;Switch&gt; 该组件用来渲染匹配地址的第一个&lt;Route&gt;或者&lt;Redirect&gt;。那么它与使用一堆route又有什么区别呢 &lt;Switch&gt;的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的&lt;Route&gt;都会被渲染 123456&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;Route path=\"/:user\" component=&#123;User&#125;/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt; 现在，如果我们处于/about，&lt;Switch&gt;将开始寻找匹配的&lt;Route&gt;。&lt;Route path=&quot;/about&quot;/&gt; 将被匹配， &lt;Switch&gt;将停止寻找匹配并渲染&lt;About&gt;。同样，如果我们处于/michael，&lt;User&gt;将被渲染 十六、更多参考 https://reacttraining.com/react-router/web/guides/philosophy","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"Router","slug":"Router","permalink":"http://yoursite.com/tags/Router/"}]},{"title":"Redux之react结合redux实战篇（十）","slug":"redux-study-combine-react-and-redux","date":"2017-11-19T08:40:24.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2017/11/19/redux-study-combine-react-and-redux/","link":"","permalink":"http://yoursite.com/2017/11/19/redux-study-combine-react-and-redux/","excerpt":"","text":"以TODO为例分析，实际开发中并不是那么简单，下面的原型只是开发中的一个原型，这个简单的例子，有助于掌握数据处理传递的原则。 一、定义constants 这一步不是必须的 1234567891011/** * 常量统一保存，便于管理 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO';export const SET_VISIBILITY = 'SET_VISIBILITY';//controll todo wheher show or hideexport const SHOW_ALL = 'SHOW_ALL';export const SHOW_ACTIVE = 'SHOW_ACTIVE';export const SHOW_COMPLETED = 'SHOW_COMPLETED'; 二、定义actionCreator12345678910111213141516171819202122232425/** * 定义action creator */import * as actionType from '../constant/index';let nextTodo = 0;export const addTodo = (text)=&gt;(&#123; type:actionType.ADD_TODO, id:nextTodo++, text&#125;)export const toggleTodo = (id)=&gt;(&#123; type:actionType.TOGGLE_TODO, id&#125;)export const setVisibilityFilter = (filter)=&gt;&#123; return &#123; type:actionType.SET_VISIBILITY, filter &#125;&#125; 三、定义reducer拆分reducer SetVisibility.js 123456789101112131415/** * 处理TODO可见与不可见的reducer */import * as actionType from '../constant/index';// 初始状态是自己设置的 后面的状态会转化// 接收当前状态(设置默认的过滤SHOW_ALL，如设置某些选项卡的active一样)，和action返回新的stateexport const visibilityFilter = (state='SHOW_ALL',action)=&gt;&#123; switch(action.type) &#123; case actionType.SET_VISIBILITY: return action.filter; default: return state; &#125;&#125; addTodo.js 12345678910111213141516171819202122232425/** * 定义处理action的reducers */import * as actionType from '../constant/index';//传入当前的状态空数、actionexport const todos = (state = [],action)=&gt;&#123; switch(action.type)&#123; // 匹配用户触发的actionType case actionType.ADD_TODO: // 合并上一次的状态和当前的状态 返回todos数组 return [ ...state,//把数组展开合并 &#123; id:action.id, text:action.text, completed:false//用户控制TODO是否处于点击完成的状态 默认false 没点击 &#125; ] // TODO列表来回切换 遍历add_todo返回的数组 通过completed来判断 case actionType.TOGGLE_TODO: return state.map(todo=&gt;(todo.id===action.id)?&#123;...todo,completed:!todo.completed&#125;:todo) default: return state;//匹配不到返回state &#125;&#125; 合并reducer 123456789101112/** * 合并reducers */import &#123; combineReducers &#125; from 'redux'import &#123;todos&#125; from './addTodo';import &#123;visibilityFilter&#125; from './SetVisibility';export default combineReducers(&#123; todos, //这些键其实就是被拆分的状态，后面在容器组件中需要通过connect链接 visibilityFilter&#125;); 四、定义store123456789import &#123; applyMiddleware, createStore &#125; from 'redux';import reducer from '../reducers/index';import logger from 'redux-logger';// 创建store 用来存储状态export const store = createStore( reducer, applyMiddleware(logger) //处理日志中间件) 五、结合react-redux 这里忽略展示组件，完成源码看文章结尾 首先我们在container组件中处理好之前分解合并的那些reducer的键，然后在通过connect链接，传递给展示组件的属性使用 容器组件处理 react-todos/src/container/FilterLink.js 12345678910111213141516171819202122232425262728// 处理数组过滤import &#123; connect &#125; from 'react-redux';import Link from '../components/Link';import &#123; setVisibilityFilter &#125; from '../actions/index';// 这里的ownProps指的是 FilterLink// 这里的state其实就是之前分解的todos，visibilityFilterconst mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active:ownProps.filter === state.visibilityFilter &#125;&#125;/** 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。 */const mapDispatchToProps = (dispatch, ownProps) =&gt; (&#123;// 这里处理对应的事件，传递给展示组件的属性 onClick: () =&gt; &#123; dispatch(setVisibilityFilter(ownProps.filter)) &#125;&#125;)export default connect( mapStateToProps, mapDispatchToProps)(Link); 分析 这里通过connect组件把之前reducer处理的那些状态链接 12345export default combineReducers(&#123; todos, //这些键其实就是被拆分的状态，后面在容器组件中需要通过connect链接 visibilityFilter&#125;); react-todos/src/container/VisibilityTodoList.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 处理可见于不可见组件的逻辑 */import &#123;connect&#125; from 'react-redux';import TodoList from '../components/TodoList';import &#123;toggleTodo&#125; from '../actions/index';import * as actionType from '../constant/index';console.log(toggleTodo)// todos是返回的数组，filter是过滤的选项如SHOW_ALL SHOW_ACTIVE.const getVisibilityTodos = (todos,filter)=&gt;&#123; switch(filter) &#123; case actionType.SHOW_ALL: return todos; case actionType.SHOW_ACTIVE: return todos.filter(t =&gt; !t.completed); case actionType.SHOW_COMPLETED: return todos.filter(t =&gt; t.completed); default: throw new Error('未知的'+filter); &#125;&#125;// 把状态转化为展示组件的属性转递过去/** * * @param &#123;*&#125; state 也就是 * export default CombineReducers(&#123; Todos, SetVisibility *&#125;); * @param &#123;*&#125; ownProps 返回的容器组件本身的参数 如&lt;Filter name=\"poetries\"&gt;此时的ownProps就是name了 */const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibilityTodos(state.todos,state.visibilityFilter), count:state.todos.length &#125;&#125;/** * 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出 */const mapDispatchToProps = &#123; onTodoClick: toggleTodo&#125;export default connect( mapStateToProps, mapDispatchToProps)(TodoList) react-todos/src/container/addTodos.js 1234567891011121314151617181920/** * Addtodo的处逻辑 */import React, &#123; Component &#125; from 'react';import &#123;addTodo&#125; from '../actions/index';import AddTask from '../components/addTodo';import &#123;connect&#125; from 'react-redux';const mapStateToProps = (state, ownProps) =&gt; (&#123; &#125;)const mapDispatchToProps = &#123; addTodo:addTodo&#125;export default connect( mapStateToProps, mapDispatchToProps)(AddTask); 到此分析完毕，展示组件就不分析了，展示组件本身是没有数据的，需要container处理传递 完整的源码 https://github.com/poetries/react-todos","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Redux之源码分析（九）","slug":"redux-study-source-code-analysis","date":"2017-11-19T08:35:24.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2017/11/19/redux-study-source-code-analysis/","link":"","permalink":"http://yoursite.com/2017/11/19/redux-study-source-code-analysis/","excerpt":"","text":"一、index.js https://github.com/reactjs/redux/blob/master/src/index.js 暴露了几个核心API 12345678910111213import createStore from './createStore';import combineReducers from './utils/combineReducers';import bindActionCreators from './utils/bindActionCreators';import applyMiddleware from './utils/applyMiddleware';import compose from './utils/compose';export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125;; 二、createStore.js https://github.com/reactjs/redux/blob/master/src/createStore.js redux.createStore(reducer, initialState) 传入了reducer、initialState，并返回一个store对象 store对象对外暴露了dispatch、getState、subscribe方法 store对象通过getState() 获取内部状态 initialState为 store 的初始状态，如果不传则为undefined store对象通过reducer来修改内部状态 store对象创建的时候，内部会主动调用dispatch({ type: ActionTypes.INIT });来对内部状态进行初始化。通过断点或者日志打印就可以看到，store对象创建的同时，reducer就会被调用进行初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171import isPlainObject from './utils/isPlainObject';/** * These are private action types reserved by Redux. * For any unknown actions, you must return the current state. * If the current state is undefined, you must return the initial state. * Do not reference these action types directly in your code. */// 初始化的时候(redux.createStore(reducer, initialState)时),传的action.type 就是这货啦export var ActionTypes = &#123; INIT: '@@redux/INIT'&#125;;/** * Creates a Redux store that holds the state tree. * The only way to change the data in the store is to call `dispatch()` on it. * * There should only be a single store in your app. To specify how different * parts of the state tree respond to actions, you may combine several reducers * into a single reducer function by using `combineReducers`. * * @param &#123;Function&#125; reducer A function that returns the next state tree, given * the current state tree and the action to handle. * * @param &#123;any&#125; [initialState] The initial state. You may optionally specify it * to hydrate the state from the server in universal apps, or to restore a * previously serialized user session. * If you use `combineReducers` to produce the root reducer function, this must be * an object with the same shape as `combineReducers` keys. * * @returns &#123;Store&#125; A Redux store that lets you read the state, dispatch actions * and subscribe to changes. */export default function createStore(reducer, initialState) &#123; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.'); &#125; var currentReducer = reducer; var currentState = initialState; var listeners = []; var isDispatching = false; /** * Reads the state tree managed by the store. * * @returns &#123;any&#125; The current state tree of your application. */ // 这个方法没什么好讲的,返回当前的state function getState() &#123; return currentState; &#125; /** * Adds a change listener. It will be called any time an action is dispatched, * and some part of the state tree may potentially have changed. You may then * call `getState()` to read the current state tree inside the callback. * * @param &#123;Function&#125; listener A callback to be invoked on every dispatch. * @returns &#123;Function&#125; A function to remove this change listener. */ // 很常见的监听函数添加方式,当store.dispatch 的时候被调用 // store.subscribe(listener) 返回一个方法(unscribe),可以用来取消监听 function subscribe(listener) &#123; listeners.push(listener); var isSubscribed = true; return function unsubscribe() &#123; if (!isSubscribed) &#123; return; &#125; isSubscribed = false; var index = listeners.indexOf(listener); listeners.splice(index, 1); &#125;; &#125; /** * Dispatches an action. It is the only way to trigger a state change. * * The `reducer` function, used to create the store, will be called with the * current state tree and the given `action`. Its return value will * be considered the **next** state of the tree, and the change listeners * will be notified. * * The base implementation only supports plain object actions. If you want to * dispatch a Promise, an Observable, a thunk, or something else, you need to * wrap your store creating function into the corresponding middleware. For * example, see the documentation for the `redux-thunk` package. Even the * middleware will eventually dispatch plain object actions using this method. * * @param &#123;Object&#125; action A plain object representing “what changed”. It is * a good idea to keep actions serializable so you can record and replay user * sessions, or use the time travelling `redux-devtools`. An action must have * a `type` property which may not be `undefined`. It is a good idea to use * string constants for action types. * * @returns &#123;Object&#125; For convenience, the same action object you dispatched. * * Note that, if you use a custom middleware, it may wrap `dispatch()` to * return something else (for example, a Promise you can await). */ // 以下情况会报错 // 1. 传入的action不是一个对象 // 2. 传入的action是个对象,但是action.type 是undefined function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ); &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ); &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.'); &#125; try &#123; isDispatching = true; // 就是这一句啦, 将 currentState 设置为 reducer(currentState, action) 返回的值 currentState = currentReducer(currentState, action); &#125; finally &#123; isDispatching = false; &#125; // 如果有监听函数,就顺序调用 listeners.slice().forEach(listener =&gt; listener()); // 最后,返回传入的action return action; &#125; /** * Replaces the reducer currently used by the store to calculate the state. * * You might need this if your app implements code splitting and you want to * load some of the reducers dynamically. You might also need this if you * implement a hot reloading mechanism for Redux. * * @param &#123;Function&#125; nextReducer The reducer for the store to use instead. * @returns &#123;void&#125; */ function replaceReducer(nextReducer) &#123; currentReducer = nextReducer; dispatch(&#123; type: ActionTypes.INIT &#125;); &#125; // When a store is created, an \"INIT\" action is dispatched so that every // reducer returns their initial state. This effectively populates // the initial state tree. // // redux.createStore(reducer, initialState) 的时候, 内部会 自己调用 dispatch(&#123; type: ActionTypes.INIT &#125;); // 来完成state的初始化 dispatch(&#123; type: ActionTypes.INIT &#125;); // 返回的就是这个东东了,只有四个方法 return &#123; dispatch, subscribe, getState, replaceReducer &#125;;&#125; 三、combineReducers.js https://github.com/reactjs/redux/blob/master/src/combineReducers.js redux.combineReducers(reducerMap) 的作用在于合并多个reducer函数，并返回一个新的reducer函数。因此可以看到，combineReducers 返回了一个函数，并且该函数的参数同样是state、reducer 最终 store.getState()返回的state，大概会是这么个样子{todos: xx, filter: xx}。简单的说，state被拆分成了两份，TodoReducer的返回值赋值给了state.todos，FilterReducer的返回值赋值给了state.filter 1234567function TodoReducer(state, action) &#123;&#125;function FilterReducer(state, action) &#123;&#125;var finalReducers = redux.combineReducers(&#123; todos: TodoReducer, filter: FilterReducer&#125;); combineReducers(reducerMap) 传入一个对象，并返回一个全新的reducer。调用方式跟跟普通的reducer一样，也是传入state、action 通过combineReducers，对 store 的状态state进行拆分 reducerMap的key，就是 state 的key，而 调用对应的reducer返回的值，则是这个key对应的值。如上面的例子，state.todos == TodoReducer(state, action) redux.createStore(finalReducers, initialState) 调用时，同样会对 state进行初始化。这个初始化跟通过普通的reducer进行初始化没多大区别。举例来说，如果 initialState.todos = undefined，那么 TodoReducer(state, action)初始传入的state就是undefined；如果initialState.todos = []，那么 TodoReducer(state, action)初始传入的state就是[] store.dispatch(action)，finalReducers 里面，会遍历整个reducerMap，依次调用每个reducer，并将每个reducer返回的子state赋给state对应的key。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163import &#123; ActionTypes &#125; from '../createStore';import isPlainObject from '../utils/isPlainObject';import mapValues from '../utils/mapValues';import pick from '../utils/pick';/* eslint-disable no-console */function getUndefinedStateErrorMessage(key, action) &#123; var actionType = action &amp;&amp; action.type; var actionName = actionType &amp;&amp; `\"$&#123;actionType.toString()&#125;\"` || 'an action'; return ( `Reducer \"$&#123;key&#125;\" returned undefined handling $&#123;actionName&#125;. ` + `To ignore an action, you must explicitly return the previous state.` );&#125;function getUnexpectedStateKeyWarningMessage(inputState, outputState, action) &#123; var reducerKeys = Object.keys(outputState); var argumentName = action &amp;&amp; action.type === ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer'; if (reducerKeys.length === 0) &#123; return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ); &#125; if (!isPlainObject(inputState)) &#123; return ( `The $&#123;argumentName&#125; has unexpected type of \"` + (&#123;&#125;).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `\". Expected argument to be an object with the following ` + `keys: \"$&#123;reducerKeys.join('\", \"')&#125;\"` ); &#125; var unexpectedKeys = Object.keys(inputState).filter( key =&gt; reducerKeys.indexOf(key) &lt; 0 ); if (unexpectedKeys.length &gt; 0) &#123; return ( `Unexpected $&#123;unexpectedKeys.length &gt; 1 ? 'keys' : 'key'&#125; ` + `\"$&#123;unexpectedKeys.join('\", \"')&#125;\" found in $&#123;argumentName&#125;. ` + `Expected to find one of the known reducer keys instead: ` + `\"$&#123;reducerKeys.join('\", \"')&#125;\". Unexpected keys will be ignored.` ); &#125;&#125;// 对reducer做合法性检测// store = Redux.createStore(reducer, initialState) --&gt;// currentState = initialState// currentState = currentReducer(currentState, action);//// 从调用关系,调用时机来看, store.getState() 的初始值(currentState)// 为 currentReducer(initialState, &#123; type: ActionTypes.INIT &#125;)//// 1. 在初始化阶段,reducer 传入的 state 值是 undefined,此时,需要返回初始state,且初始state不能为undefined// 2. 当传入不认识的 actionType 时, reducer(state, &#123;type&#125;) 返回的不能是undefined// 3. redux/ 这个 namespace 下的action 不应该做处理,直接返回 currentState 就行 (谁运气这么差会去用这种actionType...)function assertReducerSanity(reducers) &#123; Object.keys(reducers).forEach(key =&gt; &#123; var reducer = reducers[key]; var initialState = reducer(undefined, &#123; type: ActionTypes.INIT &#125;); if (typeof initialState === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined.` ); &#125; var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.'); if (typeof reducer(undefined, &#123; type &#125;) === 'undefined') &#123; throw new Error( `Reducer \"$&#123;key&#125;\" returned undefined when probed with a random type. ` + `Don't try to handle $&#123;ActionTypes.INIT&#125; or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined.` ); &#125; &#125;);&#125;/** * Turns an object whose values are different reducer functions, into a single * reducer function. It will call every child reducer, and gather their results * into a single state object, whose keys correspond to the keys of the passed * reducer functions. * * @param &#123;Object&#125; reducers An object whose values correspond to different * reducer functions that need to be combined into one. One handy way to obtain * it is to use ES6 `import * as reducers` syntax. The reducers may never return * undefined for any action. Instead, they should return their initial state * if the state passed to them was undefined, and the current state for any * unrecognized action. * * @returns &#123;Function&#125; A reducer function that invokes every reducer inside the * passed object, and builds a state object with the same shape. */export default function combineReducers(reducers) &#123; // 返回一个对象, key =&gt; value 且value是function(其实就是过滤掉非function) var finalReducers = pick(reducers, (val) =&gt; typeof val === 'function'); var sanityError; try &#123; // 对所有的子reducer 做一些合法性断言,如果没有出错再继续下面的处理 // 合法性断言的内容,见API注释 assertReducerSanity(finalReducers); &#125; catch (e) &#123; sanityError = e; &#125; // 所有的 key: value,将value置成了undefined,费解... // 总而言之, 初始state 就是 类似 &#123;hello: undefined, world: undefined&#125; 的东东 // TODO 确认这里的逻辑 var defaultState = mapValues(finalReducers, () =&gt; undefined); return function combination(state = defaultState, action) &#123; if (sanityError) &#123; throw sanityError; &#125; var hasChanged = false; // 这段代码,简单的说,就是循环一遍 finalState[key] = fn(reducer, key) var finalState = mapValues(finalReducers, (reducer, key) =&gt; &#123; var previousStateForKey = state[key]; var nextStateForKey = reducer(previousStateForKey, action); if (typeof nextStateForKey === 'undefined') &#123; // 其他一个reducer返回的是undefined,于是挂啦...抛出错误 var errorMessage = getUndefinedStateErrorMessage(key, action); throw new Error(errorMessage); &#125; // 这段代码有些费解,从redux的设计理念上来讲,除了不认识的action type,其他情况都应该返回全新的state // 也就是说 // 1. action type 认识,返回新的state,于是这里 hasChanged 为 true // 2. action type 不认识,返回原来的state,于是这里 hasChanged 为 false // 3. 不管action type 是否认识, 在原来的state上修改,但是返回的是修改后的state(没有返回拷贝),那么,hasChanged还是为false hasChanged = hasChanged || nextStateForKey !== previousStateForKey; return nextStateForKey; &#125;); // 开发环境中(于是记得在生产环境去掉) // 后面再研究这段代码,毕竟不是主线路... if (process.env.NODE_ENV !== 'production') &#123; var warningMessage = getUnexpectedStateKeyWarningMessage(state, finalState, action); if (warningMessage) &#123; console.error(warningMessage); &#125; &#125; return hasChanged ? finalState : state; &#125;;&#125; 四、bindActionCreator.js https://github.com/reactjs/redux/blob/master/src/bindActionCreators.js 先看个简单例子可能方便理解一些 1234567891011121314151617181920212223242526272829303132333435363738394041424344var addTodo = function(text)&#123; return &#123; type: 'add_todo', text: text &#125;;&#125;;var addTodos = function()&#123; return &#123; type: 'add_todos', items: Array.prototype.slice.call(arguments, 0) &#125;;&#125;;var reducer = function(state, action)&#123; switch (action.type) &#123; case 'add_todo': return state.concat(action.text); case 'add_todos': return state.concat(action.items); default: return state; &#125;&#125;;var store = redux.createStore(reducer, []);// 注意,关键代码在这里var actions = redux.bindActionCreators(&#123; addTodo: addTodo, addTodos: addTodos&#125;, store.dispatch);console.log('state is: ' + store.getState());store.dispatch(&#123;type: 'add_todo', text: '读书'&#125;);store.dispatch(&#123;type: 'add_todos', items: ['阅读', '睡觉']&#125;);console.log('state is: ' + store.getState()); // state is: 读书,阅读,睡觉actions.addTodo('看电影');console.log('state is: ' + store.getState()); // state is: 读书,阅读,睡觉,看电影actions.addTodos(['刷牙', '洗澡']);console.log('state is: ' + store.getState()); // state is: 读书,阅读,睡觉,看电影,刷牙,洗澡 直接看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import mapValues from '../utils/mapValues';function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args));&#125;/** * Turns an object whose values are action creators, into an object with the * same keys, but with every function wrapped into a `dispatch` call so they * may be invoked directly. This is just a convenience method, as you can call * `store.dispatch(MyActionCreators.doSomething())` yourself just fine. * * For convenience, you can also pass a single function as the first argument, * and get a function in return. * * @param &#123;Function|Object&#125; actionCreators An object whose values are action * creator functions. One handy way to obtain it is to use ES6 `import * as` * syntax. You may also pass a single function. * * @param &#123;Function&#125; dispatch The `dispatch` function available on your Redux * store. * * @returns &#123;Function|Object&#125; The object mimicking the original object, but with * every action creator wrapped into the `dispatch` call. If you passed a * function as `actionCreators`, the return value will also be a single * function. */// 假设 actionCreators === &#123;addTodo: addTodo, removeTodo: removeTodo&#125;// 简单的来说 bindActionCreators(actionCreators, dispatch)// 最后返回的是:// &#123;// addTodo: function(text)&#123;// dispatch( actionCreators.addTodo(text) );// &#125;,// removeTodo: function(text)&#123;// dispatch( actionCreators.removeTodo(text) );// &#125;// &#125;//// 或者说 actionCreators === addTodo (addTodo 为 actionCreator)// 最后返回的是// function() &#123;// dispatch(actionCreators());// &#125;export default function bindActionCreators(actionCreators, dispatch) &#123; if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch); &#125; if (typeof actionCreators !== 'object' || actionCreators === null || actionCreators === undefined) &#123; // eslint-disable-line no-eq-null throw new Error( `bindActionCreators expected an object or a function, instead received $&#123;actionCreators === null ? 'null' : typeof actionCreators&#125;. ` + `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?` ); &#125; return mapValues(actionCreators, actionCreator =&gt; bindActionCreator(actionCreator, dispatch) );&#125; 五、applyMiddleware.js https://github.com/reactjs/redux/blob/master/src/applyMiddleware.js 中间件应该是redux源码里面最绕的一部分 例子：redux-thunk 123456export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; typeof action === 'function' ? action(dispatch, getState) : next(action);&#125; 123456789101112//es5function thunkMiddleware(store) &#123; var dispatch = store.dispatch; var getState = store.getState; return function (next) &#123; return function (action) &#123; return typeof action === 'function' ? action(dispatch, getState) : next(action); &#125;; &#125;;&#125; 自定义中间件：logger 先看logger的实现 1234567function middleware(store)&#123; return function(next)&#123; return function(action)&#123; return next(action); &#125; &#125;&#125; 基本看出中间件声明的模版来了，就是下面这个样子。下面结合applyMiddleware的调用，来说明store、next、action 几个参数。 12345678910function logger(store)&#123; return function(next)&#123; return function(action)&#123; console.log('logger: dispatching ' + action.type); var result = next(action); console.log('logger: next state ' + result); return result; &#125; &#125;&#125; applyMiddleware调用例子 applyMiddleware 的调用方式为 applyMiddleware(...middlewares)(react.createStore)。其实这里直接先创建 store，然后applyMiddleware(...middlewares)(store) 也很容易实现相同的效果，不过作者是故意这样设计的，为了避免在同一个store上多次应用同一个middlerware 中间件顶层的store参数，并不是常规的store，虽然它也有 getState、dispatch 两个方法 12345678// 上面的store参数，其实就是这个对象// 其中，store 为内部的store，我们在外面 storeWithMiddleWare.dipatch的时候，内部实现是转成 store.dispatch// 此外，可以看到 middlewareAPI.dispatch 方法，是最终封装后的dispatch（千万注意，如果在中间件内部 调用 store.dispatch，可能导致死循环 ）var middlewareAPI = &#123; getState: store.getState, // 最后面, dispatch 被覆盖, 变成包装后的 dispatch 方法 dispatch: (action) =&gt; dispatch(action)&#125;; 第二层的next函数，其实是一个“dispatch”方法 storeWithMiddleWare.dispatch(action) 的时候，会顺序进入各个中间件（按照定义时的顺序）。从当前的例子来看，大约如下，其实就是柯里化啦 1storeWithMiddleWare.dispatch(action) --&gt; logger(store)(next)(action) --&gt; timer(store)(next)(action) --&gt; store.dispatch(action) 完整的示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function reducer(state, action)&#123; if(typeof state==='undefined') state = []; switch(action.type)&#123; case 'add_todo': return state.concat(action.text); default: return state; &#125;&#125;function addTodo(text)&#123; return &#123; type: 'add_todo', text: text &#125;;&#125;// 这里的 store，并不是 redux.createStore(reducer, initialState) 出来的 store// 而是 &#123;getState: store.getState, dispatch: function() &#123; store.dispatch(action); &#125;&#125;// function logger(store)&#123; // return function(next)&#123; return function(action)&#123; console.log('logger: dispatching ' + action.type); var result = next(action); console.log('logger: next state ' + result); return result; &#125; &#125;&#125;function timer(store)&#123; return function(next)&#123; return function(action)&#123; console.log('timer: dispatching ' + action.type); var result = next(action); console.log('timer: next state ' + result); return result; &#125; &#125;&#125;var createStoreWidthMiddleware = redux.applyMiddleware( logger, timer )(redux.createStore);var storeWithMiddleWare = createStoreWidthMiddleware(reducer);storeWithMiddleWare.subscribe(function()&#123; console.log('subscribe: state is : ' + storeWithMiddleWare.getState());&#125;);console.log( storeWithMiddleWare.dispatch(addTodo('reading')) ); 源码解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import compose from './compose';/** * Creates a store enhancer that applies middleware to the dispatch method * of the Redux store. This is handy for a variety of tasks, such as expressing * asynchronous actions in a concise manner, or logging every action payload. * * See `redux-thunk` package as an example of the Redux middleware. * * Because middleware is potentially asynchronous, this should be the first * store enhancer in the composition chain. * * Note that each middleware will be given the `dispatch` and `getState` functions * as named arguments. * * @param &#123;...Function&#125; middlewares The middleware chain to be applied. * @returns &#123;Function&#125; A store enhancer applying the middleware. *//* 从调用方法 applyMiddleware(...middlewares)(Redux.createStore) 可以看出 next 参数实际上是 Redux.createStore. 而 Redux.createStore 的调用方式为 Redux.createStore(reducer, initialState) 所以 applyMiddleware(...middlewares) 1. 参数: Redux.createStore 2. 返回值:一个function, 跟 Redux.createStore 接受的参数一样 */export default function applyMiddleware(...middlewares) &#123; return (next) =&gt; (reducer, initialState) =&gt; &#123; // 内部先创建一个store (相当于直接调用 Redux.createStore(reducer, initialState)) var store = next(reducer, initialState); // 保存最初始的store.dispatch var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, // 最后面, dispatch 被覆盖, 变成包装后的 dispatch 方法 dispatch: (action) =&gt; dispatch(action) &#125;; // 返回一个数组 // 贴个例子在这里做参考,redux-thunk // function thunkMiddleware(store) &#123; // var dispatch = store.dispatch; // var getState = store.getState; // // 这里的next其实就是dispatch // return function (next) &#123; // return function (action) &#123; // return typeof action === 'function' ? action(dispatch, getState) : next(action); // &#125;; // &#125;; //&#125; /* chain 是个数组, 参考上面的 middlleware (redux-thunk),可以看到,chain的每个元素为如下形式的function 并且, 传入的 store.getState 为原始的 store.getState,而 dispatch则是包装后的 dispatch(不是原始的store.dispatch) 似乎是为了确保, 在每个middleware里调用 dispatch(action), 最终都是 用原始的 store.dispatch(action) 避免 store.dispatch 被覆盖, 导致middleware 顺序调用的过程中, store.dispatch的值变化 --&gt; store.dispatch 返回的值可能会有不同 违背 redux 的设计理念 这里的 next 则为 原始的 store.dispatch (见下面 compose(...chain)(store.dispatch) ) function (next) &#123; return function (action) &#123; &#125; &#125; */ chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); // compose(...chain)(store.dispatch) 返回了一个function // 伪代码如下, // function (action) &#123; // middleware(store)(store.dispatch); // &#125; dispatch = compose(...chain)(store.dispatch); // 从右到左, middleware1( middleware2( middleware3(dispatch) ) ) // 于是,最终调用 applyMiddleware(...middlewares)(Redux.createStore) // 返回的 store, getState,subscribe 方法都是原始的那个 store.getState, store.subscribe // 至于dispatch是封装过的 return &#123; ...store, dispatch &#125;; &#125;;&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Redux之浅析中间件（八）","slug":"react-study-middleware","date":"2017-11-19T08:30:24.000Z","updated":"2018-03-29T15:27:26.001Z","comments":true,"path":"2017/11/19/react-study-middleware/","link":"","permalink":"http://yoursite.com/2017/11/19/react-study-middleware/","excerpt":"","text":"一、前言 在redux里，middleware是发送action和action到达reducer之间的第三方扩展，也就是中间层。也可以这样说，middleware是架在action和store之间的一座桥梁 在redux里，action仅仅是携带了数据的普通js对象 Reducer 拆分可以使组件获取其最小属性(state)，而不需要整个Store。中间件则可以在Action Creator 返回最终可供 dispatch 调用的 action 之前处理各种事情，如异步API调用、日志记录等，是扩展 Redux 功能的一种推荐方式 Redux 提供了 applyMiddleware(...middlewares) 来将中间件应用到 createStore。applyMiddleware 会返回一个函数，该函数接收原来的 creatStore 作为参数，返回一个应用了 middlewares 的增强后的 creatStore 123456789101112131415161718192021222324export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; //接收createStore参数 var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch var chain = [] //传递给中间件的参数 var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; //注册中间件调用链 chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) //返回经middlewares增强后的createStore return &#123; ...store, dispatch &#125; &#125;&#125; 未应用中间价之前，创建 store 的方式如下 1234import &#123;createStore&#125; from 'redux';import reducers from './reducers/index';export let store = createStore(reducers); 应用中间价之后，创建 store的方式如下 12345import &#123;createStore，applyMiddleware&#125; from 'redux';import reducers from './reducers/index';let createStoreWithMiddleware = applyMiddleware(...middleware)(createStore);export let store = createStoreWithMiddleware(reducers); 二、为什么要引入middleware action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发 1action ---&gt; dispatcher ---&gt; reducers 如果遇到异步情况，比如点击一个按钮，希望2秒之后更新视图，显示消息“Hi”。我们可能这么写ActionCreator 12345678var asyncSayActionCreator = function (message) &#123; setTimeout(function () &#123; return &#123; type: 'SAY', message &#125; &#125;, 2000)&#125; 这会报错，因为这个asyncSayActionCreator返回的不是一个action，而是一个function。这个返回值无法被reducer识别 也就是说，正常来说，action返回的是一个对象，而不是一个函数。如果返回函数，会出现错误 而异步操作呢，需要action的返回值是一个函数。那么咋办呢，所以需要引入中间件middleware,它在中间起到了桥梁的作用，让action的返回值可以是一个函数，从而传到reducer那里。也就是说，中间件是用在action发起之后，reducer接收到之前的这个时间段 也可以这么说，Middleware 主要是负责改变Store中的dispatch方法，从而能处理不同类型的 action 输入，得到最终的 Javascript Plain Object 形式的 action 对象 因此，上面那个ActionCreator就可以改写为这样：因为action的返回值是一个函数 12345678910var asyncSayActionCreator = function (message) &#123; return function (dispatch) &#123; setTimeout(function () &#123; dispatch(&#123; type: 'SAY', message &#125;) &#125;, 2000) &#125;&#125; image.png 上图表达的是 redux 中一个简单的同步数据流动的场景，点击button 后，在回调中 dispatch 一个 action，reducer 收到action 后，更新 state 并通知 view 重新渲染 上面这张图展示了应用middleware 后 redux 处理事件的逻辑，每一个 middleware 处理一个相对独立的业务需求，通过串联不同的 middleware，实现变化多样的的功能。那么问题来了： middleware 怎么写？ redux是如何让 middlewares 串联并跑起来的？ 三、中间件是如何工作的 Middleware的中间件有很多，不过我的这个案例只引用了其中的一个，那就是redux-thunk redux-thunk源码如下 123456export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; typeof action === 'function' ? action(dispatch, getState) : next(action);&#125; 意思是如果action是一个函数，执行这个action函数，如果不是函数，执行next函数 四、自定义中间件 中间件的签名如下 1(&#123; getState, dispatch &#125;) =&gt; next =&gt; action 根据applyMiddleware 源码，每个中间件接收 getState &amp; dispatch作为参数，并返回一个函数，该函数会被传入下一个中间件的 dispatch 方法，并返回一个接收 action 的新函数 应用多个中间件时，中间件调用链中任何一个缺少 next(action) 的调用，都会导致action 执行失败 123456function callTraceMiddleware (&#123;dispatch,getState&#125;)&#123; return next=&gt; action =&gt;&#123; console.trace(); return next(action); &#125;&#125; 然后在调用中间件部分添加中间件 12345const createStoreWithMiddleware = applyMiddleware( thunkMiddleware, loggerMiddleware, callTraceMiddleware)(createStore); redux的middleware是对action进行扩展处理，这样丰富了应用需求","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Redux之action、store、reducer分析（六）","slug":"redux-study-action-store-reducer","date":"2017-11-19T08:10:24.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2017/11/19/redux-study-action-store-reducer/","link":"","permalink":"http://yoursite.com/2017/11/19/redux-study-action-store-reducer/","excerpt":"","text":"redux的核心概念就是store、action、reducer，从调用关系来看如下所示 1store.dispatch(action) --&gt; reducer(state, action) --&gt; final state 123456789101112131415161718192021222324252627282930// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: 'xx'&#125;// 返回值: 新的statevar reducer = function(state, action)&#123; switch (action.type) &#123; case 'add_todo': return state.concat(action.text); default: return state; &#125;&#125;;// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log('state is: ' + store.getState()); // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: 'add_todo', text: '读书'&#125;);// 打印出修改后的stateconsole.log('state is: ' + store.getState()); // state is: 读书store.dispatch(&#123;type: 'add_todo', text: '写作'&#125;);console.log('state is: ' + store.getState()); // state is: 读书,写作 一、store、reducer、action关联store store在这里代表的是数据模型，内部维护了一个state变量 store有两个核心方法，分别是getState、dispatch。前者用来获取store的状态（state），后者用来修改store的状态 123456789101112// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log('state is: ' + store.getState()); // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: 'add_todo', text: '读书'&#125;); action 对行为（如用户行为）的抽象，在redux里是一个普通的js对象 action必须有一个type字段来标识这个行为的类型 123&#123;type:'add_todo', text:'读书'&#125;&#123;type:'add_todo', text:'写作'&#125;&#123;type:'add_todo', text:'睡觉', time:'晚上'&#125; reducer 一个普通的函数，用来修改store的状态。传入两个参数 state、action 其中，state为当前的状态（可通过store.getState()获得），而action为当前触发的行为（通过store.dispatch(action)调用触发） reducer(state, action) 返回的值，就是store最新的state值 123456789101112// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: 'xx'&#125;// 返回值: 新的statevar reducer = function(state, action)&#123; switch (action.type) &#123; case 'add_todo': return state.concat(action.text); default: return state; &#125;&#125;; 二、关于actionCreator1actionCreator(args) =&gt; action 12345678var addTodo = function(text)&#123; return &#123; type: 'add_todo', text: text &#125;;&#125;;addTodo('睡觉'); // 返回：&#123;type: 'add_todo', text: '睡觉'&#125;","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React之组件的生命周期以及属性状态（三）","slug":"react-study-life-props-state","date":"2017-11-18T17:10:24.000Z","updated":"2018-03-29T15:27:26.001Z","comments":true,"path":"2017/11/19/react-study-life-props-state/","link":"","permalink":"http://yoursite.com/2017/11/19/react-study-life-props-state/","excerpt":"","text":"一、什么是生命周期 image.png 组件本质是状态机，输入确定，输出一定确定 一个state对应一个render，状态转换的时候会触发不同的函数，从而让开发者有机会做出响应，可以用事件的思路理解状态，但是事件与事件之间没有关联，而状态与状态之间可能会有关联 image.png 二、初始化阶段设置初始的属性与状态 getDefaultProps：设置初始的属性，只在第一次调用，实例之间共享引用 getInitialState：设置初始的状态 componentWillMount：组件将要加载，render之前最后一次修改状态的机会 render：只能访问this.props与this.state，只有一个顶层标签（组件），不允许修改状态和DOM输出 componentDidMount：成功render并渲染完成真实DOM之后出发，可以修改DOM，要操作DOM也必须在这个阶段完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var Demo = React.createClass(&#123; // 第一步执行顺序：设置初始的属性，指执行一次 getDefaultProps:function()&#123; return &#123; name:'一个盒子', title:'box' &#125; &#125;, // 第二步执行顺序：设置初始的状态 getInitialState:function()&#123; return &#123; sss: this.props.name &#125; &#125;, // 第三步执行：组件将要加载的时候，最后一次可以修改状态的机会 componentWillMount:function()&#123; this.setState(&#123; sss:'修改状态' &#125;) // alert('componentWillMount') // 这里是没有办法获取到这个节点的 // var box = this.refs.box; // alert(box.clientWidth) &#125;, // 第四步：render渲染 render:function()&#123; // console.log(this) var styles = &#123; position:'absolute', width: '100px', height: '100px', color: 'red', background: 'lime' &#125; return &lt;div ref=\"box\" style=&#123;styles&#125;&gt;&#123;this.props.title&#125;&#123;this.state.sss&#125;&lt;/div&gt; &#125;, // 第五步：组件加载完成，只有在这一个阶段，我们才可以操作DOM节点 componentDidMount:function()&#123; // alert('componentDidMount') // 下面的this指向组件 console.log(this) var box = this.refs.box; var timer = null; var n = 0; box.onclick = function()&#123; console.log(1) // 这个this指向box console.log(this) var This = this; timer = setInterval(function()&#123; // 这个this指向window // console.log(this) n++; This.style.left = n + 'px'; This.style.top = n + 'px'; &#125;,60) &#125; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(\"app\")) 三、运行中阶段 componentWillReceiveProps：父组件修改属性触发，可以修改新属性，修改状态 shouldCompoenntUpdate：组件是否更新，返回false会阻止render调用，render后面的函数都不会执行 componentWillUpdate：不能修改属性与状态，用于日志打印与数据获取 reder：只能访问this.props与this.state，只有一个顶层标签（组件），不允许修改状态和DOM输出 componentDidUpdate：可以修改DOM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var HelloReact = React.createClass(&#123; // 组件将要接收新的属性 componentWillReceiveProps:function(newProps)&#123; console.log('componnetWillReceiveProps',1) console.log(newProps) &#125;, // 是否允许组件更新，返回true或者false，一般不会改变它的默认值：true shouldComponentUpdate:function(newProps,newState)&#123; console.log('shouldComponentUpdate',2) console.log(newProps,newState) return true; &#125;, // 组件将要更新 componentWillUpdate:function()&#123; console.log('componentWillUpdate',3) &#125;, render:function()&#123; console.log('render',4) return &lt;p&gt;Hello &#123;this.props.name?this.props.name:'React'&#125;&lt;/p&gt; &#125;, // 组件更新完毕 componentDidUpdate:function()&#123; console.log('componentDidUpdate',5) &#125;&#125;)var Demo = React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'' &#125; &#125;, handleChange:function(e)&#123; this.setState(&#123; name:e.target.value &#125;) &#125;, render:function()&#123; return( &lt;div&gt; &lt;HelloReact name=&#123;this.state.name&#125;/&gt; &lt;input type=\"text\" onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(\"app\")) 四、销毁阶段 componentWillUnmount：组件将要卸载 在ReactDOM中提供一个方法unmountComponentAtNode(删除节点的名字) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var HelloReact = React.createClass(&#123; // 组件将要接收新的属性 componentWillReceiveProps:function(newProps)&#123; console.log('componnetWillReceiveProps',1) console.log(newProps) &#125;, // 是否允许组件更新，返回true或者false，一般不会改变它的默认值：true shouldComponentUpdate:function(newProps,newState)&#123; console.log('shouldComponentUpdate',2) console.log(newProps,newState) return true; &#125;, // 组件将要更新 componentWillUpdate:function()&#123; console.log('componentWillUpdate',3) &#125;, render:function()&#123; console.log('render',4) return &lt;p&gt;Hello &#123;this.props.name?this.props.name:'React'&#125;&lt;/p&gt; &#125;, // 组件更新完毕 componentDidUpdate:function()&#123; console.log('componentDidUpdate',5) &#125;, componentWillUnmount:function()&#123; console.log('BOOOOOOOOOOOOOOOOOM') &#125;&#125;)var Demo = React.createClass(&#123; getInitialState:function()&#123; return &#123; name:'' &#125; &#125;, handleChange:function(e)&#123; // 利用input输入的内容来卸载组件 if(e.target.value == '1234')&#123; ReactDOM.unmountComponentAtNode(document.getElementById(\"app\")) // 写上这个return是为了不执行下面的语句，减少代码执行时间 return ; &#125; this.setState(&#123; name:e.target.value &#125;) &#125;, render:function()&#123; // 通过判断state的状态来卸载组件 /* if( this.state.name == '1234')&#123; return &lt;div&gt;1234&lt;/div&gt; &#125;*/ return( &lt;div&gt; &lt;HelloReact name=&#123;this.state.name&#125;/&gt; &lt;input type=\"text\" onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById(\"app\")) 五、属性状态属性的含义与用法 含义：props = properties 属性：一个事物的性质与关系，属性往往是与生俱来，无法自己改变的 12345678910111213141516171819202122232425262728// 组件传递propsvar Demo = React.createClass(&#123; render:function()&#123; return &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo title=&#123;\"Demo\"&#125;/&gt;,document.getElementById(\"app\"))``` ```javascript/* ...this.props props的一个语法糖，可以将父组件中的全部属性复制给子组件， 如果是这个标签本身拥有的这个属性*/var Demo = React.createClass(&#123; render:function()&#123; return (&lt;div&gt; &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;a &#123;...this.props&#125;&gt;&#123;this.props.title&#125;&lt;/a&gt; &lt;/div&gt;) &#125;&#125;)var props = &#123; title:'百度', href:'http://www.baidu.com'&#125;ReactDOM.render(&lt;Demo &#123;...props&#125;/&gt;,document.getElementById(\"app\")) this.props.chilidren 1234567891011121314151617181920212223242526272829/* this.props.children children没有与组件的属性一一对应，表示组件的所有子节点 一般用于列表*/console.log(React)var List = React.createClass(&#123; render:function()&#123; return(&lt;ul&gt; &#123; /* 列表项的数量以及内容不确定，在创建模板的时候需确定 利用this.props.chilidren从父组件获取需要的内容 利用React.Children.map方法进行children的遍历 */ React.Children.map(this.props.children,function(child)&#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt;) &#125;&#125;)ReactDOM.render( &lt;List&gt; &lt;h1&gt;&lt;a href=\"\"&gt;百度&lt;/a&gt;&lt;/h1&gt; &lt;a href=\"http://www.baidu.com\"&gt;http://www.baidu.com&lt;/a&gt; &lt;/List&gt;, document.getElementById(\"app\")) PropTypes 123456789101112// 属性验证：PropTypes // 验证组件的属性是否符合要求var Demo = React.createClass(&#123; PropTypes:&#123; // 要求title的类型必须是一个字符串 title:React.PropTypes.string.isRequired &#125;, render:function()&#123; return &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo title=&#123;'title'&#125; /&gt;,document.getElementById(\"app\")) 属性的两种用法 &lt;Demo title=? /&gt; ？中的内容可以是 字符串 对象{} 数组{[1,2,3]} 变量{var} 12345&lt;Demo &#123;…props&#125; /&gt;var props = &#123; one:”123”, two:”456”&#125; 状态的含义与用法 state 状态：事物所处的状况 状态是由事物自行处理，不断变化的。父组件与子组件都无法改变他的状态 状态的用法 getInitialState：初始化状态 setState：更新状态 1234567891011121314151617181920212223242526/* state 状态的意思，一般在页面中存在状态的变化以及涉及到与状态相关的 东西的时候会用他 作用：根据不同的状态显示不同的UI界面*/var Demo = React.createClass(&#123; // 设置初始的状态 getInitialState: function()&#123; return &#123; // 这里的值可以是一个boolean，string，function onOff: true &#125; &#125;, handleClick:function()&#123; // 通过点击事件来修改状态值，原来的状态值需要使用this.state获取 this.setState(&#123; onOff: !this.state.onOff &#125;) &#125;, render: function()&#123; // 每一个更新状态的时候，这个render函数都会重新被调用 return (&lt;div onClick=&#123;this.handleClick&#125;&gt;&#123;this.state.onOff?'data1':'data2'&#125;&lt;/div&gt;) &#125;&#125;)ReactDOM.render(&lt;Demo /&gt;,document.getElementById(\"app\")) 12345678910111213141516171819202122232425262728var Demo = React.createClass(&#123; // 设置默认的属性 getDefaultProps: function()&#123; return &#123; name: '现在的时间是：' &#125; &#125;, // 设置初始的状态 getInitialState: function()&#123; return &#123; time: new Date().toLocaleTimeString() &#125; &#125;, changTime:function()&#123; // 在定时器中使用this.setState的时候需要将这个this变保存起来 var that = this; setInterval(function()&#123; that.setState(&#123; time:new Date().toLocaleTimeString() &#125;) &#125;,1000) &#125;, render: function()&#123; // 每一个更新状态的时候，这个render函数都会重新被调用 return (&lt;div onClick=&#123;this.changTime()&#125;&gt;&#123;this.props.name&#125;&#123;this.state.time&#125;&lt;/div&gt;) &#125;&#125;)ReactDOM.render(&lt;Demo name='北京时间'/&gt;,document.getElementById(\"app\")) 属性与状态的对比 都是纯JS对象，使用｛｝创建的对象 都会触发render更新 都具有确定性，给定相同的属性或者是相同的状态，结果是相同的 属性与状态的区分 组件在运行时需要修改的数据就是状态 所有的数据都可以变成状态","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React之JSX语法及非DOM操作属性（二）","slug":"react-study-jsx-dom","date":"2017-11-18T17:10:24.000Z","updated":"2018-03-29T15:27:25.940Z","comments":true,"path":"2017/11/19/react-study-jsx-dom/","link":"","permalink":"http://yoursite.com/2017/11/19/react-study-jsx-dom/","excerpt":"","text":"一、JSX是什么 一个语法或者说是语法糖 基于ECMAScript一种新的特性 一种定义带属性（DOM节点）树结构（DOM结构）的语法 JSX不是 一门新的语言 XML或者HTML 一种限制，可以不使用JSX 二、JSX的特点 类XML语法，易于接受 增强JS语义，在js中编辑HTML 结构清晰 抽象程度高（核心）：避免手动DOM操作，跨平台 代码模块化 三、JSX语法 image.png 12345678910111213141516171819202122232425262728293031/* JSX（javaScriptXML）语法入门： 1、不是一门语言，是一个语法或者说是语法糖 2、JSX标签其实就是HTML标签，只不过在javascript中这些标签的时候， 不使用“”,遇到HTML标签（以&lt;开始），就用HTML规则解析，遇到代码块 （以&#123;开始），就用javascript规则解析 3、JSX语法浏览器无法解析，需要使用插件将其转化为js代码 4、代码更加直观*//* 1、首字母必须大写 2、驼峰命名 3、使用className与htmlFor代替class和for 4、组件与组件之间是可以嵌套的 5、在JSX语法中只能使用求值表达式，不能使用语句 6、只有一个顶层标签*/var Demo = React.createClass(&#123; change:function ()&#123; return 'demo' &#125;, handleClick:function()&#123; alert(1) &#125;, render: function()&#123; // this指向整个（当前的组件）组件 return &lt;div className=\"demo\" onClick=&#123;this.handleClick&#125;&gt;这是一个&#123;this.change()&#125;&lt;/div&gt; &#125;&#125;)// console.log(Demo)ReactDOM.render(&lt;Demo /&gt;,document.getElementById('app')) 四、JSX的注释 在JSX语法中，添加注释需要写在 { } 中 可以使用多行注释与单行注释 12345678910111213141516var HelloWorld = React.createClass(&#123; render:function()&#123; // 现在这里是属于js的部分,不属于JSX语法的部分 return ( &lt;div className=\"box\" // class名字 &gt; &#123;/*这是一个标题*/&#125; &lt;h1 className=\"title\"&gt;Hello World&lt;/h1&gt; &#123;/*这是说明*/&#125; &lt;p&gt;你好世界！&lt;/p&gt; &lt;div className=\"box2\"&gt;你好&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;)ReactDOM.render(&lt;HelloWorld/&gt;,document.getElementById(\"app\")) 五、JSX中使用样式 内联样式 对象样式 选择器样式（CSS样式） 123456789101112131415161718192021222324252627282930313233343536/*组件的样式: 1、行内样式：写行内样式的时候需要使用两个&#123;&#125; ==&gt;&#123;&#123;&#125;&#125; 2、对象样式：在return前面定义一个样式对象，注意样式的写法，与HTML的不同点 3、CSS样式注意事项，在HTML5中与在React中的样式的书写区别： 1、HTML5中以;结束 在React中以,结束 2、在HTML5中属性与值都不需要加上引号 在React中，属于javascript对象，key中不能存在 - , 需要使用驼峰命名，如果是value值，需要加上引号 3、在HTML中，设置带数字的值，宽度，高度==，需要带上单位 在React中可以不用带单位，直接写数字 这里是指那些规定了默认单位的值。比如说像素px，如果要使用em或者是rem则需要加上单位*//*&#123;&#125; 插值符号在使用插值符号的是有，里面需要时一个对象或者是一个表达式*/var HelloWorld = React.createClass(&#123;render:function()&#123; var styles = &#123; color: 'blue', fontSize: '30' &#125; return ( &lt;div className=\"box\"&gt; &lt;h3 className=\"title\" style=&#123;&#123;color:'red',backgroundColor:'lime'&#125;&#125;&gt;默认标题&lt;/h3&gt; &lt;p className=\"subtitle\" style=&#123;styles&#125;&gt;说明&lt;/p&gt; &lt;p className=\"details\"&gt;这个是用来教学的案例&lt;/p&gt; &lt;/div&gt; )&#125;&#125;)ReactDOM.render(&lt;HelloWorld/&gt;,document.getElementById(\"app\")) 六、条件判断的四种写法 三元表达式 ? : 使用变量，通过函数使用条件判断语句，返回一个字符串 直接在{}中调用函数 使用比较运算符 &amp;&amp; ||！` 123456789101112131415161718192021222324/*1、三元表达式 ? :2、使用变量，通过函数使用条件判断语句，返回一个字符串3、直接在&#123;&#125;中调用函数4、使用比较运算符 &amp;&amp; || ！*/var Demo = React.createClass(&#123; // 设置初始的状态 getInitialState:function()&#123; return &#123; onOff:true &#125; &#125;, // 自定义一个点击事件 handleClick:function() &#123; this.setState(&#123; onOff:!this.state.onOff &#125;) &#125;, render:function()&#123; return &lt;div className=&#123;this.state.onOff?\"box2\":\"box1\"&#125; onClick=&#123;this.handleClick&#125;&gt;我是一个盒子&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.body) 七、非DOM（元素）属性 dangerouslySetInnerHTML：在JSX中直接插入HTML代码，动态的添加HTML内容，由用户添加。需要使用属性，__html ref：父组件引用子组件 this.refs.name key：目的提高渲染性能 ，涉及到React diff算法，React通过key值判断是否重新渲染","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React之事件（四）","slug":"react-study-event","date":"2017-11-18T17:10:24.000Z","updated":"2018-03-29T15:27:25.940Z","comments":true,"path":"2017/11/19/react-study-event/","link":"","permalink":"http://yoursite.com/2017/11/19/react-study-event/","excerpt":"","text":"一、编写事件处理函数 image.png 在函数体中进行一些操作，常见的有：更新页面内容，更新组件状态，与后台交互 image.png 书写方式 123456var Demo = React.createClass(&#123; getInitialState:function()&#123; &#125;, handleClick: function(event)&#123; &#125;, handleChange: function()&#123; &#125;, render:function()&#123; &#125;, &#125;) 上面的代码中有的有参数event，有的没有，这个根据自己的需求 二、绑定事件处理函数 onClick={this,handleClick} 需要注意的是：不要在事件后面添加上一个（） 其他的事件 触摸事件：onTouchCancel，onTouchEnd，onTouchMove，onTouchStart 键盘事件：onKeyDown，onKeyUp， onKeyPress（前两者的组合） 表单时间：onChange，onInput，onSubmit 焦点事件：onFocus，onBlur UI元素事件：onScroll 滚动事件：onWhell（鼠标滚动） 鼠标事件：onClick，onContextMenu，onDoubleClick…… 1234567891011var Demo = React.createClass(&#123; handleClick:function(e)&#123; console.log(e) console.log(e.target) console.log(e.nativeEvent) &#125;, render:function()&#123; return &lt;div onClick=&#123;this.handleClick&#125;&gt;Hello World&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById('app')) 1234567891011121314151617181920212223242526272829303132var Demo = React.createClass(&#123; getInitialState:function()&#123; return &#123; width: 200, height: 200, backgroundColor: '#DDDDDD' &#125; &#125;, /*handleWheel:function(e)&#123; var newColor = (parseInt(this.state.backgroundColor.substr(1),16) + e.deltaY).toString(16) newColor = '#' + newColor.toUpperCase() console.log(newColor) this.setState(&#123; backgroundColor:newColor &#125;) &#125;,*/ randomColor:function()&#123; var r = Math.floor(Math.random()*256); var g = Math.floor(Math.random()*256); var b = Math.floor(Math.random()*256); return 'rgb('+r+','+g+','+b+')' &#125;, handleWheel:function()&#123; this.setState(&#123; backgroundColor:this.randomColor() &#125;) &#125;, render:function()&#123; return &lt;div onWheel=&#123;this.handleWheel&#125; style=&#123;this.state&#125;&gt;这是一个案例，鼠标滚动实现背景颜色的变化&lt;/div&gt; &#125;&#125;)ReactDOM.render(&lt;Demo/&gt;,document.getElementById('app')) 三、事件对象事件对象的使用 通用：所有的事件都有事件属性 image.png 键盘：键盘事件拥有的事件属性 image.png 鼠标：鼠标事件拥有的事件属性 image.png 滚动：滚动事件拥有的事件属性 为什么会有三个，因为有的设备可以实现三个方向的移动 四、事件与状态关联12345inputChange:function(event)&#123; this.setState(&#123; inputText:event.target.value &#125;)&#125; 总的来说就是使用this.setState来更新状态，而状态的值因为事件的不同会不同","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Redux之异步Action及操作（七）","slug":"redux-study-async-operation","date":"2017-11-18T17:10:24.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2017/11/19/redux-study-async-operation/","link":"","permalink":"http://yoursite.com/2017/11/19/redux-study-async-operation/","excerpt":"","text":"一、创建同步Action Action是数据从应用传递到 store/state 的载体，也是开启一次完成数据流的开始 普通的action对象 123456const action = &#123; type:'ADD_TODO', name:'poetries'&#125;dispatch(action) 封装action creator 12345678function actionCreator(data)&#123; return &#123; type:'ADD_TODO', data:data &#125;&#125;dispatch(actionCreator('poetries')) bindActionCreators合并 1234567891011121314151617181920function a(name,id)&#123; reurn &#123; type:'a', name, id &#125;&#125;function b(name,id)&#123; reurn &#123; type:'b', name, id &#125;&#125;let actions = Redux.bindActionCreators(&#123;a,b&#125;,store.dispatch)//调用actions.a('poetries','id001')actions.b('jing','id002') action创建的标准 在Flux的架构中，一个Action要符合 FSA(Flux Standard Action) 规范，需要满足如下条件 是一个纯文本对象 只具备 type 、payload、error 和 meta中的一个或者多个属性。type 字段不可缺省，其它字段可缺省 若 Action 报错，error 字段不可缺省，切必须为 true payload 是一个对象，用作Action携带数据的载体 标准action示例 A basic Flux Standard Action: 123456&#123; type: 'ADD_TODO', payload: &#123; text: 'Do something.' &#125;&#125; An FSA that represents an error, analogous to a rejected Promise 12345&#123; type: 'ADD_TODO', payload: new Error(), error: true&#125; https://github.com/acdlite/flux-standard-action 可以采用如下一个简单的方式检验一个Action是否符合FSA标准 1234// every有一个匹配不到返回falselet isFSA = Object.keys(action).every((item)=&gt;&#123; return ['payload','type','error','meta'].indexOf(item) &gt; -1&#125;) 二、创建异步action的多种方式 最简单的方式就是使用同步的方式来异步，将原来同步时一个action拆分成多个异步的action的，在异步开始前、异步请求中、异步正常返回（异常）操作分别使用同步的操作，从而模拟出一个异步操作了。这样的方式是比较麻烦的，现在已经有redux-saga等插件来解决这些问题了 异步action的实现方式一：setTimeout redux-thunk中间处理解析 12345678910function thunkAction(data) &#123; reutrn (dispatch)=&gt;&#123; setTimeout(function()&#123; dispatch(&#123; type:'ADD_TODO', data &#125;) &#125;,3000) &#125;&#125; 异步action的实现方式二：promise实现异步action redux-promise中间处理这种action 123456789101112131415function promiseAction(name)&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout((param)=&gt;&#123; resolve(&#123; type:'ADD_TODO', name &#125;) &#125;,3000) &#125;).then((param)=&gt;&#123; dispatch(action(\"action2\")) return; &#125;).then((param)=&gt;&#123; dispatch(action(\"action3\")) &#125;)&#125; 三、redux异步流程 image.png 首先发起一个action，然后通过中间件，这里为什么要用中间件呢，因为这样dispatch的返回值才能是一个函数。 通过store.dispatch，将状态的的改变传给store的小弟reducer，reducer根据action的改变，传递新的状态state。 最后将所有的改变告诉给它的大哥，store。store保存着所有的数据，并将数据注入到组件的顶部，这样组件就可以获得它需要的数据了 四、Redux异步方案选型redux-thunk Redux本身只能处理同步的Action，但可以通过中间件来拦截处理其它类型的action，比如函数(Thunk)，再用回调触发普通Action，从而实现异步处理 发送异步的action其实是被中间件捕获的，函数类型的action就被middleware捕获。至于怎么定义异步的action要看你用哪个中间件，根据他们的实例来定义，这样才会正确解析action Redux 本身不处理异步行为，需要依赖中间件。结合 redux-actions 使用，Redux 有两个推荐的异步中间件 redux-thunk redux-promise redux-thunk 的源码如下 1234567891011121314function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 源码可知，action creator 需要返回一个函数给 redux-thunk 进行调用，示例如下 1234567891011export let addTodoWithThunk = (val) =&gt; async (dispatch, getState)=&gt;&#123; //请求之前的一些处理 let value = await Promise.resolve(val + ' thunk'); dispatch(&#123; type:CONSTANT.ADD_TO_DO_THUNK, payload:&#123; value &#125; &#125;);&#125;; 而它使用起来最大的问题，就是重复的模板代码太多 1234567891011121314151617181920212223242526272829303132333435363738//action typesconst GET_DATA = 'GET_DATA', GET_DATA_SUCCESS = 'GET_DATA_SUCCESS', GET_DATA_FAILED = 'GET_DATA_FAILED'; //action creatorconst getDataAction = (id) =&gt; (dispatch, getState) =&gt; &#123; dispatch(&#123; type: GET_DATA, payload: id &#125;) api.getData(id) //注：本文所有示例的api.getData都返回promise对象 .then(response =&gt; &#123; dispatch(&#123; type: GET_DATA_SUCCESS, payload: response &#125;) &#125;) .catch(error =&gt; &#123; dispatch(&#123; type: GET_DATA_FAILED, payload: error &#125;) &#125;) &#125;&#125;//reducerconst reducer = (oldState, action) =&gt; &#123; switch(action.type) &#123; case GET_DATA : return oldState; case GET_DATA_SUCCESS : return successState; case GET_DATA_FAILED : return errorState; &#125;&#125; 这已经是最简单的场景了，请注意：我们甚至还没写一行业务逻辑，如果每个异步处理都像这样，重复且无意义的工作会变成明显的阻碍 另一方面，像GET_DATA_SUCCESS、GET_DATA_FAILED这样的字符串声明也非常无趣且易错上例中，GET_DATA这个action并不是多数场景需要的 redux-promise 由于redux-thunk写起来实在是太麻烦了，社区当然会有其它轮子出现。redux-promise则是其中比较知名的 它自定义了一个middleware，当检测到有action的payload属性是Promise对象时，就会 若resolve，触发一个此action的拷贝，但payload为promise的value，并设status属性为&quot;success&quot; 若reject，触发一个此action的拷贝，但payload为promise的reason，并设status属性为&quot;error&quot; 12345678910111213141516171819202122//action typesconst GET_DATA = 'GET_DATA';//action creatorconst getData = function(id) &#123; return &#123; type: GET_DATA, payload: api.getData(id) //payload为promise对象 &#125;&#125;//reducerfunction reducer(oldState, action) &#123; switch(action.type) &#123; case GET_DATA: if (action.status === 'success') &#123; return successState &#125; else &#123; return errorState &#125; &#125;&#125; redux-promise为了精简而做出的妥协非常明显：无法处理乐观更新 场景解析之：乐观更新 多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据 由于乐观更新发生在用户操作时，要处理它，意味着必须有action表示用户的初始动作 在上面redux-thunk的例子中，我们看到了GET_DATA, GET_DATA_SUCCESS、GET_DATA_FAILED三个action，分别表示初始动作、异步成功和异步失败，其中第一个action使得redux-thunk具备乐观更新的能力 而在redux-promise中，最初触发的action被中间件拦截然后过滤掉了。原因很简单，redux认可的action对象是 plain JavaScript objects，即简单对象，而在redux-promise中，初始action的payload是个Promise redux-promise-middleware redux-promise-middleware相比redux-promise，采取了更为温和和渐进式的思路，保留了和redux-thunk类似的三个action 12345678910111213141516171819202122232425262728//action typesconst GET_DATA = 'GET_DATA', GET_DATA_PENDING = 'GET_DATA_PENDING', GET_DATA_FULFILLED = 'GET_DATA_FULFILLED', GET_DATA_REJECTED = 'GET_DATA_REJECTED'; //action creatorconst getData = function(id) &#123; return &#123; type: GET_DATA, payload: &#123; promise: api.getData(id), data: id &#125; &#125;&#125;//reducerconst reducer = function(oldState, action) &#123; switch(action.type) &#123; case GET_DATA_PENDING : return oldState; // 可通过action.payload.data获取id case GET_DATA_FULFILLED : return successState; case GET_DATA_REJECTED : return errorState; &#125;&#125; 五、redux异步操作代码演示 根据官网的async例子分析 https://github.com/lewis617/react-redux-tutorial/tree/master/redux-examples/async action/index.js 123456789101112131415161718192021222324252627282930313233import fetch from 'isomorphic-fetch'export const RECEIVE_POSTS = 'RECEIVE_POSTS'//获取新闻成功的actionfunction receivePosts(reddit, json) &#123; return &#123; type: RECEIVE_POSTS, reddit: reddit, posts: json.data.children.map(child =&gt;child.data) &#125;&#125;function fetchPosts(subreddit) &#123; return function (dispatch) &#123; return fetch(`http://www.subreddit.com/r/$&#123;subreddit&#125;.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(subreddit, json)) ) &#125;&#125;//如果需要则开始获取文章export function fetchPostsIfNeeded(subreddit) &#123; return (dispatch, getState) =&gt; &#123; return dispatch(fetchPosts(subreddit)) &#125;&#125; fetchPostsIfNeeded这里就是一个中间件。redux-thunk会拦截fetchPostsIfNeeded这个action，会先发起数据请求，如果成功，就将数据传给action从而到达reducer那里 reducers/index.js 1234567891011121314151617181920212223242526272829import &#123; combineReducers &#125; from 'redux'import &#123; RECEIVE_POSTS&#125; from '../actions'function posts(state = &#123; items: []&#125;, action) &#123; switch (action.type) &#123; case RECEIVE_POSTS: // Object.assign是ES6的一个语法。合并对象，将对象合并为一个，前后相同的话，后者覆盖强者。详情可以看这里 // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign return Object.assign(&#123;&#125;, state, &#123; items: action.posts //数据都存在了这里 &#125;) default: return state &#125;&#125;// 将所有的reducer结合为一个,传给storeconst rootReducer = combineReducers(&#123; postsByReddit&#125;)export default rootReducer 这个跟正常的reducer差不多。判断action的类型，从而根据action的不同类型，返回不同的数据。这里将数据存储在了items这里。这里的reducer只有一个。最后结合成rootReducer,传给store store/configureStore.js 1234567891011121314151617181920212223import &#123; createStore, applyMiddleware &#125; from 'redux'import thunkMiddleware from 'redux-thunk'import createLogger from 'redux-logger'import rootReducer from '../reducers'const createStoreWithMiddleware = applyMiddleware( thunkMiddleware, createLogger() )(createStore)export default function configureStore(initialState) &#123; const store = createStoreWithMiddleware(rootReducer, initialState) if (module.hot) &#123; // Enable Webpack hot module replacement for reducers module.hot.accept('../reducers', () =&gt; &#123; const nextRootReducer = require('../reducers') store.replaceReducer(nextRootReducer) &#125;) &#125; return store&#125; 我们是如何在 dispatch 机制中引入 Redux Thunk middleware 的呢？我们使用了applyMiddleware() 通过使用指定的 middleware，action creator 除了返回 action 对象外还可以返回函数 这时，这个 action creator 就成为了 thunk 界面上的调用：在containers/App.js 123456//初始化渲染后触发 componentDidMount() &#123; const &#123; dispatch&#125; = this.props // 这里可以传两个值，一个是 reactjs 一个是 frontend dispatch(fetchPostsIfNeeded('frontend')) &#125; 改变状态的时候也是需要通过dispatch来传递的 数据的获取是通过provider,将store里面的数据注入给组件。让顶级组件提供给他们的子孙组件调用。代码如下： 12345678910111213import 'babel-core/polyfill'import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Provider &#125; from 'react-redux'import App from './containers/App'import configureStore from './store/configureStore'const store = configureStore()render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 这样就完成了redux的异步操作。其实最主要的区别还是action里面还有中间件的调用，其他的地方基本跟同步的redux差不多的。搞懂了中间件，就基本搞懂了redux的异步操作 image.png","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React之环境的搭建（一）","slug":"react-study-build-env","date":"2017-11-18T17:10:24.000Z","updated":"2018-03-29T15:27:25.939Z","comments":true,"path":"2017/11/19/react-study-build-env/","link":"","permalink":"http://yoursite.com/2017/11/19/react-study-build-env/","excerpt":"","text":"一、什么是react react是由Facebook开发的一个JavaScript库，而不是一个框架。当时Facebook需要解决一个问题，开发（或者说是构建）一个数据不断变化的大型应用。而数据变化会带来两个很严重的问题 二、react的特点 简单：学习简单，代码简单 声明式（编程）：自动DOM操作 React的核心是组件，组件的设计目的是提升代码的复用率、降低测试难度和代码复杂度。 提高代码复用率：组件将数据与逻辑封装 降低测试难度：组件高内聚低耦合，很容易对单个组件进行测试 降低代码复杂度：使用JSX语法，更直观的在js文件中看HTML代码，提高可读性 三、react的开发环境的配置 如果是要直接在HTML上编辑，需要下载react.js与react-dom.js。如果要使用JSX语法，则需要使用转换JSX语法的插件。这里使用brower.js。在线地址：https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js react.js：react的核心库 react-dom.js：提供操作DOM相关的功能 brower,js：将使用的JSX语法转换成JavaScript语法 注意：三者引用顺序必须是react、react-dom、brower 四、React、ReactDOM中有什么 image.png image.png 五、yeoman环境 yeoman前端脚手架工具 1cnpm i -g yeoman http://yeoman.io/ https://github.com/react-webpack-generators/generator-react-webpack#readme123456789# Make sure both is installed globallynpm install -g yonpm install -g generator-react-webpack# Create a new directory, and `cd` into it:mkdir my-new-project &amp;&amp; cd my-new-project# Run the generatoryo react-webpack 123456789101112131415161718192021222324# Start for developmentnpm start # ornpm run serve# Start the dev-server with the dist versionnpm run serve:dist# Just build the dist version and copy static filesnpm run dist# Run unit testsnpm test# Auto-run unit tests on file changesnpm run test:watch# Lint all files in src (also automatically done AFTER tests are run)npm run lint# Clean up the dist directorynpm run clean# Just copy the static assetsnpm run copy 六、React脚手架搭建1234567npm i create-react-appcreate-react-app your-app-name &amp;&amp; cd your-app-namenpm install npm start","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React之组件的协同及（不）可控组件（五）","slug":"react-study-component-corp-and-uncontrol","date":"2017-11-18T17:10:24.000Z","updated":"2018-03-29T15:27:25.940Z","comments":true,"path":"2017/11/19/react-study-component-corp-and-uncontrol/","link":"","permalink":"http://yoursite.com/2017/11/19/react-study-component-corp-and-uncontrol/","excerpt":"","text":"一、为什么要进行组件的协同 我们在实际的开发项目的时候，不会只用几个组件，有时候遇到大型的项目，可能会有成千上百的组件，难免会遇到有功能重复的组件。要进行修改，就会修改大部分的文件。所以我们需要进行组件的协同开发。 image.png 二、什么是组件的协同使用？ 组件的协同本质上是对组件的一种组织、管理的方式。 目的： 逻辑清晰：这是组件与组件之间的逻辑 代码模块化 封装细节：像面向对象一样将常用的方法以及数据封装起来 提高代码的复用性：因为是组件，相当于一个封装好的东西，用的时候直接调用 三、如何实现组件的协同使用 第一种：增加一个父组件，将其他的组件进行嵌套，更多的是实现代码的封装 第二种：通过一些操作从后台获取数据，React中的Mixin，更多的是实现代码的复用 四、组件嵌套的含义 组件嵌套的本质是父子关系 image.png 五、组件嵌套的优缺点 优点： 逻辑清晰：父子关系类似于人类中的父子关系 模块化开发：每个模块对应一个功能，不同的模块可以同步开发 封装细节：开发者必须要关注组件的功能，不需要了解细节 缺点： 编写难度高：父子组件的关系需要经过深思熟虑，贸然编写可能导致关系混乱，代码难以维护 无法掌握所有细节：使用者只知道组件的用法，不知道实现细节，遇到问题难以修复 六、MixinMixin的含义 Mixin=一组方法。 他的目的是横向抽离出组件的相似代码，把组件的共同作用以及效果的代码提出来 image.png Mixin的优缺点 优点 代码复用：抽离出通用的代码，减少开发成本，提高开发效率 即插即用：可以使用许多现有的Mixin来开发自己的代码 适应性强：改动一次代码，影响多个组件 缺点 编写难度高：Mixin可能被用在各种环境中，想要兼容多种环境就需要更多的 - 码与逻辑，通用的代价是提高复杂度 降低代码的可读性：组件的优势在于将逻辑与是界面直接结合在一起，Mixin本质上会分散逻辑，理解起来难度大 七、不可控组件 image.png 上图：defaultValue的值是固定的，这就是一个不可控组件 如果要获取input的value值，只有使用ref获取节点来获取值 八、可控组件 image.png defaultValue的值是根据状态确定了，只需要拿到this.state.value的值就可以了 这里需要注意一下：使用value的值是不可修改的，defaultValue的值是可以修改的 可控组件的优点 符合React的数据流 数据存储在state中，便于获取 便于处理数据","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"浅谈styled-components","slug":"react-styled-components","date":"2017-11-08T08:55:24.000Z","updated":"2018-03-29T15:27:26.001Z","comments":true,"path":"2017/11/08/react-styled-components/","link":"","permalink":"http://yoursite.com/2017/11/08/react-styled-components/","excerpt":"","text":"一、简介 styled components一种全新的控制样式的编程方式，它能解决CSS全局作用域的问题，而且移除了样式和组件间的映射关系 我们要理清一件事情：styled-components 只是 CSS 层面的高度抽象。它只是解析定义在 JavaScript中的 CSS，然后生成对应 CSS 的 JSX元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import styled from 'styled-components';import &#123; render &#125; from 'react-dom'; const Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred;`;WrapSearchBox=styled.div` width : 200px; // 媒体查询 @media (max-width : 800px)&#123; width : 100%; padding-left:15px; margin-top:-14px; &#125; &gt;div&#123; @media (max-width : 800px)&#123; width : 100% !important; &#125; &#125; &gt;div&gt;input &#123; width:200px !important; padding-left:25px !important; @media (max-width : 800px)&#123; width : 100% !important; &#125;&#125;` class App extends React.Component &#123; render() &#123; return ( &lt;Title&gt;Hello world&lt;/Title&gt; ) &#125;&#125; render( &lt;App /&gt;, document.getElementById('app')); styled.h1是一个标签模板函数 styled.h1函数返回一个React Component，styled components会为这个React Component添加一个class，该class的值为一个随机字符串。传给styled.h1的模板字符串参数的值实际上是CSS语法，这些CSS会附加到该React Component的class中，从而为React Component添加样式 image.png 二、基于 props 定制主题12345678910111213141516const Button = styled.button` background: $&#123;props =&gt; props.primary ? 'palevioletred' : 'white'&#125;; color: $&#123;props =&gt; props.primary ? 'white' : 'palevioletred'&#125;; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button primary&gt;Primary&lt;/Button&gt; &lt;/div&gt;); 1234567891011121314151617export const StyledSlider = styled(Slider)` $&#123;props =&gt; &#123; const theme = props.theme.slider; return css` div.rc-slider-track &#123; background-color: $&#123;theme.themeColor&#125;; &#125; div.rc-slider-handle &#123; border: 2px solid $&#123;theme.themeColor&#125;; &#125; span.rc-slider-dot-active &#123; border-color: $&#123;theme.themeColor&#125;; &#125; `; &#125;&#125;`; 12345678910111213141516171819202122232425262728export const SmallSelectWrapper = styled.div ` // div下面的类样式 .Select-control &#123; height: 30px; &#125; .Select-input &#123; height: 28px; &#125; .Select-value, .Select-placeholder &#123; line-height: 28px !important; &#125; .Select-menu-outer &#123; max-height: 270px; .Select-option.is-disabled &#123; cursor: default; padding-left: .5em; font-weight: bold; color: #333; background: #f8f8f8; &#125; &#125; .Select-menu &#123; max-height:268px; &#125; text-align: left;` 我们在组件中传入的所有 props 都可以在定义组件时获取到，这样就可以很容易实现组件主题的定制。如果没有 styled-components的情况下，需要使用组件 style 属性或者定义多个 class 的方式来实现 三、组件样式继承 通常在 css 中一般会通过给 class传入多个 name 通过空格分隔的方式来复用 class 定义，类似 class=&quot;button tomato&quot;。在 styled-components中利用了 js 的继承实现了这种样式的复用： 12345678910111213const Button = styled.button` color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;const TomatoButton = Button.extend` color: tomato; border-color: tomato;`; 子组件中的属性会覆盖父组件中同名的属性 四、组件内部使用 className 在日常开发中总会出现覆盖组件内部样式的需求，你可能想在 styled-components 中使用 className，或者在使用第三方组件时。 1234&lt;Wrapper&gt; &lt;h4&gt;Hello Word&lt;/h4&gt; &lt;div className=\"detail\"&gt;&lt;/div&gt;&lt;/Wrapper&gt; 五、组件中维护其他属性 styled-components 同时支持为组件传入 html 元素的其他属性，比如为 input 元素指定一个 type 属性，我们可以使用 attrs 方法来完成 12345678const Password = styled.input.attrs(&#123; type: 'password',&#125;)` color: palevioletred; font-size: 1em; border: 2px solid palevioletred; border-radius: 3px;`; 在实际开发中，这个方法还有一个有用处，用来引用第三方类库的 css样式： 1234567891011const Button = styled.button.attrs(&#123; className: 'small',&#125;)` background: black; color: white; cursor: pointer; margin: 1em; padding: 0.25em 1em; border: 2px solid black; border-radius: 3px;`; 编译后的 html 结构如下： 123&lt;button class=\"sc-gPEVay small gYllyG\"&gt; Styled Components&lt;/button&gt; 可以用这种方式来使用在别处定义的 small 样式，或者单纯为了识别自己定义的 class，因为正常情况下我们得到的 class名是不可读的编码 六、CSS 动画支持 styled-components 同样对 css 动画中的 @keyframe 做了很好的支持。 12345678910111213import &#123; keyframes &#125; from 'styled-components';const fadeIn = keyframes` 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;`;const FadeInButton = styled.button` animation: 1s $&#123;fadeIn&#125; ease-out;`; 七、兼容现在已有的 react components 和 css 框架 styled-components 采用的 css-module 的模式有另外一个好处就是可以很好的与其他的主题库进行兼容。因为大部分的 css 框架或者css主题都是以 className 的方式进行样式处理的，额外的 className 和主题的 className 并不会有太大的冲突 styled-components 的语法同样支持对一个 React组件进行扩展 12345678910111213141516const StyledDiv = styled(Row)` position: relative; height: 100%; .image img &#123; width: 100%; &#125; .content &#123; min-height: 30em; overflow: auto; &#125; .content h2 &#123; font-size: 1.8em; color: black; margin-bottom: 1em; &#125;`; 八、实战篇extend与styled 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*基础组件button*/export const Button = styled.button` border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: $&#123;props=&gt;props.primary?\"palevioletred\":\"transparent\"&#125;; color: $&#123;props=&gt;props.primary?\"white\":\"palevioletred\"&#125;; border: 2px solid palevioletred;`;/*扩展按钮的属性，不再原来基础上修改 如在&lt;button class=\"abc con\"&gt;上添加一个con类一样*/export const AButton = styled(Button)` width:200px; height:20px; padding:20px;`/*扩展的结果*/button &#123; border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: transparent; color: palevioletred; border: 2px solid palevioletred;&#125;/**添加的扩展属性**/.con &#123; background: yellow;&#125;/*继承按钮的样式并且在原来基础上修改 如在&lt;button class=\"con\"&gt;.con类上叠加属性一样**/export const TomatoButton = Button.extend` width:200px; height:10%;`/*继承的结果 子组件中的属性会覆盖父组件中同名的属性*/button &#123; border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: transparent; color: palevioletred; border: 2px solid palevioletred; /*添加的继承属性*/ width: 200px; height: 10%;&#125; 1234567891011121314const Button = styled.button` padding: 10px;`;const TomatoButton = Button.extend` color: #f00;`;/** css写法 **/button &#123; padding: 10px;&#125;button.tomato-button &#123; color: #f00;&#125; 传递属性的两中写法 123&lt;Button primary /&gt;&lt;Button secondary /&gt;&lt;Button primary active=&#123;true&#125; /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*对单个属性的值做判断赋值*/styled.Button` background: $&#123;props =&gt; props.primary ? '#f00' : props.secondary ? '#0f0' : '#00f'&#125;; color: $&#123;props =&gt; props.primary ? '#fff' : props.secondary ? '#fff' : '#000'&#125;; opacity: $&#123;props =&gt; props.active ? 1 : 0&#125;;`;const Button = styled.button` border-radius: 3px; padding: 0.25em 1em; margin: 0 1em; background: transparent; color: palevioletred; border: 2px solid palevioletred; /*可以写一堆属性*/ $&#123;props =&gt; props.primary &amp;&amp; css` background: palevioletred; color: white; `&#125;`;/**css写法**/button &#123; background: #00f; opacity: 0; color: #000;&#125;button.primary,button.seconary &#123; color: #fff;&#125;button.primary &#123; background: #f00;&#125;button.secondary &#123; background: #0f0;&#125;button.active &#123; opacity: 1;&#125; 使用 1&lt;Button primary&gt;&lt;/Button&gt; 九、总结 提出了 container 和 components 的概念，移除了组件和样式之间的映射关系，符合关注度分离的模式； 可以在样式定义中直接引用到 js 变量，共享变量，非常便利； 支持组件之间继承，方便代码复用，提升可维护性； 兼容现有的 className 方式，升级无痛；","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react知识点回顾","slug":"react-summary","date":"2017-11-07T11:55:24.000Z","updated":"2018-03-29T15:27:26.035Z","comments":true,"path":"2017/11/07/react-summary/","link":"","permalink":"http://yoursite.com/2017/11/07/react-summary/","excerpt":"","text":"来源于互联网 一、npm的配置 切换淘宝镜像源 12345npm config set registry https://registry.npm.taobao.orgnpm config get registrynpm install -g cnpm --registry=https://registry.npm.taobao.org 使用npm安装react 1cnpm install react react-dom --save 二、开发环境配置 这里使用create-react-app初始化项目 1npm install create-react-app -g 安装完成之后就可以在命令行使用 create-react-app 了，首先选择一个合适的目录，然后只需要简单地输入 1create-react-app yourfilename 三、认识JSX3.1 JSX 简介 JSX 其是一个语法扩展，它既不是单纯的字符串，也不是HTML，虽然长得和 HTML 很像甚至基本上看起来一样。但事实上它是 React 内部实现的一种，允许我们直接在 JS 里书写 UI 的方式 3.2 JSX 属性 JSX 的标签同样可以拥有自己的属性 1const title = &lt;h1 id=\"main\"&gt;React Learning&lt;/h1&gt; 12// 注意是 className 而不是 classconst title = &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; 3.3 JSX 嵌套 JSX 的标签也可以像 HTML 一样相互嵌套，一般有嵌套解构的 JSX 元素外面，我们习惯于为它加上一个小括号 123456const title = ( &lt;div&gt; &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; &lt;p&gt;Let's learn JSX&lt;/p&gt; &lt;/div&gt;) 需要注意的是，JSX 在嵌套时，最外层有且只能有一个标签，否则就会出错 12345// 这是一个错误示例const title = ( &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; &lt;p&gt;Let's learn JSX&lt;/p&gt;) 3.4 JSX表达式 在 JSX 元素中，我们同样可以使用 JavaScript 表达式，在 JSX 当中的表达式需要用一个大括号括起来 12345678910function sayhi(name) &#123; return 'Hi,' + name&#125;const title = ( &lt;div&gt; &lt;h1 className=\"main\"&gt;React Learning&lt;/h1&gt; &lt;p&gt;Let's learn JSX. &lt;span&gt;&#123;sayhi('you')&#125;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;) 四、组件类型4.1 函数定义与类定义组件 第一种函数定义组件，非常简单啦，我们只需要定义一个接收props传值，返回React元素的方法即可 123function Title(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;&#125; 12// 甚至使用ES6的箭头函数简写之后可以变成这样const Title = props =&gt; &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt; 第二种是类定义组件，也就是使用ES6中新引入的类的概念来定义React组件 组件在定义好之后，可以通过JSX描述的方式被引用，组件之间也可以相互嵌套和组合 12345class Title extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 4.2 展示与容器组件12345678910111213141516// 展示组件class CommentList extends React.Component &#123; constructor(props) &#123; super(props) &#125; renderComment(&#123;body, author&#125;) &#123; return &lt;li&gt;&#123;body&#125;—&#123;author&#125;&lt;/li&gt; &#125; render() &#123; return &lt;ul&gt; &#123;this.props.comments.map(this.renderComment)&#125; &lt;/ul&gt; &#125; &#125; 123456789101112131415161718192021// 容器组件class CommentListContainer extends React.Component &#123; constructor() &#123; super() this.state = &#123; comments: [] &#125; &#125; componentDidMount() &#123; $.ajax(&#123; url: \"/my-comments.json\", dataType: 'json', success: function(comments) &#123; this.setState(&#123;comments: comments&#125;) &#125;.bind(this) &#125;) &#125; render() &#123; return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt; &#125;&#125; 展示组件 主要负责组件内容如何展示 从props接收父组件传递来的数据 大多数情况可以通过函数定义组件声明 容器组件 主要关注组件数据如何交互 拥有自身的state，从服务器获取数据，或与redux等其他数据处理模块协作 需要通过类定义组件声明，并包含生命周期函数和其他附加方法 那么这样写具体有什么好处呢？ 解耦了界面和数据的逻辑 更好的可复用性，比如同一个回复列表展示组件可以套用不同数据源的容器组件 利于团队协作，一个人负责界面结构，一个人负责数据交互 4.3 有状态与无状态组件有状态组件 这个组件能够获取储存改变应用或组件本身的状态数据，在React当中也就是state，一些比较明显的特征是我们可以在这样的组件当中看到对this.state的初始化，或this.setState方法的调用 无状态组件 这样的组件一般只接收来自其他组件的数据。一般这样的组件中只能看到对this.props的调用 12345678910111213141516171819202122// 有状态组件class StatefulLink extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; active: false &#125; &#125; handleClick() &#123; this.setState(&#123; active: !this.state.active &#125;) &#125; render() &#123; return &lt;a style=&#123;&#123; color: this.state.active ? 'red' : 'black' &#125;&#125; onClick=&#123;this.handleClick.bind(this)&#125; &gt; Stateful Link &lt;/a&gt; &#125;&#125; 12345678910111213141516171819202122// 无状态组件class StatelessLink extends React.Component &#123; constructor(props) &#123; super(props) &#125; handleClick() &#123; this.props.handleClick(this.props.router) &#125; render() &#123; const active = this.props.activeRouter === this.props.router return ( &lt;li&gt; &lt;a style=&#123;&#123; color: active ? 'red' : 'black' &#125;&#125; onClick=&#123;this.handleClick.bind(this)&#125; &gt; Stateless Link &lt;/a&gt; &lt;/li&gt; ) &#125;&#125; 在React的实际开发当中，我们编写的组件大部分都是无状态组件。毕竟React的主要作用是编写用户界面。再加上ES6的新特性，绝大多数的无状态组件都可以通过箭头函数简写成类似下面这样 1const SimpleButton = props =&gt; &lt;button&gt;&#123;props.text&#125;&lt;/button&gt; 4.4 受控与非受控组件受控组件 比如说设置了value的&lt;input&gt; 是一个受控组件。对于受控的&lt;input&gt;，渲染出来的html元素始终保持着value属性的值，如以下代码 image 此时如果想要更新用户的值。需要使用onChange事件 image 非受控组件 即没有设置value或者设置为null的是一个非受控组件，对于非受控的input组件，用户的输入会直接反映在页面上 image 上面的代码渲染出一个空值的输入框，用户的输入立即会反映在元素上 和受控组件一样，使用onChange事件来监听值的变化，如果想要给组件设置一个非空的初始值。可以使用defaultValue属 通常情况下，React当中所有的表单控件都需要是受控组件 4.5 组合与继承 React当中的组件是通过嵌套或组合的方式实现组件代码复用的 通过props传值和组合使用组件几乎可以满足所有场景下的需求。这样也更符合组件化的理念，就好像使用互相嵌套的DOM元素一样使用React的组件，并不需要引入继承的概念 继承的写法并不符合React的理念。在React当中props其实是非常强大的，props几乎可以传入任何东西，变量、函数、甚至是组件本身 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className=\"SplitPane\"&gt; &lt;div className=\"SplitPane-left\"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=\"SplitPane-right\"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; )&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; )&#125; React官方也希望我们通过组合的方式来使用组件，如果你想实现一些非界面类型函数的复用，可以单独写在其他的模块当中在引入组件进行使用 五、组件数据 5.1 props 传入变量 传入函数 传入组件 props.children 在形式上，props之于JSX就相当于attributes之于HTML。从写法上来看呢，我们为组件传入props就可以像为HTML标签添加属性一样 在概念上，props对于组件就相当于JS中参数之于函数。我们可以抽象出这样一个函数来解释 props 几乎可以传递所有的内容，包括变量、函数、甚至是组件本身 props是只读的 在React中，props都是自上向下传递，从父组件传入子组件 并且props是只读的，我们不能在组件中直接修改props的内容 也即是说组件只能根据传入的props渲染界面，而不能在其内部对props进行修改 props类型检查 正是因为props的强大，什么类型的内容都可以传递，所以在开发过程中，为了避免错误类型的内容传入，我们可以为props添加类型检查 props默认值 由于props是只读的，我们不能直接为props赋值。React专门准备了一个方法定义props的默认值 123456789101112import React from 'react'import PropTypes from 'prop-types'const Title = props =&gt; &lt;h1&gt;&#123;props.title&#125;&lt;/h1&gt;Title.defaultProps = &#123; title: 'Wait for parent to pass props.'&#125;Title.propTypes = &#123; title: PropTypes.string.isRequired&#125; 5.2 state 初始化 setState方法 向下传递数据 在React中state也是我们进行数据交互的地方，又或者叫做state management状态管理。 一个应用需要进行数据交互，比如同服务器之间的交互，同用户输入进行交互。话反过来，从API获取数据，处理用户输入也就是我们需要用到state的时候 在新版本的React当中，我们通过类定义组件来声明一个有状态组件，之后在它的构造方法中初始化组件的state，我们可以先赋予它默认值。 之后就可以在组件中通过this.state来访问它，既然是state那么肯定涉及到数据的改变，因此我们还需额外定义一个负责处理state变化的函数，这样的函数中一般都会包含this.setState这个方法 和之前的props一样，初始化state之后，如果我们想改变它，是不可以直接对其赋值的，直接修改state的值没有任何意义，因为这样的操作脱离了React运行的逻辑，不会触发组件的重新渲染。所以需要this.setState这个方法，在改变state的同时，触发React内部的一系列函数，最后在页面上重新渲染出组件 1234567891011121314151617181920212223242526class Counter extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; counter: 0 &#125; &#125; addOne() &#123; this.setState((prevState) =&gt;(&#123; counter: prevState.counter + 1 &#125;)) &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123; this.state.counter &#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.addOne()&#125;&gt; Increment &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 六、组件生命周期6.1 React是如何渲染组件的 在新版本的React当中，React的底层被重写了。React换上了一个新的引擎，这个引擎叫做React Fiber.React Fiber 作用的也即是React最核心的功能，它将React应用界面更新的过程分为了两个主要的部分： 调度过程 执行过程 在调度过程中，有4个生命周期函数会被触发 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 在执行过程中，有3个生命周期函数会被触发： componentDidMount componentDidUpdate componentWillUnmount 6.2 React组件生命周期方法 React为了方便我们更好地控制自己的应用，提供了许多预置的生命周期方法。这些固定的生命周期方法分别会在组件的挂载流程、更新流程、卸载流程中触发 componentWillMount 开始插入真实DOM componentDidMount 插入真实DOM完成 componentWillUpdate 开始重新渲染 componentDidUpdate 重新渲染完成 componentWillUnmount已移出真实 DOM componentWillReceiveProps 已加载组件收到新的参数时调用 shouldComponentUpdate组件判断是否重新渲染时调用 image.png componentDidMount 在此方法中可进行 与其他 JavaScript 框架集成，如初始化 jQuery 插件； 使用 setTimeout/setInterval 设置定时器； 通过 Ajax/Fetch 获取数据； 绑定 DOM 事件 6.3 总结 React组件渲染包含三个流程：挂载流程、更新流程、卸载流程 各个生命周期函数会在特定的时刻触发并适用于不同的使用场景 通过使用生命周期函数我们可以对应用进行更精准的控制 如果你需要发起网络请求，将其安排在合适的生命周期函数中是值得推荐的做法 了解掌握React组件渲染的流程和原理对我们更深入掌握React非常有帮助 七、表单及事件处理7.1 表单 受控与非受控组件就是专门适用于React当中的表单元素的 只要是有表单出现的地方，就会有用户输入，就会有表单事件触发，就会涉及的数据处理 在我们用React开发应用时，为了更好地管理应用中的数据，响应用户的输入，编写组件的时候呢，我们就会运用到受控组件与非受控组件这两个概念。 7.2 表单元素 我们在组件中声明表单元素时，一般都要为表单元素传入应用状态中的值，可以通过state也可以通过props传递，之后需要为其绑定相关事件，例如表单提交，输入改变等。在相关事件触发的处理函数中，我们需要根据表单元素中用户的输入，对应用数据进行相应的操作和改变 12345678910111213141516171819202122class ControlledInput extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; value: \"\" &#125; &#125; handleChange(event) &#123; this.setState(&#123; value: event.target.value &#125;) &#125; render() &#123; return &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;() =&gt; this.handleChange()&#125; /&gt; &#125;&#125; 受控组件的输入数据是一直和我们的应用状态绑定的，事件处理函数中一定要有关state的更新操作，这样表单组件才能及时正确响应用户的输入 textarea 1234567&lt;!--HTML--&gt;&lt;textarea&gt; Hello there, this is some text in a text area&lt;/textarea&gt;&lt;!--jsx--&gt;&lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; select 123456789101112131415&lt;!--HTML--&gt;&lt;select&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option selected value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;&lt;/select&gt;&lt;!--jsx--&gt;&lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;&lt;/select&gt; 7.3 事件123456789&lt;!--HTML--&gt;&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt;&lt;!--jsx--&gt;&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; 八、redux-router react-router 8.1、基本用法 使用时，路由器Router就是React的一个组件 12import &#123; Router &#125; from 'react-router';render(&lt;Router/&gt;, document.getElementById('app')); Router组件本身只是一个容器，真正的路由要通过Route组件定义 1234567import &#123; Router, Route, hashHistory &#125; from 'react-router';render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;/&gt; &lt;/Router&gt;), document.getElementById('app')); 上面代码中，用户访问根路由/，组件APP就会加载到document.getElementById(&#39;app&#39;) Router组件有一个参数history，它的值hashHistory表示，路由的切换由URL的hash变化决定，即URL的#部分发生变化 Route组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件 12345&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;/&gt; &lt;Route path=\"/repos\" component=&#123;Repos&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt;&lt;/Router&gt; 上面代码中，用户访问/repos（比如http://localhost:8080/#/repos）时，加载Repos组件；访问/about（http://localhost:8080/#/about）时，加载About组件 8.2、嵌套路由 Route组件还可以嵌套 123456&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;Route path=\"/repos\" component=&#123;Repos&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面代码中，用户访问/repos时，会先加载App组件，然后在它的内部再加载Repos组件 123&lt;App&gt; &lt;Repos/&gt;&lt;/App&gt; App组件要写成下面的样子 1234567export default React.createClass(&#123; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125;) App组件的this.props.children属性就是子组件 8.3、 path 属性 Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件 Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件 123&lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt;&lt;/Route&gt; 当用户访问/inbox/messages/:id时，会加载下面的组件 123&lt;Inbox&gt; &lt;Message/&gt;&lt;/Inbox&gt; 如果省略外层Route的path参数，写成下面的样子 123&lt;Route component=&#123;Inbox&#125;&gt; &lt;Route path=\"inbox/messages/:id\" component=&#123;Message&#125; /&gt;&lt;/Route&gt; 现在用户访问/inbox/messages/:id时，组件加载还是原来的样子 123&lt;Inbox&gt; &lt;Message/&gt;&lt;/Inbox&gt; 8.4、通配符 path属性可以使用通配符 123456789101112131415161718192021&lt;Route path=\"/hello/:name\"&gt;// 匹配 /hello/michael// 匹配 /hello/ryan&lt;Route path=\"/hello(/:name)\"&gt;// 匹配 /hello// 匹配 /hello/michael// 匹配 /hello/ryan&lt;Route path=\"/files/*.*\"&gt;// 匹配 /files/hello.jpg// 匹配 /files/hello.html&lt;Route path=\"/files/*\"&gt;// 匹配 /files/ // 匹配 /files/a// 匹配 /files/a/b&lt;Route path=\"/**/*.jpg\"&gt;// 匹配 /files/hello.jpg// 匹配 /files/path/to/file.jpg 通配符的规则如下 :paramName :paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出 () ()表示URL的这个部分是可选的 匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式 path属性也可以使用相对路径（不以/开头），匹配时就会相对于父组件的路径。嵌套路由如果想摆脱这个规则，可以使用绝对路由 此外，URL的查询字符串/foo?bar=baz，可以用this.props.location.query.bar获取 8.5、IndexRoute 组件123456&lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;Route path=\"accounts\" component=&#123;Accounts&#125;/&gt; &lt;Route path=\"statements\" component=&#123;Statements&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面代码中，访问根路径/，不会加载任何子组件。也就是说，App组件的this.props.children，这时是undefined 因此，通常会采用{this.props.children || &lt;Home/&gt;}这样的写法。这时，Home明明是Accounts和Statements的同级组件，却没有写在Route中 IndexRoute就是解决这个问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html 1234567&lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path=\"accounts\" component=&#123;Accounts&#125;/&gt; &lt;Route path=\"statements\" component=&#123;Statements&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 现在，用户访问/的时候，加载的组件结构如下 123&lt;App&gt; &lt;Home/&gt;&lt;/App&gt; 注意，IndexRoute组件没有路径参数path 8.6、Redirect 组件 &lt;Redirect&gt;组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由 1234&lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125; ＜Redirect from=\"messages/:id\" to=\"/messages/:id\" /&gt;&lt;/Route&gt; 现在访问/inbox/messages/5，会自动跳转到/messages/5 8.7、IndexRedirect 组件 IndexRedirect组件用于访问根路由的时候，将用户重定向到某个子组件 12345&lt;Route path=\"/\" component=&#123;App&#125;&gt; ＜IndexRedirect to=\"/welcome\" /&gt; &lt;Route path=\"welcome\" component=&#123;Welcome&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt;&lt;/Route&gt; 用户访问根路径时，将自动重定向到子组件welcome 8.8、Link Link组件用于取代&lt;a&gt;元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是&lt;a&gt;元素的React 版本，可以接收Router的状态 12345678render() &#123; return &lt;div&gt; &lt;ul role=\"nav\"&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/repos\"&gt;Repos&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&#125; 如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性 12&lt;Link to=\"/about\" activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;About&lt;/Link&gt;&lt;Link to=\"/repos\" activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;Repos&lt;/Link&gt; 在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写 12import &#123; browserHistory &#125; from 'react-router';browserHistory.push('/some/path'); 8.9、IndexLink 如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件 是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配 123&lt;IndexLink to=\"/\" activeClassName=\"active\"&gt; Home&lt;/IndexLink&gt; 上面代码中，根路由只会在精确匹配时，才具有activeClassName 8.10、histroy 属性 Router组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配 history属性，一共可以设置三种值。 browserHistory hashHistory createMemoryHistory 如果设为hashHistory，路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path 123456import &#123; hashHistory &#125; from 'react-router'render( &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById('app')) 如果设为browserHistory，浏览器的路由就不再通过Hash完成了，而显示正常的路径example.com/some/path，背后调用的是浏览器的History API 123456import &#123; browserHistory &#125; from 'react-router'render( &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById('app')) 但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。 8.11、表单处理 Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作 12345&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" placeholder=\"userName\"/&gt; &lt;input type=\"text\" placeholder=\"repo\"/&gt; &lt;button type=\"submit\"&gt;Go&lt;/button&gt;&lt;/form&gt; 第一种方法是使用browserHistory.push 12345678910import &#123; browserHistory &#125; from 'react-router'// ... handleSubmit(event) &#123; event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;` browserHistory.push(path) &#125;, 第二种方法是使用context对象 123456789101112export default React.createClass(&#123; // ask for `router` from context contextTypes: &#123; router: React.PropTypes.object &#125;, handleSubmit(event) &#123; // ... this.context.router.push(path) &#125;,&#125;) 8.12、路由的钩子 每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发 上面的代码中，如果用户离开/messages/:id，进入/about时，会依次触发以下的钩子 /messages/:id的onLeave /inbox的onLeave /about的onEnter 九、redux9.1 Redux 的适用场景 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 Redux设计思想 Redux 的设计思想很简单，就两句话 Web 应用是一个状态机，视图与状态是一一对应的 所有的状态，保存在一个对象里面 9.2 基本概念和 APIStore Store 提供了三个方法 store.getState() store.dispatch() store.subscribe() 12import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); Store就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store Redux 提供createStore这个函数，用来生成 Store 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); // 返回新生成的 Store 对象 State Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State 当前时刻的 State，可以通过store.getState()拿到 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然 Action State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了 Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置 1234const action = &#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux 可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store action有两个作用，一个是定义我们的应用可以进行的动作或操作的类型，另一个是传递改变应用状态的数据。在Redux的约定中，action只有type属性是必须包含的，其他的数据如何定义全在于你想要如何使用，当然如果你希望你定义的action能够规范一些的话，也可以遵从Flux Standard Action的标准 1234567891011121314&#123; // action 类型 type: 'INCREMENT', // payload 中返回我们要传递的数据，用来修改应用 state payload: &#123; num: 1 &#125;, // payload 数据未获取成功时返回 true error: false, // 一些不必要在 payload 中传递的其他数据 meta: &#123; success: true &#125;&#125; Action Creator View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator 12345678910const ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); 上面代码中，addTodo函数就是一个 Action Creator store.dispatch() store.dispatch()是 View 发出 Action 的唯一方法 1234567import &#123; createStore &#125; from 'redux';const store = createStore(fn);store.dispatch(&#123; type: 'ADD_TODO', payload: 'Learn Redux'&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去 结合 Action Creator，这段代码可以改写如下 1store.dispatch(addTodo('Learn Redux')); Reducer Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer 1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行 为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法 12import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(reducer); 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State 为什么这个函数叫做 Reducer呢？因为它可以作为数组的reduce方法的参数 纯函数 Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出 纯函数是函数式编程的概念，必须遵守以下一些约束 不得改写参数 不能调用系统 I/O 的API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象 store.subscribe() Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数 1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染 store.subscribe方法返回一个函数，调用这个函数就可以解除监听 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); 9.3 Reducer 的拆分 Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大 123456789101112131415161718const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case ADD_CHAT: return Object.assign(&#123;&#125;, state, &#123; chatLog: state.chatLog.concat(payload) &#125;); case CHANGE_STATUS: return Object.assign(&#123;&#125;, state, &#123; statusMessage: payload &#125;); case CHANGE_USERNAME: return Object.assign(&#123;&#125;, state, &#123; userName: payload &#125;); default: return state; &#125;&#125;; 1234567const chatReducer = (state = defaultState, action = &#123;&#125;) =&gt; &#123; return &#123; chatLog: chatLog(state.chatLog, action), statusMessage: statusMessage(state.statusMessage, action), userName: userName(state.userName, action) &#125;&#125;; 上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属 这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合:一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer 123456789import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法 1234567function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象 你可以把所有子 Reducer 放在一个文件里面，然后统一引入 1234import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 9.4 工作流程 image image.png react组件+redux单向数据流 前端异步请求用例 PFAT如何解决前端异步请求的用例？ 首先，用户发出 Action 1store.dispatch(action); 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 1let nextState = todoApp(previousState, action); State 一旦有变化，Store 就会调用监听函数 12// 设置监听函数store.subscribe(listener); listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View 1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 9.5 实例：计数器12345678910111213141516171819202122232425262728293031const Counter = (&#123; value, onIncrement, onDecrement &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const reducer = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(reducer);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125; /&gt;, document.getElementById('root') );&#125;;render();store.subscribe(render); 十、中间件与异步操作 Redux 的基本做法：用户发出 Action，Reducer 函数算出新的 State，View 重新渲染 一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步 怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware） image 10.1 中间件的概念 中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 10.2 中间件的用法 常用的中间件都有现成的，只要引用别人写好的模块即可。比如日志中间件，就有现成的redux-logger模块 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger)); 上面代码中，redux-logger提供一个生成器createLogger，可以生成日志中间件logger。然后，将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强 这里有两点需要注意 （1）createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了 12345const store = createStore( reducer, initial_state, applyMiddleware(logger)); （2）中间件的次序有讲究 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); 上面代码中，applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确 10.3、applyMiddlewares() applyMiddlewares这个方法。它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行 10.4 异步操作的基本思路 理解了中间件以后，就可以处理异步操作了 同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action 操作发起时的 Action 操作成功时的 Action 操作失败时的 Action 以向服务器取出数据为例，三种 Action 可以有两种不同的写法 123456789// 写法一：名称相同，参数不同&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', response: &#123; ... &#125; &#125;// 写法二：名称不同&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125; 除了 Action种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子 123456let state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125;; 上面代码中，State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间 现在，整个异步操作的思路就很清楚了 操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染 操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染 10.5 redux-thunk 中间件 异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢 奥妙就在 Action Creator 之中 1234567class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props dispatch(fetchPosts(selectedPost)) &#125;// ... 上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，向服务器要求数据 fetchPosts(selectedSubreddit)。这里的fetchPosts就是 Action Creator 下面就是fetchPosts的代码，关键之处就在里面 image 1234567891011121314const fetchPosts = postTitle =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(postTitle, json))); &#125;;&#125;;// 使用方法一store.dispatch(fetchPosts('reactjs'));// 使用方法二store.dispatch(fetchPosts('reactjs')).then(() =&gt; console.log(store.getState())); 上面代码中，fetchPosts是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（requestPosts(postTitle)），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)） 上面代码中，有几个地方需要注意 fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象 返回的函数的参数是dispatch和getState这两个 Redux方法，普通的Action Creator的参数是 Action 的内容 在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始 异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束 这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数 这时，就要使用中间件redux-thunk 123456789import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducers';// Note: this API requires redux@&gt;=3.1.0const store = createStore( reducer, applyMiddleware(thunk)); 上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数 因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch 10.6、redux-promise 中间件 既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象 这就需要使用redux-promise中间件 12345678import &#123; createStore, applyMiddleware &#125; from 'redux';import promiseMiddleware from 'redux-promise';import reducer from './reducers';const store = createStore( reducer, applyMiddleware(promiseMiddleware)); 这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法 写法一，返回值是一个 Promise 对象 123456789const fetchPosts = (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; &#123; type: 'FETCH_POSTS', payload: response.json() &#125;);&#125;); 写法二，Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，并且写法也要变成下面这样 1234567891011121314import &#123; createAction &#125; from 'redux-actions';class AsyncApp extends Component &#123; componentDidMount() &#123; const &#123; dispatch, selectedPost &#125; = this.props // 发出同步 Action dispatch(requestPosts(selectedPost)); // 发出异步 Action dispatch(createAction( 'FETCH_POSTS', fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) )); &#125; 上面代码中，第二个dispatch方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出 注意，createAction的第二个参数必须是一个 Promise 对象 十一、react-redux 为了方便使用，Redux 的作者封装了一个 React专用的库 React-Redux 这个库是可以选用的。实际项目中，你应该权衡一下，是直接使用 Redux，还是使用 React-Redux。后者虽然提供了便利，但是需要掌握额外的 API，并且要遵守它的组件拆分规范 11.1 UI 组件 React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component） UI 组件有以下几个特征 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 123// 例子const Title = value =&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt;; 因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值 11.2、容器组件 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑 如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它 11.3、connect() React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。 12import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect()(TodoList); 上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件 但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。 （1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数 （2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去 因此，connect方法的完整 API 如下 123456import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action 11.4、mapStateToProps() mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系 作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射 12345const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; 上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象 这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值 下面就是getVisibleTodos的一个例子，用来算出todos 123456789101112const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) default: throw new Error('Unknown filter: ' + filter) &#125;&#125; mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象 12345678910// 容器组件的代码// &lt;FilterLink filter=\"SHOW_ALL\"&gt;// All// &lt;/FilterLink&gt;const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active: ownProps.filter === state.visibilityFilter &#125;&#125; 使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染 connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新 11.5、mapDispatchToProps() mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射 也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象 如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数 12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter &#125;); &#125; &#125;;&#125; 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样 123456const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; 11.6、 组件 connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数 一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。 React-Redux 提供Provider组件，可以让容器组件拿到state 12345678910111213import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state 它的原理是React组件的context属性 11.7、实例：计数器 我们来看一个实例。下面是一个计数器组件，它是一个纯的 UI 组件 1234567891011class Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 这个 UI 组件有两个参数：value和onIncreaseClick。前者需要从state计算得到，后者需要向外发出 Action 接着，定义value到state的映射，以及onIncreaseClick到dispatch的映射 1234567891011121314function mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;// Action Creatorconst increaseAction = &#123; type: 'increase' &#125; 然后，使用connect方法生成容器组件 1234const App = connect( mapStateToProps, mapDispatchToProps)(Counter) 然后，定义这个组件的 Reducer 12345678910// Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125; 最后，生成store对象，并使用Provider在根组件外面包一层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import ReactDOM from 'react-dom'import &#123; createStore &#125; from 'redux'import &#123; Provider, connect &#125; from 'react-redux'// React componentclass Counter extends Component &#123; render() &#123; const &#123; value, onIncreaseClick &#125; = this.props return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;Counter.propTypes = &#123; value: PropTypes.number.isRequired, onIncreaseClick: PropTypes.func.isRequired&#125;// Actionconst increaseAction = &#123; type: 'increase' &#125;// Reducerfunction counter(state = &#123; count: 0 &#125;, action) &#123; const count = state.count switch (action.type) &#123; case 'increase': return &#123; count: count + 1 &#125; default: return state &#125;&#125;// Storeconst store = createStore(counter)// Map Redux state to component propsfunction mapStateToProps(state) &#123; return &#123; value: state.count &#125;&#125;// Map Redux actions to component propsfunction mapDispatchToProps(dispatch) &#123; return &#123; onIncreaseClick: () =&gt; dispatch(increaseAction) &#125;&#125;// Connected Componentconst App = connect( mapStateToProps, mapDispatchToProps)(Counter)ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 十二、思维导图总结 image.png","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"使用Fiddler做抓包分析","slug":"抓包","date":"2017-11-04T06:09:43.000Z","updated":"2018-03-29T15:14:57.044Z","comments":true,"path":"2017/11/04/抓包/","link":"","permalink":"http://yoursite.com/2017/11/04/抓包/","excerpt":"","text":"一、Fiddler简介 Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器 客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端 使用了Fiddler之后，web客户端和服务器的请求如下所示 主界面中主要包括四个常用的块 Fiddler的菜单栏，上图绿色部分。包括捕获http请求，停止捕获请求，保存http请求，载入本地session、设置捕获规则等功能。 Fiddler的工具栏,上图红色部分。包括Fiddler针对当前view的操作（暂停，清除session,decode模式、清除缓存等）。 web Session面板，上图黄色区域，主要是Fiddler抓取到的每条http请求（每一条称为一个session）,主要包含了请求的url，协议，状态码，body等信息，详细的字段含义如下图所示 二、HTTP请求图标说明 三、Statistic 关于HTTP请求的性能和其他数据分析 我们可以从中看出一些基本性能数据：如DNS解析的时间消耗是8ms,建立TCP/IP连接的时间消耗是8ms等等信息 四、Inspectors 分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。对于每一部分，提供了多种不同格式查看每个请求和响应的内容。 JPG 格式使用 ImageView 就可以看到图片 HTML/JS/CSS 使用 TextView可以看到响应的内容。 Raw标签可以查看原始的符合HTTP标准的请求和响应头。 Auth则可以查看授权Proxy-Authorization 和 Authorization的相关信息。 Cookies标签可以看到请求的cookie和响应的set-cookie头信息 五、Composer 老版本的fiddler中叫request-builder.顾名思义，可以构建相应的请求，有两种常用的方式构建请求 Parsed 输入请求的url之后executed即可，也可以修改相应的头信息（如添加常用的accept,host,referrer,cookie，cache-control等头部）后execute`. Raw。使用HTTP头部信息构建http请求。与上类似 六、fiddler过滤会话 问题：每次使用Fiddler,打开一个网站，都能在Fiddler中看到几十个会话，看得眼花缭乱。 期望：只想抓取自己想要的请求 七、Response乱码时的处理方法 问题：有时候我们看到Response中的HTML是乱码的， 这是因为HTML被压缩了， 我们可以通过两种方法去解压缩 方法二：选中工具栏中的”Decode”。 这样会自动解压缩 八、反向代理-AutoResponder 原理：利用fiddler作為反向代理。意思就是将外界的request请求端口修改掉！ 改写返回数据，最实用的功能 用浏览器随意输入一个网址，如http://www.baidu.com/ 选中序号16记录，右击-勾选“Unlock fo Editing”,选择Fiddler右侧reponse块下的TextView，这里修改title,如图： 选择Fiddler右侧reponse块下的TextView，这里修改title,如图： 去掉“Unlock for Editing”，再选择右侧上方的AutoResponder,勾选下方的checkbox选框，并将序号16托到下方，同时，里面会多条记录，如下图： 回到浏览器，刷新页面，如图，标题变为上面改的内容 九、fiddler提供了一个功能，让我们模拟低速网路环境 启用方法如：Rules → Performances → Simulate Modem Speeds 十、直接在fiddler上配置host 点击tools&gt;&gt;hosts,在里面填写自己想要设置的host即可 十一、Fiddler显示请求服务器的ip及系统环境的配置方法 打开Rules——&gt;Customize Rules 找到如下这段代码 12345678910111213static function Main()&#123;var today: Date = new Date();FiddlerObject.StatusText = \" CustomRules.js was loaded at: \" + today;// Uncomment to add a \"Server\" column containing the response \"Server\" header, if present在这一行后面添加如下代码：// 显示服务器web环境FiddlerObject.UI.lvSessions.AddBoundColumn(\"Server\", 50, \"@response.server\");// 显示服务器IP地址FiddlerObject.UI.lvSessions.AddBoundColumn(\"HostIP\", 50, \"x-hostIP\");&#125; 设置后重启fiddler，效果如下 十二、fiddler断点调试 第一种方法：菜单栏 Rules –》 Automatic Breakpoints –》 Before Requests(请求被发送到服务器端之前)；或者 After Responses(响应返回客户端之前)，这种设置对客户机发出的所有请求都进行拦截 十三、配合SwitchySharp插件使用 为fiddler创建一个规则，代理到本地的8888端口（fiddler所用的端口）google设置代理的方法：下载SwitchySharp插件，设置如下： 接着点击保存即可~ 这样在需要的时候可以切换到Fiddler","categories":[{"name":"Tools","slug":"Tools","permalink":"http://yoursite.com/categories/Tools/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"},{"name":"Fiddler","slug":"Fiddler","permalink":"http://yoursite.com/tags/Fiddler/"}]},{"title":"微信小程序一些常用方法","slug":"微信小程序方法","date":"2017-09-30T03:16:12.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/09/30/微信小程序方法/","link":"","permalink":"http://yoursite.com/2017/09/30/微信小程序方法/","excerpt":"","text":"微信小程序 最近一个月都在写小程序，有用到一些封装方法和深坑记录一下 1.微信小程序路由跳转navigateTo封装 12345678910111213141516171819202122232425262728const parse = (query) =&gt; &#123; return Object.keys(query).map(key =&gt; `$&#123;key&#125;=$&#123;query[key]&#125;`).join(&apos;&amp;&apos;)&#125;module.exports = &#123; go(url, query = &#123;&#125;) &#123; console.log(url) return new Promise((resolve, reject) =&gt; &#123; wx.navigateTo(&#123; url: `$&#123;url&#125;?$&#123;parse(query)&#125;`, success: resolve, fail: reject &#125;) &#125;) &#125;, replace(url, query = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.redirectTo(&#123; url: `$&#123;url&#125;?$&#123;parse(query)&#125;`, success: resolve, fail: reject &#125;) &#125;) &#125;, back(delta) &#123; wx.navigateBack(&#123; delta &#125;) &#125;&#125; 2.promise封装request请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var Promise = require(&apos;../plugins/es6-promise.js&apos;)function wxPromisify(fn) &#123; return function (obj = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; obj.success = function (res) &#123; //成功 resolve(res) &#125; obj.fail = function (res) &#123; //失败 reject(res) &#125; fn(obj) &#125;) &#125;&#125;//无论promise对象最后状态如何都会执行Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;;/** * 微信请求get方法 * url * data 以对象的格式传入 */function getRequest(url, data) &#123; var getRequest = wxPromisify(wx.request) return getRequest(&#123; url: url, method: &apos;GET&apos;, data: data, header: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125; &#125;)&#125;/** * 微信请求post方法封装 * url * data 以对象的格式传入 */function postRequest(url, data) &#123; var postRequest = wxPromisify(wx.request) return postRequest(&#123; url: url, method: &apos;POST&apos;, data: data, header: &#123; &quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;, &#125;)&#125;module.exports = &#123; postRequest: postRequest, getRequest: getRequest&#125; 小程序不支持promise所以先引入promise库才行3.promise封装storage请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var Promise = require(&apos;../plugins/es6-promise.js&apos;)function wxPromisify(fn) &#123; return function (obj = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; obj.success = function (res) &#123; //成功 resolve(res) &#125; obj.fail = function (res) &#123; //失败 reject(res) &#125; fn(obj) &#125;) &#125;&#125;//无论promise对象最后状态如何都会执行Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;;//异步设置storagefunction setStorage(keys, value) &#123; wx.setStorage(&#123; key: keys, data: value &#125;)&#125;//同步设置storagefunction setStorageSync(keys, value) &#123; try &#123; wx.setStorageSync(kes, value) &#125; catch (e) &#123; &#125;&#125;//异步获取stotagefunction getStorage(keys) &#123; let getStorage = wxPromisify(wx.getStorage) return getStorage(&#123; key: keys &#125;)&#125;//同步获取storagefunction getStorageSync(keys) &#123; try &#123; var value = wx.getStorageSync(keys) if (value) &#123; // Do something with return value &#125; &#125; catch (e) &#123; // Do something when catch error &#125;&#125;//移除指定key storagefunction removeStorage(obj) &#123; let removeStorage = wxPromisify(wx.removeStorage); return removeStorage(&#123; key: obj &#125;)&#125;//module.exports = &#123; setStorage, setStorageSync, getStorage, getStorageSync, removeStorage, clearStorageSync: wx.clearStorageSync(), clearStorage: wx.clearStorage()&#125; 项目中还遇到html转wxml用wxParse解决https://github.com/icindy/wxParse； 微信小程序启动时，调用生命周期方法为：onLaunch方法（app.js）—onShow方法（app.js）---onLoad方法（首页面：index.js的onLoad方法）；所以如果在app.js里面去获取用户信息操作token，在index页面使用会出现异步还没获取到数据就执行,一般情况用promise就可以直接解决问题，稍微麻烦的一般使用settimeout去解决。 项目中还用上了socket实时更新数据，比较坑的地方就是小程序的socket只能连接60秒就断，可以让用户上拉刷新，试了定时器方法，但是由于会频繁的去操作setData考虑到性能问题并没有使用.","categories":[{"name":"Wechat","slug":"Wechat","permalink":"http://yoursite.com/categories/Wechat/"}],"tags":[{"name":"Wechat","slug":"Wechat","permalink":"http://yoursite.com/tags/Wechat/"}]},{"title":"Vue-Router整理","slug":"vue-router总结","date":"2017-09-12T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/09/12/vue-router总结/","link":"","permalink":"http://yoursite.com/2017/09/12/vue-router总结/","excerpt":"","text":"##VUE-ROUTER API文档 一.&lt;router-link&gt;1.Props to 类型:string | Location required表示目标路由的链接。当被点击后，内部会立刻把to的值传到router.push()，所以这个值是可以一个字符串或者是描述目标位置的对象。12345678910111213141516171819&lt;!-- 字符串 --&gt; &lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt; &lt;!-- 渲染结果 --&gt; &lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt; &lt;!-- 使用 v-bind 的 JS 表达式 --&gt; &lt;router-link v-bind:to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt; &lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt; &lt;router-link :to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt; &lt;!-- 同上 --&gt; &lt;router-link :to=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/router-link&gt; &lt;!-- 命名的路由 --&gt; &lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; &lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt; &lt;router-link :to=&quot;&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;&quot;&gt;Register&lt;/router-link&gt; to可以是字符串或者表达式，动态设置需要加上v-bind或： path路径 params传参 query问号后面的值。 replace 类型:boolean 默认值:false设置了replace的属性话，当点击时，会调用router.replace()而不是router.push()于是导航不会留下history记录。&lt;router-link :to=&quot;{path: &#39;/home&#39;} replace&gt;&lt;/router-link&gt;&quot; append 类型:boolean 默认值:false设置append属性后，则在当前(相对)路径前添加基路径。例如，我们从/a导航到一个相对路径b，如果没有配置append，则路径为/b,如果赔了，则为/a/b&lt;router-link :to=&quot;{path : &quot;relative/path&quot; append} &lt;/router-link&gt;&quot; tag 类型: string 默认值: &quot;a&quot;有时候想要 &lt;router-link&gt; 渲染成某种标签，例如 &lt;li&gt;。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。 123&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;li&gt;foo&lt;/li&gt; active-class 类型:string 默认值:”router-link-active“设置链接激活时使用的css类名。默认值可以通过路由的构造选项linkActiveClass来全局配置。 exact 类型:boolean 默认值:false“是否激活” 默认类名的依据是 inclusive match （全包含匹配）。 举个例子，如果当前的路径是 /a 开头的，那么 &lt;router-link to=&quot;/a&quot;&gt; 也会被设置 CSS 类名。 按照这个规则，&lt;router-link to=&quot;/&quot;&gt; 将会点亮各个路由！想要链接使用 “exact 匹配模式”，则使用 exact 属性： 12&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;&lt;router-link to=&quot;/&quot; exact&gt; events 类型: string | Array 默认值: ‘click’声明可以用来触发导航的时间。可以是一个字符串或是一个包含字符串的数组 将”激活时的CSS类名”应用在外层元素有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 &lt;a&gt; 标签本身，那么可以用 &lt;router-link&gt; 渲染外层元素，包裹着内层的原生 &lt;a&gt; 标签： 123&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt; &lt;a&gt;/foo&lt;/a&gt;&lt;/router-link&gt; 在这种情况下，&lt;a&gt; 将作为真实的链接（它会获得正确的 href 的），而 “激活时的CSS类名” 则设置到外层的 二.&lt;router-view&gt;&lt;router-view&gt;组件是一个functional组件，渲染路径匹配到的视图组件。&lt;router-view&gt;渲染的组件还可以内嵌自己的&lt;router-view&gt;，根据嵌套的路径，渲染嵌套组件。 属性 name 类型:string 默认值:”default”如果&lt;router-view&gt;设置了名称，则会渲染对应的路由配置中comonents下的相应组件。查看命名视图中的列子。行为表现其他属性（非router-view使用的属性）都直接传给渲染的组件，很多时候，每个路由的数据都是包含在路由的参数中。因为它也是一个组件，可以配合&lt;transtion&gt;和&lt;keep-alive&gt;使用，如果两者结合使用一定要保证在内层使用&lt;keep-alive&gt;12345&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 三.路由信息对象一个route object（路由信息对象）表示当前激活的路由的状态信息，包含了当前的url解析得到的信息，还有url匹配到的route record （路由记录） route object是immutable（不可变）的，每次成功的导航后都会产生一个新的对象。 route object出现在多个地方： 组件内的this.$route和$route watcher回调（监测变化处理）； router.match(location)的返回值 导航钩子的参数:123 router.beforeEach((to,from,next)=&gt;&#123; //ro 和 from 都是路由信息对象&#125;) 路由信息对象的属性 $route.path 类型:string 字符串，对应当前的路径，总是解析为绝对路径，如&quot;/foo/bar&quot;。 $route.params 类型:Object一个key/value对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。 $route.query 类型：Object一个key/value对象，表示URL查询参数。例如，对于路径/foo?user=1,则有$route.query.user=1,如果没有查询参数，则是一个空对象。 $route.hash 类型:string当前路由的hash值（带#），如果没有hash值，则为空字符串。 $route.fullPath 类型:string完成解析后的URL，包含查询参数和hash的完整路径。 $route.matched 类型:Array&lt;RouteRecord&gt;一个数组，包含当前路由的所有嵌套路径片段的路由记录。路由记录就是routes配置数组中的对象副本（还有在children数组）。 1234567891011const router = new VueRouter(&#123; routes: [ // 下面的对象就是 route record &#123; path: &apos;/foo&apos;, component: Foo, children: [ // 这也是个 route record &#123; path: &apos;bar&apos;, component: Bar &#125; ] &#125; ]&#125;) 当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象（副本）。 $route.name 当前路由的名称，如果有的话。（查看 命名路由） enter image description here 四.Router构造配置routes 类型Array&lt;RouteConfig&gt; RouteConfig的类型定义：1234567891011 declare type RouteConfig = &#123; path: string;//路径 component?: Component;//组件 name?: string; // for named routes (命名路由) components?: &#123; [name: string]: Component &#125;; // for named views (命名视图组件) redirect?: string | Location | Function;//重定向 alias?: string | Array&lt;string&gt;;//别名 children?: Array&lt;RouteConfig&gt;; // for nested routes beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void;//全局route注册之前的钩子 meta?: any;//路由配置元信息meta字段&#125; mode 类型:string 默认值:&quot;hash‘(浏览器环境) | &quot;abstract&quot;(Node.js环境) 可选值:&quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot; 配置路由模式： hash:使用URL hash值来做路由，支持所有浏览器，包括不支持HTML5 History Api的浏览器 history:依赖HTML5 History API和服务器配置，查看HTML5 History模式 abstract:支持所有JavaScript运行环境，如Node.js服务器端。如果发现没有浏览器的API,路由会自动强制进入这个模式base 类型:string 默认值:”/“应用的基路径。例如，如果整个单页面应用服务在/app/下，然后base就应该设为&quot;/app/&quot;。linkActiveClass 类型:string 默认值:”router-link-active”全局配置的默认[激活cass类名]。参考router-linkscrollBehavior 类型:function 签名：12345 ( to: Route, from: Route, savedPosition?: &#123; x: number, y: number &#125;) =&gt; &#123; x: number, y: number &#125; | &#123; selector: string &#125; | ?&#123;&#125; 更多详情参考 滚动行为. 五.Router实例属性router.app 类型:Vue instace 配置了router的Vue根实例。 route.mode 类型:string 路由使用的模式。 router.currentRoute 类型:Route当前路由对应的路由信息对象信息对象方法 router.beforeEach(guard)路由加载之前 router.befireResolve(guard)此时异步组件已加载完成 router.afterEach(hood) 增加全局的导航钩子 router.push(location,ONccomplete?,onAbort?) router.replace(location,ONccomplete?,onAbort?) router.go(n) router.back() router.forward()动态的导航到一个新 url。 router.getMatchedComponents(location?) 返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。 router.resolve(location, current?, append?)解析目标位置，返回包含如下属性的对象 12345&#123; location: Location; route: Route; href: string;&#125; router.addRoutes(routes) 动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。 router.onReady(callback) 添加一个会在第一次路由跳转完成时被调用的回调函数。此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue官网基础整理","slug":"vue官网总结.1","date":"2017-09-12T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/09/12/vue官网总结.1/","link":"","permalink":"http://yoursite.com/2017/09/12/vue官网总结.1/","excerpt":"","text":"##VUE2.0总结 一.vue实例 创建一个vue的实例每个vue应用都是通过vue函数创建的一个新的vue实例开始的：123var vm = new Vue(&#123; //选项&#125;) 数据与方法当一个Vue实例被创建时，它项Vue的响应式系统中加入了其data对象中能找到的缩影的属性。当这些数据的值发生改变是，视图将会产生’响应’，即匹配更新为新的值。 1234567891011121314// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个 Vue 实例中var vm = new Vue(&#123; data: data&#125;)// 他们引用相同的对象！vm.a === data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// ... and vice-versadata.a = 3vm.a // =&gt; 3 只有在data中存在的属性是响应式的，所以可以在一开始给data附一个初始值。除了data属性，vue实例暴露了一些其他的方法和属性，他们加上了$前缀，以便与用户定义的属性区分开来，例如: 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById(&apos;example&apos;) // =&gt; true// $watch 是一个实例方法vm.$watch(&apos;a&apos;, function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 实例生命周期 enter image description here http://blog.csdn.net/qq_21439971/article/details/76502598详细链接 create 和 mounted beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成挂载另外在标红处，我们能发现el还是 ，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。 update 我们单击页面中的“更新数据”按钮，将数据更新。下面就能看到data里的值被修改后，将会触发update的操作。ps:注意beforeUpdate是指view层的数据变化前，不是data中的数据改变前触发。因为Vue是数据驱动的。注意观察弹窗就容易发现。 destroy 销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。因为这个Vue实例已经不存在了。我们单击页面中的“销毁”按钮，将指定的Vue实例销毁。 三、生命周期总结beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 二.模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。 插值1.文本数据绑定文本用Mustache”语法(双大括号)的文本插值:&lt;span&gt;msg:&lt;/span&gt;通过v-once指令可以一次性插值，当文本改变不会响应改变插值&lt;span v-once&gt;msg:&lt;/span&gt;2.原始HTML真正的html输出需要v-html&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt;3.特性mustache语法不能作用在html的特性上，需要使用v-bind,&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;这同样适用于布尔类特性，如果求值结果是 falsy 的值，则该特性将会被删除：&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;4.使用JavaScript表达式vue提供了完全的JavaScript表达式的支持。每个绑定的表达式只能是单个的表达式 123456789&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;//下面语句不会生效&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 5.指令指令是带有v-前缀的特殊属性。指令的职责是，当表达式的值改变是，将其产生的连带影响，响应式的作用于DOM。例如:v-if v-for v-bind 等等6.参数一些指令能够接受一个参数，在指令的名称之后以冒号表示，例如:&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;这里href是参数，告知v-bind指令将该元素的href属性与表达式的url绑定。7.修饰符修饰符是以.半角句号指明的特殊后缀，用于指出一个指令应该以什么方式绑定，例如:.stop .prevent等等8.缩写v-bind 缩写 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-on 缩写 1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; 三.计算属性和观察者 计算属性模板的表达式只适用于简单的表达式，如果有更复杂的计算需要使用compute计算属性1.基础例子 1234567891011121314151617&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 2.计算属性的缓存vs方法你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： 1234567&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;// in componentmethods: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 使用计算属性会有缓存，因为计算属性是依赖缓存来进行缓存的。如果不需要缓存，用方法代替。3.计算属性VS被观察的属性Vue.js 提供了一个方法 watch，它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。具体的用法可以直接看下面的示例，简单直接。 1234567891011121314151617181920212223242526272829303132333435363738[html] view plain copy&lt;span style=&quot;color:#006600;&quot;&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;childrens.name&quot; /&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;lastName&quot; /&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue( &#123; el: &apos;#app&apos;, data: &#123; childrens: &#123; name: &apos;小强&apos;, age: 20, sex: &apos;男&apos; &#125;, tdArray:[&quot;1&quot;,&quot;2&quot;], lastName:&quot;张三&quot; &#125;, watch:&#123; childrens:&#123; handler:function(val,oldval)&#123; console.log(val.name) &#125;, deep:true//对象内部的属性监听，也叫深度监听 &#125;, &apos;childrens.name&apos;:function(val,oldval)&#123; console.log(val+&quot;aaa&quot;) &#125;,//键路径必须加上引号 lastName:function(val,oldval)&#123; console.log(this.lastName) &#125; &#125;,//以V-model绑定数据时使用的数据变化监测 &#125; ); vm.$watch(&quot;lastName&quot;,function(val,oldval)&#123; console.log(val) &#125;)//主动调用$watch方法来进行数据监测&lt;/span&gt; &lt;/script&gt; &lt;/body&gt; 注意：数组的改变不需要使用深度watch。4计算属性的setter计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也相应地会被更新。 四.Class与Style绑定 绑定HTML Class1.对象语法可以通过v-bind:class一个对象动态切换class：&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;判断isActive是否为真值也可以直接绑定一个对象 1234567&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125;&#125; 或者可以绑定一个计算属性 12345678910111213&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos; &#125; &#125;&#125; 2数组语法我们可以把一个数组传给v-bind:class，以应用一个class列表： 12345&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 渲染为：&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;如果你也想根据条件切换列表中的 class，可以用三元表达式：&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;此例始终添加 errorClass ，但是只有在 isActive 是 true 时添加 activeClass。不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt; 绑定内联样式1.对象语法v-bind:style 的对象语法十分直观——看着非常像 CSS，其实它是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或 (配合引号的) 短横分隔命名 (kebab-case)： 12345&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; 直接绑定到一个样式对象通常更好，让模板更清晰： 1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; 同样的，对象语法常常结合返回对象的计算属性使用。2.数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上：&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;3.自动添加前缀 当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。4.多重值 从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：&lt;div :style=&quot;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&quot;&gt;&lt;/div&gt;这会渲染数组中最后一个被浏览器支持的值。在这个例子中，如果浏览器支持不带浏览器前缀的 flexbox，那么渲染结果会是 display: flex。 五.条件渲染 v-if 1234&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;也可以用 v-else 添加一个 “else” 块：&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 还有 v-else 和 v-else-if可以用key来管理可以复用的元素使元素全部重新渲染 v-showv-show只是切换元素的display属性，v-show渲染的元素始终会被渲染并保留在DOM中。tips：v-if和v-for一起使用过的时候 v-for比v-if有更高的优先级 六.列表渲染 1.用v-for把一个数组对应为一组元素可以用 v-for item in items (item,index) in items 或者 v-for of 对象遍历 123&lt;div v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)： 数组的更新监测1.变异方法vue数组的 push() pop() shift() unshift() splice() sort() reverse()都会触发视图更新2.替换数组变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组3.注意事项1.利用索引直接设置一个项时，不会触犯状态更新vm.items[indexOfItem] = newValue2.改变数组长度时候也不会粗发状态更新。第一个问题的解决办法2中 1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// Array.prototype.spliceexample1.items.splice(indexOfItem, 1, newValue) 第二类问题可以使用splice 1example1.items.splice(newLength) 对象更改检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：已经创建的实例需要使用vue.set(object,key,value)方法向嵌套对象添加响应式属性。还可以使用vm.$set实例方法，它只是Vue.set的别名：如果需要个已有的对象赋予多个新属性，比如使用Object.assign()或_extend().不要像这样:1234Object.assign(this.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) 你应该这样做： 1234this.userProfile = Object.assign(&#123;&#125;, this.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) 显示过滤/排序结果有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。例如： 1234567891011&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个 method 方法： 123456789&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) 七.事件处理 可以用v-on监听事件和触发一些javascript代码。如果需要访问原生的DOM事件。可以使用特殊变量$event把它传入方法： 事件修饰符.stop .prevent .capture .self .once 123456789101112&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 键值修饰符.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right 八.表单输入绑定 基础用法可以使用v-model实现双向数据绑定 修饰符.lazy 在默认情况下，v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步： 123&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt;.number 如果想自动将用户的输入值转为 Number 类型 (如果原值的转换结果为 NaN 则返回原值)，可以添加一个修饰符 number 给 v-model 来处理输入值： 1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; 这通常很有用，因为在 type=”number” 时 HTML 中输入的值也总是会返回字符串类型。.trim 如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入： 12&lt;input v-model.trim=&quot;msg&quot;&gt;v-model 与组件 九.组件 使用组件1.注册要注册一个全局组件可以使用Vue.component(tagName,options)123Vue.component(&apos;my-conmponent&apos;,&#123; //选项&#125;) 组件在注册之后，便可以在父实例的模块中以自定义元素 &lt;my-component&gt;&lt;/my-component&gt; 的形式使用。要确保在初始化根实例之前注册了组件： 1234567891011&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;// 注册Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;)// 创建根实例new Vue(&#123; el: &apos;#example&apos;&#125;) 2.局部注册组件 12345678910var Child = &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父模板可用 &apos;my-component&apos;: Child &#125;&#125;) 3.data必须是函数 4.组合组件组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。在 Vue 中，父子组件的关系可以总结为 props down, events up。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。 enter image description here Props1.使用Props传递数据要让子组件使用父组件的数据，我们需要通过props选项。子组件要显式地用 props 选项声明它期待获得的数据： 1234567Vue.component(&apos;child&apos;, &#123; // 声明 props props: [&apos;message&apos;], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像“this.message”这样使用 template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;&#125;) 然后我们可以这样向它传入一个普通字符串： 1&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt; 2.动态props在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的 HTML 特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件： 12345&lt;div&gt; &lt;input v-model=&quot;parentMsg&quot;&gt; &lt;br&gt; &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;&lt;/div&gt; 使用 v-bind 的缩写语法通常更简单： 1&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt; 3.单向数据流 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。为什么我们会有修改 prop 中数据的冲动呢？通常是这两种原因：prop 作为初始值传入后，子组件想把它当作局部数据来用；prop 作为初始值传入，由子组件处理成其它数据输出。对这两种原因，正确的应对方式是：定义一个局部变量，并用 prop 的值初始化它： 1234props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 定义一个计算属性，处理 prop 的值并返回。 123456props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 4.Prop 验证 我们可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue 会发出警告。当组件给其他人使用时，这很有用。要指定验证规格，需要用对象的形式，而不能用字符串数组： 12345678910111213141516171819202122232425262728293031Vue.component(&apos;example&apos;, &#123; props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器：StringNumberBooleanFunctionObjectArraySymboltype 也可以是一个自定义构造器函数，使用 instanceof 检测。当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。 自定义事件子组件和父组件通讯每个 Vue 实例都实现了事件接口 (Events interface)，即：使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件绑定原生事件有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on。例如： 1&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt; 使用插槽分发内容在使用组件时，我们常常要像这样组合它们： 1234&lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt; 注意两点：&lt;app&gt; 组件不知道它会收到什么内容。这是由使用 &lt;app&gt; 的父组件决定的。&lt;app&gt; 组件很可能有它自己的模板。为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发 (或“transclusion”如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API，参照了当前 Web 组件规范草案，使用特殊的 &lt;slot&gt; 元素作为原始内容的插槽。编译作用域 在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为： 123&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法： 12&lt;!-- 无效 --&gt;&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt; 假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做： 123456789Vue.component(&apos;child-component&apos;, &#123; // 有效，因为是在正确的作用域内 template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;, data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 类似地，分发内容是在父作用域内编译。单个插槽 除非子组件模板包含至少一个 &lt;slot&gt; 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。最初在 &lt;slot&gt; 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。假定 my-component 组件有下面模板： 123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; 父组件模板： 1234567&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 渲染结果： 12345678&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名插槽 &lt;slot&gt; 元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。例如，假定我们有一个 app-layout 组件，它的模板为： 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 父组件模板： 123456&lt;app-layout&gt; &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 渲染结果为： 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 在组合组件时，内容分发 API 是非常有用的机制。 作用域插槽作用域插槽是一种特殊类型的插槽，用作使用一个 (能够传递数据到) 可重用模板替换已渲染元素。在子组件中，只需将数据传递到插槽，就像你将 props 传递给组件一样： 123&lt;div class=&quot;child&quot;&gt; &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;&lt;/div&gt; 在父级中，具有特殊属性 scope 的 元素必须存在，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 props 对象： 12345678&lt;div class=&quot;parent&quot;&gt; &lt;child&gt; &lt;template scope=&quot;props&quot;&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 如果我们渲染以上结果，得到的输出会是： 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项： 123456&lt;my-awesome-list :items=&quot;items&quot;&gt; &lt;!-- 作用域插槽也可以是具名的 --&gt; &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt; &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt; &lt;/template&gt;&lt;/my-awesome-list&gt; 列表组件的模板： 1234567&lt;ul&gt; &lt;slot name=&quot;item&quot; v-for=&quot;item in items&quot; :text=&quot;item.text&quot;&gt; &lt;!-- 这里写入备用内容 --&gt; &lt;/slot&gt;&lt;/ul&gt; 动态组件使用is动态绑定componentkeep-alive如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数： 12345&lt;keep-alive&gt; &lt;component :is=&quot;currentView&quot;&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 异步组件 在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如： 12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // Pass the component definition to the resolve callback resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;) 工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能： 123456Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require([&apos;./my-async-component&apos;], resolve)&#125;) 你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数： 1234Vue.component( &apos;async-webpack-example&apos;, () =&gt; import(&apos;./my-async-component&apos;)) 当使用局部注册时，你也可以直接提供一个返回 Promise 的函数： 123456new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"web开发中跨域解决方案","slug":"web开发中跨域解决方案","date":"2017-08-20T04:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/08/20/web开发中跨域解决方案/","link":"","permalink":"http://yoursite.com/2017/08/20/web开发中跨域解决方案/","excerpt":"","text":"web开发中跨域解决方案什么是跨域？概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的 下面是具体的跨域情况详解 URL 说明 是否允许通信 http://www.a.com/a.js、http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js、http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js、http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js、http://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js、http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js、http://script.a.com/b.js 主域相同，子域不同 不允许（cookie也不允许） http://www.a.com/a.js、http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie也不允许） http://www.cnblogs.com/a.js、http://www.a.com/b.js 不同域名 不允许 一、document.domain跨域 原理：相同主域名不同子域名下的页面，可以设置document.domain让它们同域 限制：同域document提供的是页面间的互操作，需要载入iframe页面 下面几个域名下的页面都是可以通过document.domain跨域互操作的： http://a.com/foo,http://b.a.com/bar, http://c.a.com/bar。但只能以页面嵌套的方式来进行页面互操作，比如常见的iframe方式就可以完成页面嵌套 123456789// URL http://a.com/foovar ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://b.a.com/bar&apos;; ifr.onload = function()&#123; var ifrdoc = ifr.contentDocument || ifr.contentWindow.document; ifrdoc.getElementsById(&quot;foo&quot;).innerHTML);&#125;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr); 上述代码所在的URL是http://a.com/foo，它对http://b.a.com/bar的DOM访问要求后者将 document.domain往上设置一级 12// URL http://b.a.com/bardocument.domain = &apos;a.com&apos; document.domain只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在Chrome中给出的错误是这样的 1Uncaught DOMException: Failed to set the &apos;domain&apos; property on &apos;Document&apos;: &apos;baidu.com&apos; is not a suffix of &apos;b.a.com&apos; 二、有src的标签 原理：所有具有src属性的HTML标签都是可以跨域的，包括&lt;img&gt;, &lt;script&gt; 限制：需要创建一个DOM对象，只能用于GET方法 在document.body中append一个具有src属性的HTML标签， src属性值指向的URL会以GET方法被访问，该访问是可以跨域的其实样式表的&lt;link&gt;标签也是可以跨域的，只要是有src或href的HTML标签都有跨域的能力 不同的HTML标签发送HTTP请求的时机不同，例如&lt;img&gt;在更改src属性时就会发送请求，而script, iframe, link[rel=stylesheet]只有在添加到DOM树之后才会发送HTTP请求： 1234var img = new Image();img.src = &apos;http://some/picture&apos;; // 发送HTTP请求var ifr = $(&apos;&lt;iframe&gt;&apos;, &#123;src: &apos;http://b.a.com/bar&apos;&#125;);$(&apos;body&apos;).append(ifr); // 发送HTTP请求 三、JSONP 原理：&lt;script&gt;是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数 限制：需要创建一个DOM对象并且添加到DOM树，只能用于GET方法 JSONP利用的是&lt;script&gt;可以跨域的特性，跨域URL返回的脚本不仅包含数据，还包含一个回调 123456// URL: http://b.a.com/foovar data = &#123; foo: &apos;bar&apos;, bar: &apos;foo&apos;&#125;;callback(data); 然后在我们在主站http://a.com中，可以这样来跨域获取http://b.a.com的数据： // URL: http://a.com/foo 12345var callback = function(data)&#123; // 处理跨域请求得到的数据&#125;;var script = $(&apos;&lt;script&gt;&apos;, &#123;src: &apos;http://b.a.com/bar&apos;&#125;);$(&apos;body&apos;).append(script); 其实jQuery已经封装了JSONP的使用，我们可以这样来 123$.getJSON( &quot;http://b.a.com/bar?callback=callback&quot;, function( data )&#123; // 处理跨域请求得到的数据&#125;); $.getJSON与$.get的区别是前者会把responseText转换为JSON，而且当URL具有callback参数时， jQuery将会把它解释为一个JSONP请求，创建一个&lt;script&gt;标签来完成该请求 四、navigation 对象 原理：iframe之间是共享navigator对象的，用它来传递信息 要求：IE6/7 有些人注意到了IE6/7的一个漏洞：iframe之间的window.navigator对象是共享的。 我们可以把它作为一个Messenger，通过它来传递信息。比如一个简单的委托： 1234567// a.comnavigation.onData()&#123; // 数据到达的处理函数&#125;typeof navigation.getData === &apos;function&apos; || navigation.getData()1 12345678// b.comnavigation.getData = function()&#123; $.get(&apos;/path/under/b.com&apos;) .success(function(data)&#123; typeof navigation.onData === &apos;function&apos; || navigation.onData(data) &#125;);&#125; 与document.navigator类似，window.name也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递Hash（有些人叫锚点），这是因为每次浏览器打开一个URL时，URL后面的#xxx部分会保留下来，那么新的页面可以从这里获得上一个页面的数据 五、跨域资源共享（CORS） 原理：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 限制：浏览器需要支持HTML5，可以支持POST，PUT等方法 前面提到的跨域手段都是某种意义上的Hack， HTML5标准中提出的跨域资源共享（Cross Origin Resource Share，CORS）才是正道。 它支持其他的HTTP方法如PUT, POST等，可以从本质上解决跨域问题。 例如，从http://a.com要访问http://b.com的数据，通常情况下`Chrome`会因跨域请求而报错 1XMLHttpRequest cannot load http://b.com. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://a.com&apos; is therefore not allowed access 错误原因是被请求资源没有设置Access-Control-Allow-Origin，所以我们在b.com的服务器中设置这个响应头字段即可 12Access-Control-Allow-Origin: * # 允许所有域名访问，或者Access-Control-Allow-Origin: http://a.com # 只允许所有域名访问 六、window.postMessage 原理：HTML5允许窗口之间发送消息 限制：浏览器需要支持HTML5，获取窗口句柄后才能相互通信 这是一个安全的跨域通信方法，postMessage(message,targetOrigin)也是HTML5引入的特性。 可以给任何一个window发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个URL但不相符，那么该事件不会被分发。看一个普通的使用方式吧 123// URL: http://a.com/foovar win = window.open(&apos;http://b.com/bar&apos;);win.postMessage(&apos;Hello, bar!&apos;, &apos;http://b.com&apos;); 1234// URL: http://b.com/barwindow.addEventListener(&apos;message&apos;,function(event) &#123; console.log(event.data);&#125;); 七、访问控制安全的讨论 在HTML5之前，JSONP已经成为跨域的事实标准了，jQuery都给出了支持。 值得注意的是它只是Hack，并没有产生额外的安全问题。 因为JSONP要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问 跨域的正道还是要使用HTML5提供的CORS头字段以及window.postMessage， 可以支持POST, PUT等HTTP方法，从机制上解决跨域问题。 值得注意的是Access-Control-Allow-Origin头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和JSONP是一样的","categories":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/categories/跨域/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"Vue2.0总结","slug":"VUE2.0总结","date":"2017-07-12T14:24:08.000Z","updated":"2018-03-29T15:01:57.746Z","comments":true,"path":"2017/07/12/VUE2.0总结/","link":"","permalink":"http://yoursite.com/2017/07/12/VUE2.0总结/","excerpt":"","text":"##VUE2.0总结 ###一.vue实例 创建一个vue的实例每个vue应用都是通过vue函数创建的一个新的vue实例开始的：123var vm = new Vue(&#123; //选项&#125;) 数据与方法当一个Vue实例被创建时，它项Vue的响应式系统中加入了其data对象中能找到的缩影的属性。当这些数据的值发生改变是，视图将会产生’响应’，即匹配更新为新的值。 1234567891011121314// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个 Vue 实例中var vm = new Vue(&#123; data: data&#125;)// 他们引用相同的对象！vm.a === data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// ... and vice-versadata.a = 3vm.a // =&gt; 3 只有在data中存在的属性是响应式的，所以可以在一开始给data附一个初始值。除了data属性，vue实例暴露了一些其他的方法和属性，他们加上了$前缀，以便与用户定义的属性区分开来，例如: 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById(&apos;example&apos;) // =&gt; true// $watch 是一个实例方法vm.$watch(&apos;a&apos;, function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 实例生命周期 enter image description here http://blog.csdn.net/qq_21439971/article/details/76502598详细链接 create 和 mounted beforecreated：el 和 data 并未初始化created:完成了 data 数据的初始化，el没有beforeMount：完成了 el 和 data 初始化mounted ：完成挂载另外在标红处，我们能发现el还是 ，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。 update 我们单击页面中的“更新数据”按钮，将数据更新。下面就能看到data里的值被修改后，将会触发update的操作。ps:注意beforeUpdate是指view层的数据变化前，不是data中的数据改变前触发。因为Vue是数据驱动的。注意观察弹窗就容易发现。 destroy 销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。因为这个Vue实例已经不存在了。我们单击页面中的“销毁”按钮，将指定的Vue实例销毁。 三、生命周期总结beforecreate : 举个栗子：可以在这加个loading事件created ：在这结束loading，还做一些初始化，实现函数自执行mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情beforeDestory： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容 ###二.模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。 插值1.文本数据绑定文本用Mustache”语法(双大括号)的文本插值:&lt;span&gt;msg:&lt;/span&gt;通过v-once指令可以一次性插值，当文本改变不会响应改变插值&lt;span v-once&gt;msg:&lt;/span&gt;2.原始HTML真正的html输出需要v-html&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt;3.特性mustache语法不能作用在html的特性上，需要使用v-bind,&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;这同样适用于布尔类特性，如果求值结果是 falsy 的值，则该特性将会被删除：&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;4.使用JavaScript表达式vue提供了完全的JavaScript表达式的支持。每个绑定的表达式只能是单个的表达式 123456789&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;//下面语句不会生效&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 5.指令指令是带有v-前缀的特殊属性。指令的职责是，当表达式的值改变是，将其产生的连带影响，响应式的作用于DOM。例如:v-if v-for v-bind 等等6.参数一些指令能够接受一个参数，在指令的名称之后以冒号表示，例如:&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;这里href是参数，告知v-bind指令将该元素的href属性与表达式的url绑定。7.修饰符修饰符是以.半角句号指明的特殊后缀，用于指出一个指令应该以什么方式绑定，例如:.stop .prevent等等8.缩写v-bind 缩写 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-on 缩写 1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; ###三.计算属性和观察者 计算属性模板的表达式只适用于简单的表达式，如果有更复杂的计算需要使用compute计算属性1.基础例子 1234567891011121314151617&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 2.计算属性的缓存vs方法你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果： 1234567&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;// in componentmethods: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 使用计算属性会有缓存，因为计算属性是依赖缓存来进行缓存的。如果不需要缓存，用方法代替。3.计算属性VS被观察的属性Vue.js 提供了一个方法 watch，它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。具体的用法可以直接看下面的示例，简单直接。 1234567891011121314151617181920212223242526272829303132333435363738[html] view plain copy&lt;span style=&quot;color:#006600;&quot;&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;childrens.name&quot; /&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;lastName&quot; /&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue( &#123; el: &apos;#app&apos;, data: &#123; childrens: &#123; name: &apos;小强&apos;, age: 20, sex: &apos;男&apos; &#125;, tdArray:[&quot;1&quot;,&quot;2&quot;], lastName:&quot;张三&quot; &#125;, watch:&#123; childrens:&#123; handler:function(val,oldval)&#123; console.log(val.name) &#125;, deep:true//对象内部的属性监听，也叫深度监听 &#125;, &apos;childrens.name&apos;:function(val,oldval)&#123; console.log(val+&quot;aaa&quot;) &#125;,//键路径必须加上引号 lastName:function(val,oldval)&#123; console.log(this.lastName) &#125; &#125;,//以V-model绑定数据时使用的数据变化监测 &#125; ); vm.$watch(&quot;lastName&quot;,function(val,oldval)&#123; console.log(val) &#125;)//主动调用$watch方法来进行数据监测&lt;/span&gt; &lt;/script&gt; &lt;/body&gt; 注意：数组的改变不需要使用深度watch。4计算属性的setter计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ： 12345678910111213141516// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... 现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也相应地会被更新。 ###四.Class与Style绑定 绑定HTML Class1.对象语法可以通过v-bind:class一个对象动态切换class：&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;判断isActive是否为真值也可以直接绑定一个对象 1234567&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125;&#125; 或者可以绑定一个计算属性 12345678910111213&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos; &#125; &#125;&#125; 2数组语法我们可以把一个数组传给v-bind:class，以应用一个class列表： 12345&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 渲染为：&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;如果你也想根据条件切换列表中的 class，可以用三元表达式：&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;此例始终添加 errorClass ，但是只有在 isActive 是 true 时添加 activeClass。不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt; 绑定内联样式1.对象语法v-bind:style 的对象语法十分直观——看着非常像 CSS，其实它是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或 (配合引号的) 短横分隔命名 (kebab-case)： 12345&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; 直接绑定到一个样式对象通常更好，让模板更清晰： 1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; 同样的，对象语法常常结合返回对象的计算属性使用。2.数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上：&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;3.自动添加前缀 当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。4.多重值 从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：&lt;div :style=&quot;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&quot;&gt;&lt;/div&gt;这会渲染数组中最后一个被浏览器支持的值。在这个例子中，如果浏览器支持不带浏览器前缀的 flexbox，那么渲染结果会是 display: flex。 ###五.条件渲染 v-if 1234&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;也可以用 v-else 添加一个 “else” 块：&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 还有 v-else 和 v-else-if可以用key来管理可以复用的元素使元素全部重新渲染 v-showv-show只是切换元素的display属性，v-show渲染的元素始终会被渲染并保留在DOM中。tips：v-if和v-for一起使用过的时候 v-for比v-if有更高的优先级 ###六.列表渲染 1.用v-for把一个数组对应为一组元素可以用 v-for item in items (item,index) in items 或者 v-for of 对象遍历 123&lt;div v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)： 数组的更新监测1.变异方法vue数组的 push() pop() shift() unshift() splice() sort() reverse()都会触发视图更新2.替换数组变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组3.注意事项1.利用索引直接设置一个项时，不会触犯状态更新vm.items[indexOfItem] = newValue2.改变数组长度时候也不会粗发状态更新。第一个问题的解决办法2中 1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// Array.prototype.spliceexample1.items.splice(indexOfItem, 1, newValue) 第二类问题可以使用splice 1example1.items.splice(newLength) 对象更改检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：已经创建的实例需要使用vue.set(object,key,value)方法向嵌套对象添加响应式属性。还可以使用vm.$set实例方法，它只是Vue.set的别名：如果需要个已有的对象赋予多个新属性，比如使用Object.assign()或_extend().不要像这样:1234Object.assign(this.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) 你应该这样做： 1234this.userProfile = Object.assign(&#123;&#125;, this.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) 显示过滤/排序结果有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。例如： 1234567891011&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个 method 方法： 123456789&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) ###七.事件处理 可以用v-on监听事件和触发一些javascript代码。如果需要访问原生的DOM事件。可以使用特殊变量$event把它传入方法： 事件修饰符.stop .prevent .capture .self .once 123456789101112&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 键值修饰符.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right ###八.表单输入绑定 基础用法可以使用v-model实现双向数据绑定 修饰符.lazy 在默认情况下，v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步： 123&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt;.number 如果想自动将用户的输入值转为 Number 类型 (如果原值的转换结果为 NaN 则返回原值)，可以添加一个修饰符 number 给 v-model 来处理输入值： 1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; 这通常很有用，因为在 type=”number” 时 HTML 中输入的值也总是会返回字符串类型。.trim 如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入： 12&lt;input v-model.trim=&quot;msg&quot;&gt;v-model 与组件 ###九.组件 使用组件1.注册要注册一个全局组件可以使用Vue.component(tagName,options)123Vue.component(&apos;my-conmponent&apos;,&#123; //选项&#125;) 组件在注册之后，便可以在父实例的模块中以自定义元素 &lt;my-component&gt;&lt;/my-component&gt; 的形式使用。要确保在初始化根实例之前注册了组件： 1234567891011&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;// 注册Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;)// 创建根实例new Vue(&#123; el: &apos;#example&apos;&#125;) 2.局部注册组件 12345678910var Child = &#123; template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父模板可用 &apos;my-component&apos;: Child &#125;&#125;) 3.data必须是函数 4.组合组件组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。在 Vue 中，父子组件的关系可以总结为 props down, events up。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。 enter image description here Props1.使用Props传递数据要让子组件使用父组件的数据，我们需要通过props选项。子组件要显式地用 props 选项声明它期待获得的数据： 1234567Vue.component(&apos;child&apos;, &#123; // 声明 props props: [&apos;message&apos;], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像“this.message”这样使用 template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;&#125;) 然后我们可以这样向它传入一个普通字符串： 1&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt; 2.动态props在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的 HTML 特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件： 12345&lt;div&gt; &lt;input v-model=&quot;parentMsg&quot;&gt; &lt;br&gt; &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;&lt;/div&gt; 使用 v-bind 的缩写语法通常更简单： 1&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt; 3.单向数据流 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。为什么我们会有修改 prop 中数据的冲动呢？通常是这两种原因：prop 作为初始值传入后，子组件想把它当作局部数据来用；prop 作为初始值传入，由子组件处理成其它数据输出。对这两种原因，正确的应对方式是：定义一个局部变量，并用 prop 的值初始化它： 1234props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 定义一个计算属性，处理 prop 的值并返回。 123456props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 4.Prop 验证 我们可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue 会发出警告。当组件给其他人使用时，这很有用。要指定验证规格，需要用对象的形式，而不能用字符串数组： 12345678910111213141516171819202122232425262728293031Vue.component(&apos;example&apos;, &#123; props: &#123; // 基础类型检测 (`null` 意思是任何类型都可以) propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组/对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: &apos;hello&apos; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器：StringNumberBooleanFunctionObjectArraySymboltype 也可以是一个自定义构造器函数，使用 instanceof 检测。当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。 自定义事件子组件和父组件通讯每个 Vue 实例都实现了事件接口 (Events interface)，即：使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件绑定原生事件有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on。例如： 1&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt; 使用插槽分发内容在使用组件时，我们常常要像这样组合它们： 1234&lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt; 注意两点：&lt;app&gt; 组件不知道它会收到什么内容。这是由使用 &lt;app&gt; 的父组件决定的。&lt;app&gt; 组件很可能有它自己的模板。为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发 (或“transclusion”如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API，参照了当前 Web 组件规范草案，使用特殊的 &lt;slot&gt; 元素作为原始内容的插槽。编译作用域 在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为： 123&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法： 12&lt;!-- 无效 --&gt;&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt; 假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做： 123456789Vue.component(&apos;child-component&apos;, &#123; // 有效，因为是在正确的作用域内 template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;, data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 类似地，分发内容是在父作用域内编译。单个插槽 除非子组件模板包含至少一个 &lt;slot&gt; 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。最初在 &lt;slot&gt; 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。假定 my-component 组件有下面模板： 123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; 父组件模板： 1234567&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 渲染结果： 12345678&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名插槽 &lt;slot&gt; 元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。例如，假定我们有一个 app-layout 组件，它的模板为： 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 父组件模板： 123456&lt;app-layout&gt; &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 渲染结果为： 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 在组合组件时，内容分发 API 是非常有用的机制。 作用域插槽作用域插槽是一种特殊类型的插槽，用作使用一个 (能够传递数据到) 可重用模板替换已渲染元素。在子组件中，只需将数据传递到插槽，就像你将 props 传递给组件一样： 123&lt;div class=&quot;child&quot;&gt; &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;&lt;/div&gt; 在父级中，具有特殊属性 scope 的 元素必须存在，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 props 对象： 12345678&lt;div class=&quot;parent&quot;&gt; &lt;child&gt; &lt;template scope=&quot;props&quot;&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 如果我们渲染以上结果，得到的输出会是： 123456&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项： 123456&lt;my-awesome-list :items=&quot;items&quot;&gt; &lt;!-- 作用域插槽也可以是具名的 --&gt; &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt; &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt; &lt;/template&gt;&lt;/my-awesome-list&gt; 列表组件的模板： 1234567&lt;ul&gt; &lt;slot name=&quot;item&quot; v-for=&quot;item in items&quot; :text=&quot;item.text&quot;&gt; &lt;!-- 这里写入备用内容 --&gt; &lt;/slot&gt;&lt;/ul&gt; 动态组件使用is动态绑定componentkeep-alive如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数： 12345&lt;keep-alive&gt; &lt;component :is=&quot;currentView&quot;&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 异步组件 在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如： 12345678Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; setTimeout(function () &#123; // Pass the component definition to the resolve callback resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;, 1000)&#125;) 工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能： 123456Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require([&apos;./my-async-component&apos;], resolve)&#125;) 你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数： 1234Vue.component( &apos;async-webpack-example&apos;, () =&gt; import(&apos;./my-async-component&apos;)) 当使用局部注册时，你也可以直接提供一个返回 Promise 的函数： 123456new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"6.测试用例：mocha，should，istanbul","slug":"node测试用例：mocha，should，istanbul","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node测试用例：mocha，should，istanbul/","link":"","permalink":"http://yoursite.com/2017/06/20/node测试用例：mocha，should，istanbul/","excerpt":"","text":"《测试用例：mocha，should，istanbul》目标建立一个 lesson6 项目，在其中编写代码。 main.js: 其中有个 fibonacci 函数。fibonacci 的介绍见：http://en.wikipedia.org/wiki/Fibonacci_number 。 此函数的定义为 int fibonacci(int n) 当 n === 0 时，返回 0；n === 1时，返回 1; n &gt; 1 时，返回 fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)，如 fibonacci(10) === 55; n 不可大于10，否则抛错，因为 Node.js 的计算性能没那么强。 n 也不可小于 0，否则抛错，因为没意义。 n 不为数字时，抛错。 test/main.test.js: 对 main 函数进行测试，并使行覆盖率和分支覆盖率都达到 100%。 知识点 学习使用测试框架 mocha : http://mochajs.org/ 学习使用断言库 should : https://github.com/tj/should.js 学习使用测试率覆盖工具 istanbul : https://github.com/gotwarlost/istanbul 简单 Makefile 的编写 : http://blog.csdn.net/haoel/article/details/2886 课程内容首先，作为一个 Node.js 项目，先执行 npm init 创建 package.json。 其次，建立我们的 main.js 文件，编写 fibonacci 函数。 12345678910111213141516var fibonacci = function (n) &#123; if (n === 0) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; return fibonacci(n-1) + fibonacci(n-2);&#125;;if (require.main === module) &#123; // 如果是直接执行 main.js，则进入此处 // 如果 main.js 被其他文件 require，则此处不会执行。 var n = Number(process.argv[2]); console.log('fibonacci(' + n + ') is', fibonacci(n));&#125; OK，这只是个简单的实现。 我们可以执行试试 $ node main.js 10 嗯，结果是 55，符合预期。 接下来我们开始测试驱动开发，现在简单的实现已经完成，那我们就对它进行一下简单测试吧。 我们先得把 main.js 里面的 fibonacci 暴露出来，这个简单。加一句 exports.fibonacci = fibonacci;（要是看不懂这句就去补补 Node.js 的基础知识吧） 就好了。 然后我们在 test/main.test.js 中引用我们的 main.js，并开始一个简单的测试。 123456789// file: test/main.test.jsvar main = require('../main');var should = require('should');describe('test/main.test.js', function () &#123; it('should equal 55 when n === 10', function () &#123; main.fibonacci(10).should.equal(55); &#125;);&#125;); 把测试先跑通，我们再讲这段测试代码的含义。 装个全局的 mocha: $ npm install mocha -g。 -g 与 非-g 的区别，就是安装位置的区别，g 是 global 的意思。如果不加的话，则安装 mocha 在你的项目目录下面；如果加了，则这个 mocha 是安装在全局的，如果 mocha 有可执行命令的话，那么这个命令也会自动加入到你系统 $PATH 中的某个地方（在我的系统中，是这里 /Users/alsotang/.nvm/v0.10.29/bin） 在 lesson6 目录下，直接执行 $ mocha 输出应如下 那么，代码中的 describe 和 it 是什么意思呢？其实就是 BDD 中的那些意思，把它们当做语法来记就好了。 大家来看看 nodeclub 中，关于 topicController 的测试文件： https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js 这文件的内容没有超出之前课程的范围吧。 describe 中的字符串，用来描述你要测的主体是什么；it 当中，描述具体的 case 内容。 而引入的那个 should 模块，是个断言库。玩过 ruby 的同学应该知道 rspec，rspec 它把测试框架和断言库的事情一起做了，而在 Node.js 中，这两样东西的作用分别是 mocha 和 should 在协作完成。 should 在 js 的 Object “基类”上注入了一个 #should 属性，这个属性中，又有着许许多多的属性可以被访问。 比如测试一个数是不是大于3，则是 (5).should.above(3)；测试一个字符串是否有着特定前缀：&#39;foobar&#39;.should.startWith(&#39;foo&#39;);。should.js API 在：https://github.com/tj/should.js should.js 如果现在还是 version 3 的话，我倒是推荐大家去看看它的 API 和 源码；现在 should 是 version 4 了，API 丑得很，但为了不掉队，我还是一直用着它。我觉得 expect 麻烦，所以不用 expect，对了，expect 也是一个断言库：https://github.com/LearnBoost/expect.js/ 。 回到正题，还记得我们 fibonacci 函数的几个要求吗？ 12345* 当 n === 0 时，返回 0；n === 1时，返回 1;* n &gt; 1 时，返回 `fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)`，如 `fibonacci(10) === 55`;* n 不可大于10，否则抛错，因为 Node.js 的计算性能没那么强。* n 也不可小于 0，否则抛错，因为没意义。* n 不为数字时，抛错。 我们用测试用例来描述一下这几个要求，更新后的 main.test.js 如下： 12345678910111213141516171819202122232425262728293031323334var main = require('../main');var should = require('should');describe('test/main.test.js', function () &#123; it('should equal 0 when n === 0', function () &#123; main.fibonacci(0).should.equal(0); &#125;); it('should equal 1 when n === 1', function () &#123; main.fibonacci(1).should.equal(1); &#125;); it('should equal 55 when n === 10', function () &#123; main.fibonacci(10).should.equal(55); &#125;); it('should throw when n &gt; 10', function () &#123; (function () &#123; main.fibonacci(11); &#125;).should.throw('n should &lt;= 10'); &#125;); it('should throw when n &lt; 0', function () &#123; (function () &#123; main.fibonacci(-1); &#125;).should.throw('n should &gt;= 0'); &#125;); it('should throw when n isnt Number', function () &#123; (function () &#123; main.fibonacci('呵呵'); &#125;).should.throw('n should be a Number'); &#125;);&#125;); 还是比较清晰的吧？ 我们这时候跑一下 $ mocha，会发现后三个 case 都没过。 于是我们更新 fibonacci 的实现： 12345678910111213141516171819var fibonacci = function (n) &#123; if (typeof n !== 'number') &#123; throw new Error('n should be a Number'); &#125; if (n &lt; 0) &#123; throw new Error('n should &gt;= 0'); &#125; if (n &gt; 10) &#123; throw new Error('n should &lt;= 10'); &#125; if (n === 0) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; return fibonacci(n-1) + fibonacci(n-2);&#125;; 再跑一次 $ mocha，就过了。这就是传说中的测试驱动开发：先把要达到的目的都描述清楚，然后让现有的程序跑不过 case，再修补程序，让 case 通过。 安装一个 istanbul : $ npm i istanbul -g 执行 $ istanbul cover _mocha 这会比直接使用 mocha 多一行覆盖率的输出， 可以看到，我们其中的分支覆盖率是 91.67%，行覆盖率是 87.5%。 打开 open coverage/lcov-report/index.html 看看 其实这覆盖率是 100% 的，24 25 两行没法测。 mocha 和 istanbul 的结合是相当无缝的，只要 mocha 跑得动，那么 istanbul 就接得进来。 到此这门课其实就完了，剩下要说的内容，都是些比较细节的。比较懒的同学可以踩坑了之后再回来看。 上面的课程，不完美的地方就在于 mocha 和 istanbul 版本依赖的问题，但为了不引入不必要的复杂性，所以上面就没提到这点了。 假设你有一个项目A，用到了 mocha 的 version 3，其他人有个项目B，用到了 mocha 的 version 10，那么如果你 npm i mocha -g 装的是 version 3 的话，你用 $ mocha 是不兼容B项目的。因为 mocha 版本改变之后，很可能语法也变了，对吧。 这时，跑测试用例的正确方法，应该是 $ npm i mocha --save-dev，装个 mocha 到项目目录中去 $ ./node_modules/.bin/mocha，用刚才安装的这个特定版本的 mocha，来跑项目的测试代码。 ./node_modules/.bin 这个目录下放着我们所有依赖自带的那些可执行文件。 每次输入这个很麻烦对吧？所以我们要引入 Makefile，让 Makefile 帮我们记住复杂的配置。 1234567test: ./node_modules/.bin/mochacov test-cov: ./node_modules/.bin/istanbul cover _mocha.PHONY: test cov test-cov 这时，我们只需要调用 make test 或者 make cov，就可以跑我们相应的测试了。 至于 Makefile 怎么写？以及 .PHONY 是什么意思，请看这里：http://blog.csdn.net/haoel/article/details/2886 ，左耳朵耗子陈皓2004年的文章。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"14.js 中的那些最佳实践","slug":"nodejs 中的那些最佳实践","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/nodejs 中的那些最佳实践/","link":"","permalink":"http://yoursite.com/2017/06/20/nodejs 中的那些最佳实践/","excerpt":"","text":"《js 中的那些最佳实践》这个章节需要大家帮忙补充，一次性想不完那么多 JavaScript 语言精粹http://book.douban.com/subject/3590768/ 这本书很薄，只有 155 页，但该讲的几乎都讲了。大家想办法搞来看看吧（我总不能很没节操地给个电子版 PDF 链接在这里吧）。 js 这门语言，水很浅。没有太复杂的地方可以钻，但特么的坑又多。 上面的那本书是一定要看的。这本书专注在讲 js 语法，其他 js 的书都过多地涉及了浏览器知识。 JavaScript 之美 其一：http://fxck.it/post/72326363595 其二：http://fxck.it/post/73513189448 继承js 前端不懂有什么好办法，后端的话，很方便。 用 node 官方的 util 库，下面是直接从官网摘抄来的： 12345678910111213141516171819202122var util = require(\"util\");var events = require(\"events\");function MyStream() &#123; events.EventEmitter.call(this);&#125;util.inherits(MyStream, events.EventEmitter);MyStream.prototype.write = function(data) &#123; this.emit(\"data\", data);&#125;var stream = new MyStream();console.log(stream instanceof events.EventEmitter); // trueconsole.log(MyStream.super_ === events.EventEmitter); // truestream.on(\"data\", function(data) &#123; console.log('Received data: \"' + data + '\"');&#125;)stream.write(\"It works!\"); // Received data: \"It works!\" js 是面向对象的，但是是“基于原型的面向对象”，没有类。没有多重继承，没有接口。没有结构体，没有枚举类型。 但它的字面量哈希和 function 都足够灵活，拼拼凑凑，上面那些东西都能“模拟”着用。 说到没有类的这个问题，很多人总是要纠正其他人关于 js 原型的理解的。我觉得这是没有必要的。基于原型又不是很牛逼，ES6不是照样给出了 class 关键字吗。不管类还是原型都是为了抽象，烂的东西始终烂，不好理解的始终不好理解。 最近学习 ios 的 swift，看见里面有不少相比 objc 舒服的改进。比如 objc 的“方法调用”，学的是 smalltalk 那一套，那不叫方法调用，而是消息传递。结果 swift 里面不照样是方法调用的形式？ callback hell用 eventproxy 和 async 已经能解决大部分问题。剩下的小部分问题，肯定是设计错误。：） 参见： 《使用 eventproxy 控制并发》：https://github.com/alsotang/node-lessons/tree/master/lesson4 《使用 async 控制并发》：https://github.com/alsotang/node-lessons/tree/master/lesson5 数据类型写 js 很少去定义类。Object 的便利在多数其他语言需要定义类的场景下都能直接用。 js 中，用好 Number，String，Array，Object 和 Function 就够了。有时用用 RegExp。 用于 js 这门语言本身的残废，大多数时候都采用“约定胜于配置”的思想来交互合作。 控制流很常规，C 语言那套。 基本运算符C 语言那套。二进制操作并不会降低效率，V8 很聪明的。 计算型属性也就是帮一个对象的属性定义 get 和 set 方法，通过 obj.value 和 obj.value= 的形式来调用。 koa(http://koajs.com/ ) 把这套玩得炉火纯青。 运算符重载无 类型转换手动帮你需要转换的类型的类定义 .toxxx 方法，比如 .toString，.toJSON，toNumber。 js 的隐式类型转换用一次坑一次。 相等比较在 js 中，务必使用 === 三个等于号来比较对象，或者自定义方法来比较，不要使用 ==。 我最近做一个项目，从数据库中取出的数据，虽然应该是字符型的，但有时它们是 String 的表示，有时是 Number 的表示。为了省事，会有人直接用 == 来对它们进行比较。这种时候，建议在比较时，把它们都转成 String 类型，然后用 === 来比较。 比如 var x = 31243; var y = &#39;31243&#39;，比较时，这么做：String(x) === String(y) 嵌套类型随便弄。 function 构造函数、闭包、字面量哈希，都可以混在一起写，多少层都行，无限制。 拓展当无法接触一个类的源码，又想帮这个类新增方法的时候。操作它的 prototype 就好了。但不推荐！ 函数式编程js 中，匿名函数非常的方便，有效利用函数式编程的特性可以使人写代码时心情愉悦。 使用 lodash：https://lodash.com/docs 泛型类型都经常忽略还泛型！every parammeter is 泛型 in js 权限控制类定义中，没有 public private 等关键词，都靠约定。而且经常有人突破约定。 有些 http 方面的库，时不时就去 stub 原生 http 库的方法，0.11 时的 node.js 完全不按章法出牌，所以很多这些库都出现兼容性问题。 设计模式《解密设计模式-王垠》 https://github.com/alsotang/node-lessons/blob/master/lesson14/%E8%A7%A3%E5%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8E%8B%E5%9E%A0.md 构建大型项目从 npm 上面寻找质量高的库，并用质量高的方式拼凑起来。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"17.使用 promise 替代回调函数","slug":"node使用 promise 替代回调函数","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node使用 promise 替代回调函数/","link":"","permalink":"http://yoursite.com/2017/06/20/node使用 promise 替代回调函数/","excerpt":"","text":"《使用 promise 替代回调函数》知识点 理解 Promise 概念，为什么需要 promise 学习 q 的 API，利用 q 来替代回调函数(https://github.com/kriskowal/q ) 课程内容第五课(https://github.com/alsotang/node-lessons/tree/master/lesson5 )讲述了如何使用 async 来控制并发。async 的本质是一个流程控制。其实在异步编程中，还有一个更为经典的模型，叫做 Promise/Deferred 模型。 本节我们就来学习这个模型的代表实现：q 首先，我们思考一个典型的异步编程模型，考虑这样一个题目：读取一个文件，在控制台输出这个文件内容。 1234var fs = require('fs');fs.readFile('sample.txt', 'utf8', function (err, data) &#123; console.log(data);&#125;); 看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容。 1234567var fs = require('fs');fs.readFile('sample01.txt', 'utf8', function (err, data) &#123; console.log(data); fs.readFile('sample02.txt', 'utf8', function (err,data) &#123; console.log(data); &#125;);&#125;); 要是读取更多的文件呢? 12345678910var fs = require('fs');fs.readFile('sample01.txt', 'utf8', function (err, data) &#123; fs.readFile('sample02.txt', 'utf8', function (err,data) &#123; fs.readFile('sample03.txt', 'utf8', function (err, data) &#123; fs.readFile('sample04.txt', 'utf8', function (err, data) &#123; &#125;); &#125;); &#125;);&#125;); 这段代码就是臭名昭著的邪恶金字塔(Pyramid of Doom)。可以使用async来改善这段代码，但是在本课中我们要用promise/defer来改善它。 promise基本概念先学习promise的基本概念。 promise只有三种状态，未完成，完成(fulfilled)和失败(rejected)。 promise的状态可以由未完成转换成完成，或者未完成转换成失败。 promise的状态转换只发生一次 promise有一个then方法，then方法可以接受3个函数作为参数。前两个函数对应promise的两种状态fulfilled, rejected的回调函数。第三个函数用于处理进度信息。 1234567promiseSomething().then(function(fulfilled)&#123; //当promise状态变成fulfilled时，调用此函数 &#125;,function(rejected)&#123; //当promise状态变成rejected时，调用此函数 &#125;,function(progress)&#123; //当返回进度信息时，调用此函数 &#125;); 学习一个简单的例子： 12345678910111213141516171819202122var Q = require('q');var defer = Q.defer();/** * 获取初始promise * @private */function getInitialPromise() &#123; return defer.promise;&#125;/** * 为promise设置三种状态的回调函数 */getInitialPromise().then(function(success)&#123; console.log(success);&#125;,function(error)&#123; console.log(error);&#125;,function(progress)&#123; console.log(progress);&#125;);defer.notify('in progress');//控制台打印in progressdefer.resolve('resolve'); //控制台打印resolvedefer.reject('reject'); //没有输出。promise的状态只能改变一次 promise的传递then方法会返回一个promise，在下面这个例子中，我们用outputPromise指向then返回的promise。 123var outputPromise = getInputPromise().then(function (fulfilled) &#123; &#125;, function (rejected) &#123; &#125;); 现在outputPromise就变成了受 function(fulfilled) 或者 function(rejected)控制状态的promise了。怎么理解这句话呢？ 当function(fulfilled)或者function(rejected)返回一个值，比如一个字符串，数组，对象等等，那么outputPromise的状态就会变成fulfilled。 在下面这个例子中，我们可以看到，当我们把inputPromise的状态通过defer.resovle()变成fulfilled时，控制台输出fulfilled. 当我们把inputPromise的状态通过defer.reject()变成rejected，控制台输出rejected 12345678910111213141516171819202122232425262728293031323334353637383940414243var Q = require('q');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled) * 当inputPromise状态由未完成变成rejected时，调用function(rejected) * 将then返回的promise赋给outputPromise * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由 * 未完成改变为fulfilled * @private */var outputPromise = getInputPromise().then(function(fulfilled)&#123; return 'fulfilled';&#125;,function(rejected)&#123; return 'rejected';&#125;);/** * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印'fulfilled: fulfilled'。 * 当outputPromise状态由未完成变成rejected, 调用function(rejected), 控制台打印'rejected: rejected'。 */outputPromise.then(function(fulfilled)&#123; console.log('fulfilled: ' + fulfilled);&#125;,function(rejected)&#123; console.log('rejected: ' + rejected);&#125;);/** * 将inputPromise的状态由未完成变成rejected */defer.reject(); //输出 fulfilled: rejected/** * 将inputPromise的状态由未完成变成fulfilled *///defer.resolve(); //输出 fulfilled: fulfilled 当function(fulfilled)或者function(rejected)抛出异常时，那么outputPromise的状态就会变成rejected 123456789101112131415161718192021222324252627282930313233343536373839404142434445var Q = require('q');var fs = require('fs');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled) * 当inputPromise状态由未完成变成rejected时，调用function(rejected) * 将then返回的promise赋给outputPromise * function(fulfilled) 和 function(rejected) 通过抛出异常将outputPromise的状态由 * 未完成改变为reject * @private */var outputPromise = getInputPromise().then(function(fulfilled)&#123; throw new Error('fulfilled');&#125;,function(rejected)&#123; throw new Error('rejected');&#125;);/** * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)。 * 当outputPromise状态由未完成变成rejected, 调用function(rejected)。 */outputPromise.then(function(fulfilled)&#123; console.log('fulfilled: ' + fulfilled);&#125;,function(rejected)&#123; console.log('rejected: ' + rejected);&#125;);/** * 将inputPromise的状态由未完成变成rejected */defer.reject(); //控制台打印 rejected [Error:rejected]/** * 将inputPromise的状态由未完成变成fulfilled *///defer.resolve(); //控制台打印 rejected [Error:fulfilled] 当function(fulfilled)或者function(rejected)返回一个promise时，outputPromise就会成为这个新的promise. 这样做有什么意义呢? 主要在于聚合结果(Q.all)，管理延时，异常恢复等等 比如说我们想要读取一个文件的内容，然后把这些内容打印出来。可能会写出这样的代码： 123456//错误的写法var outputPromise = getInputPromise().then(function(fulfilled)&#123; fs.readFile('test.txt','utf8',function(err,data)&#123; return data; &#125;);&#125;); 然而这样写是错误的，因为function(fulfilled)并没有返回任何值。需要下面的方式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var Q = require('q');var fs = require('fs');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled) * 当inputPromise状态由未完成变成rejected时，调用function(rejected) * 将then返回的promise赋给outputPromise * function(fulfilled)将新的promise赋给outputPromise * 未完成改变为reject * @private */var outputPromise = getInputPromise().then(function(fulfilled)&#123; var myDefer = Q.defer(); fs.readFile('test.txt','utf8',function(err,data)&#123; if(!err &amp;&amp; data) &#123; myDefer.resolve(data); &#125; &#125;); return myDefer.promise;&#125;,function(rejected)&#123; throw new Error('rejected');&#125;);/** * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印test.txt文件内容。 * */outputPromise.then(function(fulfilled)&#123; console.log(fulfilled);&#125;,function(rejected)&#123; console.log(rejected);&#125;);/** * 将inputPromise的状态由未完成变成rejected *///defer.reject();/** * 将inputPromise的状态由未完成变成fulfilled */defer.resolve(); //控制台打印出 test.txt 的内容 方法传递方法传递有些类似于Java中的try和catch。当一个异常没有响应的捕获时，这个异常会接着往下传递。 方法传递的含义是当一个状态没有响应的回调函数，就会沿着then往下找。 没有提供function(rejected) 1var outputPromise = getInputPromise().then(function(fulfilled)&#123;&#125;) 如果inputPromise的状态由未完成变成rejected, 此时对rejected的处理会由outputPromise来完成。 12345678910111213141516171819202122232425262728293031323334var Q = require('q');var fs = require('fs');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled) * 当inputPromise状态由未完成变成rejected时，这个rejected会传向outputPromise */var outputPromise = getInputPromise().then(function(fulfilled)&#123; return 'fulfilled'&#125;);outputPromise.then(function(fulfilled)&#123; console.log('fulfilled: ' + fulfilled);&#125;,function(rejected)&#123; console.log('rejected: ' + rejected);&#125;);/** * 将inputPromise的状态由未完成变成rejected */defer.reject('inputpromise rejected'); //控制台打印rejected: inputpromise rejected/** * 将inputPromise的状态由未完成变成fulfilled *///defer.resolve(); 没有提供function(fulfilled) 1var outputPromise = getInputPromise().then(null,function(rejected)&#123;&#125;) 如果inputPromise的状态由未完成变成fulfilled, 此时对fulfil的处理会由outputPromise来完成。 1234567891011121314151617181920212223242526272829303132333435363738var Q = require('q');var fs = require('fs');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfil时，传递给outputPromise * 当inputPromise状态由未完成变成rejected时，调用function(rejected) * function(fulfilled)将新的promise赋给outputPromise * 未完成改变为reject * @private */var outputPromise = getInputPromise().then(null,function(rejected)&#123; return 'rejected';&#125;);outputPromise.then(function(fulfilled)&#123; console.log('fulfilled: ' + fulfilled);&#125;,function(rejected)&#123; console.log('rejected: ' + rejected);&#125;);/** * 将inputPromise的状态由未完成变成rejected *///defer.reject('inputpromise rejected');/** * 将inputPromise的状态由未完成变成fulfilled */defer.resolve('inputpromise fulfilled'); //控制台打印fulfilled: inputpromise fulfilled 可以使用fail(function(error))来专门针对错误处理，而不是使用then(null,function(error)) 1var outputPromise = getInputPromise().fail(function(error)&#123;&#125;) 看这个例子 123456789101112131415161718192021222324252627282930313233var Q = require('q');var fs = require('fs');var defer = Q.defer();/** * 通过defer获得promise * @private */function getInputPromise() &#123; return defer.promise;&#125;/** * 当inputPromise状态由未完成变成fulfil时，调用then(function(fulfilled)) * 当inputPromise状态由未完成变成rejected时，调用fail(function(error)) * function(fulfilled)将新的promise赋给outputPromise * 未完成改变为reject * @private */var outputPromise = getInputPromise().then(function(fulfilled)&#123; return fulfilled;&#125;).fail(function(error)&#123; console.log('fail: ' + error);&#125;);/** * 将inputPromise的状态由未完成变成rejected */defer.reject('inputpromise rejected');//控制台打印fail: inputpromise rejected/** * 将inputPromise的状态由未完成变成fulfilled *///defer.resolve('inputpromise fulfilled'); 可以使用progress(function(progress))来专门针对进度信息进行处理，而不是使用 then(function(success){},function(error){},function(progress){}) 1234567891011121314151617181920var Q = require('q');var defer = Q.defer();/** * 获取初始promise * @private */function getInitialPromise() &#123; return defer.promise;&#125;/** * 为promise设置progress信息处理函数 */var outputPromise = getInitialPromise().then(function(success)&#123;&#125;).progress(function(progress)&#123; console.log(progress);&#125;);defer.notify(1);defer.notify(2); //控制台打印1，2 promise链promise链提供了一种让函数顺序执行的方法。 函数顺序执行是很重要的一个功能。比如知道用户名，需要根据用户名从数据库中找到相应的用户，然后将用户信息传给下一个函数进行处理。 12345678910111213141516171819202122232425262728var Q = require('q');var defer = Q.defer();//一个模拟数据库var users = [&#123;'name':'andrew','passwd':'password'&#125;];function getUsername() &#123;return defer.promise;&#125;function getUser(username)&#123; var user; users.forEach(function(element)&#123; if(element.name === username) &#123; user = element; &#125; &#125;); return user;&#125;//promise链getUsername().then(function(username)&#123; return getUser(username);&#125;).then(function(user)&#123; console.log(user);&#125;);defer.resolve('andrew'); 我们通过两个then达到让函数顺序执行的目的。 then的数量其实是没有限制的。当然，then的数量过多，要手动把他们链接起来是很麻烦的。比如 1foo(initialVal).then(bar).then(baz).then(qux) 这时我们需要用代码来动态制造promise链 123456var funcs = [foo,bar,baz,qux]var result = Q(initialVal)funcs.forEach(function(func)&#123; result = result.then(func)&#125;)return result 当然，我们可以再简洁一点 1234var funcs = [foo,bar,baz,qux]funcs.reduce(function(pre,current),Q(initialVal)&#123; return pre.then(current)&#125;) 看一个具体的例子 12345678910111213141516171819function foo(result) &#123; console.log(result); return result+result;&#125;//手动链接Q('hello').then(foo).then(foo).then(foo); //控制台输出： hello // hellohello // hellohellohello//动态链接var funcs = [foo,foo,foo];var result = Q('hello');funcs.forEach(function(func)&#123; result = result.then(func);&#125;);//精简后的动态链接funcs.reduce(function(prev,current)&#123; return prev.then(current);&#125;,Q('hello')); 对于promise链，最重要的是需要理解为什么这个链能够顺序执行。如果能够理解这点，那么以后自己写promise链可以说是轻车熟路啊。 promise组合回到我们一开始读取文件内容的例子。如果现在让我们把它改写成promise链，是不是很简单呢？ 12345678910111213141516171819var Q = require('q'), fs = require('fs');function printFileContent(fileName) &#123; return function()&#123; var defer = Q.defer(); fs.readFile(fileName,'utf8',function(err,data)&#123; if(!err &amp;&amp; data) &#123; console.log(data); defer.resolve(); &#125; &#125;) return defer.promise; &#125;&#125;//手动链接printFileContent('sample01.txt')() .then(printFileContent('sample02.txt')) .then(printFileContent('sample03.txt')) .then(printFileContent('sample04.txt')); //控制台顺序打印sample01到sample04的内容 很有成就感是不是。然而如果仔细分析，我们会发现为什么要他们顺序执行呢，如果他们能够并行执行不是更好吗? 我们只需要在他们都执行完成之后，得到他们的执行结果就可以了。 我们可以通过Q.all([promise1,promise2…])将多个promise组合成一个promise返回。注意： 当all里面所有的promise都fulfil时，Q.all返回的promise状态变成fulfil 当任意一个promise被reject时，Q.all返回的promise状态立即变成reject 我们来把上面读取文件内容的例子改成并行执行吧 123456789101112131415161718192021222324var Q = require('q');var fs = require('fs');/** *读取文件内容 *@private */function printFileContent(fileName) &#123; //Todo: 这段代码不够简洁。可以使用Q.denodeify来简化 var defer = Q.defer(); fs.readFile(fileName,'utf8',function(err,data)&#123; if(!err &amp;&amp; data) &#123; console.log(data); defer.resolve(fileName + ' success '); &#125;else &#123; defer.reject(fileName + ' fail '); &#125; &#125;) return defer.promise;&#125;Q.all([printFileContent('sample01.txt'),printFileContent('sample02.txt'),printFileContent('sample03.txt'),printFileContent('sample04.txt')]) .then(function(success)&#123; console.log(success); &#125;); //控制台打印各个文件内容 顺序不一定 现在知道Q.all会在任意一个promise进入reject状态后立即进入reject状态。如果我们需要等到所有的promise都发生状态后(有的fulfil, 有的reject)，再转换Q.all的状态, 这时我们可以使用Q.allSettled 12345678910111213141516171819202122232425262728var Q = require('q'), fs = require('fs');/** *读取文件内容 *@private */function printFileContent(fileName) &#123; //Todo: 这段代码不够简洁。可以使用Q.denodeify来简化 var defer = Q.defer(); fs.readFile(fileName,'utf8',function(err,data)&#123; if(!err &amp;&amp; data) &#123; console.log(data); defer.resolve(fileName + ' success '); &#125;else &#123; defer.reject(fileName + ' fail '); &#125; &#125;) return defer.promise;&#125;Q.allSettled([printFileContent('nosuchfile.txt'),printFileContent('sample02.txt'),printFileContent('sample03.txt'),printFileContent('sample04.txt')]) .then(function(results)&#123; results.forEach( function(result) &#123; console.log(result.state); &#125; ); &#125;); 结束promise链通常，对于一个promise链，有两种结束的方式。第一种方式是返回最后一个promise 如 return foo().then(bar); 第二种方式就是通过done来结束promise链 如 foo().then(bar).done() 为什么需要通过done来结束一个promise链呢? 如果在我们的链中有错误没有被处理，那么在一个正确结束的promise链中，这个没被处理的错误会通过异常抛出。 12345678910111213141516171819202122232425262728293031var Q = require('q');/** *@private */function getPromise(msg,timeout,opt) &#123; var defer = Q.defer(); setTimeout(function()&#123; console.log(msg); if(opt) defer.reject(msg); else defer.resolve(msg); &#125;,timeout); return defer.promise;&#125;/** *没有用done()结束的promise链 *由于getPromse('2',2000,'opt')返回rejected, getPromise('3',1000)就没有执行 *然后这个异常并没有任何提醒，是一个潜在的bug */getPromise('1',3000) .then(function()&#123;return getPromise('2',2000,'opt')&#125;) .then(function()&#123;return getPromise('3',1000)&#125;);/** *用done()结束的promise链 *有异常抛出 */getPromise('1',3000) .then(function()&#123;return getPromise('2',2000,'opt')&#125;) .then(function()&#123;return getPromise('3',1000)&#125;) .done(); 结束语当你理解完上面所有的知识点时，你就会正确高效的使用promise了。本节只是讲了promise的原理和几个基本的API，不过你掌握了这些之后，再去看q的文档，应该很容易就能理解各个api的意图。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"16.cookie 和 session","slug":"nodecookie 和 session","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/nodecookie 和 session/","link":"","permalink":"http://yoursite.com/2017/06/20/nodecookie 和 session/","excerpt":"","text":"cookie 和 session众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？ 比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？ cookie首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步： 服务器向客户端发送 cookie。 通常使用 HTTP 协议规定的 set-cookie 头操作。 规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。 浏览器将 cookie 保存。 每次请求浏览器都会将 cookie 发向服务器。 其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种： path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。 expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。 secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。 express 中的 cookieexpress 在 4.x 版本之后，session管理和cookies等许多模块都不再直接包含在express中，而是需要单独添加相应模块。 express4 中操作 cookie 使用 cookie-parser 模块(https://github.com/expressjs/cookie-parser )。 1234567891011121314151617181920212223var express = require('express');// 首先引入 cookie-parser 这个模块var cookieParser = require('cookie-parser');var app = express();app.listen(3000);// 使用 cookieParser 中间件，cookieParser(secret, options)// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）// options 传入上面介绍的 cookie 可选参数app.use(cookieParser());app.get('/', function (req, res) &#123; // 如果请求中的 cookie 存在 isVisit, 则输出 cookie // 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟 if (req.cookies.isVisit) &#123; console.log(req.cookies); res.send(\"再次欢迎访问\"); &#125; else &#123; res.cookie('isVisit', 1, &#123;maxAge: 60 * 1000&#125;); res.send(\"欢迎第一次访问\"); &#125;&#125;); sessioncookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。 session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 connect.sid 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。 这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。 session 可以存放在 1）内存、2）cookie本身、3）redis 或 memcached 等缓存中，或者4）数据库中。线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，下面会提到。 express 中操作 session 要用到 express-session (https://github.com/expressjs/session ) 这个模块，主要的方法就是 session(options)，其中 options 中包含可选参数，主要有： name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid 。 store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。 secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。 cookie: 设置存放 session id 的 cookie 的相关选项，默认为 (default: { path: ‘/‘, httpOnly: true, secure: false, maxAge: null }) genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包。 rolling: 每个请求都重新设置一个 cookie，默认为 false。 resave: 即使 session 没有被修改，也保存 session 值，默认为 true。 1） 在内存中存储 session express-session 默认使用内存来存 session，对于开发调试来说很方便。 1234567891011121314151617181920212223242526var express = require('express');// 首先引入 express-session 这个模块var session = require('express-session');var app = express();app.listen(5000);// 按照上面的解释，设置 session 的可选参数app.use(session(&#123; secret: 'recommand 128 bytes random string', // 建议使用 128 个字符的随机字符串 cookie: &#123; maxAge: 60 * 1000 &#125;&#125;));app.get('/', function (req, res) &#123; // 检查 session 中的 isVisit 字段 // 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1。 if(req.session.isVisit) &#123; req.session.isVisit++; res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来此页面&lt;/p&gt;'); &#125; else &#123; req.session.isVisit = 1; res.send(\"欢迎第一次来这里\"); console.log(req.session); &#125;&#125;); 2） 在 redis 中存储 session session 存放在内存中不方便进程间共享，因此可以使用 redis 等缓存来存储 session。 假设你的机器是 4 核的，你使用了 4 个进程在跑同一个 node web 服务，当用户访问进程1时，他被设置了一些数据当做 session 存在内存中。而下一次访问时，他被负载均衡到了进程2，则此时进程2的内存中没有他的信息，认为他是个新用户。这就会导致用户在我们服务中的状态不一致。 使用 redis 作为缓存，可以使用 connect-redis 模块(https://github.com/tj/connect-redis )来得到 redis 连接实例，然后在 session 中设置存储方式为该实例。 123456789101112131415161718192021222324var express = require('express');var session = require('express-session');var redisStore = require('connect-redis')(session);var app = express();app.listen(5000);app.use(session(&#123; // 假如你不想使用 redis 而想要使用 memcached 的话，代码改动也不会超过 5 行。 // 这些 store 都遵循着统一的接口，凡是实现了那些接口的库，都可以作为 session 的 store 使用，比如都需要实现 .get(keyString) 和 .set(keyString, value) 方法。 // 编写自己的 store 也很简单 store: new redisStore(), secret: 'somesecrettoken'&#125;));app.get('/', function (req, res) &#123; if(req.session.isVisit) &#123; req.session.isVisit++; res.send('&lt;p&gt;第 ' + req.session.isVisit + '次来到此页面&lt;/p&gt;'); &#125; else &#123; req.session.isVisit = 1; res.send('欢迎第一次来这里'); &#125;&#125;); 我们可以运行 redis-cli 查看结果，如图可以看到 redis 中缓存结果。 各种存储的利弊上面我们说到，session 的 store 有四个常用选项：1）内存 2）cookie 3）缓存 4）数据库 其中，开发环境存内存就好了。一般的小程序为了省事，如果不涉及状态共享的问题，用内存 session 也没问题。但内存 session 除了省事之外，没有别的好处。 cookie session 我们下面会提到，现在说说利弊。用 cookie session 的话，是不用担心状态共享问题的，因为 session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息。当然在这里，安全性之类的，只要遵照最佳实践来，也是有保证的。它的弊端是增大了数据量传输，利端是方便。 缓存方式是最常用的方式了，即快，又能共享状态。相比 cookie session 来说，当 session data 比较大的时候，可以节省网络传输。推荐使用。 数据库 session。除非你很熟悉这一块，知道自己要什么，否则还是老老实实用缓存吧。 signedCookie上面都是讲基础，现在讲一些专业点的。 上面有提到 cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造 其实不是这样的，那只是为了方便理解才那么写。要知道，计算机领域有个名词叫 签名，专业点说，叫 信息摘要算法。 比如我们现在面临着一个菜鸟开发的网站，他用 cookie 来记录登陆的用户凭证。相应的 cookie 长这样：dotcom_user=alsotang，它说明现在的用户是 alsotang 这个用户。如果我在浏览器中装个插件，把它改成 dotcom_user=ricardo，服务器一读取，就会误认为我是 ricardo。然后我就可以进行 ricardo 才能进行的操作了。之前 web 开发不成熟的时候，用这招甚至可以黑个网站下来，把 cookie 改成 dotcom_user=admin 就行了，唉，那是个玩黑客的黄金年代啊。 OK，现在我有一些数据，不想存在 session 中，想存在 cookie 中，怎么保证不被篡改呢？答案很简单，签个名。 假设我的服务器有个秘密字符串，是 this_is_my_secret_and_fuck_you_all，我为用户 cookie 的 dotcom_user 字段设置了个值 alsotang。cookie 本应是 1&#123;dotcom_user: 'alsotang'&#125; 这样的。 而如果我们签个名，比如把 dotcom_user 的值跟我的 secret_string 做个 sha1 sha1(&#39;this_is_my_secret_and_fuck_you_all&#39; + &#39;alsotang&#39;) === &#39;4850a42e3bc0d39c978770392cbd8dc2923e3d1d&#39; 然后把 cookie 变成这样 1234&#123; dotcom_user: 'alsotang', 'dotcom_user.sig': '4850a42e3bc0d39c978770392cbd8dc2923e3d1d',&#125; 这样一来，用户就没法伪造信息了。一旦它更改了 cookie 中的信息，则服务器会发现 hash 校验的不一致。 毕竟他不懂我们的 secret_string 是什么，而暴力破解哈希值的成本太高。 cookie-session上面一直提到 session 可以存在 cookie 中，现在来讲讲具体的思路。这里所涉及的专业名词叫做 对称加密。 假设我们想在用户的 cookie 中存 session data，使用一个名为 session_data 的字段。 存 1var sessionData = &#123;username: 'alsotang', age: 22, company: 'alibaba', location: 'hangzhou'&#125; 这段信息的话，可以将 sessionData 与我们的 secret_string 一起做个对称加密，存到 cookie 的 session_data 字段中，只要你的 secret_string 足够长，那么攻击者也是无法获取实际 session 内容的。对称加密之后的内容对于攻击者来说相当于一段乱码。 而当用户下次访问时，我们就可以用 secret_string 来解密 sessionData，得到我们需要的 session data。 signedCookies 跟 cookie-session 还是有区别的： 1）是前者信息可见不可篡改，后者不可见也不可篡改 2）是前者一般是长期保存，而后者是 session cookie cookie-session 的实现跟 signedCookies 差不多。 不过 cookie-session 我个人建议不要使用，有受到回放攻击的危险。 回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 session 中，session 保存在 cookie 中。他先复制下现在的这段 cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了。而他现在可以将之前复制下的那段 cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分。 如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 cookie session，而验证所需的信息，一定不能存在 cookie 中。这么一来，避免了这种攻击后，使用 cookie session 的好处就荡然无存了。如果为了避免攻击而引入了缓存使用的话，那不如把 cookie session 也一起放进缓存中。 session cookie初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie。即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失。 常见的场景就是在开发用户登陆状态保持时。 假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁。所以我们要在 cookie 中，也保存一份关于用户身份的信息。 比如有这样一个用户 1&#123;username: 'alsotang', age: 22, company: 'alibaba', location: 'hangzhou'&#125; 我们可以考虑把这四个字段的信息都存在 session 中，而在 cookie，我们用 signedCookies 来存个 username。 登陆的检验过程伪代码如下： 1234567891011121314if (req.session.user) &#123; // 获取 user 并进行下一步 next()&#125; else if (req.signedCookies['username']) &#123; // 如果存在则从数据库中获取这个 username 的信息，并保存到 session 中 getuser(function (err, user) &#123; req.session.user = user; next(); &#125;);&#125; else &#123; // 当做为登陆用户处理 next();&#125; etag 当做 session，保存 http 会话很黑客的一种玩法：https://cnodejs.org/topic/5212d82d0a746c580b43d948","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"8.benchmark 怎么写","slug":"nodebenchmark 怎么写","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/nodebenchmark 怎么写/","link":"","permalink":"http://yoursite.com/2017/06/20/nodebenchmark 怎么写/","excerpt":"","text":"《benchmark 怎么写》目标有一个字符串 var number = &#39;100&#39;，我们要将它转换成 Number 类型的 100。 目前有三个选项：+, parseInt, Number 请测试哪个方法更快。 知识点 学习使用 benchmark 库 学习使用 http://jsperf.com/ 分享你的 benchmark 课程内容首先去弄个 benchmark 库，https://github.com/bestiejs/benchmark.js 。 这个库已经两年没有更新了，两年前发了个 1.0.0 版本，直到现在。 这个库的最新版本是 2.1.0 用法也特别简单，照着官网的 copy 下来就好。 我们先来实现这三个函数： 1234567891011var int1 = function (str) &#123; return +str;&#125;;var int2 = function (str) &#123; return parseInt(str, 10);&#125;;var int3 = function (str) &#123; return Number(str);&#125;; 然后照着官方的模板写 benchmark suite： 12345678910111213141516171819202122var number = '100';// 添加测试suite.add('+', function() &#123; int1(number);&#125;).add('parseInt', function() &#123; int2(number);&#125;).add('Number', function () &#123; int3(number);&#125;)// 每个测试跑完后，输出信息.on('cycle', function(event) &#123; console.log(String(event.target));&#125;).on('complete', function() &#123; console.log('Fastest is ' + this.filter('fastest').map('name'));&#125;)// 这里的 async 不是 mocha 测试那个 async 的意思，这个选项与它的时间计算有关，默认勾上就好了。.run(&#123; 'async': true &#125;); 直接运行： 可以看到，parseInt 是最快的。 在线分享如果想要在线分享你的 js benchmark，用这个网站：http://jsperf.com/ 。 比如我在上面测试 Math.log 的效率： http://jsperf.com/math-perf-alsotang 进入之后点击那个 Run tests 按钮，就可以在浏览器中看到它们的效率差异了，毕竟浏览器也是可以跑 js 的。 点击这里：http://jsperf.com/math-perf-alsotang/edit ，就可以看到这个 benchmark 是怎么配置的，很简单。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"18.何为 connect 中间件","slug":"何为 connect 中间件","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/何为 connect 中间件/","link":"","permalink":"http://yoursite.com/2017/06/20/何为 connect 中间件/","excerpt":"","text":"《何为 connect 中间件》目标 理解中间件的概念 了解 Connect 的实现 课程内容 原生 httpServer 遇到的问题 中间件思想 Connect 实现 Express 简介 这是从 httpServer 到 Express 的升级过程。 HTTPNodejs 的经典 httpServer 代码 1234567var http = require('http');var server = http.createServer(requestHandler);function requestHandler(req, res) &#123; res.end('hello visitor!');&#125;server.listen(3000); 里面的函数 requestHandler 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。 通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 hello visitor!。 然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。 1231. 检测请求中请求体是否存在，若存在则解析请求体；1. 查看请求体中的id是否存在，若存在则去数据库查询；1. 根据数据库结果返回约定的值； 我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。 实现代码: 12345678910111213141516171819202122function parseBody(req, callback) &#123; //根据http协议从req中解析body callback(null, body);&#125;function checkIdInDatabase(body, callback) &#123; //根据body.id在Database中检测，返回结果 callback(null, dbResult);&#125;function returnResult(dbResult, res) &#123; if (dbResult &amp;&amp; dbResult.length &gt; 0) &#123; res.end('true'); &#125; else &#123; res.end('false') &#125;&#125;function requestHandler(req, res) &#123; parseBody(req, function(err, body) &#123; checkIdInDatabase(body, function(err, dbResult) &#123; returnResult(dbResult, res); &#125;); &#125;);&#125; 上面的解决方案解决了包含三个步骤的业务问题，出现了3个 }); 还有3个 err 需要处理，上面的写法可以得达到预期效果。 然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 }); 及30个 err异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 多次返回 或返回地方不对等问题，这就是 回调金字塔 问题了。 大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。 EventProxy —— 事件发布订阅模式(第四课讲到) BlueBird —— Promise方案(第十七课讲到) Async —— 异步流程控制库(第五课讲到) Generator —— ES6原生Generator 理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 类似异步流程控制的思想 。 关于异步流程控制库下面简要介绍下，或移步@第五课。异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 顺序执行 。 callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数 我们动手实现一个类似的链式调用，其中 funlist 更名为 middlewares、callback 更名为 next，码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var middlewares = [ function fun1(req, res, next) &#123; parseBody(req, function(err, body) &#123; if (err) return next(err); req.body = body; next(); &#125;); &#125;, function fun2(req, res, next) &#123; checkIdInDatabase(req.body.id, function(err, rows) &#123; if (err) return next(err); res.dbResult = rows; next(); &#125;); &#125;, function fun3(req, res, next) &#123; if (res.dbResult &amp;&amp; res.dbResult.length &gt; 0) &#123; res.end('true'); &#125; else &#123; res.end('false'); &#125; next(); &#125;]function requestHandler(req, res) &#123; var i=0; //由middlewares链式调用 function next(err) &#123; if (err) &#123; return res.end('error:', err.toString()); &#125; if (i&lt;middlewares.length) &#123; middlewares[i++](req, res, next); &#125; else &#123; return ; &#125; &#125; //触发第一个middleware next();&#125; 上面用middlewares+next完成了业务逻辑的 链式调用，而middlewares里的每个函数，都是一个 中间件。 整体思路是： 将所有 处理逻辑函数(中间件) 存储在一个list中； 请求到达时 循环调用 list中的 处理逻辑函数(中间件)； Connect的实现Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。 Connect中主要有五个函数PS: Connect的核心代码是200+行，建议对照源码看下面的函数介绍。 函数名 作用 createServer 包装httpServer形成app listen 监听端口函数 use 向middlewares里面放入业务逻辑 handle 上一章的requestHandler函数增强版 call 业务逻辑的真正执行者 createServer()输入: 无 执行过程: app是一个函数对象(包含handle方法) app具有Event所有属性(详见utils-merge，十行代码) app有route属性(路由)、和stack属性(用于存储中间件，类似上面的middlewares) 输出: 12345 app is function(req, res, next) &#123;...&#125;; | +---+---+ | has |route stack ##app.use(route, fn) 作用是向stack中添加 逻辑处理函数 (中间件)。 输入: route 可省略，默认’/‘ fn 具体的业务处理逻辑 tips: 上面的fn表示处理逻辑，它可以是 一个普通的 function(req,res[,next]){}； 一个httpServer； 另一个connect的app对象(sub app特性)； 由于它们的本质都是 处理逻辑，都可以用一个 function(req,res,next){}将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。 如何将这三种分别转换为 function(req, res, next) {}的形式呢？ 不用转换； httpServer的定义是“对事件’request’后handler的对象”，我们可以从httpServer.listeners(‘request’)中得到这个函数； 另一个connect对象，而connect()返回的app就是function(req, res, out) {}； 执行过程: 将三种处理逻辑统一转换为function(req,res,next){}的形式表示。 把这个处理逻辑与route一起，放入stack中(存储处理逻辑，route用来匹配路由) 核心代码片段 12//route是路由路径，handle是一个`function(req, res, next) &#123;...&#125;`形式的业务逻辑this.stack.push(&#123; route: path, handle: handle &#125;); 返回: 12//返回自己，可以完成链式调用return this; 总结:: 12var app = connect();app.use('/api', function(req, res, next) &#123;&#125;); 等价于 12var app = connect();app.stack.push(&#123;route: '/api', handle: function(req, res, next) &#123;&#125;&#125;); 最后，app.stack里 顺序存储 了所有的 逻辑处理函数 (中间件)。 1app.stack = [function1, function2, function3, ... function30]; app.handle(req, res, out)这个函数就是请求到达时，负责 顺序调用 我们存储在stack中的 逻辑处理函数 (中间件)函数，类似上一章的requestHandler。 输入: req是Nodejs本身的可读流，不做过多介绍 res是Nodejs本身的可写流，不做过多介绍 out是为了Connect的 sub app特性 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心 处理过程: 可以回头看一下上面的requestHandler函数，handle的实现是这个函数的增强版 取得stack(存储逻辑处理函数列表)，index(列表下标) 构建next函数，next的作用是执行下一个逻辑处理函数 触发第一个next，触发链式调用 next函数实现: next函数实现在handle函数体内，用来顺序执行处理逻辑，它是异步流程控制库的核心，不明白它的作用请看上面的异步流程控制库简介 path是请求路径，route是逻辑处理函数自带的属性。 取得下一个逻辑处理函数; 若路由不匹配，跳过此逻辑; 若路由匹配下面的call执行匹配到的逻辑处理函数 tips: 跟上一章最后的代码一样，每个逻辑处理函数调用next来让后面的函数执行，存储在stack中的函数就实现了链式调用。不一定所有的函数都在返回的时候才调用next，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。 核心代码： 12345678//取下一个逻辑逻辑处理函数1: var layer = stack[index++];//不匹配时跳过2: if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) &#123; return next(err); &#125;//匹配时执行3: call(layer.handle, route, err, req, res, next); 返回: 无 总结: 画图总结 12345678910111213141516request come | vmiddleware1 : 不匹配路由，skip | vmiddleware2 : 匹配路由，执行 | vmiddleware3 : 匹配路由，执行 | vmiddleware4 : 不匹配路由，skip | v end ##call(handle, route, err, req, res, next) 这里有个比较有趣的知识，console.log(Function.length)会返回函数定义的参数个数。值跟在函数体内执行arguments.length一样。 Connect中规定function(err, req, res, next) {}形式为错误处理函数，function(req, res, next) {}为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。 输入: 参数名 描述 handle 逻辑处理函数 route 路由 err 是否发生过错误 req Nodejs对象 res Nodejs对象 next next函数 处理过程: 是否有错误，本次handle是否是错误处理函数; 若有错误且handle为错误处理函数，则执行handle，本函数返回; 若没错误且handle不是错误处理函数，则执行handle，本函数返回; 如果上面两个都不满足，不执行handle，本函数调用next，返回; 返回: 无 总结: call函数是一个执行者，根据当前错误情况和handle类型决定是否执行当前的handle。 ##listen 创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口 代码 12var server = http.createServer(this);return server.listen.apply(server, arguments); ##图解Connect Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。 图形总结 1234567891011121314151617181920212223request app(out) | yes +------------------&gt;match?-----&gt;middleware1 | no | v | next&lt;----------+ | v yes match?------&gt;middleware2 | no | v | next&lt;----------+ | v yes match?------&gt;middleware3 | no | v | out&lt;-----------+ | +---------------------+ | v end(response在处理过程中已经返回了) ##Connect的subapp特性 我们再看看Connect是怎么实现subapp的，比较有趣。 什么是subapp? 1234567var sub_app = connect();var app = connect();app.use(&apos;/route1&apos;, sub_app);// request path: &apos;/route1/route2&apos;// 由app接收到请求后，切割 path为&apos;/route2&apos;转交给sub_app的处理逻辑处理// 再由sub_app返回到app，由app继续向下执行处理逻辑 结合上面的函数画图 123456789101112131415161718192021request app(out1) sub_app(out2) | +---------------&gt;middleware1 +------------&gt;middleware1 | | | next | next | | | v | v middleware2-----+ middleware2 | next&lt;--------+ next | | | v | v middleware3 | middleware3 | | | v | v out1 | out2 | | | +---------------------+ +-----------------+ | v end(response在处理过程中已经返回了) 完成上面的sub_app只需要做到两点： 从app的调用链进入到sub_app的调用链中; 从sub_app的逻辑回到app的调用链中; connect在handle函数中的第三个参数out为这个特性实现提供可能。out的特点是在middlewares链式调用完成以后调用。那么将app的next作为sub_app的out传入sub_app的handle中可以做到sub_app自己的业务逻辑处理完后调用out，即处理权回到了本app的next手里。 上面图中的sub_app.out2===app.next，所以能完成逻辑的交接和sub app调用。 Express大家都知道Express是Connect的升级版。 Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。 Express大概可以分为几个模块 模块 描述 router 路由模块是Connect升级版 request 经过Express封装的req对象 response 经过Express封装的res对象 application app上面的各种默认设置 简要介绍一下每个模块 ##Router 在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版 正则匹配route; 进行将http的方法在route中分解开; ##Request 在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是req.param。 ##Response 在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、res.render、res.redirect、res.sendFile等等。 我们可以拓展它写一个res.sendPersonInfoById。 关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑，我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。 ##Application 除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。 ##Express小结 Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、connect-redis等。 实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。 总结Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑；Koa用Generator方法解决回调问题； 我们应该也可以用事件、Promise的方式实现； PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"学习使用外部模块","slug":"node学习使用外部模块","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node学习使用外部模块/","link":"","permalink":"http://yoursite.com/2017/06/20/node学习使用外部模块/","excerpt":"","text":"《学习使用外部模块》目标建立一个 lesson2 项目，在其中编写代码。 当在浏览器中访问 http://localhost:3000/?q=alsotang 时，输出 alsotang 的 md5 值，即 bdd5e57b5c0040f9dc23d430846e68a3。 挑战访问 http://localhost:3000/?q=alsotang 时，输出 alsotang 的 sha1 值，即 e3c766d71667567e18f77869c65cd62f6a1b9ab9。 知识点 学习 req.query 的用法 学习建立 package.json 来管理 Node.js 项目。 课程内容卧槽，不写 package.json 就写项目我觉得好不爽啊，所以这个 lesson2 我就得跟大家介绍一下 package.json 这个文件的用法了。 简单说来呢，这个 package.json 文件就是定义了项目的各种元信息，包括项目的名称，git repo 的地址，作者等等。最重要的是，其中定义了我们项目的依赖，这样这个项目在部署时，我们就不必将 node_modules 目录也上传到服务器，服务器在拿到我们的项目时，只需要执行 npm install，则 npm 会自动读取 package.json 中的依赖并安装在项目的 node_modules 下面，然后程序就可以在服务器上跑起来了。 本课程的每个 lesson 里面的示例代码都会带上一份 package.json，大家可以去看看它的大概样子。 我们来新建一个 lesson2 项目，并生成一份它的 package.json。 12$ mkdir lesson2 &amp;&amp; cd lesson2$ npm init OK，这时会要求我们输入一些信息，乱填就好了，反正这个地方也不用填依赖关系。 npm init 这个命令的作用就是帮我们互动式地生成一份最简单的 package.json 文件，init 是 initialize 的意思，初始化。 当乱填信息完毕之后，我们的目录下就会有个 package.json 文件了。 这时我们来安装依赖，这次的应用，我们依赖 express 和 utility 两个模块。 $ npm install express utility --save 这次的安装命令与上节课的命令有两点不同，一是没有指定 registry，没有指定的情况下，默认从 npm 官方安装，上次我们是从淘宝的源安装的。二是多了个 --save 参数，这个参数的作用，就是会在你安装依赖的同时，自动把这些依赖写入 package.json。命令执行完成之后，查看 package.json，会发现多了一个 dependencies 字段，如下图： 这时查看 node_modules 目录，会发现有两个文件夹，分别是 express 和 utility 我们开始写应用层的代码，建立一个 app.js 文件，复制以下代码进去： 1234567891011121314151617181920212223242526// 引入依赖var express = require('express');var utility = require('utility');// 建立 express 实例var app = express();app.get('/', function (req, res) &#123; // 从 req.query 中取出我们的 q 参数。 // 如果是 post 传来的 body 数据，则是在 req.body 里面，不过 express 默认不处理 body 中的信息，需要引入 https://github.com/expressjs/body-parser 这个中间件才会处理，这个后面会讲到。 // 如果分不清什么是 query，什么是 body 的话，那就需要补一下 http 的知识了 var q = req.query.q; // 调用 utility.md5 方法，得到 md5 之后的值 // 之所以使用 utility 这个库来生成 md5 值，其实只是习惯问题。每个人都有自己习惯的技术堆栈， // 我刚入职阿里的时候跟着苏千和朴灵混，所以也混到了不少他们的技术堆栈，仅此而已。 // utility 的 github 地址：https://github.com/node-modules/utility // 里面定义了很多常用且比较杂的辅助方法，可以去看看 var md5Value = utility.md5(q); res.send(md5Value);&#125;);app.listen(3000, function (req, res) &#123; console.log('app is running at port 3000');&#125;); OK，运行我们的程序 $ node app.js 访问 http://localhost:3000/?q=alsotang，完成。 题外话如果直接访问 http://localhost:3000/ 会抛错 可以看到，这个错误是从 crypto.js 中抛出的。 这是因为，当我们不传入 q 参数时，req.query.q 取到的值是 undefined，utility.md5 直接使用了这个空值，导致下层的 crypto 抛错。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"2.一个最简单的 express 应用","slug":"一个最简单的 express 应用","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/一个最简单的 express 应用/","link":"","permalink":"http://yoursite.com/2017/06/20/一个最简单的 express 应用/","excerpt":"","text":"《一个最简单的 express 应用》目标建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 http://localhost:3000/ 时，输出 Hello World。 挑战访问 http://localhost:3000/ 时，输出 你好，世界。 知识点 包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。 框架 express 。学习新建 express 实例，并定义 routes ，产生输出。 课程内容按照惯例，我们来个 helloworld 入门。 包管理器 npmnpm 可以自动管理包的依赖. 只需要安装你想要的包, 不必考虑这个包的依赖包. 在 PHP 中, 包管理使用的 Composer, python 中，包管理使用 easy_install 或者 pip，ruby 中我们使用 gem。而在 Node.js 中，对应就是 npm，npm 是 Node.js Package Manager 的意思。 框架 Expressexpress 是 Node.js 应用最广泛的 web 框架，现在是 4.x 版本，它非常薄。跟 Rails 比起来，完全两个极端。 express 的官网是 http://expressjs.com/ ，我常常上去看它的 API。 首先我们需要得到一个 express。 不同于 ruby 的 gem 装在全局，Node.js 的依赖是以项目为单位管理的，直接就安装在项目的 node_modules 目录下，而且每个依赖都可以有指定版本的其他依赖，这些依赖像一棵树一样。根据我自己的使用经验来说，npm 的体验在 pip 和 gem 之上。 OK，新建一个文件夹叫 lesson1 的，进去里面安装 express 123$ mkdir lesson1 &amp;&amp; cd lesson1# 这里没有从官方 npm 安装，而是使用了大淘宝的 npm 镜像$ npm install express --registry=https://registry.npm.taobao.org 安装完成后，我们的 lesson1 目录下应该会出现一个 node_modules 文件夹，ls 看看 1$ ls node_modules 里面如果出现 express 文件夹则说明安装成功。 或者 npm命令提供更清晰直观的显示:1$ npm list 我们继续应用程序的编写。 新建一个 app.js 文件 1$ touch app.js copy 进去这些代码 1234567891011121314151617// 这句的意思就是引入 `express` 模块，并将它赋予 `express` 这个变量等待使用。var express = require('express');// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。var app = express();// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。app.get('/', function (req, res) &#123; res.send('Hello World');&#125;);// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。app.listen(3000, function () &#123; console.log('app is listening at port 3000');&#125;); 执行 $ node app.js 这时候我们的 app 就跑起来了，终端中会输出 app is listening at port 3000。这时我们打开浏览器，访问 http://localhost:3000/，会出现 Hello World。如果没有出现的话，肯定是上述哪一步弄错了，自己调试一下。 补充知识在这个例子中，node代码监听了3000端口，用户通过访问http://localhost:3000/ 得到了内容，为什么呢？ 端口端口的作用：通过端口来区分出同一电脑内不同应用或者进程，从而实现一条物理网线(通过分组交换技术-比如internet)同时链接多个程序Port_(computer_networking)) 端口号是一个 16位的 uint, 所以其范围为 1 to 65535 (对TCP来说, port 0 被保留，不能被使用. 对于UDP来说, source端的端口号是可选的， 为0时表示无端口). app.listen(3000)，进程就被打标，电脑接收到的3000端口的网络消息就会被发送给我们启动的这个进程 URLRFC1738 定义的url格式笼统版本&lt;scheme&gt;:&lt;scheme-specific-part&gt;，scheme有我们很熟悉的http、https、ftp，以及著名的ed2k，thunder。 通常我们熟悉的url定义成这个样子1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 用过ftp的估计能体会这么长的，网页上很少带auth信息，所以就精简成这样:1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 在上面的例子中, scheme=http, host=localhost, port=3000, url-path=/, 再联想对照一下浏览器端window.location对象。著名的localhost，你可以在电脑的hosts文件上找到 在这篇文章中提到： URI schemes are frequently and incorrectly referred to as &quot;protocols&quot;, or specifically as URI protocols or URL protocols, since most were originally designed to be used with a particular protocol, and often have the same name，比较认同这个观点，尤其是今天移动设备的时代里， android和ios的开发中大量使用uri作为跨app通讯通道，把scheme理解为协议略狭隘了。 尾声在了解完端口和url之后，再去看例子代码，相信应该好理解很多。有必要的话，还可以在解刨一下express的use逻辑，对峙http.createServer，相信还有火花，:)","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"3.使用 superagent 与 cheerio 完成简单爬虫","slug":"node使用 superagent 与 cheerio 完成简单爬虫","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node使用 superagent 与 cheerio 完成简单爬虫/","link":"","permalink":"http://yoursite.com/2017/06/20/node使用 superagent 与 cheerio 完成简单爬虫/","excerpt":"","text":"《使用 superagent 与 cheerio 完成简单爬虫》目标建立一个 lesson3 项目，在其中编写代码。 当在浏览器中访问 http://localhost:3000/ 时，输出 CNode(https://cnodejs.org/ ) 社区首页的所有帖子标题和链接，以 json 的形式。 输出示例： 12345678910[ &#123; \"title\": \"【公告】发招聘帖的同学留意一下这里\", \"href\": \"http://cnodejs.org/topic/541ed2d05e28155f24676a12\" &#125;, &#123; \"title\": \"发布一款 Sublime Text 下的 JavaScript 语法高亮插件\", \"href\": \"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f\" &#125;] 挑战访问 http://localhost:3000/ 时，输出包括主题的作者， 示例： 123456789101112[ &#123; \"title\": \"【公告】发招聘帖的同学留意一下这里\", \"href\": \"http://cnodejs.org/topic/541ed2d05e28155f24676a12\", \"author\": \"alsotang\" &#125;, &#123; \"title\": \"发布一款 Sublime Text 下的 JavaScript 语法高亮插件\", \"href\": \"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f\", \"author\": \"otheruser\" &#125;] 知识点 学习使用 superagent 抓取网页 学习使用 cheerio 分析网页 课程内容Node.js 总是吹牛逼说自己异步特性多么多么厉害，但是对于初学者来说，要找一个能好好利用异步的场景不容易。我想来想去，爬虫的场景就比较适合，没事就异步并发地爬几个网站玩玩。 本来想教大家怎么爬 github 的 api 的，但是 github 有 rate limit 的限制，所以只好牺牲一下 CNode 社区（国内最专业的 Node.js 开源技术社区），教大家怎么去爬它了。 我们这回需要用到三个依赖，分别是 express，superagent 和 cheerio。 先介绍一下， superagent(http://visionmedia.github.io/superagent/ ) 是个 http 方面的库，可以发起 get 或 post 请求。 cheerio(https://github.com/cheeriojs/cheerio ) 大家可以理解成一个 Node.js 版的 jquery，用来从网页中以 css selector 取数据，使用方式跟 jquery 一样一样的。 还记得我们怎么新建一个项目吗？ 新建一个文件夹，进去之后 npm init 安装依赖 npm install --save PACKAGE_NAME 写应用逻辑 我们应用的核心逻辑长这样 123456789101112131415161718192021222324app.get('/', function (req, res, next) &#123; // 用 superagent 去抓取 https://cnodejs.org/ 的内容 superagent.get('https://cnodejs.org/') .end(function (err, sres) &#123; // 常规的错误处理 if (err) &#123; return next(err); &#125; // sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load 之后 // 就可以得到一个实现了 jquery 接口的变量，我们习惯性地将它命名为 `$` // 剩下就都是 jquery 的内容了 var $ = cheerio.load(sres.text); var items = []; $('#topic_list .topic_title').each(function (idx, element) &#123; var $element = $(element); items.push(&#123; title: $element.attr('title'), href: $element.attr('href') &#125;); &#125;); res.send(items); &#125;);&#125;); OK，一个简单的爬虫就是这么简单。这里我们还没有利用到 Node.js 的异步并发特性。不过下两章内容都是关于异步控制的。 记得好好看看 superagent 的 API，它把链式调用的风格玩到了极致。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"5.使用 async 控制并发","slug":"node使用 eventproxy 控制并发","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node使用 eventproxy 控制并发/","link":"","permalink":"http://yoursite.com/2017/06/20/node使用 eventproxy 控制并发/","excerpt":"","text":"《使用 async 控制并发》目标建立一个 lesson5 项目，在其中编写代码。 代码的入口是 app.js，当调用 node app.js 时，它会输出 CNode(https://cnodejs.org/ ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。 注意：与上节课不同，并发连接数需要控制在 5 个。 输出示例： 123456789101112[ &#123; \"title\": \"【公告】发招聘帖的同学留意一下这里\", \"href\": \"http://cnodejs.org/topic/541ed2d05e28155f24676a12\", \"comment1\": \"呵呵呵呵\" &#125;, &#123; \"title\": \"发布一款 Sublime Text 下的 JavaScript 语法高亮插件\", \"href\": \"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f\", \"comment1\": \"沙发！\" &#125;] 知识点 学习 async(https://github.com/caolan/async ) 的使用。这里有个详细的 async demo 演示：https://github.com/alsotang/async_demo 学习使用 async 来控制并发连接数。 课程内容lesson4 的代码其实是不完美的。为什么这么说，是因为在 lesson4 中，我们一次性发了 40 个并发请求出去，要知道，除去 CNode 的话，别的网站有可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的 IP 封掉。 我们在写爬虫的时候，如果有 1000 个链接要去爬，那么不可能同时发出 1000 个并发链接出去对不对？我们需要控制一下并发的数量，比如并发 10 个就好，然后慢慢抓完这 1000 个链接。 用 async 来做这件事很简单。 这次我们要介绍的是 async 的 mapLimit(arr, limit, iterator, callback) 接口。另外，还有个常用的控制并发连接数的接口是 queue(worker, concurrency)，大家可以去 https://github.com/caolan/async#queueworker-concurrency 看看说明。 这回我就不带大家爬网站了，我们来专注知识点：并发连接数控制。 对了，还有个问题是，什么时候用 eventproxy，什么时候使用 async 呢？它们不都是用来做异步流程控制的吗？ 我的答案是： 当你需要去多个源(一般是小于 10 个)汇总数据的时候，用 eventproxy 方便；当你需要用到队列，需要控制并发数，或者你喜欢函数式编程思维时，使用 async。大部分场景是前者，所以我个人大部分时间是用 eventproxy 的。 正题开始。 首先，我们伪造一个 fetchUrl(url, callback) 函数，这个函数的作用就是，当你通过 123fetchUrl('http://www.baidu.com', function (err, content) &#123; // do something with `content`&#125;); 调用它时，它会返回 http://www.baidu.com 的页面内容回来。 当然，我们这里的返回内容是假的，返回延时是随机的。并且在它被调用时，会告诉你它现在一共被多少个地方并发调用着。 123456789101112// 并发连接数的计数器var concurrencyCount = 0;var fetchUrl = function (url, callback) &#123; // delay 的值在 2000 以内，是个随机的整数 var delay = parseInt((Math.random() * 10000000) % 2000, 10); concurrencyCount++; console.log('现在的并发数是', concurrencyCount, '，正在抓取的是', url, '，耗时' + delay + '毫秒'); setTimeout(function () &#123; concurrencyCount--; callback(null, url + ' html content'); &#125;, delay);&#125;; 我们接着来伪造一组链接 1234var urls = [];for(var i = 0; i &lt; 30; i++) &#123; urls.push('http://datasource_' + i);&#125; 这组链接的长这样： 接着，我们使用 async.mapLimit 来并发抓取，并获取结果。 123456async.mapLimit(urls, 5, function (url, callback) &#123; fetchUrl(url, callback);&#125;, function (err, result) &#123; console.log('final:'); console.log(result);&#125;); 运行输出是这样的： 可以看到，一开始，并发链接数是从 1 开始增长的，增长到 5 时，就不再增加。当其中有任务完成时，再继续抓取。并发连接数始终控制在 5 个。 完整代码请参见 app.js 文件。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"1.搭建 Node.js 开发环境","slug":"搭建 Node.js 开发环境","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/搭建 Node.js 开发环境/","link":"","permalink":"http://yoursite.com/2017/06/20/搭建 Node.js 开发环境/","excerpt":"","text":"《搭建 Node.js 开发环境》本课程假设大家都是在 Linux 或者 Mac 下面。至于使用 Windows 并坚持玩新技术的同学，我坚信他们一定有着过人的、甚至是不可告人的兼容性 bug 处理能力，所以这部分同学麻烦在课程无法继续时，自行兼容一下。 不久前公司刚发一台新 Mac 给我，所以我对于在新环境中安装 Node.js 的过程还是记忆犹新的。 其实这过程特别简单: 先安装一个 nvm（ https://github.com/creationix/nvm ）1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。 安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试 1$ nvm 当看到有输出时，则 nvm 安装成功。 安装 Node.js使用 nvm 的命令安装 Node.js 最新稳定版，现在是 v0.12.3。 1$ nvm install 0.12 安装完成后，查看一下 1$ nvm ls 这时候可以看到自己安装的所有 Node.js 版本，输出应如下： （图1） 那个绿色小箭头的意思就是现在正在使用的版本，我这里是 v0.10.29。我还安装了 v0.11.14，但它并非我当前使用的版本。 如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 0.12.x 版本 1$ nvm use 0.12 然后再次查看，这时候小箭头应该出现了。 OK，我们在终端中输入 1$ node REPL(read–eval–print loop) 应该就出来了，那我们就成功了。 随便敲两行命令玩玩吧。 比如 &gt; while (true) {}，这时你的 CPU 应该会飚高。 完善安装上述过程完成后，有时会出现，当开启一个新的 shell 窗口时，找不到 node 命令的情况。 这种情况一般来自两个原因 一、shell 不知道 nvm 的存在 二、nvm 已经存在，但是没有 default 的 Node.js 版本可用。 解决方式： 一、检查 ~/.profile 或者 ~/.bash_profile 中有没有这样两句 12export NVM_DIR=&quot;/Users/YOURUSERNAME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 没有的话，加进去。 这两句会在 bash 启动的时候被调用，然后注册 nvm 命令。 二、 调用 $ nvm ls 看看像不像上述图1中一样，有 default 的指向。 如果没有的话，执行 $ nvm alias default 0.12 再 $ nvm ls 看一下","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"7.浏览器端测试：mocha，chai，phantomjs","slug":"node浏览器端测试：mocha，chai，phantomjs","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node浏览器端测试：mocha，chai，phantomjs/","link":"","permalink":"http://yoursite.com/2017/06/20/node浏览器端测试：mocha，chai，phantomjs/","excerpt":"","text":"《浏览器端测试：mocha，chai，phantomjs》目标建立一个 lesson7 项目，在其中编写代码，我们暂时命名为 vendor根据下面的步骤，最终的项目结构应该长这样 这次我们测试的对象是上文提到的 fibonacci 函数 此函数的定义为 int fibonacci(int n) 当 n === 0 时，返回 0；n === 1时，返回 1; n &gt; 1 时，返回 fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)，如 fibonacci(10) === 55; 知识点 学习使用测试框架 mocha 进行前端测试 : http://mochajs.org/ 了解全栈的断言库 chai: http://chaijs.com/ 了解 headless 浏览器 phantomjs: http://phantomjs.org/ 前端脚本单元测试lesson6 的内容都是针对后端环境中 node 的一些单元测试方案，出于应用健壮性的考量，针对前端 js 脚本的单元测试也非常重要。而前后端通吃，也是 mocha 的一大特点。 首先，前端脚本的单元测试主要有两个困难需要解决。 运行环境应当在浏览器中，可以操纵浏览器的DOM对象，且可以随意定义执行时的 html 上下文。 测试结果应当可以直接反馈给 mocha，判断测试是否通过。 浏览器环境执行我们首先搭建一个测试原型，用 mocha 自带的脚手架可以自动生成。 123cd vendor # 进入我们的项目文件夹npm i -g mocha # 安装全局的 mocha 命令行工具mocha init . # 生成脚手架 mocha就会自动帮我们生成一个简单的测试原型, 目录结构如下12345.├── index.html # 这是前端单元测试的入口├── mocha.css├── mocha.js└── tests.js # 我们的单元测试代码将在这里编写 其中 index.html 是单元测试的入口，tests.js 是我们的测试用例文件。 我们直接在 index.html 插入上述示例的 fibonacci 函数以及断言库 chaijs。 12345678910111213&lt;div id=\"mocha\"&gt;&lt;/div&gt;&lt;script src='https://cdn.rawgit.com/chaijs/chai/master/chai.js'&gt;&lt;/script&gt;&lt;script&gt; var fibonacci = function (n) &#123; if (n === 0) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; return fibonacci(n-1) + fibonacci(n-2); &#125;;&lt;/script&gt; 然后在tests.js中写入对应测试用例 123456var should = chai.should();describe('simple test', function () &#123; it('should equal 0 when n === 0', function () &#123; window.fibonacci(0).should.equal(0); &#125;);&#125;); 这时打开index.html，可以发现测试结果，我们完成了浏览器端的脚本测试(注意我们调用了 window 对象) 测试反馈mocha没有提供一个命令行的前端脚本测试环境(因为我们的脚本文件需要运行在浏览器环境中)，因此我们使用phantomjs帮助我们搭建一个模拟环境。不重复制造轮子，这里直接使用mocha-phantomjs帮助我们在命令行运行测试。 首先安装mocha-phanatomjs 1npm i -g mocha-phantomjs 然后在 index.html 的页面下加上这段兼容代码 1&lt;script&gt;mocha.run()&lt;/script&gt; 改为 123456789&lt;script&gt; if (window.initMochaPhantomJS &amp;&amp; window.location.search.indexOf('skip') === -1) &#123; initMochaPhantomJS() &#125; mocha.ui('bdd'); expect = chai.expect; mocha.run();&lt;/script&gt; 这时候, 我们在命令行中运行 1mocha-phantomjs index.html --ssl-protocol=any --ignore-ssl-errors=true 结果展现是不是和后端代码测试很类似 :smile: 更进一步，我们可以直接在 package.json 的 scripts 中添加(package.json 通过 npm init 生成，这里不再赘述) 123\"scripts\": &#123; \"test\": \"mocha-phantomjs index.html --ssl-protocol=any --ignore-ssl-errors=true\"&#125;, 将mocha-phantomjs作为依赖 1npm i mocha-phantomjs --save-dev 直接运行 1npm test 运行结果如下: 至此,我们实现了前端脚本的单元测试，基于 phanatomjs 你几乎可以调用所有的浏览器方法，而 mocha-phanatomjs 也可以很便捷地将测试结果反馈到 mocha，便于后续的持续集成。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"12.线上部署：heroku","slug":"node线上部署：heroku","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node线上部署：heroku/","link":"","permalink":"http://yoursite.com/2017/06/20/node线上部署：heroku/","excerpt":"","text":"《线上部署：heroku》目标将 https://github.com/Ricardo-Li/node-practice-2 (这个项目已经被删了。参照 https://github.com/alsotang/node-lessons/tree/master/lesson3 的代码自己操作一下吧。)这个项目部署上 heroku，成为一个线上项目 我部署的在这里 http://serene-falls-9294.herokuapp.com/ 知识点 学习 heroku 的线上部署(https://www.heroku.com/ ) 课程内容什么是 herokuheroku 是弄 ruby 的 paas 起家，现在支持多种语言环境，更甚的是它强大的 add-on 服务。 paas 平台相信大家都不陌生。Google 有 gae，国内新浪有 sae。paas 平台相对 vps 来说，不需要你配置服务器，不需要装数据库，也不需要理会负载均衡。这一切都可以在平台上直接获取。 你只要专注自己的业务，把应用的逻辑写好，然后发布上去，应用自然就上线了。数据库方面，如果你用 mysql，那么你可以从平台商那里得到一个 mysql 的地址、账号和密码，直接连接就能用。如果应用的流量增大，需要横向拓展，则只用去到 paas 平台的管理页面，增大服务器实例的数量即可，负载均衡会自动帮你完成。 说起来，我之所以对于 web 开发产生兴趣也是因为当年 gae 的关系。那时候除了 gae 之外，没有别的 paas 平台，gae 是横空出世的。有款翻墙的软件，叫 gappproxy(https://code.google.com/p/gappproxy/ )——可以认为是 goagent 的前身——就是搭建在 gae 上面的，不仅快，而且免费。于是我就很想弄懂这样一个程序是如何开发的。好在 gappproxy 是开源的，于是我下了源码来看，那时候才大一，只学过 c，看到那些 python 代码就凌乱了。于是转头也去学 python，后来渐渐发现了 web 开发的乐趣，于是 ruby 和 node.js 也碰碰。后来 goagent 火起来了，我又去看了看它的代码，发现非常难看，就自己写了个 https://github.com/alsotang/keepagent 。不过现在回想起来，还是 goagent 的实现比较稳定以及效率高。 heroku 的免费额度还是足够的，对于 demo 应用来说，放上去是绰绰有余的。各位搞 web 开发的大学生朋友，一定要试着让你开发的项目尽可能早地去线上跑，这样你的项目可以被其他人看到，能够促使你更有热情地进行进一步开发。这回我们放的是 cnode 社区的爬虫上去，你其实可以试着为你们学院或者学校的新闻站点写个爬虫，提供 json api，然后去申请个微信公共平台，每天推送学院网站的新闻。这东西辅导员是有需求的，可以做个给他们用。 好了，我们先 clone https://github.com/Ricardo-Li/node-practice-2 这个项目。由于我们这回讲部署，所以代码就用现成的了，代码的内容就是 lesson 3（https://github.com/alsotang/node-lessons/tree/master/lesson3 ） 里面的那个爬虫。 clone 下来以后，我们去看看代码。代码中有两个特殊的地方， 一个是一个叫 Procfile 的文件，内容是： 1web: node app.js 一个是 app.js 里面， 1app.listen(process.env.PORT || 5000); 这两者都是为了部署 heroku 所做的。 大家有没有想过，当部署一个应用上 paas 平台以后，paas 要为我们干些什么？ 首先，平台要有我们语言的运行时； 然后，对于 node.js 来说，它要帮我们安装 package.json 里面的依赖； 然后呢？然后需要启动我们的项目； 然后把外界的流量导入我们的项目，让我们的项目提供服务。 上面那两处特殊的地方，一个是启动项目的，一个是导流量的。 heroku 虽然能推测出你的应用是 node.js 应用，但它不懂你的主程序是哪个，所以我们提供了 Procfile 来指导它启动我们的程序。 而我们的程序，本来是监听 5000 端口的，但是 heroku 并不知道。当然，你也可以在 Procfile 中告诉 heroku，可如果大家都监听 5000 端口，这时候不就有冲突了吗？所以这个地方，heroku 使用了主动的策略，主动提供一个环境变量 process.env.PORT 来供我们监听。 这样的话，一个简单 app 的配置就完成了。 我们去 https://www.heroku.com/ 申请个账号，然后下载它的工具包 https://toolbelt.heroku.com/ ，然后再在命令行里面，通过 heroku login 来登录。 上述步骤完成后，我们进入 node-practice-2 的目录，执行 heroku create。这时候，heroku 会为我们随机取一个应用名字，并提供一个 git 仓库给我们。 接着，往 heroku 这个远端地址推送我们的 master 分支： heroku 会自动检测出我们是 node.js 程序，并安装依赖，然后按照 Procfile 进行启动。 push 完成后，在命令键入 heroku open，则 heroku 会自动打开浏览器带我们去到相应的网址： 到此课程也就结束了。 随便聊聊 heroku 的 addon 吧。这个 addon 确实是个神奇的东西，反正在 heroku 之外我还没怎么见到这类概念。这些 addon 提供商，有些提供 redis 的服务，有些提供 mongodb，有些提供 mysql。你可以直接在 heroku 上面进行购买，然后 heroku 就会提供一段相应服务的地址和账号密码给你用来连接。 大家可以去 https://addons.heroku.com/ 这个页面看看，玲琅满目各种应用可以方便接入。之所以这类服务有市场，也是因为亚马逊的 aws 非常牛逼。为什么这么说呢，因为网络速度啊。如果现在在国内，你在 ucloud 买个主机，然后用个阿里云的 rds，那么应用的响应速度会因为 mysql 连接的问题卡得动不了。但在 heroku 这里，提供商们，包括 heroku 自己，都是构建在 aws 上面，这样一来，各种服务的互通其实走的是内网，速度很可以接受，于是各种 addon 提供商就做起来了。 国内的话，其实在阿里云上面也可以考虑这么搞一搞。 完。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"13.持续集成平台：travis","slug":"node持续集成平台：travis","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node持续集成平台：travis/","link":"","permalink":"http://yoursite.com/2017/06/20/node持续集成平台：travis/","excerpt":"","text":"《持续集成平台：travis》目标无明确目标 知识点 学习使用 travis-ci 对项目进行持续集成测试 (https://travis-ci.org/ ) 课程内容首先来看看这个项目：https://github.com/Ricardo-Li/node-practice-3 （图1） 类似这样的 badges，在很多项目中都可以看到。前者是告诉我们，这个项目的测试目前是通过的；后者是告诉我们，这个测试的行覆盖率是多少。行覆盖率当然是越多越好。测试的重要性我就不说了。 为什么要使用 travis 这样的平台，是因为它可以让你明白自己的项目在一个“空白环境”中，是否能正确运行；也可以让你知道，用不同的 Node.js 版本运行的话，有没有兼容性问题。 当你在自己的机器上跑测试的时候，你用着特定的 Node.js 版本，比如 0.10，如果测试过了，你也还是不懂在 0.11 下，你的测试能不能通过。你可以手动地切换 node 版本再跑一次，也可以选择让 travis 帮你把不同的 node 版本跑一次。而且有时候，我们 npm 安装了某个包，但却忘记将它写入 package.json 里面了，在自己的机器上，测试没问题，但当别的用户安装你的包时，会发现有依赖缺失。 travis 应该是把虚拟机的技术玩得比较好，它每次跑测试时，都会提供一个空白的环境。这个环境只有 Linux 基本的 build-essential 和 wget、git 那些依赖。连 Node.js 的运行时都是现跑现安装的。 travis 默认带有的那些依赖，都是每个用户的机器上都会有的，所以一旦你的应用在 travis 上面能够跑通，那么就不用担心别的用户安装不上了。 我们来讲讲接入 travis 的步骤。 travis 的价格是免费的，对于 github 上的开源项目来说。它默认当然不可能帮 github 的每个用户都跑测试，所以你需要去注册一下 travis，然后告诉它你需要开启集成测试的仓库。 比如上图，可以看到我帮自己的 alsohosts 项目以及 adsf 项目开启了测试。 当你在 travis 授权了仓库之后，每当你 push 代码到 github，travis 都会自动帮你跑测试。 travis 通过授权，可以知道你的项目在什么地方，于是它就可以把项目 clone 过去。但问题又来了，它不懂你的测试怎么跑啊。用 npm test 还是 make test 还是 jake test 呢？ 所以我们需要给出一些配置信息，配置信息以 .travis.yml 文件的形式放在项目根目录，比如一个简单的 .travis.yml。 1234567language: node_jsnode_js: - '0.8' - '0.10' - '0.11'script: make test 这个文件传递的信息是： 这是一个 node.js 应用 这个测试需要用 0.8、0.10 以及 0.11 三个版本来跑 跑测试的命令是 make test 将这个文件添加到项目的根目录下，再 push 上 github，这时候 travis 就会被触发了。 travis 接着会做的事情是： 安装一个 node.js 运行时。由于我们指定了三个不同版本，于是 travis 会使用三个机器，分别安装三个版本的 node.js 这些机器在完成运行时安装后，会进入项目目录执行 npm install 来安装依赖。 当依赖安装完成后，执行我们指定的 script，在这里也就是 make test 如果测试通过的话，make 命令的返回码会是 0（如果不懂什么是返回码，则需要补补 shell 的知识），则测试通过；如果测试有不通过的 case，则返回码不会为 0，travis 则判断测试失败。 每一个 travis 上面的项目，都可以得到一个图片地址，这个地址上的图片会显示你项目当前的测试通过状态，把这个图片添加到自己项目的 README 中，就可以得到我们图1的那种逼格了。 对了，行覆盖率的那个 badge 是由一个叫 coveralls(https://coveralls.io/ ) 的服务提供的。大家可以试着自己接入。 补充说明:如果你的应用有使用到数据库, 需要在 .travis.yml 中添加一些内容. 以 MongoDB 为例: 12services: mongodb 其它数据库详细内容参考travis 官方文档","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"11.作用域与闭包：this，var，(function () {})","slug":"node作用域与闭包：this，var，(function () {})","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node作用域与闭包：this，var，(function () {})/","link":"","permalink":"http://yoursite.com/2017/06/20/node作用域与闭包：this，var，(function () {})/","excerpt":"","text":"《作用域与闭包：this，var，(function () {})》目标无具体目标 知识点 理解 js 中 var 的作用域 了解闭包的概念 理解 this 的指向 课程内容es6中新增了 let 关键词，与块级作用域，相关知识参考： http://es6.ruanyifeng.com/#docs/let var 作用域先来看个简单的例子： 1234567891011121314151617181920var parent = function () &#123; var name = \"parent_name\"; var age = 13; var child = function () &#123; var name = \"child_name\"; var childAge = 0.3; // =&gt; child_name 13 0.3 console.log(name, age, childAge); &#125;; child(); // will throw Error // ReferenceError: childAge is not defined console.log(name, age, childAge);&#125;;parent(); 直觉地，内部函数可以访问外部函数的变量，外部不能访问内部函数的变量。上面的例子中内部函数 child 可以访问变量 age，而外部函数 parent 不可以访问 child 中的变量 childAge，因此会抛出没有定义变量的异常。 有个重要的事，如果忘记var，那么变量就被声明为全局变量了。 123456function foo() &#123; value = \"hello\";&#125;foo();console.log(value); // 输出helloconsole.log(global.value) // 输出hello 这个例子可以很正常的输出 hello，是因为 value 变量在定义时，没有使用 var 关键词，所以被定义成了全局变量。在 Node 中，全局变量会被定义在 global 对象下；在浏览器中，全局变量会被定义在 window 对象下。 如果你确实要定义一个全局变量的话，请显示地定义在 global 或者 window 对象上。 这类不小心定义全局变量的问题可以被 jshint 检测出来，如果你使用 sublime 编辑器的话，记得装一个 SublimeLinter 插件，这是插件支持多语言的语法错误检测，js 的检测是原生支持的。 JavaScript 中，变量的局部作用域是函数级别的。不同于 C 语言，在 C 语言中，作用域是块级别的。JavaScript 中没有块级作用域。 js 中，函数中声明的变量在整个函数中都有定义。比如如下代码段，变量 i 和 value 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i 和 value。 12345678function foo() &#123; for (var i = 0; i &lt; 10; i++) &#123; var value = \"hello world\"; &#125; console.log(i); //输出10 console.log(value);//输出hello world&#125;foo(); 所以有种说法是：应该提前声明函数中需要用到的变量，即，在函数体的顶部声明可能用到的变量，这样就可以避免出现一些奇奇怪怪怪的 bug。 但我个人不喜欢遵守这一点，一般都是现用现声明的。这类错误的检测交给 jshint 来做就好了。 闭包闭包这个概念，在函数式编程里很常见，简单的说，就是使内部函数可以访问定义在外部函数中的变量。 假如我们要实现一系列的函数：add10，add20，它们的定义是 int add10(int n)。 为此我们构造了一个名为 adder 的构造器，如下： 123456789101112var adder = function (x) &#123; var base = x; return function (n) &#123; return n + base; &#125;;&#125;;var add10 = adder(10);console.log(add10(5));var add20 = adder(20);console.log(add20(5)); 每次调用 adder 时，adder 都会返回一个函数给我们。我们传给 adder 的值，会保存在一个名为 base 的变量中。由于返回的函数在其中引用了 base 的值，于是 base 的引用计数被 +1。当返回函数不被垃圾回收时，则 base 也会一直存在。 我暂时想不出什么实用的例子来，如果想深入理解这块，可以看看这篇 http://coolshell.cn/articles/6731.html 闭包的一个坑12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;, 5);&#125; 上面这个代码块会打印五个 5 出来，而我们预想的结果是打印 0 1 2 3 4。 之所以会这样，是因为 setTimeout 中的 i 是对外层 i 的引用。当 setTimeout 的代码被解释的时候，运行时只是记录了 i 的引用，而不是值。而当 setTimeout 被触发时，五个 setTimeout 中的 i 同时被取值，由于它们都指向了外层的同一个 i，而那个 i 的值在迭代完成时为 5，所以打印了五次 5。 为了得到我们预想的结果，我们可以把 i 赋值成一个局部的变量，从而摆脱外层迭代的影响。 1234567for (var i = 0; i &lt; 5; i++) &#123; (function (idx) &#123; setTimeout(function () &#123; console.log(idx); &#125;, 5); &#125;)(i);&#125; this在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。 在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是： 有对象就指向调用对象 没调用对象就指向全局对象 用new构造就指向新对象 通过 apply 或 call 或 bind 来改变 this 的所指。 1）函数有所属对象时：指向所属对象 函数有所属对象时，通常通过 . 表达式调用，这时 this 自然指向所属对象。比如下面的例子： 123456789101112var myObject = &#123;value: 100&#125;;myObject.getValue = function () &#123; console.log(this.value); // 输出 100 // 输出 &#123; value: 100, getValue: [Function] &#125;， // 其实就是 myObject 对象本身 console.log(this); return this.value;&#125;;console.log(myObject.getValue()); // =&gt; 100 getValue() 属于对象 myObject，并由 myOjbect 进行 . 调用，因此 this 指向对象 myObject。 2) 函数没有所属对象：指向全局对象 12345678910111213var myObject = &#123;value: 100&#125;;myObject.getValue = function () &#123; var foo = function () &#123; console.log(this.value) // =&gt; undefined console.log(this);// 输出全局对象 global &#125;; foo(); return this.value;&#125;;console.log(myObject.getValue()); // =&gt; 100 在上述代码块中，foo 函数虽然定义在 getValue 的函数体内，但实际上它既不属于 getValue 也不属于 myObject。foo 并没有被绑定在任何对象上，所以当调用时，它的 this 指针指向了全局对象 global。 据说这是个设计错误。 3）构造器中的 this：指向新对象 js 中，我们通过 new 关键词来调用构造函数，此时 this 会绑定在该新对象上。 12345678var SomeClass = function()&#123; this.value = 100;&#125;var myCreate = new SomeClass();console.log(myCreate.value); // 输出100 顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。 4) apply 和 call 调用以及 bind 绑定：指向绑定的对象 apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。 call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。 简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。 123456789101112var myObject = &#123;value: 100&#125;;var foo = function()&#123; console.log(this);&#125;;foo(); // 全局变量 globalfoo.apply(myObject); // &#123; value: 100 &#125;foo.call(myObject); // &#123; value: 100 &#125;var newFoo = foo.bind(myObject);newFoo(); // &#123; value: 100 &#125; 完。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"9.正则表达式","slug":"node正则表达式","date":"2017-06-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/20/node正则表达式/","link":"","permalink":"http://yoursite.com/2017/06/20/node正则表达式/","excerpt":"","text":"《正则表达式》目标1var web_development = \"python php ruby javascript jsonp perhapsphpisoutdated\"; 找出其中 包含 p 但不包含 ph 的所有单词，即 [ &#39;python&#39;, &#39;javascript&#39;, &#39;jsonp&#39; ] 知识点 正则表达式的使用 js 中的正则表达式与 pcre(http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions ) 的区别 课程内容开始这门课之前，大家先去看两篇文章。 《正则表达式30分钟入门教程》：http://deerchao.net/tutorials/regex/regex.htm 上面这篇介绍了正则表达式的基础知识，但是对于零宽断言没有展开来讲，零宽断言看下面这篇： 《正则表达式之：零宽断言不『消费』》：http://fxck.it/post/50558232873 好了。 在很久很久以前，有一门语言一度是字符串处理领域的王者，叫 perl。 伴随着 perl，有一个类似正则表达式的标准被实现了出来，叫 pcre：Perl Compatible Regular Expressions。 不遗憾的是，js 里面的正则与 pcre 不是兼容的。很多语言都这样。 如果需要测试你自己写的正则表达式，建议上这里：http://refiddle.com/ ，可以所见即所得地调试。 接下来我们主要讲讲 js 中需要注意的地方，至于正则表达式的内容，上面那两篇文章足够学习了。 第一， js 中，对于四种零宽断言，只支持 零宽度正预测先行断言 和 零宽度负预测先行断言 这两种。 第二， js 中，正则表达式后面可以跟三个 flag，比如 /something/igm。 他们的意义分别是， i 的意义是不区分大小写 g 的意义是，匹配多个 m 的意义是，是 ^ 和 $ 可以匹配每一行的开头。 分别举个例子： 12345678/a/.test('A') // =&gt; false/a/i.test('A') // =&gt; true'hello hell hoo'.match(/h.*?\\b/) // =&gt; [ 'hello', index: 0, input: 'hello hell hoo' ]'hello hell hoo'.match(/h.*?\\b/g) // =&gt; [ 'hello', 'hell', 'hoo' ]'aaa\\nbbb\\nccc'.match(/^[\\s\\S]*?$/g) // =&gt; [ 'aaa\\nbbb\\nccc' ]'aaa\\nbbb\\nccc'.match(/^[\\s\\S]*?$/gm) // =&gt; [ 'aaa', 'bbb', 'ccc' ] 与 m 意义相关的，还有 \\A, \\Z 和 \\z 他们的意义分别是： 123\\A 字符串开头(类似^，但不受处理多行选项的影响)\\Z 字符串结尾或行尾(不受处理多行选项的影响)\\z 字符串结尾(类似$，但不受处理多行选项的影响) 在 js 中，g flag 会影响 String.prototype.match() 和 RegExp.prototype.exec() 的行为 String.prototype.match() 中，返回数据的格式会不一样，加 g 会返回数组，不加 g 则返回比较详细的信息 12345678&gt; 'hello hell'.match(/h(.*?)\\b/g)[ 'hello', 'hell' ]&gt; 'hello hell'.match(/h(.*?)\\b/)[ 'hello', 'ello', index: 0, input: 'hello hell' ] RegExp.prototype.exec() 中，加 g 之后，如果你的正则不是字面量的正则，而是存储在变量中的话，特么的这个变量就会变得有记忆！！ 12345678910111213141516171819202122232425&gt; /h(.*?)\\b/g.exec('hello hell')[ 'hello', 'ello', index: 0, input: 'hello hell' ]&gt; /h(.*?)\\b/g.exec('hello hell')[ 'hello', 'ello', index: 0, input: 'hello hell' ]&gt; var re = /h(.*?)\\b/g;undefined&gt; re.exec('hello hell')[ 'hello', 'ello', index: 0, input: 'hello hell' ]&gt; re.exec('hello hell')[ 'hell', 'ell', index: 6, input: 'hello hell' ]&gt; 第三， 大家知道，. 是不可以匹配 \\n 的。如果我们想匹配的数据涉及到了跨行，比如下面这样的。 12345var multiline = require('multiline');var text = multiline.stripIndent(function () &#123;/* head code code2 .code31 foot */});1234567891011121314如果我们想把两个 \\`\\`\\` 中包含的内容取出来，应该怎么办？直接用 `.` 匹配不到 `\\n`，所以我们需要找到一个原子，能匹配包括 `\\n` 在内的所有字符。这个原子的惯用写法就是 `[\\s\\S]````jsvar match1 = text.match(/^```[\\s\\S]+?^```/gm);console.log(match1) // =&gt; [ &apos;```\\ncode code2 code3```\\n```&apos; ]// 这里有一种很骚的写法，[^] 与 [\\s\\S] 等价var match2 = text.match(/^```[^]+?^```/gm)console.log(match2) // =&gt; [ &apos;```\\ncode code2 .code3```\\n```&apos; ] 完。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"Git笔记","slug":"Git笔记","date":"2017-06-15T03:16:12.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/15/Git笔记/","link":"","permalink":"http://yoursite.com/2017/06/15/Git笔记/","excerpt":"","text":"安装 在 Windows 上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包： http://msysgit.github.io/完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 配置 首先是配置帐号信息 12345git config -e [--global] # 编辑Git配置文件git config --global user.name yanhaijinggit config --global user.email yanhaijing@yeah.netgit config --list #查看配置的信息git help config #获取帮助信息 配置自动换行（自动转换坑太大） 1git config --global core.autocrlf input #提交到git是自动将换行符转换为lf 配置密钥 1ssh-keygen -t rsa -C yanhaijing@yeah.net #生成密钥 1ssh -T git@github.com #测试是否成功 配置别名，git的命令没有自动完成功能，有点坑哈，别名派上了用场 1234git config --global alias.st status #git stgit config --global alias.co checkout #git cogit config --global alias.br branch #git brgit config --global alias.ci commit #git ci 新建仓库 123456git init #初始化git status #获取状态git add [file1] [file2] ... #.或*代表全部添加git commit -m &quot;message&quot; #此处注意乱码git remote add origin git@github.com:yanhaijing/test.git #添加源git push -u origin master #push同事设置默认跟踪分支 从现有仓库克隆 12git clone git://github.com/yanhaijing/data.js.git git clone git://github.com/schacon/grit.git mypro#克隆到自定义文件夹 本地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546git add * # 跟踪新文件git add -u [path] # 添加[指定路径下]已跟踪文件rm *&amp;git rm * # 移除文件git rm -f * # 移除文件git rm --cached * # 停止追踪指定文件，但该文件会保留在工作区git mv file_from file_to # 重命名跟踪文件git log # 查看提交记录git commit # 提交更新 git commit [file1] [file2] ... # 提交指定文件 git commit -m &apos;message&apos;git commit -a # 跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交git commit --amend#修改最后一次提交git commit -v # 提交时显示所有diff信息git reset HEAD *#取消已经暂存的文件git reset --mixed HEAD *#同上git reset --soft HEAD *#重置到指定状态，不会修改索引区和工作树git reset --hard HEAD *#重置到指定状态，会修改索引区和工作树git reset -- files#重置index区文件git revert HEAD #撤销前一次操作git revert HEAD~ #撤销前前一次操作git revert commit ## 撤销指定操作git checkout -- file#取消对文件的修改（从暂存区——覆盖worktree file）git checkout branch|tag|commit -- file_name#从仓库取出file覆盖当前分支git checkout -- .#从暂存区取出文件覆盖工作区git diff file #查看指定文件的差异git diff --stat #查看简单的diff结果git diff #比较Worktree和Index之间的差异git diff --cached #比较Index和HEAD之间的差异git diff HEAD #比较Worktree和HEAD之间的差异git diff branch #比较Worktree和branch之间的差异git diff branch1 branch2 #比较两次分支之间的差异git diff commit commit #比较两次提交之间的差异git log #查看最近的提交日志git log --pretty=oneline #单行显示提交日志git log --graph # 图形化显示git log --abbrev-commit # 显示log id的缩写git log -num #显示第几条log（倒数）git log --stat # 显示commit历史，以及每次commit发生变更的文件git log --follow [file] # 显示某个文件的版本历史，包括文件改名git log -p [file] # 显示指定文件相关的每一次diffgit stash #将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。git stash list #查看保存的工作现场git stash apply #恢复工作现场git stash drop #删除stash内容git stash pop #恢复的同时直接删除stash内容git stash apply stash@&#123;0&#125; #恢复指定的工作现场，当你保存了不只一份工作现场时。 分支 1234567891011121314151617181920212223242526git branch#列出本地分支git branch -r#列出远端分支git branch -a#列出所有分支git branch -v#查看各个分支最后一个提交对象的信息git branch --merge#查看已经合并到当前分支的分支git branch --no-merge#查看为合并到当前分支的分支git branch test#新建test分支git branch branch [branch|commit|tag] # 从指定位置出新建分支git branch --track branch remote-branch # 新建一个分支，与指定的远程分支建立追踪关系git branch -m old new #重命名分支git branch -d test#删除test分支git branch -D test#强制删除test分支git branch --set-upstream dev origin/dev #将本地dev分支与远程dev分支之间建立链接git checkout test#切换到test分支git checkout -b test#新建+切换到test分支git checkout -b test dev#基于dev新建test分支，并切换git merge test#将test分支合并到当前分支git merge --squash test ## 合并压缩，将test上的commit压缩为一条git cherry-pick commit #拣选合并，将commit合并到当前分支git cherry-pick -n commit #拣选多个提交，合并完后可以继续拣选下一个提交git rebase master#将master分之上超前的提交，变基到当前分支git rebase --onto master 169a6 #限制回滚范围，rebase当前分支从169a6以后的提交git rebase --interactive #交互模式 git rebase --continue# 处理完冲突继续合并 git rebase --skip# 跳过 git rebase --abort# 取消合并 远端 1234567git fetch origin remotebranch[:localbranch]# 从远端拉去分支[到本地指定分支]git push origin branch#将当前分支，推送到远端上指定分支git push origin localbranch:remotebranch#推送本地指定分支，到远端上指定分支git push origin :remotebranch # 删除远端指定分支git push origin remotebranch --delete # 删除远程分支git branch -dr branch # 删除本地和远程分支git checkout -b [--track] test origin/dev#基于远端dev分支，新建本地test分支[同时设置跟踪] 源 git是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。 个人开发时，多源用的可能不多，但多源其实非常有用。 1234567git remote add origin1 git@github.com:yanhaijing/data.js.gitgit remote#显示全部源git remote -v#显示全部源+详细信息git remote rename origin1 origin2#重命名git remote rm origin#删除git remote show origin#查看指定源的全部信息标签 当开发到一定阶段时，给程序打标签是非常棒的功能。 12345678git tag#列出现有标签 git tag v0.1 [branch|commit] # [从指定位置]新建标签git tag -a v0.1 -m &apos;my version 1.4&apos;#新建带注释标签git checkout tagname#切换到标签git push origin v1.5#推送分支到源上git push origin --tags#一次性推送所有分支git tag -d v0.1#删除标签git push origin :refs/tags/v0.1#删除远程标签","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"Git常用命令备忘记录","slug":"Git常用命令备忘记录","date":"2017-06-15T03:16:12.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/06/15/Git常用命令备忘记录/","link":"","permalink":"http://yoursite.com/2017/06/15/Git常用命令备忘记录/","excerpt":"Git配置","text":"Git配置 12345678910git config --global user.name &quot;robbin&quot; git config --global user.email &quot;fankai@gmail.com&quot;git config --global color.ui truegit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.br branchgit config --global core.editor &quot;mate -w&quot; # 设置Editor使用textmategit config -l # 列举所有配置用户的git配置文件~/.gitconfig Git常用命令:查看、添加、提交、删除、找回，重置修改文件** 1234567891011121314151617181920212223242526git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci .git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git commit --amend #修改最后一次提交注释的，利用–amend参数 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff** 1234567git diff &lt;file&gt; # 比较当前文件和暂存区文件差异git diffgit diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录** 12345git loggit log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat # 查看提交统计信息 tigGit 本地分支管理查看、切换、创建和删除分支 123456789101112131415git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase** 12345git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于：git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)123git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch # 测试补丁能否成功 Git暂存管理 1234git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git远程分支管理 12345678910111213git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理 12345git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库 123456789git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 12git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"Angular基础总结","slug":"Angular基础","date":"2017-04-13T09:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/04/13/Angular基础/","link":"","permalink":"http://yoursite.com/2017/04/13/Angular基础/","excerpt":"","text":"Angular基础总结一、使用Angular1.引入`angualrjs` 2.定义`ng-app`告诉`angualrjs`那些代码要被`angualrjs`解析 3. `ng-model` 表示把`input`输入的值赋值给 `username` 4.`{{}}` 绑定数据 二、控制器 1.通过ng-app定义myApp模块 告诉angularjs这里面的代码要被angularjs解析 2.得通过angular.module(&#39;myApp&#39;,[]) 实现 两个参数: 1.模块名称 2.依赖注入的让他模块 4.定义控制器 view ng-controller5.定义控制器以后要实现这个控制器 12345app.controller(&apos;firstController&apos;,function($scope)&#123; $scope.name=&apos;张三&apos;; &#125;) $scope视图和控制器的桥梁，所有的数据都要绑定到$scope 所有的方法也要绑定到$scope 三、view和控制器的桥梁1.$rootScope 全局作用域 可以数据和方法 （多个控制器共享数据） 2.$scope 局部作用域 四、$applyAngularJS外部的控制器（DOM事件、外部的回调函数如jQuery 事件等）调用了AngularJS函数之后，必须调用$apply。 在这种情况下，你需要命令AngularJS刷新自已（模型、视图等），$apply就是用来做这件事情的。 angularjs外部的事件 或者方法 改变$scope绑定的数据的时候，改变不了，这时候就要用到$apply 五、内置定时器 1.$timeout 2.$interval六、数据 1.数据绑定 ng-model=&#39;name&#39;,,可以将$scope的数据绑定到视图 2.ng-reapet循环(track by $index出现相同值的时候需要绑定index) 3.ng-bind-html，数据绑定 &lt;element ng-bind-html=&quot;expression&quot;&gt;&lt;/element&gt; 4.数字绑定ng-init,不常见建议用ng-bind 123&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt;&lt;p&gt;总价： &#123;&#123; quantity * cost &#125;&#125;&lt;/p&gt;&lt;/div&gt; 5.ng-bind 七、$watch$watch用于监听每个scope中的变量 1.$watch单一的变量 1234$scope.count=1;$scope.$watch(&apos;count&apos;,function()&#123;...&#125;); 2.$watch多个变量用+号隔开 123456//当count或page变化时，都会执行这个匿名函数$scope.count=1;$scope.page=1;$scope.$watch(&apos;count + page&apos;,function()&#123;...&#125;); 3.$watch页可以监听数组或者对象 12345$scope.items=[&#123;a:1&#125;,&#123;a:2&#125;&#123;a:3&#125;];$scope.$watch(&apos;items&apos;,function()&#123;...&#125;,true); 八、$http请求1.get请求(post同理)123456789101112131415161718192021var url=&quot;http://www.phonegap100.com/appapi.php&quot;; $http.get(url,&#123; params:&#123; &apos;a&apos;:&apos;getPortalList&apos;, &apos;catid&apos;:20, &quot;x&quot;:&apos;xxx&apos; &#125; &#125;).then(function(res)&#123; console.log(res.data.result); $scope.list=res.data.result; &#125;,function(err)&#123; console.log(err); &#125;) 2.jsonp请求 12345678var url=&apos;http://www.phonegap100.com/appapi.php?a=getPortalArticle&amp;aid=109&amp;callback=JSON_CALLBACK&apos; $http.jsonp(url).success(function(data)&#123; console.log(data); &#125;).error(function()&#123; &#125;) 3.jsonp1.6.2的版本 12345678var url=&apos;http://www.phonegap100.com/appapi.php?a=getPortalArticle&amp;aid=109&amp;callback=JSON_CALLBACK&apos; $http.jsonp(url).success(function(data)&#123; console.log(data); &#125;).error(function()&#123; &#125;) 九、代码压缩的问题第二个参数写数组可以完美解决 123456 app.controller(&apos;secondController&apos;,[&apos;$scope&apos;,&apos;$http&apos;,function($scope,$http)&#123; $scope.msg=&quot;你好angualrjs&quot;// $http.get() &#125;]) 十、模块依赖ngSanitize.js（html代码解析模块）1.引入 angular-sanitize.js2.依赖注入ngSanitize3.ng-bind-html 绑定数据 123456var app=angular.module(&apos;myApp&apos;,[&apos;ngSanitize&apos;]); app.controller(&apos;firstController&apos;,function($scope)&#123; $scope.title=&apos;&lt;h2&gt;这是一个标题&lt;/h2&gt;&apos; &#125;) 十一、angular的路由配置1.引入js angular-route.min.js 2.在html页面中定义 ng-view 显示我们模板里面动态加载的数据 3.var app=angular.module(&apos;myApp&apos;,[&apos;ngRoute&apos;]); 依赖注入 //根据不同的路由加载不同的控制器和模板 //加载出来的模板和控制回头放在视图里面 123456789101112131415161718192021222324app.config(function($routeProvider)&#123; $routeProvider.when(&apos;/home&apos;,&#123; templateUrl:&quot;templates/home.html&quot;, controller:&apos;homeController&apos; &#125;).when(&apos;/news&apos;,&#123; templateUrl:&quot;templates/news.html&quot;, controller:&apos;newsController&apos; &#125;).when(&apos;/newscontent/:aid&apos;,&#123;//动态路由 templateUrl:&quot;templates/newscontent.html&quot;, controller:&apos;newsContentController&apos; &#125;).otherwise(&#123; /*找不到路由的时候动态跳转的页面*/ redirectTo:&apos;/home&apos; &#125;) &#125;) 5.注意：要实现路由里面定义的controller 十二、angular的广播 $scope $rootScope上面都可以绑定广播 $broadcast 给子controller 广播数据 $emit 给 父亲controller广播数据 $scope.$on 接收数据 (&#39;名称&#39;,function(event,data){}) $scope.$broadcast(&#39;to-child&#39;, &#39;给child数据&#39;); //前面是名字 后面是数据 数据可以是 字符串 也可以是数组 和对象 $scope.$broadcast(&#39;to-parent&#39;, &#39;给父亲元素广播数据&#39;)十三、angular的动画12345678910111213141516171819202122232425262728293031323334353637 &lt;script src=&quot;http://cdn.bootcss.com/angular.js/1.2.9/angular-animate.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var m1 = angular.module(&apos;myApp&apos;,[&apos;ngAnimate&apos;]); m1.controller(&apos;firstController&apos;,[&apos;$scope&apos;,function($scope)&#123; $scope.bBtn = true; &#125;]); m1.animation(&apos;.box&apos;,function()&#123; return&#123; enter:function(element,done)&#123; console.log(element); console.log(done); $(element).css(&#123;width:0,height:0&#125;);// / $(element).animate(&#123;width:0,height:0&#125;); $(element).animate(&#123;width:200,height:200&#125;,1000,done); &#125;, leave:function(element,done)&#123; $(element).animate(&#123;width:0,height:0&#125;,1000,done); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-controller=&quot;firstController&quot;&gt; &lt;input type=&quot;checkbox&quot; ng-model=&quot;bBtn&quot;&gt; &lt;div ng-if=&quot;bBtn&quot; class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Angular4基础总结","slug":"angular4x","date":"2017-04-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/04/13/angular4x/","link":"","permalink":"http://yoursite.com/2017/04/13/angular4x/","excerpt":"","text":"一、文档官方文档https://angular.cn/docs/ts/latest/quickstart.html知乎angular简单入门笔记https://zhuanlan.zhihu.com/p/27696268邹业盛 angular的学习笔记http://zouyesheng.com/angular.htmlAngular.js 的一些学习资源https://github.com/dolymood/AngularLearning 二、安装 1.安装最新版本的nodejs注意：请先在终端/控制台窗口中运行命令 node -v 和 npm -v， 来验证一下你正在运行 node 6.9.x 和 npm 3.x.x 以上的版本。 更老的版本可能会出现错误，更新的版本则没问题。 2.全局安装 Angular CLI 脚手架工具 使用 npm命令安装 1npm install -g @angular/cli 1cnpm install -g @angular/cli 三、创建项目 打开cmd找到你要创建项目的目录 创建项目 ng new 项目名称 创建一个项目 1ng new my-app 进入刚才创建的项目里面启动服务123cd my-appcnpm install ng serve --open 四、目录结构分析https://angular.cn/docs/ts/latest/cli-quickstart.html src文件夹你的应用代码位于src文件夹中。 所有的Angular组件、模板、样式、图片以及你的应用所需的任何东西都在那里。 这个文件夹之外的文件都是为构建应用提供支持用的。 五、创建angualr组件 使用组件Component 1ng g component my-new-component 指定目录创建 ：ng g component components/FooterDirective 1ng g directive my-new-directive Pipe 1ng g pipe my-new-pipe Service 1ng g service my-new-service Class 1ng g class my-new-class Guard 1ng g guard my-new-guard Interface 1ng g interface my-new-interface Enum12ng g enum my-new-enumModule 1ng g module my-module 1.app.components.ts 123456789101112131415 import &#123; Component &#125; from &apos;@angular/core&apos;; /*引入angular核心*/@Component(&#123; selector: &apos;app-root&apos;, /*标签 html里面用的组件名称*/ templateUrl: &apos;./app.component.html&apos;, /*模板*/ styleUrls: [&apos;./app.component.css&apos;] /*css样式*/&#125;)export class AppComponent &#123; title = &apos;app&apos;; /*属性 类*/ msg=&quot;你好angular4.x&quot;&#125; 2.app.module.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 定义AppModule，这个根模块会告诉Angular如何组装该应用,组件 服务得在这个配置import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;; /*浏览器相关的*/import &#123; NgModule &#125; from &apos;@angular/core&apos;; /*核心模块*///要用 双向数据绑定必须引入 FormsModuleimport &#123; FormsModule &#125; from &apos;@angular/forms&apos;; //使用http请求数据需要首先引入import &#123; HttpModule, JsonpModule &#125; from &apos;@angular/http&apos;; import &#123; AppComponent &#125; from &apos;./app.component&apos;;import &#123; HomeComponent &#125; from &apos;./components/home/home.component&apos;;import &#123; NewsComponent &#125; from &apos;./components/news/news.component&apos;;import &#123; TodolistComponent &#125; from &apos;./components/todolist/todolist.component&apos;; /*根组件*///引入服务import &#123; StorageService &#125; from &apos;./services/storage.service&apos;;import &#123; NewslistComponent &#125; from &apos;./components/newslist/newslist.component&apos;; /*不需要加ts*/@NgModule(&#123; declarations: [ /*申明组件 依赖注入*/ AppComponent, HomeComponent, NewsComponent, TodolistComponent, NewslistComponent ], imports: [ /*模块都放在这个里面*/ BrowserModule, FormsModule, HttpModule, /*注入模块*/ JsonpModule ], providers: [StorageService], /*所有的服务*/ bootstrap: [AppComponent] /*默认启动的组件*/&#125;)export class AppModule &#123; &#125; /*暴露模块 默认就行*/ 1.数据文本绑定 123&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; 2.绑定html12this.h=&quot;&lt;h2&gt;这是一个h2用[innerHTML]来解析&lt;/h2&gt;&quot;&lt;div [innerHTML]=&quot;2&quot;&gt;&lt;/div&gt; 3*ngFor普通循环 12345&lt;ul&gt; &lt;li *ngFor=&quot;let item of list&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; 123456//带index下标的循环&lt;ul&gt; &lt;li *ngFor=&quot;let item of list2; let i = index&quot;&gt; &#123;&#123;i&#125;&#125;----- &#123;&#123;item.title&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 4、条件判断 1&lt;p *ngIf=&quot;list.length &gt; 3&quot;&gt;这是ngIF判断是否显示&lt;/p&gt; 5、执行事件 123456789&lt;button class=&quot;button&quot; (click)=&quot;getData()&quot;&gt; 点击按钮触发事件 &lt;/button&gt; getData()&#123; /*自定义方法获取数据*/ //获取 alert(this.msg); &#125; 6.双向数据绑定&lt;input [{ngModel}]=&quot;inputValue&gt;&quot;注意引入FormsModule 1import &#123; FormsModule &#125; from &apos;@angular/forms&apos;; 123456789101112131415@NgModule(&#123; declarations: [ AppComponent, HeaderComponent, FooterComponent, NewsComponent ], imports: [ BrowserModule, FormsModule//这里引入 ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 使用： 123&lt;input type=&quot;text&quot; [(ngModel)]=&quot;inputValue&quot;/&gt;&#123;&#123;inputValue&#125;&#125; 六、创建angualr服务使用服务1234ng g service my-new-service创建到指定目录下面ng g service services/storage 1.app.module.ts里面引入创建的服务1import &#123;StorageService&#125; from &quot;./services/storage.service&quot; 2.NgModule里面的providers里面依赖注入服务 12345678910111213141516@NgModule(&#123; declarations: [ AppComponent, HeaderComponent, FooterComponent, NewsComponent, TodolistComponent ], imports: [ BrowserModule, FormsModule ], providers: [StorageService],//这里注入 bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 3.使用页面引入服务，注册服务 1import &#123; StorageService &#125; from &apos;../../services/storage.service&apos;; 123constructor(private storage: StorageService) &#123; &#125; 使用 123456789101112131415addData()&#123; // alert(this.username); this.list.push(this.username); this.storage.set(&apos;todolist&apos;,this.list); &#125; removerData(key)&#123; console.log(key); this.list.splice(key,1); this.storage.set(&apos;todolist&apos;,this.list); &#125; 七、Angular4.x get post以及 jsonp请求数据不使用rxjs请求数据 1.引入HttpModule 、JsonpModule 普通的 HTTP 调用并不需要用到 JsonpModule，不过稍后我们就会演示对 JSONP 的支持， 所以现在就加载它，免得再回来改浪费时间。 1import &#123; HttpModule, JsonpModule &#125; from &apos;@angular/http&apos;; 2.HttpModule 、JsonpModule依赖注入 123456789101112131415161718@NgModule(&#123; declarations: [ AppComponent, HomeComponent, NewsComponent, NewscontentComponent ], imports: [ BrowserModule, FormsModule, HttpModule, JsonpModule, AppRoutingModule ], providers: [StorageService,NewsService], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; 使用Http、Jsonp：1、在需要请求数据的地方引入 Http 1import &#123;Http,Jsonp&#125; from &quot;@angular/http&quot;; 2、构造函数内申明： 1constructor(private http:Http,private jsonp:Jsonp) &#123; &#125; 3、对应的方法内使用http请求数据 12345678this.http.get(&quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&quot;) .subscribe( function(data)&#123; console.log(data); &#125;,function(err)&#123; console.log(&apos;失败&apos;); &#125; ); 12345678this.jsonp.get(&quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&amp;callback=JSONP_CALLBACK&quot;) .subscribe( function(data)&#123; console.log(data); &#125;,function(err)&#123; console.log(&apos;失败&apos;); &#125; ); 使用Post 引入Headers 、Http模块 用的地方 1import &#123;Http,Jsonp,Headers&#125; from &quot;@angular/http&quot;; 实例化Headers 1private headers = new Headers(&#123;&apos;Content-Type&apos;: &apos;application/json&apos;&#125;); 3.post提交数据 1234567this.http .post(&apos;http://localhost:8008/api/test&apos;, JSON.stringify(&#123;username: &apos;admin&apos;&#125;), &#123;headers:this.headers&#125;) // .toPromise() .subscribe(function(res)&#123; console.log(res.json()); &#125;); 使用rxjs请求数据 RxJS是一种针对异步数据流编程工具，或者叫响应式扩展编程；可不管如何解释RxJS其目标就是异步编程，Angular引入RxJS为了就是让异步可控、更简单。 大部分RxJS操作符都不包括在Angular的Observable基本实现中，基本实现只包括Angular本身所需的功能。如果想要更多的RxJS功能，我们必须导入其所定义的库来扩展Observable对象， 以下是这个模块所需导入的所有RxJS操作符： 1、 引入Http 、Jsonp、RxJs 模块 1234import &#123;Http,Jsonp&#125; from &quot;@angular/http&quot;;import &#123;Observable&#125; from &quot;rxjs&quot;;import &quot;rxjs/Rx&quot;; 你可能并不熟悉这种import ‘rxjs/Rx’语法，它缺少了花括号中的导入列表：{…}。这是因为我们并不需要操作符本身，这种情况下，我们所做的其实是导入这个库，加载并运行其中的脚本， 它会把操作符添加到Observable类中。 2、 构造函数内申明： 1constructor(private http:Http,private jsonp:Jsonp) &#123; &#125; 3、get请求 123456this.http.get(&quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&quot;) .map(res =&gt; res.json()) .subscribe( function(data)&#123; console.log(data); &#125; ); 4、Jsonp请求 this.jsonp.get(“http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&amp;callback=JSONP_CALLBACK&quot;) .map(res =&gt; res.json()) .subscribe( function(data){ console.log(data); } ); http.get 方法中返回一个Observable对象，我们之后调用RxJS的map操作符对返回的数据做处理。 八、路由ng new 项目名称 --routing 1ng new angulardemo02 –routing 123456789101112131415app-routing.module.tsconst routes: Routes = [ &#123; path: &apos;home&apos;, component:HomeComponent // children: [] &#125;, &#123; path: &apos;news&apos;, component:NewsComponent // children: [] &#125; &#123; path: &apos;&apos;, redirectTo: &apos;/home&apos;, pathMatch: &apos;full&apos; &#125;,]; 动态路由 12345678910111213141516171819202122232425262728293031import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;import &#123; NewsComponent &#125; from &apos;./components/news/news.component&apos;;import &#123; HomeComponent &#125; from &apos;./components/home/home.component&apos;;import &#123; NewcontentComponent &#125; from &apos;./components/newcontent/newcontent.component&apos;;const routes: Routes = [ &#123; path: &apos;home&apos;, component:HomeComponent // children: [] &#125;, &#123; path: &apos;news&apos;, component:NewsComponent // children: [] &#125;,&#123; path: &apos;newscontent/:aid&apos;, component:NewcontentComponent // children: [] &#125;, &#123; path: &apos;&apos;, redirectTo: &apos;/home&apos;, pathMatch: &apos;full&apos; &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; 获取传值1.引入 1import &#123;ActivatedRoute &#125; from &apos;@angular/router&apos;; 2.实例化 1constructor(private route:ActivatedRoute) &#123; &#125; 3. 1234567ngOnInit() &#123; // console.log(); this.route.params.subscribe(function(data)&#123; console.log(data); &#125;) &#125; 九、父子组件传值 父组件给子组件传值 1.子组件 1import &#123; Component, OnInit ,Input &#125; from &apos;@angular/core&apos;; 2.父组件调用子组件 1&lt;app-header [msg]=&quot;msg&quot;&gt;&lt;/app-header&gt; 3.子组件中接收数据 1234567891011export class HeaderComponent implements OnInit &#123; @Input() msg:string constructor() &#123; &#125; ngOnInit() &#123; &#125;&#125; 子组件给父组件传值 子组件引入Output 和 EventEmitter 1import &#123; Component, OnInit ,Input,Output,EventEmitter&#125; from &apos;@angular/core&apos;; 2.子组件中实例化 EventEmitter 1@Output() private outer=new EventEmitter&lt;string&gt;(); 12 /*用EventEmitter 和output装饰器配合使用 &lt;string&gt;指定类型变量*/ 子组件通过 EventEmitter 对象outer实例广播数据 1234sendParent()&#123; // alert(&apos;zhixing&apos;); this.outer.emit(&apos;msg from child&apos;) &#125; 4.父组件调用子组件的时候，定义接收事件 , outer就是子组件的EventEmitter 对象outer 1&lt;app-header (outer)=&quot;runParent($event)&quot;&gt;&lt;/app-header&gt; 5.父组件接收到数据会调用自己的runParent方法，这个时候就能拿到子组件的数据 //接收子组件传递过来的数据 123runParent(msg:string)&#123; alert(msg); &#125;","categories":[{"name":"Angular4.x","slug":"Angular4-x","permalink":"http://yoursite.com/categories/Angular4-x/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Vue学习总结(一)","slug":"vue-summary-1","date":"2017-03-19T04:24:08.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2017/03/19/vue-summary-1/","link":"","permalink":"http://yoursite.com/2017/03/19/vue-summary-1/","excerpt":"","text":"一、介绍 Paste_Image.png Vue是一套构建用户界面的 渐进式框架。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。 二、Vue实例构造器 每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的 123var vm = new Vue(&#123;// 选项&#125;) 在实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 API 文档中查看 属性与方法 每个 Vue实例都会代理其data 对象里所有的属性 123456789101112var data = &#123; a: 1 &#125;var vm = new Vue(&#123;data: data&#125;)vm.a === data.a// -&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // -&gt; 2// ... 反之亦然data.a = 3vm.a // -&gt; 3 除了 data属性， Vue实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的data属性区分。例如： 12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123;el: '#example',data: data&#125;)vm.$data === data// -&gt; truevm.$el === document.getElementById('example')// -&gt; true// $watch 是一个实例方法vm.$watch('a', function (newVal, oldVal) &#123;// 这个回调将在 `vm.a` 改变后调用&#125;) 实例生命周期 12345678var vm = new Vue(&#123;data: &#123; a: 1 &#125;,created: function () &#123;// `this` 指向 vm 实例console.log('a is: ' + this.a)&#125;&#125;)// -&gt; \"a is: 1\" 也有一些其它的钩子，在实例生命周期的不同阶段调用，如 mounted 、 updated 、 destroyed 。钩子的 this 指向调用它的 Vue 实例。一些用户可能会问 Vue.js 是否有“控制器”的概念？答案是，没有。组件的自定义逻辑可以分布在这些钩子中 生命周期图示 三、模板语法 Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。 在底层的实现上， Vue将模板编译成虚拟DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。 插值文本 数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定 1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 纯 HTML 双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML，你需要使用v-html指令： 1&lt;div v-html=\"rawHtml\"&gt;&lt;/div&gt; 被插入的内容都会被当做 HTML —— 数据绑定会被忽略 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用HTML 插值，绝不要对用户提供的内容插值 属性 Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令： 1&lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt; 使用 JavaScript 表达式 对于所有的数据绑定， Vue.js都提供了完全的 JavaScript表达式支持。 123&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析 过滤器 Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在mustache 插值的尾部，由“管道符”指示： 1&#123;&#123; message | capitalize &#125;&#125; 指令 指令（Directives）是带有v-前缀的特殊属性。指令属性的值预期是单一 JavaScript表达式（除了v-for ，之后再讨论） 指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上 1&lt;p v-if=\"seen\"&gt;Now you see me&lt;/p&gt; 这里， v-if 指令将根据表达式 seen 的值的真假来移除/插入&lt;p&gt;元素 参数 一些指令能接受一个“参数”，在指令后以冒号指明。例如，v-bind指令被用来响应地更新 HTML 属性 1&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt; 在这里 href是参数，告知v-bind 指令将该元素的 href 属性与表达式 url的值绑定 另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=\"doSomething\"&gt; 修饰符 修饰符（Modifiers）是以半角句号.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定 例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 缩写 v- 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识 Vue.js 为两个最为常用的指令提供了特别的缩写 v-bind 缩写 12&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on 缩写 12345&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 四、计算属性 在模板中绑定表达式是非常便利的，但是它们实际上只用于简单的操作。在模板中放入太多的逻辑会让模板过重且难以维护。例如： 1&lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 在这种情况下，模板不再简单和清晰。在实现反向显示 message 之前，你应该确认它。这个问题在你不止一次反向显示 message 的时候变得更加糟糕。 这就是为什么任何复杂逻辑，你都应当使用计算属性 基础例子 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 12345678var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; //a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split('').reverse().join('')&#125; &#125;&#125;) 结果： Original message: “Hello” Computed reversed message: “olleH” 这里我们声明了一个计算属性 reversedMessage 。我们提供的函数将用作属性 计算缓存 vs Methods 你可能已经注意到我们可以通过调用表达式中的method来达到同样的效果： 1&lt;p&gt;Reversed message: \"&#123;&#123; reverseMessage() &#125;&#125;\"&lt;/p&gt; 123456// in componentmethods: &#123;reverseMessage: function () &#123; return this.message.split(' ').reverse().join('') &#125;&#125; 不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。对于最终的结果，两种方式确实是相同的。然而，不同的是计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 message 没有发生改变，多次访问reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着如下计算属性将不会更新，因为 Date.now()不是响应式依赖： 1computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 相比而言，每当重新渲染的时候，method 调用总会执行函数 我们为什么需要缓存？假设我们有一个重要的计算属性 A ，这个计算属性需要一个巨大的数组遍历和做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用 method 替代 计算属性 vs Watched Property Vue.js 提供了一个方法$watch ，它用于观察 Vue实例上的数据变动 计算 setter 计算属性默认只有 getter，不过在需要时你也可以提供一个 setter： 123456789101112131415// ...computed: &#123;fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125;&#125;&#125; 现在在运行vm.fullName = &#39;John Doe&#39; 时， setter会被调用， vm.firstName 和vm.lastName 也会被对应更新 观察 Watchers 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher 。这是为什么 Vue 提供一个更通用的方法通过 watch 选项，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或昂贵操作时，这是很有用的 五、Class与Style绑定Class 与 Style 绑定 数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用 v-bind处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 v-bind 用于class 和 style时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组 绑定 HTML Class对象语法 我们可以传给v-bind:class 一个对象，以动态地切换 class 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; 上面的语法表示class active的更新将取决于数据属性isActive 是否为真值 我们也可以在对象中传入更多属性用来动态切换多个class。此外， v-bind:class 指令可以与普通的class 属性共存。如下模板: 1&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 如下 data: 1data: &#123; isActive: true, hasError: false&#125; 渲染为: 1&lt;div class=\"static active\"&gt;&lt;/div&gt; 当 isActive 或者 hasError 变化时，class 列表将相应地更新。例如，如果 hasError的值为true ， class列表将变为&quot;static active text-danger&quot; 你也可以直接绑定数据里的一个对象 1&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt; 1data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 数组语法 我们可以把一个数组传给 v-bind:class ，以应用一个 class 列表 1&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt; 1data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 渲染为: 1&lt;div class=\"active text-danger\"&gt;&lt;/div&gt; 如果你也想根据条件切换列表中的 class ，可以用三元表达式 1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt; 绑定内联样式对象语法 v-bind:style 的对象语法十分直观——看着非常像CSS ，其实它是一个 JavaScript 对象。 CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case） 123&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; 1data: &#123; activeColor: 'red', fontSize: 30&#125; 直接绑定到一个样式对象通常更好，让模板更清晰 1&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; 1data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 数组语法 v-bind:style 的数组语法可以将多个样式对象应用到一个元素上 1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt; 自动添加前缀 当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js会自动侦测并添加相应的前缀 六、条件渲染v-if 在字符串模板中，如 Handlebars，我们得像这样写一个条件块 12&lt;!-- Handlebars 模板 --&gt;&#123;&#123;#if ok&#125;&#125; &lt;h1&gt;Yes&lt;/h1&gt;&#123;&#123;/if&#125;&#125; 在 Vue.js，我们使用 v-if指令实现同样的功能 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; 也可以用 v-else添加一个 “else”块 1&lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; template v-if 因为 v-if 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 &lt;template&gt; 元素当做包装元素，并在上面使用 v-if ，最终的渲染结果不会包含它 1&lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-else 可以用 v-else指令给 v-if或 v-show 添加一个 “else” 块 1&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Sorry&lt;/div&gt;&lt;div v-else&gt; Not sorry&lt;/div&gt; v-else 元素必须紧跟在v-if或 v-show 元素的后面——否则它不能被识别 v-show 另一个根据条件展示元素的选项是v-show指令。用法大体上一样 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。 v-show是简单的切换元素的 CSS 属性display 注意 v-show 不支持 &lt;template&gt; 语法 v-if vs. v-show v-if 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件 v-if也是惰性的：如果在初始渲染时条件为假，则什么也不做 相比之下， v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换 一般来说， v-if有更高的切换消耗而 v-show 有更高的初始渲染消耗 因此，如果需要频繁切换使用v-show较好，如果在运行时条件不大可能改变则使用v-if较好 七、列表渲染v-for 我们用 v-for指令根据一组数组的选项列表进行渲染。v-for指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名 在 v-for 块中，我们拥有对父作用域属性的完全访问权限。 v-for 还支持一个可选的第二个参数为当前项的索引 12345&lt;ul id=\"example-2\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 你也可以用 of替代 in作为分隔符，因为它是最接近 JavaScript 迭代器的语法 1&lt;div v-for=\"item of items\"&gt;&lt;/div&gt; Template v-for 如同 v-if模板，你也可以用带有 v-for 的 &lt;template&gt;标签来渲染多个元素块。例如：123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 对象迭代 v-for 你也可以用v-for 通过一个对象的属性来迭代 123&lt;ul id=\"repeat-object\" class=\"demo\"&gt; &lt;li v-for=\"value in object\"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678new Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; FirstName: 'John', LastName: 'Doe', Age: 30 &#125; &#125;&#125;) 你也可以提供第二个的参数为键名 1&lt;div v-for=\"(value, key) in object\"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 第三个参数为索引 123&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 整数迭代 v-for v-for 也可以取整数。在这种情况下，它将重复多次模板 123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;&lt;/div&gt; 结果： 1 2 3 4 5 6 7 8 9 10 组件 和 v-for 在自定义组件里，你可以像任何普通元素一样用 v-for 1&lt;my-component v-for=\"item in items\"&gt;&lt;/my-component&gt; 然而他不能自动传递数据到组件里，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们要用props 123&lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\"&gt;&lt;/my-component&gt;&gt; 不自动注入 item到组件里的原因是，因为这使得组件会紧密耦合到 v-for如何运作。在一些情况下，明确数据的来源可以使组件可重用。 八、事件处理器监听事件 可以用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码 1234&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt; 12345var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) 方法事件处理器 许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 可以接收一个定义的方法来调用 内联处理器方法 除了直接绑定到一个方法，也可以用内联 JavaScript语句 1234&lt;div id=\"example-3\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; 1234567new Vue(&#123;el: '#example-3', methods: &#123; say: function (message) &#123; alert(message) &#125;&#125;&#125;) 有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event把它传入方法 123&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt;Submit&lt;/button&gt; 12345678methods: &#123;warn: function (message, event) &#123;// 现在我们可以访问原生事件对象 if(event) &#123; event.preventDefault() alert(message) &#125;&#125;&#125; 事件修饰符 在事件处理程序中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。尽管我们可以在methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理DOM 事件细节 为了解决这个问题， Vue.js 为 v-on提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符 .stop .prevent .capture .self 1234567891011121314151617&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用时间捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; 按键修饰符 在监听键盘事件时，我们经常需要监测常见的键值。 Vue允许为 v-on在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=\"submit\"&gt; 记住所有的 keyCode比较困难，所以 Vue为最常用的按键提供了别名 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： enter tab delete (捕获 “删除” 和 “退格” 键) esc space up down left right 为什么在 HTML 中监听事件? 你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。不必担心，因为所有的 Vue.js事件处理方法和表达式都严格绑定在当前视图的 ViewModel上，它不会导致任何维护上的困难。 实际上，使用 v-on有几个好处 扫一眼HTML 模板便能轻松定位在 JavaScript代码里对应的方法 因为你无须在 JavaScript里手动绑定事件，你的 ViewModel代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。 九、表单控制绑定基础用法 你可以用 v-model指令在表单控件元素上创建双向数据绑定 它会根据控件类型自动选取正确的方法来更新元素。 尽管有些神奇，但 v-model本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 v-model 并不关心表单控件初始化所生成的值。因为它会选择Vue实例数据来作为具体的值。 文本 12&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 复选框 单个勾选框，逻辑值 12&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked&#125;&#125;&lt;/label&gt; 多个勾选框，绑定到同一个数组 1234567891011&lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;&lt;label for=\"jack\"&gt;Jack&lt;/label&gt;&lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;&lt;label for=\"john\"&gt;John&lt;/label&gt;&lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;&lt;label for=\"mike\"&gt;Mike&lt;/label&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt; 1new Vue(&#123; el: '...', data: &#123; checkedNames: [] &#125;&#125;) 十、组件什么是组件？ 组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以is 特性扩展 使用组件注册 之前说过，我们可以通过以下方式创建一个 Vue实例 1new Vue(&#123; el: '#some-element', // 选项&#125;) 要注册一个全局组件，你可以使用 Vue.component(tagName, options) 。例如：Vue.component(&#39;my-component&#39;, { // 选项}) 组件在注册之后，便可以在父实例的模块中以自定义元素 &lt;my-component&gt;&lt;/my-component&gt; 的形式使用。要确保在初始化根实例 之前 注册了组件：&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 123456// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)//创建根实例new Vue(&#123; el: '#example'&#125;) 渲染为：&lt;div id=&quot;example&quot;&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; 局部注册 不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用 构成组件 组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性 在 Vue.js中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events给父组件发送消息。看看它们是怎么工作的 Props使用Props传递数据 组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用props把数据传给子组件。 prop是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项 声明 “prop”： 12345678Vue.component('child', &#123; // 声明 propsprops: ['message'],// 就像 data 一样，prop 可以用在模板内// 同样也可以在 vm 实例中像 “this.message” 这样使用template: '&lt;span&gt;&#123;&#123; message&#125;&#125;&lt;/span&gt;'&#125;) 然后向它传入一个普通字符串&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt; 结果：hello! 动态 Props 类似于用v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 绑定动态 props到父组件的数据。每当父组件的数据变化时，也会传导给子组件： 单向数据流 prop是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解 另外，每次父组件更新时，子组件的所有 prop都会更新为最新值。这意味着你不应该在子组件内部改变prop 。如果你这么做了，Vue 会在控制台给出警告 十一、附录附录一 MVC、MVP、MVVM模式对比MVC 什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户 模型（数据保存） 模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑 模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑 视图（用户界面） 视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的 控制器（业务逻辑） 控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。 当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了 总结一下： Controller 监听 Model 变化，Model 一变，Controller 就会去更新View。 Controller 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 各部分之间的通信方式 互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller 另一种是直接通过controller接受指令 MVP MVP 模式将 Controller 改名为Presenter`，同时改变了通信方向 各部分之间的通信，都是双向的。 View 与Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然 附录二 vue与其他框架的对比React React 和 Vue 有许多相似之处，它们都有 使用 Virtual DOM 提供了响应式（Reactive）和组件化（Composable）的视图组件。 将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库 angular1 Vue 的一些语法和 Angular的很相似（例如 v-if vs ng-if）。因为Angular是 Vue早期开发的灵感来源。然而，Angular 中存在的许多问题，在 Vue 中已经得到解决 复杂性 在 API 与设计两方面上Vue.js都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。 灵活性和模块化 Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1制定的规则，这让Vue能适用于各种项目。我们知道把决定权交给你是非常必要的 数据绑定 Angular 1使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。 指令与组件 在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方 性能 Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查 在 Angular 1 中，当 watchers 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watchers都要重新计算。并且，如果一些watchers触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watchers的作用域 Vue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"MVC、MVP、MVVM之间的关系","slug":"mvc-mvp-mvvm","date":"2017-03-13T06:35:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/03/13/mvc-mvp-mvvm/","link":"","permalink":"http://yoursite.com/2017/03/13/mvc-mvp-mvvm/","excerpt":"一、MVC 什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户","text":"一、MVC 什么是MVC MVC是一种模式，它将应用分为3个部分：数据（模型）、表现层（视图）、用户交互层（控制器） 一个事件的处理大概是这样 用户和应用产生交互 控制器的事件处理器被触发 控制器从模型中请求数据，并将其交给视图 视图将数据呈现给用户 模型（数据保存） 模型用来存放用户的所有数据对象。比如有一个user模型，用来存放用户列表、他们的属性以及所有和模型有关的逻辑 模型不必知晓视图和控制器的细节，模型只需包含数据以及直接和这些数据相关的逻辑 视图（用户界面） 视图是呈现给用户的，用户与之产生交互。在JavaScript应用中，视图大都是由HTML、css、JavaScript模板组成的 控制器（业务逻辑） 控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行进行处理，并相应的更新视图。 当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了 总结一下： Controller 监听 Model 变化，Model 一变，Controller 就会去更新View。 Controller 监听用户交互，用户点了提交或修改按钮，Controller 就要去更新 Model View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 各部分之间的通信方式 互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller 另一种是直接通过controller接受指令 二、MVP MVP 模式将 Controller 改名为Presenter`，同时改变了通信方向 各部分之间的通信，都是双向的。 View 与Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里 三、MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"http://yoursite.com/tags/MVC/"}]},{"title":"mysql笔记整理","slug":"mysql笔记整理","date":"2017-01-26T10:32:12.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/01/26/mysql笔记整理/","link":"","permalink":"http://yoursite.com/2017/01/26/mysql笔记整理/","excerpt":"","text":"mysql学习笔记整理","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/categories/DataBase/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"mysql复习秘籍","slug":"mysql复习秘籍","date":"2017-01-25T02:26:48.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/01/25/mysql复习秘籍/","link":"","permalink":"http://yoursite.com/2017/01/25/mysql复习秘籍/","excerpt":"","text":"Mysql复习重要资料","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/categories/DataBase/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"php基础之字符串常用函数","slug":"php基础之字符串常用函数","date":"2017-01-24T07:35:57.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/01/24/php基础之字符串常用函数/","link":"","permalink":"http://yoursite.com/2017/01/24/php基础之字符串常用函数/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//heredoc nowdoc 适用于定义大段文本header(\"Content-type:text/html;charset=utf-8\");$str3 = &lt;&lt;&lt;INFOhelloworld abc ok nowINFO;echo $str3.\"&lt;br /&gt;\";echo '\\'\\\\ \\n \\t \\v \\$'.\"&lt;/br&gt;\";echo \"\\'\\\\ \\n \\t \\v \\$ '' \".\"&lt;/br&gt;\";echo '单引号只能转义\\或\\'';echo '双引号可以转义多字符，运行速度来说，单引号更快。另外，单引号不能输出变量值'.\"&lt;/br&gt;\";$str1 = \"liubei\";echo \"老大是$str1\".\"&lt;br /&gt;\";echo '老大是$str1'.\"&lt;br /&gt;\";echo strlen('你好').\"&lt;br /&gt;\";//返回6个字节。utf-8编码一个中文占3个字节。gbk编码一个中文占2个字符。echo mb_strlen('你好','utf-8').\"&lt;br /&gt;\";//指定字符集，返回字节数。echo strpos('abcdefg', 'c').\"&lt;br /&gt;\";//返回数组索引位置。否则结果返回boolean值。//有趣的运算:strpos返回的数组索引下标为0，在布尔值运算过程中，变为0了。if(strpos('abcdefg','a') !== false)&#123; echo '存在'.\"&lt;br /&gt;\";&#125;else&#123; echo '不存在'.\"&lt;br /&gt;\";&#125;//替换字符串$str = 'fuck you';echo str_replace('fuck', '萌萌', $str).\"&lt;br /&gt;\";//替换一批字符串$str ='男人，女人，男孩，女孩';echo strtr($str, array('男'=&gt;'女','女'=&gt;'男')).\"&lt;br /&gt;\";//截取子字符串$str = 'tommrow is another day';echo substr($str, 0,3).\"&lt;br /&gt;\";//tomecho substr($str, 0,-3).\"&lt;br /&gt;\";//tommrow is another //拆分字符串变数组.$str = 'tech,linux,mysql';$arr = explode(',', $str);print_r($arr);echo \"&lt;br /&gt;\";//拆分数组被字符串.$str = implode(',', $arr);echo $str;echo \"&lt;br /&gt;\";//字符串大小写转换.echo strtolower('abcdEFG').\"&lt;br /&gt;\";//abcdefgecho strtoupper('abcdEFG').\"&lt;br /&gt;\";//ABCDEFG","categories":[{"name":"Back-end","slug":"Back-end","permalink":"http://yoursite.com/categories/Back-end/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"前端页面部署","slug":"前端页面部署","date":"2017-01-23T08:55:24.000Z","updated":"2018-03-29T15:29:46.716Z","comments":true,"path":"2017/01/23/前端页面部署/","link":"","permalink":"http://yoursite.com/2017/01/23/前端页面部署/","excerpt":"","text":"###前端页面部署####打包项目打包静态文件 上传到服务器 npm run build 你会得到一个build文件夹, 这里面的所有内容加起来 ####服务器打包好的项目直接上传到服务器 前提1.服务器2.域名3.node环境4.nginx环境 服务器 你可以租用各式各样的服务器, 此处, 我们选择 阿里云ECS -&gt; CentOS 7.X系统. 长期的价格可能会比较贵, 有个小技巧是先在阿里云购买一个域名, 有可能你会得到一个优惠券, 域名几十块钱, 而优惠券价值 300 多, 用来购买年费的 ECS 花费 300多RMB(最低配), 当然, 如果你只是拿来练习, 貌似他们有提供 7天版本的, 短期练习是完全足够的 ~ 域名 购买域名 然后, 把实名认证做了, 并尽早备案, 如果你希望通过域名访问你的应用, 而不是 ip:port, 此处不做细述, 有官方流程走(很漫长的审核过程建议预算一个月). node环境 ####部署 直接放在服务器web服务访问静态目录 通过node-static开启静态web服务 node-static 12345678910111213141516171819202122# serve up the current directory $ staticserving &quot;.&quot; at http://127.0.0.1:8080 # serve up a different directory $ static publicserving &quot;public&quot; at http://127.0.0.1:8080 # specify additional headers (this one is useful for development) $ static -H &apos;&#123;&quot;Cache-Control&quot;: &quot;no-cache, must-revalidate&quot;&#125;&apos;serving &quot;.&quot; at http://127.0.0.1:8080 # set cache control max age $ static -c 7200serving &quot;.&quot; at http://127.0.0.1:8080 # expose the server to your local network $ static -a 0.0.0.0serving &quot;.&quot; at http://0.0.0.0:8080 # show help message, including all options $ static -h 3.写个node运行 123456789101112131415const express = require(&apos;express&apos;);const path = require(&apos;path&apos;);const host = &apos;xx.xx.xxx.xx&apos;;const port = process.env.PORT || 8080;const app = express();app.use(express.static(__dirname));app.get(&apos;*&apos;, (req, res) =&gt; &#123; res.sendFile(path.reslove(__dirname, &apos;index.html&apos;));&#125;);app.listen(port);console.log(`server is running at $&#123;host&#125;:$&#123;port&#125;`); 初始化项目, 指定入口名字别搞错了, 不然后面自己去 package.json 里面改. npm init 安装express npm install –save express 然后, 运行项目: node app.js 安装pm2维持进程 npm install -g pm2 用法 1234567891011121314151617$ npm install pm2 -g # 命令行安装 pm2 $ pm2 start app.js -i 4 # 后台运行pm2，启动4个app.js # 也可以把&apos;max&apos; 参数传递给 start # 正确的进程数目依赖于Cpu的核心数目$ pm2 start app.js --name my-api # 命名进程$ pm2 list # 显示所有进程状态$ pm2 monit # 监视所有进程$ pm2 logs # 显示所有进程日志$ pm2 stop all # 停止所有进程$ pm2 restart all # 重启所有进程$ pm2 reload all # 0 秒停机重载进程 (用于 NETWORKED 进程)$ pm2 stop 0 # 停止指定的进程$ pm2 restart 0 # 重启指定的进程$ pm2 startup # 产生 init 脚本 保持进程活着$ pm2 web # 运行健壮的 computer API endpoint (http://localhost:9615)$ pm2 delete 0 # 杀死指定的进程$ pm2 delete all # 杀死全部进程 运行进程的不同方式 123456789101112$ pm2 start app.js -i max # 根据有效CPU数目启动最大进程数目$ pm2 start app.js -i 3 # 启动3个进程$ pm2 start app.js -x #用fork模式启动 app.js 而不是使用 cluster$ pm2 start app.js -x -- -a 23 # 用fork模式启动 app.js 并且传递参数 (-a 23)$ pm2 start app.js --name serverone # 启动一个进程并把它命名为 serverone$ pm2 stop serverone # 停止 serverone 进程$ pm2 start app.json # 启动进程, 在 app.json里设置选项$ pm2 start app.js -i max -- -a 23 #在--之后给 app.js 传递参数$ pm2 start app.js -i max -e err.log -o out.log # 启动 并 生成一个配置文件你也可以执行用其他语言编写的app ( fork 模式):$ pm2 start my-bash-script.sh -x --interpreter bash$ pm2 start my-python-script.py -x --interpreter python ####naginx配置 打开nginx 存放配置文件的目录: cd /etc/nginx/conf.d 在这里, 你可以新建自定义规则的配置文件, 如: vi domain-port.conf 其中, domain 代表域, port 表示端口, 只是为了更好的区分配置文件的用途和关联性, 命名也可以很随意 你可以在 domain-port.conf 这个文件写入如下内容, # 代表注释, js程序员理解成 // 即可 1234567891011121314server &#123; listen 80; # 域名 此处格式为 ip:port, 也可以是一个域名 www.baidu.com # ip 是你的服务器的公网ip, port 是你要跑应用程序的端口 server_name xx.xx.xxx.xx:8080; location / &#123; # 应用服务器的 http 地址 # 服务是跑在本地的, 但外网访问默认的 TCP/IP 端口为80 已经被 nginx 代理 # 接收到指定 server_name 的请求, 流量会被转发到指定的 8080 端口 proxy_pass http://127.0.0.1:8080; &#125;&#125; 检查配置文件的有效性: nginx -t重新加载 nginx 配置信息 nginx -s reload","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"规则","slug":"规则","permalink":"http://yoursite.com/tags/规则/"},{"name":"实践","slug":"实践","permalink":"http://yoursite.com/tags/实践/"}]},{"title":"SqlServer2005学习总结","slug":"SqlServer2005学习总结","date":"2017-01-17T09:42:17.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/01/17/SqlServer2005学习总结/","link":"","permalink":"http://yoursite.com/2017/01/17/SqlServer2005学习总结/","excerpt":"第一部分：数据库相关概念什么是数据库","text":"第一部分：数据库相关概念什么是数据库 狭义: 存情数据的仓库 广义: 可以对数据进行存储和管理的软件以及数据本身统称为数据库 数据库是由表、 关系、 操作组成 为什么需要数据库 几乎所有的应用软件的后台都需要数据库 数据库存储数据占用空间小容易持久保存 存储比较安全 容易维护和升级 数据库移植比较容易 简化对数据的操作 为将来学习0racle做准备 B/s架构里面包含数据库数据库的安装和卸载 sq12000 解决挂起的问题 预备知识 学习SqlServer2005必须的先学一门编程语言么 不需要,但是懂一门编程语言的话会有助于学习sqlserver2005 的TL SQ 数据结构和数据库的区别 数据库是在应用软件级别研究数据的存储和操作数据结构是在系统软件级别研究数据的存储和操作 什么是连接 【重点】 有了编程语言为什么还需要数据库 对内存数据操作是编程语言的强项, 但是对硬盘数据操作却是编程语言的弱项对硬盘数据操作是数据库的强项, 是数据库研究的核心同题 建议初学者从三个方面学习数据库数据库是如何存储数据的 字段记录表约束(主键外键唯一键非空 check default触发器) 数据库是如何操作数据的insert update delete T-SQL 存储过程函数触发器 数据库是如何显示数据的select(重点的重点) 必各的一些操作 如何建数据库 如何删除数据库 如何附加和分高数据库 设置登录用户名和密码 如何创建用户 数据库是如何解决数据存储问题的 【最基础内容, 必须掌握】 1.表的相关数据 字段 一个事物的某一个特征 记录 字段的组合表示的是一个具体的事物 表 记录的组合表示的是同一类型事物的集合 表和字段、记录的关系 字段是事物的属性 记录是事物本身 表是事物的集合 列 字段的另一种称谓 属性 字段的另一种称谓 元组 记录的另一种称谓 2. create table命令 通过图形化界面建表create table最后一个字段的后面建议不要写逗号说明:简単掌握后面我们会再详细的介绍 3. 什么是约束 定义 对一个表中属性操作的限制叫做约束 分类 主键约束不允许重复元素選免了数据的冗余 外键约束 通过外键约束从语法上保证了本事物所 关联的其他事物一定是存在的 事物和事物之间的关系是通过外键来体现的 check约束 保证事物属性的取值在合法的范围之内 default约束 保证事物的属性一定会有一个值 唯一约束 保证了事物属性的取值不允许重复,,但允许其中有一列且只能有一列为空 间题: ul,i que键是否允许多列为空? 答: SqlServer2005只允许一个uni que列为空 Oracle1 IG允许多个uni que列为空 not null 要求用户必须的为该属性赋一个值,否则语法出错! 如果一个字段不写n,11也不行not n,11 则默认是rm11即默认允许为空,用户可以不给该字段赋值 如果用户没有为该字段赋值,则该字段的值默认是nd1 要注意nu11和 default的区别 相同点: 都允许用户不赋值 不同点: nu11修饰的字段如果用户不赋值则默认是nu1 1 default修饰的字段如果用户不赋値则默认是default指定的那个值 4. 表和约束的异同 数据库是通过表来解决事物的存備同题的 数据库是通过约束来解决事物取值的有效性和合法性的问题 建表的过程就是指定事物属性及其事物属性各种约束的过程 什么是关系 定义:表和表之间的联系 实现方式 通过设置不同形式的外键来体现表和表的不同关系 分类(假设是A表和B表) 一对一既可以把表A 的主键充当表B的外键也可以把表B的主键充当表A的外键 一对多【重点】把表A 的主键充当表B的外键或者讲: 把A表的主键添加到B表来充当B表的外键 在多的一方添加外键 多对多多对多必须的通过単独的一张表来表示 例子 班级和教师 班级是一张表 教师是一张表 班级和教师的关系也是一张表 6. 主键 定义 能够唯一标示一个事物的一个字段或者多个字段的组合, 被称为主键 主键的特点【重点】: 含有主键的表叫做主键表 主键通常都是整数不建议使用字符串当主體(如果主體是用于集群式服务,才可以考虑用字符串当主體) 主键的值通常都不允许修改, 除非本记录被删除 主键不要定义成i d, 而要定义成表名 Id或者表名_i d 要用代理主键,不要用业务主键 任何一张表, 强烈建议不要使用有业务含义的字段充当主键 我们通常都是在表中単独添加一个整型的编号充当主键字段 主键是否连续增长不是十分重要 7. 外键 定义: 如果一个表中的若干个字段是来自另外若干个表的主键或唯一键则这若干个字段就是外键 注意: 外键通常是来自另外表的主键而不是唯一键, 因为唯一键可能为M11 外键不一定是来自另外的表, 也可能来自本表的主键 含有外键的表叫外建表, 外键字段来自的那一张表叫做主键表 问题: 先删主键表还是外建表? 答集: 先删外建表如果先删主键表,会报错,因为这会导致外建表中的数据引用失败 第二部分：查询査询【最重要难度最大,考试必考内容,强烈建议所有的学生都要熟练掌握査询的内容】 1.计算列 from emp;```12345- -- *表示所有的- -- from emp 表示从emp表査询```select empno, ename from emp ename, sa1 from emp;```1234567- select ename, sa1*12 as″年薪″ from emp;- --as可以省略记住:″年薪″不要写成&apos;年薪&apos;也不要写成年薪- select ename, sa1*12 as″年薪″, sa1″月薪″, job from emp;```select888 from emp; –ok-一输出的行数是emp表的行数 每行只有一个字段, select5; –ok-一不推荐 注意: 在0racle中字段的别名不允许用单引号括起来 但是sqlserver2005却允许,,因此为了兼容性 -最好字段别名用双引号括起来, 不要用单引号 2. distinct【不允许重复的】 distinct deptno from emp;```1```--distince deptno会过滤掉重复的deptno distinct comm from emp;```123456789--distinct也可以过滤掉重复的nu11 或者说如果有多个nu11只输出一个```select distinct comm, deptno from emp;```-一把comm和deptno的组合进行过滤```select deptno, distinct comn from emp1```--error逻辑上有冲突**3. between【在某个范围】**- -一査找工资在1 500到3000之间(包括和)的所有的员工的信息```select* from e1lIpwhere sa1&gt;=1500 and sa1&lt;=3000 等价于from emp1where sa1 between1500 and3000 -一査找工资小于3ooo或大于1 5oo的所有的员工的信息from emp where sa13000```12等价于```select* from emp where sa1 not between1500 and3000 4. in【属于若干个弧立的值】 select*from emp where sa1 in(1500, 3000, 5000)123等价于```select* from empwhere sa1=1500 or sa1=3000 or sa1=5000 emp where salnot in(1500, 3000, 5000)``` 12345- -一把sa1既不是也不是也不是的记录输出等价于```select* from enpwhere sa1〇1500 and sat〇3000 and sat〇5000 -一数据库中不等于有两种表示: != &lt;&gt; 推荐使用第二种 -一对或取反是并且对并且取反是或 5. top【最前面的若干个记录专属于sqlserver的语法,不可移植到其他数据库】 top5 *from emp;```123456789101112131415161718192021222324252627``select top15 percent* from emp; ``` -一输出的是3个,不是2个``select top5 from emp;``` --error**6. nu11【没有值空值】**- 零和rm11是不一样的, nu11表示空值,投有值,零表示一个确定的值- nu11不能参与如下运算: 〇 != =- n111可以参与如下运算: is not is- select* from emp where comm is nu11; -一输出奖金为空的员工的信息```select* from emp where comm is not nu11;``` - 一输出奖金不为空的员工的信息```select* from e叩 where comm 〇 null; ```-一输出为空error```select*from emp where comm !=nu11; ```-一输出为空error```select* from emp where comm = nu11; ``` -一输出为空error- 任何类型的数据都允许为 nu1 1```create table t1 (:l,lamenvarchar(20), cnt int, riqi datetime);insert into t1 values(nu1l, nu11, nu11);``` -0K- 任何数字与rm1 1参与数学运算的结果永远是nu1 1- 一输出每个员工的姓名年薪(包含了奖金) comn假设是一年的奖金```select empno, ename, sa1*12+comm ″年薪&quot; from emp; -一本程序证明了: r,u11不能参与任何数据运算否则结果永远为空 一正确的写法是: ename, sa1*12+isnu11(comm, 0)″年薪″ from emp;```123456789101112131415161718192021222324252627282930313233--is null(comm, 0)如果comm是nu11就返回零否则返回comm的值**7. order by 【以某个字段排序】**- `order by a, b` --a和b都是升序- `order by a, b desc` --a升序 b降序- `order by a desc, b` -a降序 b升序- `order by a desc, b desc` --a和b都是降序- 文字描述: - 如果不指定排序的标准,则默认是升序升序用asc表示默认可以不写 - 为一个字段指定的排序标准并不会对另一个字段产生影响强烈建议为每一个字段都指定排序的标准**例子:** - asc是升序的意思默认可以不写 desc是降序`select* from emp order by sa1;` 一默认是按照升序排序 select*from emp order by deptno, sa1;- -一先按照deptno升序排序,如果deptno相同,再按照sa1升序排序 select* from emp order by deptno desc, sa1;- -一先按deptno降序排序如果deptno相同再按照sal升序排序- -一记住sa1是升序不是降序`--orderby a desc, b, c, d` desc只对a产生影响不会对后面的b c d产生影响```select*from emp order by deptno, sa1 desc -一问题: desc是否会对deptno产生影响? -一答案:不会 -一先按deptno升序,如果deptno相同,再按sa1降序 8.模糊査询 【搜索时经常使用】 格式:select字段的集合 from表名 where某个字段的名字1ike匹配的条件匹配的条件通常含有通配符 通配符:%表示任意o个或多个字符 emp where enamelike'%A%' ``` 123456- --ename只要含有字母A就输出```select*from emp where enamelike&apos;A%&apos; ``` - -ename只要首字母是A的就输出```select* from emp where enamelike&apos;%A&apos; -ename只要尾字母是A的就输出 [这是下划线不是減号] 表示任意单个字符 from emp where enamelike'_A%'```12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- -ename只要第二个字母是A的就输出**[a-f]**- a到f中的任意单个字符只能是a b c d e f中的任意一个字符`select* from emp where` - `enamelike&apos;_[A-F]%&apos;&apos;&apos;`-一把ename中第二个字符是A或B或c或D或E或F的记录输出**[a, f]**- a或f**[a-c]**- 不是a也不是b也不是c的任意单个字符`select* from emp where enamelike&apos;_[A-F]%&apos;&apos;&apos;`-一把ename中第二个字符不是A也不是B也不是c也不是D也不是E也不是F的记录输出**注意:**- 匹配的条件必须的用单引号括起来 不能省略也不能改用双引号通配符作为不同字符使用的同题```select* from student where namelike&apos;%\\%%&apos; escape&apos;\\&apos; ``` -一把name中包含有%的输出```select* from student where namelike&apos;%\\_%&apos; escape&apos;\\&apos;``` 一把name中包含有_的输出**9.聚合函数【多行记录返回至一个值通常用于统计分组的信息】函数的分类**- 単行函数 - 每一行返回一个值- 多行函数 - 多行返回一个值 - 聚合函数是多行函数 **例子:**```selectlower(ename) from emp;``` 一最终返回的是行1ower0是单行函数`select max(sa1) from emp;` 一返回行max0是多行函数**聚合函数的分类**- max()-min()-avg() 平均值-count()求个数-count(*)返回表中所有的记录的个数`select count(*) from emp;` -一返回emp表所有记录的个数count(字段名)- 返回字段值非空的记录的个数, 重复的记录也会被当做有效的记录```select courlt(deptno) from emp; -一返回值是这说明deptno重复的记录也被当做有效的记录 coul,it(l1omm) from emp;``1234567- -一返回値是这说明 c omm为ru」1 1的记录不会被当做有效的记录- count(distinct字段名) - 返回字段不重复并且非空的记录的个数```select count(distinct deptno) from emp; -一返回值是 统计deptno不重复的记录的个数 注意的问题 判断如下sq1语句是否正确 ma:x(sa1), min(sa1), count(*) from emp; ```--ok12345678910111213141516select max(sa1) -最高工资″, min(sa1)″最低工资″, count(*)″员工人数″ from emp; --ok```select max(sa1), 1ower(ename) from emp;``` --error单行函数和多行函数不能混用```select ma;x(sa1) from emp;``` --ok默认把所有的信息当做一组**10. group by 【分组难点】**- 格式: - group by字段的集合- 功能: - 把表中的记录按照字段分成不同的组**例子**- 査询不同部门的平均工资```select deptno, avg(sa1) as″部门平均工资⊠ from emp group by deptno 注意: 理解: gro·up by a, b, c的用法 先按a分组,如果a相同,再按b分组,如果b相同,再按c分组 最终统计的是最小分组的信息 一定要明自下列语句为什么是错误的 select deptno, avg(sa1) as″部门平均工资⊠, enamefrom emp解oup by deptno select deptno, enamefrom emp解oup by deptno select deptno, job, sa1from emp解oup by deptno, job记住:使用了gro1」p by之后select 不能出现组内的详细信息中只能出现分组后的整体信息, 11. having【对分组之后的信息进行过滤难点】 having子句是用来对分组之后的数据进行过滤因此使用having时通常都会先使用group by 如果没使用gro·L!p by但使用了having则意味着having把所有的记录当做一组来进行过滤极少用 count(*)12from emphaving avg(sa1) &gt; 1000 having子句出现的字段必须的是分组之后的组的整体信息having子句不允许出现组内的详细信息 尽管select字段中可以出现别名 但是having子句中不能出现字段的别名, 只能使用字段最原始的名字原因不得而知 having和where的异同 相同的: 都是对数据过滤,只保留有效的数据where和having一样, 都不允许出现字段的别名,,只允许出现最原始的字段的名字,本结论在S‘11Server2005和Olracle11G都成立 不同: where是对原始的记录过滤 having是对分组之后的记录过滤 where必须的写在having的前面,顺序不可颠倒否则运行出错 例子: 一把工资大于,-一统计输出部门平均工资大于的部门的部门编号部门的平均工资select deptno, avg(sa1)″平均工资″, count(*)″部门人数″,,max(sa1) ″部门的最高工资″from empwhere sa1 &gt;2000 –where是对原始的记录过滤group by deptnohaving avg(sa1) &gt; 3000 -一对分组之后的记录过滤 一判断入选语句是否正确 select deptno, avg(sal)″平均工资″, count(*)″部门人数″,,max(sa1) ″部门的最高工资″ fromemp group by deptno having avg(sa1) &gt;3000 -一对分组之后的记录过滤 where sa1 &gt;2000 一一where写在了having的后面 error 12.连接査询 定义 将两个表或者两个以上的表以一定的连接条件连接起来 从中检索出满足条件的数据 分类 内连接【重点的重点也是难点的难点】 select... fromA, B的用法产生的结果: 行数是A和B的乘积 列数是A和B之和 或者说油表的每一条记录都和B表的每一条记录组合在一起形成的是个笛卡尔积 或者说: 把B表的每一条记录都和A表的每一条记录组合在一起形成的是个笛卡尔积 注意: from A, B```12输出结果和```select* from B, A 是一模一样的 例子-一输出70行11列from emp, dept```1234567891011121314**2. select... from A, Bwhere... 的用法**```select... from A, B ``` --A和B可以互换产生的簡卡尔积, 用where中的条件进行过滤**例子:**-一输出5行11列select*from emp, dept --dept和emp互换输出结果不变where empno= 7369- select... from A join B on... select... from A join B on- SQL92标准和 SQL99标准的区别```select... from A, B where. from A join B on```12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182输出结果是一样**推荐使用 sQL99标准**- sq199更容易理解- 在sq199标准中, on和,rhere可以做不同的分工on指定连接条件where对连接之后临时表的数据进行过糖**示例:**一把工资大于2000的员工的姓名和部门的名称输出 和 工资的等级-sc1199标准明显的优于sq192 select″E″.enae,″D″.hme,″S&quot;.grade from e叩 &quot;E″ join dept″D″ on″E″.deptno=″D〟.deptno Join salgrade″S″ on″E″.sa1&gt;=″S″.1osal md&quot;E″.sa1 &lt;=″S″.hisal where″E&quot;.sa1 &gt; 2000一把工资大于2ooo的员工的姓名和部门的名称输出 和 工资的等级-sq192标准 select″E″.en訓e,″D″.如ae,″S″.grade from e叩 ″E″, dept&quot;D〟, salpade″S″ where″E&quot;,sa1 &gt; 2000 md &quot;E″,deptno=″D″,deptno md (″E″.sa1&gt;=″S″.1osa1 md -E″.sa1 &lt;=″S″.hisa1)**5. select、 from、 where、 Join、 on、 group、 order、 top、 having的混合使用****査询的顺序**- select top....- from A- join B- on....- join C- on....- where,.....- group by...- having. , , . .- order by.....**例子:**- -一把工资大于的所有的员工按部门分组把部门平均工资大于的最- -一高前个的部门的编号部门的名称部 「J平均工资的等级- **一第一种写法**&gt; select&quot;T″,*, &quot;D″,如ae, &quot;S″.grade&gt; from dept″D″&gt; join(select top2″E&quot;.deptno, avg(sa1)″avg_sa1″&gt; from emp″E″&gt; join dept″D″&gt; on″E″.deptno=″D&quot;.deptno&gt; Join salpade″S&quot;&gt; on -E″.sa1 between〃S&quot;.1osa1 nd″S&quot;.hisa1&gt; where ⊠E&quot;.sa1 &gt; 1500&gt; group by ⊠E″.deptno&gt; having avg(″E〟.sat) &gt; 2000&gt; order by avg(&quot;E&quot;.sat) desc&gt; ) ″T″&gt; on&quot;D〟.deptno=″T″.deptno&gt; imer join salgrade″S&quot;&gt; on″T&quot;.″avg_sa1&quot; between&quot;S″.1osa1 nd&quot;S″.hisa1- **一第二种写法**&gt; select″T-.*, ″D-. hae, ″S&quot;.grade from dept″D″ join(select top2&gt; deptno, avg(sa1) as″avg_sa1″ from emp where sa1 &gt; 1500 group by&gt; deptno having avg(sa1) &gt; 2000 order by″avg_sa1″ desc ) ″T″&gt; on″D″.deptno=″T″.deptno Join salgrade″S&quot; on″T&quot;.″avg_sa1″&gt; between″S″.1osa1 nd″S″,hisal**6. 习题**- 判断以下语句输出是几行```select&apos;l: from emp, dept where emp.deptno= 10 from emp, dept where dept.deptno1234567891011121314151617181920212223242526272829303132333435363738394041- -一过滤条件不是连接条件考虑如何把selelit:* from emp, dept where dept.dept:lio= 10 以sq199标准来输出1&gt;求出每个员工的姓名部门编号薪水和薪水的等级2&gt;査找每个部门的编号该部门所有员工的平均工资平均工资的等级3&gt;査找每个部门的编号部门名称该部门所有员工的平均工资平均工资的等级4&gt;求出emp表中所有领导的信息5&gt; 求出平均薪水最高的部门的编号和部门的平均工资6&gt;把工资大于所有员工中工资最低的前3个人的姓名工资部门编号部门名称工资等级输出**自连接**- 定义 - 一张表自己和自己连接起来査询数据 **例子** - 不准用聚合函数求薪水最高的员工的信息**联合**- 定义 - 表和表之间的数据以纵向的方式连接在一起 - **注意:** 我们以前讲的所有的连接是以横向的方式连接在一起的**例子:**- 输出每个员工的姓名工资上司的姓名```select&quot;E1″,enae,″E1″.sa1, ″E2″.en訓e″上司的姓名″from emp″E1″Join emp″磁″on&quot;E1&quot;.m解 =″E2″.empnouni onselect ename, sa1, &apos;已是最大老板&apos; from emp where mgr is nul1 注意: 若干个select子句要联合成功的话,必须的满足两个条件 这若干个select子句输出的列数必须是相等的 这若干个se1 ect子句输出列的数据类型至少是兼容的 identity【主键自动增长,用户不需要为identity修饰的主键赋值】用户如何手动给被i dent i ty修饰的主键赋值不重要 表中删除数据后又插入数据会导致主键不连续递增 怎么办?主键是否连续增长不十分重要 视图 为什么需要视图 示例 求出平均工资最高的部门的编号和部门的平均工资 总结: 简化査询 避免了代码的冗余 避免了书写大量重复的sq1语句 什么是视图 视图从代码上看是一个select语句 视图从逻辑上看被当做一个虚拟表看待 如何创建视图 create view视图的名字as-se1 ect的前面不能添加beginselect语句-se1 ect的后面不能添加end 注意的问题 创建视图的 se1 ec t语句必须的为所有的计算列指定别名-errorcreate view v$_aasselect avg(sa1) from emp; -okcreate view v$_a asselect avg(sa1) as ⊠avg_sa1″ from emp; 视图不是物理表,是虚拟表 不建议通过视图更新视图所依附的原始表的数据或结构 视图的优点 简化査询 增加数据的保密性 视图的缺点 增加了数据库维护的成本 视图只是简化了査询,但是并不能加快査询的速度这也是视图使用不足的地方 事务【重要】 初学者必须要理解的三个概念 事务是用来研究什么的 避免数据处于不合理的中间状态 转账 怎样保证多用户同时访间同一个数据时呈现给用户的数据是合理的很复杂,现在人类仍然投有设计出很好的解决办法! 事务和线程的关系 事务是通过锁来解决并发访问的 线程同步也是通过锁来解决并发访同的 synchronized 所谓并发访同是指: 多用户同时访同同一个数据 事务和第三方插件的关系 直接使用事务库技术难度很大 很多人是借助第三放插件来实现 因此我们一般人不需要细细的研究数据库中事务的语法细节 第三方插件要想完成预期的功能, 一般必须的借助数据库中的事物机制来实现 索引 存储过程游标 TL_SQL 触发器 分页査询 总结 假设每页显示n条记录, 当前要显示的是第m页表名是A 主键是A_idselect top nfrom Awhere A_id not in(select top (m-1)n A_id from emp)","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://yoursite.com/categories/DataBase/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://yoursite.com/tags/sql/"}]},{"title":"webpack学习总结(二)","slug":"webpack-summary","date":"2017-01-14T09:40:43.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2017/01/14/webpack-summary/","link":"","permalink":"http://yoursite.com/2017/01/14/webpack-summary/","excerpt":"","text":"声明 本教程整理于互联网 webpack是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如CommonJs模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS等 一、模块系统的演进 模块系统主要解决模块的定义、依赖和导出，先来看看已经存在的模块系统 &lt;script&gt;标签 1234&lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;libraryA.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;module3.js&quot;&gt;&lt;/script&gt; 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如 YUI 库 这种原始的加载方式暴露了一些显而易见的弊端 全局作用域下容易造成变量冲突 文件只能按照 &lt;script&gt;的书写顺序进行加载 开发人员必须主观解决模块和代码库的依赖关系 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 1.1 CommonJS 服务器端的 Node.js遵循 CommonJS规范，该规范的核心思想是允许模块通过require方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口 1234require(&quot;module&quot;);require(&quot;../file.js&quot;);exports.doStuff = function() &#123;&#125;;module.exports = someValue; 优点： 服务器端模块便于重用 NPM 中已经有将近20万个可以使用模块包 简单并容易使用 缺点： 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的 不能非阻塞的并行加载多个模块 实现 服务器端的 Node.js Browserify，浏览器端的 CommonJS 实现，可以使用 NPM的模块，但是编译打包后的文件体积可能很大 modules-webmake，类似Browserify，还不如 Browserify 灵活 wreq，Browserify的前身 1.2 AMD Asynchronous Module Definition 规范其实只有一个主要接口define(id?, dependencies?,factory) ，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到factory 中，对于依赖的模块提前执行，依赖前置 123define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123;return someExportedValue;&#125;);require([&quot;module&quot;, &quot;../file&quot;], function(module, file) &#123; /* ... */ &#125;); 优点： 适合在浏览器环境中异步加载模块 可以并行加载多个模块 缺点： 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义 不顺畅 不符合通用的模块化思维方式，是一种妥协的实现 实现： RequireJS curl 1.3 CMD Common Module Definition 规范和 AMD很相似，尽量保持简单，并与 CommonJS 和Node.js 的 Modules规范保持了很大的兼容性 123456define(function(require, exports, module) &#123;var $ = require(&apos;jquery&apos;);var Spinning = require(&apos;./spinning&apos;);exports.doSomething = ...module.exports = ...&#125;) 优点： 依赖就近，延迟执行 可以很容易在 Node.js 中运行 缺点： 依赖 SPM 打包，模块的加载逻辑偏重 实现： Sea.js coolie 1.4 ES6 模块 EcmaScript6 标准增加了 JavaScript语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和AMD 模块，都只能在运行时确定这些东西 123import &quot;jquery&quot;;export function doStuff() &#123;&#125;module &quot;localModule&quot; &#123;&#125; 优点： 容易进行静态分析 面向未来的 EcmaScript标准 缺点： 原生浏览器端还没有实现该标准 全新的命令字，新版的 Node.js才支持 实现： Babel 1.5 前端模块加载 前端模块要在客户端中执行，所以他们需要增量加载到浏览器中 模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是把所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴 分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案 要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程 1.6 所有资源都是模块 在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等 如果他们都可以视作模块，并且都可以通过 require 的方式来加载，将带来优雅的开发体验，比如 1234require(&quot;./style.css&quot;);require(&quot;./style.less&quot;);require(&quot;./template.jade&quot;);require(&quot;./image.png&quot;); 那么如何做到让 require 能加载各种资源呢？ 1.7 静态分析 在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。比如一个用LESS 写的样式模块，可以先用LESS 加载器将它转成一个CSS模块，在通过 CSS 模块把他插入到页面的 &lt;style&gt; 标签中执行。Webpack就是在这样的需求中应运而生 二、webpack基础知识 2.1 什么是 Webpack Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源 2.2 Webpack 的特点 代码拆分 Webpack有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包 Loader Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack可以处理的模块 智能解析 Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是CommonJS、 AMD还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式require(&quot;./templates/&quot; + name + &quot;.jade&quot;) 插件系统 Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求 快速运行 Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack能够以令人难以置信的速度快速增量编译 2.3 总览 他的目的就是把有依赖关系的各种文件打包成一系列的静态资源 webpack简单点来说就就是一个配置文件，所有的魔力都是在这一个文件中发生的。 这个配置文件主要分为三大块 entry 入口文件 让webpack用哪个文件作为项目的入口 output 出口 让webpack把处理完成的文件放在哪里 module 模块 要用什么不同的模块来处理各种类型的文件 Paste_Image.png 2.4 安装 先装好node和npm，因为webpack是一个基于node的项目。然后 1npm install -g webpack 此时 Webpack已经安装到了全局环境下，可以通过命令行webpack -h 试试 通常我们会将 Webpack安装到项目的依赖中，这样就可以使用项目本地版本的 Webpack 1234# 进入项目目录# 确定已经有 package.json，没有就通过 npm init 创建# 安装 webpack 依赖$ npm install webpack --save-dev Webpack 目前有两个主版本，一个是在 master 主干的稳定版，一个是在 webpack-2 分支的测试版，测试版拥有一些实验性功能并且和稳定版不兼容，在正式项目中应该使用稳定版 1234# 查看 webpack 版本信息$ npm info webpack# 安装指定版本的 webpack$ npm install webpack@1.12.x --save-dev 如果需要使用 Webpack开发工具，要单独安装 1$ npm install webpack-dev-server --save-dev 2.5 建立一个项目 123mkdir webpackcd webpacknpm init 如果你使用git管理你的这个项目的话，建议你新建一个.gitignore文件，不要让git提交一些node依赖的模块 创建一个静态页面 index.html 和一个 JS 入口文件 entry.js： 123456789&lt;!-- index.html --&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12// entry.jsdocument.write('It works.') 然后编译 entry.js 并打包到 bundle.js： 1$ webpack entry.js bundle.js 打包过程会显示日志： 123456Hash: e964f90ec65eb2c29bb9Version: webpack 1.12.2Time: 54msAsset Size Chunks Chunk Namesbundle.js 1.42 kB 0 [emitted] main[0] ./entry.js 27 bytes &#123;0&#125; [built] 用浏览器打开 index.html 将会看到 It works. 接下来添加一个模块 module.js并修改入口 entry.js： 12// module.jsmodule.exports = &apos;It works from module.js.&apos; 123// entry.jsdocument.write(&apos;It works.&apos;)document.write(require(&apos;./module.js&apos;)) // 添加模块 重新打包 webpack entry.js bundle.js后刷新页面看到变化 It works.It works from module.js. Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到bundle.js 。Webpack 会给每个模块分配一个唯一的id并通过这个id 索引和访问模块。在页面启动时，会先执entry.js 中的代码，其它模块会在运行require的时候再执行 三、Loader Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader进行转换 Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如CoffeeScript、 JSX、 LESS 3.1 loader 有哪些特性 Loader 可以通过管道方式链式调用，每个 loader 可以把资源转换成任意格式并传递给下一个 loader ，但是最后一个 loader 必须返回 JavaScript Loader可以同步或异步执行。 Loader 运行在 node.js 环境中，所以可以做任何可能的事情。 Loader 可以接受参数，以此来传递配置项给 loader。 Loader 可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。 Loader可以通过 npm发布和安装。 除了通过 package.json的 main指定，通常的模块也可以导出一个 loader来使用。 Loader 可以访问配置。 插件可以让 loader 拥有更多特性。 Loader可以分发出附加的任意文件 Loader本身也是运行在 node.js 环境中的 JavaScript模块，它通常会返回一个函数。大多数情况下，我们通过 npm 来管理 loader，但是你也可以在项目中自己写 loader 模块 按照惯例，而非必须，loader 一般以 xxx-loader 的方式命名， xxx 代表了这个 loader要做的转换功能，比如 json-loader 在引用 loader 的时候可以使用全名 json-loader ，或者使用短名 json。这个命名规则和搜索优先级顺序在webpack 的resolveLoader.moduleTemplates api中定义 1Default: [&quot;*-webpack-loader&quot;, &quot;*-web-loader&quot;, &quot;*-loader&quot;, &quot;*&quot;] Loader可以在 require()引用模块的时候添加，也可以在 webpack 全局配置中进行绑定，还可以通过命令行的方式使用 我们要在页面中引入一个CSS文件style.css，首页将 style.css也看成是一个模块，然后用 css-loader 来读取它，再用style-loader把它插入到页面中 1234/* style.css */body &#123; background: yellow; &#125; 修改 entry.js： 123require(&quot;!style!css!./style.css&quot;) // 载入 style.cssdocument.write(&apos;It works.&apos;)document.write(require(&apos;./module.js&apos;)) 安装 loader： 1npm install css-loader style-loader 重新编译打包，刷新页面，就可以看到黄色的页面背景了 如果每次 require CSS 文件的时候都要写 loader 前缀，是一件很繁琐的事情。我们可以根据模块类型（扩展名）来自动绑定需要的 loader 将 entry.js 中的 require(&quot;!style!css!./style.css&quot;)修改为 require(&quot;./style.css&quot;)，然后执行： 123$ webpack entry.js bundle.js --module-bind &apos;css=style!css&apos;# 有些环境下可能需要使用双引号$ webpack entry.js bundle.js --module-bind &quot;css=style!css&quot; 显然，这两种使用 loader 的方式，效果是一样的 四、配置webpack Webpack在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目webpack.config.js 文件，这个文件是一个 node.js模块，返回一个json 格式的配置信息对象，或者通过 --config 选项来指定配置文件 现在开始配置webpack，目标是把这两个js文件合并成一个文件. 我们可以自己在build文件夹里面手动建一个index.html文件夹，然后再把合并以后的js引用在里面，但是这样有些麻烦，所以我们这里安装一个plugin，可以自动快速的帮我们生成HTML 创建一个配置文件 webpack.config.js 12345678910111213var webpack = require(&apos;webpack&apos;)module.exports = &#123;entry: &apos;./entry.js&apos;,output: &#123;path: __dirname,filename: &apos;bundle.js&apos;&#125;,module: &#123;loaders: [&#123;test: /\\.css$/, loader: &apos;style!css&apos;&#125;]&#125;&#125; 同时简化 entry.js 中的 style.css 加载方式 require(&#39;./style.css&#39;) 最后运行 webpack ，可以看到 webpack 通过配置文件执行的结果和通过命令行webpack entry.js bundle.js --module-bind &#39;css=style!css&#39;执行的结果是一样的 1npm install html-webpack-plugin --save-dev 有了这个插件 开始写config文件 123456789101112131415161718192021var path = require(&apos;path&apos;);var HtmlwebpackPlugin = require(&apos;html-webpack-plugin&apos;);//定义了一些文件夹的路径var ROOT_PATH = path.resolve(__dirname);var APP_PATH = path.resolve(ROOT_PATH, &apos;app&apos;);var BUILD_PATH = path.resolve(ROOT_PATH, &apos;build&apos;);module.exports = &#123;//项目的文件夹 可以直接用文件夹名称 默认会找index.js 也可以确定是哪个文件名字entry: APP_PATH,//输出的文件名 合并以后的js会命名为bundle.jsoutput: &#123;path: BUILD_PATH,filename: &apos;bundle.js&apos;&#125;,//添加我们的插件 会自动生成一个html文件plugins: [new HtmlwebpackPlugin(&#123;title: &apos;Hello World app&apos;&#125;)]&#125;; 然后在项目根目录运行 1webpack 你会发现多出来一个build文件夹，直接点开里面的html文件，你会发现我们可爱的“hello world”已经插入到页面了。我们的任务完成了，成功生成html，合并js，html引入了js，js被执行了 4.1 配置webpack-dev-server 上面任务虽然完成了，但是我们要不断运行程序然后查看页面，所以最好新建一个开发服务器，可以serve我们pack以后的代码，并且当代码更新的时候自动刷新浏览器 安装webpack-dev-server 1npm install webpack-dev-server --save-dev 安装完毕后在config中添加配置 12345678910module.exports = &#123;devServer: &#123;historyApiFallback: true,hot: true,inline: true,progress: true,&#125;,&#125; 然后再package.json里面配置一下运行的命令,npm支持自定义一些命令 123&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;webpack-dev-server --hot --inline&quot;&#125;, 在项目根目录下输入npm start,一堆花花绿绿的信息后server已经起来了，在浏览器里面输入http://localhost:8080发现hello world出现了，在js里面随便修改一些输出,然后保存,浏览器自动刷新，新的结果出现了 拓展阅读 如果你的服务器端使用的是express框架，你还可以直接安装express的middleware，webpack配合express，很好用 1npm install webpack-dev-middleware --save-dev 4.2 添加CSS样式 现在来添加一些样式，webpack使用loader的方式来处理各种各样的资源，比如说样式文件，我们需要两种loader，css-loader和 style－loader，css-loader会遍历css文件，找到所有的url(...)并且处理。style-loader会把所有的样式插入到你页面的一个style tag中 安装我们的loader 1npm install css-loader style-loader --save-dev 配置loader，在webpack.config.js中 1234567891011121314151617181920devServer: &#123;historyApiFallback: true,hot: true,inline: true,progress: true,&#125;,...module: &#123;loaders: [&#123;test: /\\.css$/,loaders: [&apos;style&apos;, &apos;css&apos;],include: APP_PATH&#125;]&#125;,...plugins: [new HtmlwebpackPlugin(&#123;title: &apos;Hello World app&apos; 看loaders的书写方式，test里面包含一个正则，包含需要匹配的文件，loaders是一个数组，包含要处理这些程序的loaders，这里我们用了css和style，注意loaders的处理顺序是从右到左的，这里就是先运行css-loader然后是style-loader 新建一个样式文件 main.css 123h1 &#123;color: red;&#125; 记得在入口文件index.js中引用 1require(&apos;./main.css&apos;); 然后发现标题变成红色的了，webpack的理念是基于项目处理的，把对应的文件格式给对应的loader处理，然后你就不用管了，它会决定怎么压缩，编译 那现在想使用一些有爱的css预编译程序，来点sass吧。 你可能已经想到了，再来个loader就行啦，确实是这样简单 1npm install sass-loader --save-dev 稍微修改一下config，删掉我们先前添加的css规则，加上下面的loader 12345&#123;test: /\\.scss$/,loaders: [&apos;style&apos;, &apos;css&apos;, &apos;sass&apos;],include: APP_PATH&#125;, 添加两个sass文件，variables.scss和main.scss variables.scss 1$red: red; main.scss 1234@import &quot;./variables.scss&quot;;h1 &#123;color: $red;&#125; 在index.js中引用1require(&apos;./main.scss&apos;); 然后发现标题如愿变红 4.3 处理图片和其他静态文件 这个和其他一样，也许你也已经会玩了。安装loader，处理文件。诸如图片，字体等等，不过有个神奇的地方它可以根据你的需求将一些图片自动转成base64编码的，为你减轻很多的网络请求 安装url-loader 1npm install url-loader --save-dev 配置config文件 1234&#123;test: /\\.(png|jpg)$/,loader: &apos;url?limit=40000&apos;&#125; 注意后面那个limit的参数，当你图片大小小于这个限制的时候，会自动启用base64编码图片 新建一个imgs文件夹，往里面添加一张照片。在scss文件中添加如下的东西 12345@import &quot;./variables.scss&quot;;h1 &#123;color: $red;background: url(&apos;./imgs/avatar.jpg&apos;);&#125; npm start, 然后查看图片的url 4.4 添加第三方库 有的时候还想来点jquery，moment，undersocre之类的库webpack可以非常容易的做到这一点 那么我们现在安装在我们的app中添加jquery和moment的支持 1npm install jquery moment --save-dev 在js中引用 12345678var sub = require(&apos;./sub&apos;);var $ = require(&apos;jquery&apos;);var moment = require(&apos;moment&apos;);var app = document.createElement(&apos;div&apos;);app.innerHTML = &apos;&lt;h1&gt;Hello World it&lt;/h1&gt;&apos;;document.body.appendChild(app);app.appendChild(sub());$(&apos;body&apos;).append(&apos;&lt;p&gt;look at me! now is &apos; + moment().format() + &apos;&lt;/p&gt;&apos;); 看看浏览器，成功！ jquery和moment现在都起作用了 4.5 添加ES6的支持 首先 装各种loader 1npm install babel-loader babel-preset-es2015 --save-dev 配置我们的config文件 12345678&#123;test: /\\.jsx?$/,loader: &apos;babel&apos;,include: APP_PATH,query: &#123;presets: [&apos;es2015&apos;]&#125;&#125;, es2015这个参数是babel的plugin，可以支持各种最新的es6的特性，具体的情况看这个链接 现在我们可以改掉CommonJS风格的文件了 sub.js 12345export default function() &#123; var element = document.createElement(&apos;h2&apos;); element.innerHTML = &quot;Hello h2 world hahaha&quot;; return element;&#125; index.js 123456789101112import &apos;./main.scss&apos;;import generateText from &apos;./sub&apos;;import $ from &apos;jquery&apos;;import moment from &apos;moment&apos;;let app = document.createElement(&apos;div&apos;);const myPromise = Promise.resolve(42);myPromise.then((number) =&gt; &#123;$(&apos;body&apos;).append(&apos;&lt;p&gt;promise result is &apos; + number + &apos; now is &apos; + moment().format() + &apos;&lt;/p&gt;&apos;);&#125;);app.innerHTML = &apos;&lt;h1&gt;Hello World it&lt;/h1&gt;&apos;;document.body.appendChild(app);app.appendChild(generateText()); 我们上面测试了import,export，const，let，promise等一系列es6的特性 五、插件 插件可以完成更多 loader 不能完成的功能 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定 Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件 接下来，我们利用一个最简单的 BannerPlugin 内置插件来实践插件的配置和运行，这个插件的作用是给输出的文件头部添加注释信息 修改 webpack.config.js，添加 plugins 12345678910111213141516var webpack = require(&apos;webpack&apos;)module.exports = &#123;entry: &apos;./entry.js&apos;,output: &#123;path: __dirname,filename: &apos;bundle.js&apos;&#125;,module: &#123;loaders: [&#123;test: /\\.css$/, loader: &apos;style!css&apos;&#125;]&#125;,plugins: [new webpack.BannerPlugin(&apos;This file is created by zhaoda&apos;)]&#125; 然后运行 webpack ，打开 bundle.js ，可以看到文件头部出现了我们指定的注释信息 12345/*! This file is created by zhaoda *//******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;// 后面代码省略 六、开发环境 当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色 1$ webpack --progress --colors 如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的 1$ webpack --progress --colors --watch 当然，使用 webpack-dev-server开发服务是一个更好的选择。它将在 localhost:8080 启动一个 express 静态资源 web服务器，并且会以监听模式自动运行 webpack，在浏览器打开http://localhost:8080/或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面 1234# 安装$ npm install webpack-dev-server -g# 运行$ webpack-dev-server --progress --colors 七、故障处理 Webpack 的配置比较复杂，很容出现错误，下面是一些通常的故障处理手段 一般情况下，webpack如果出问题，会打印一些简单的错误信息，比如模块没有找到。我们还可以通过参数 --display-error-details来打印错误详情 1234567891011121314151617181920212223242526$ webpack --display-error-detailsHash: a40fbc6d852c51fceadbVersion: webpack 1.12.2Time: 586msAsset Size Chunks Chunk Namesbundle.js 12.1 kB 0 [emitted] main[0] ./entry.js 153 bytes &#123;0&#125; [built] [1 error][5] ./module.js 43 bytes &#123;0&#125; [built]+ 4 hidden modulesERROR in ./entry.jsModule not found: Error: Cannot resolve &apos;file&apos; or &apos;directory&apos; ./badpathmodule in /Users/zhaoda/data/projects/webpack-handbook/examplesresolve file/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js doesn&apos;t exist/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json doesn&apos;t existresolve directory/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule doesn&apos;t exist (directory default file)/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule/package.json doesn&apos;t exist (directory description file)[/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.webpack.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.web.js][/Users/zhaoda/data/projects/webpack-handbook/examples/badpathmodule.json]@ ./entry.js 3:0-26 Webpack的配置提供了 resolve 和resolveLoader 参数来设置模块解析的处理细节， resolve用来配置应用层的模块（要被打包的模块）解析， resolveLoader用来配置loader模块的解析 当引入通过 npm 安装的 node.js 模块时，可能出现找不到依赖的错误。Node.js模块的依赖解析算法很简单，是通过查看模块的每一层父目录中的 node_modules 文件夹来查询依赖的。当出现 Node.js模块依赖查找失败的时候，可以尝试设置 resolve.fallback和resolveLoader.fallback 来解决问题 1234module.exports = &#123;resolve: &#123; fallback: path.join(__dirname, &quot;node_modules&quot;) &#125;,resolveLoader: &#123; fallback: path.join(__dirname, &quot;node_modules&quot;) &#125;&#125;; Webpack中涉及路径配置最好使用绝对路径，建议通过 path.resolve(__dirname,&quot;app/folder&quot;) 或 path.join(__dirname, &quot;app&quot;, &quot;folder&quot;)的方式来配置，以兼容 Windows环境 八、开发和部署技巧 8.1 启用source-map 现在的代码是合并以后的代码，不利于排错和定位，只需要在config中添加 1devtool: &apos;eval-source-map&apos;, 这样出错以后就会采用source-map的形式直接显示你出错代码的位置 8.2 使用preLoaders和postLoaders 也许你想在写代码的时候检查自己的js是否符合jshint的规范，那么隆重推荐preLoaders和postLoaders perLoaders顾名思义就是在loaders执行之前处理的，webpack的处理顺序是perLoaders - loaders - postLoaders 安装jshint 1npm install jshint-loader --save-dev 在config文件中配置 12345678910111213141516module: &#123;...//和loaders一样的语法，很简单perLoaders: [&#123;test: /\\.jsx?$/,include: APP_PATH,loader: &apos;jshint-loader&apos;&#125;]&#125;...//配置jshint的选项，支持es6的校验jshint: &#123;&quot;esnext&quot;: true&#125;, 好了 现在每次npm run start的时候就可以看到jshint的提示信息啦 8.3 部署上线 刚才说的各种情况都是在开发时候的情况，那么假如项目已经开发完了，需要部署上线了。我们应该新创建一个单独的config文件，因为部署上线使用webpack的时候我们不需要一些dev-tools,dev-server和jshint校验等 复制我们现有的config文件，命名webpack.production.config.js，将里面关于 devServer等和开发有关的东西删掉 在package.json中添加一个命令 1234&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;webpack-dev-server --hot --inline&quot;,&quot;build&quot;: &quot;webpack --progress --profile --colors --config webpack.production.config.js&quot;&#125;, 当要上线的时候,运行 1npm run build 可以发现build文件夹中生成了所有东西","categories":[{"name":"Build","slug":"Build","permalink":"http://yoursite.com/categories/Build/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack创建vue和vue-router","slug":"webpack创建vue和vue-router","date":"2017-01-13T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/01/13/webpack创建vue和vue-router/","link":"","permalink":"http://yoursite.com/2017/01/13/webpack创建vue和vue-router/","excerpt":"","text":"一、Vue1.安装脚手架工具 （只需要安装一次） npm install --global vue-cli / cnpm install --global vue-cli 2.创建项目 1.cd到项目所在目录 2.官方 vue init webpack my-project （不推荐） 推荐这样创建项目。 vue init webpack-simple my-project (没有语法检查) vue init webpack-simple固定写法 my-project 项目名称 3.cd 到这个项目里面 cd my-project 4.安装依赖 npm install / cnpm install 5.运行 npm run dev 6.编译打包 npm run build 1.安装vue-resource `npm install vue-resource --save / cnpm install vue-resource --save` `npm install vue-resource --save-dev` 2.引入vue-resource import VueResource from ‘vue-resource’ Vue.use(VueResource); /*任何插件引入以后都必须use一下 4.其他页面里面使用 二、Vue-router1.安装vue-router npm install vue-router --save 2.引入vue-router import VueRouter from &#39;vue-router&#39; `Vue.use(VueRouter)` 3.创建组件，引入组件 4.配置路由 1234const routes = [ &#123; path: &apos;/home&apos;, component: Home &#125;, &#123; path: &apos;/news&apos;, component: News &#125;] 5.实例化VueRouter 123const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes &#125;) 6.挂载到vue实例上面 12345new Vue(&#123; el: &apos;#app&apos;, router, render: h =&gt; h(App) &#125;) App.vue一定注意配置 组件显示的视图 1&lt;router-view&gt;&lt;/router-view&gt; 三、gulp和webpack一样是web工程构建工具gulp对项目文件进行流程控制。要进行模块化，需要借助require.js webpack：gulp有的功能，webpack都有。模块化：一个js文件就是一个独立的隔绝的作用域。可以把js文件当成一个对象。 在模块化中，如果a文件需要访问b文件的内容，需要向外暴露出去。 模块化的方式： 1).require.js —–&gt;&gt; 遵循amd规范 2).`es6 model` 输出 `export` 引入 `import` 3).node.js提供的 -----&gt;&gt; common.js规范 //向外暴露 module.exports = &lt;需要暴露的内容&gt;; //引入其他文件暴露的内容 //路径的写法： 1.如果从当前路径找文件需要写&apos;./&apos; 2.如果从node_modules中找模块，就直接写模块名字 2.如果从node_modules中找模块，就直接写模块名字，如果找不到，就会从node内置中找， 还找不到就抛出异常。 var obj = require(&apos;相对路径&apos;); webpack支持的以上模块化的模块化方式借助loader，插件，预设去处理文件。 使用webpack1.安装npm install -g cnpm --registry=https://registry.npm.taobao.org 全局安装 cnpm install -g webpack 查看版本 webpack -v 本地安装(在项目路径下安装) cnpm init ---创建package.json文件 cnpm install webpack --save-dev //卸载：cnpm uninstall webpack --save-dev 简写：cnpm i webpack -D 完成后在package.json文件中出现： //项目的开发依赖，指项目在开发过程中需要用到插件，但是在发布项目后不再需要使用。 &quot;devDependencies&quot;: { &quot;webpack&quot;: &quot;^3.1.0&quot; } //项目的生产依赖，指项目在开发过程中需要用到插件，但是在发布项目后还需要使用。 例： 123456cnpm install jquery --save cnpm install jquery -S 完成后在package.json文件中出现: &quot;dependencies&quot;: &#123; &quot;jquery&quot;: &quot;^3.2.1&quot; &#125; webpack操作：1.webpack编辑js文件。//使用webpack编译文件webpack 源文件 目标文件 2.webpack配置后编译,webpack配置文件:webpack.config.js: 123456789module.exports = &#123; //入口文件 entry: &apos;./js/b.js&apos;, //输出文件 output: &#123; path: __dirname, //__dirname是nodejs的全局变量,指的是当前路径 filename: &apos;js/app.js&apos; &#125;&#125; 如果只有webpack那么只能编译JavaScript文件。 如果需要编译其他文件，css，html，es6，vue，jsx，ts。。。。 loader加载器 plugin 插件 es6箭头函数 es6promise es6modle es6class preset 预设 es6所有插件打包好做成预设 编译`css`文件需要两个`loader：css-loader style-loader` 编译es6语法的loader:babel-loader 第一次安装还需要安装babel命令 npm install -g babel-cli 安装 npm install babel-loader babel-core -D `//babel-loader:babel加载器` //babel-core:babel核心语法es6的预设 npm install babel-preset-es2015 -D babel编译规则需要.babelrc文件配置 四、VueX1.state为状态的参数。 2.getters为获取器，用于过滤的方法获取参数。 3.mutations是改变状态参数的函数，但是不能直接被调用，需要对应的store.commit（可以额外传参数）。 4.actions不是直接修改状态，而是基于mutations，可以执行异步处理 5.store更像一个容器，装着以上的所有函数和参数，最后需要注入到Vue的实例当中。 1.安装vuex cnpm install vuex --save 2.新建文件夹 在这个文件夹里面新建一个store.js 3.在这个js里面引入vue 和vuex 注意use 4.定义state 123456var state=&#123; list:[], /*放增加的数据*/ count:0&#125; 5.mutations 定义方法 12345678910111213141516171819 var mutations=&#123; addData(state,listdata)&#123; //listdata表示穿过来的数据 state.list.push(listdata); &#125;, removeData(state,key)&#123; //key删除数据的索引值 state.list.splice(key,1); &#125;, incCount(state)&#123; state.count++ &#125;&#125; 6.类似于计算属性 1234567var getters=&#123; countState:function(state)&#123; return state.count+100; &#125;&#125; 7.操作 改变mutations context this store 12345var actions = &#123; /*方法*/ doIncCount:function(context) &#123; context.commit(&apos;incCount&apos;) &#125;&#125; 8.VueX使用 要用外面定义好的store 1.引入import store from ‘../vuex/store.js’; 2.注册这个store 123456789101112131415161718192021222324252627282930313233343536import store from &apos;../vuex/store.js&apos;;//引入import Footer from &apos;./Footer.vue&apos;;export default&#123; store,//注册 data()&#123; return &#123; msg:&apos;home&apos;, username:&apos;&apos; &#125; &#125;, methods:&#123; addData()&#123; store.commit(&apos;addData&apos;,this.username); //使用strre.commit(&apos;mutations里面的方法&apos;，传入的参数) &#125;, removeData()&#123; // store.commit(&apos;dec&apos;); &#125;, incCount()&#123; store.commit(&apos;incCount&apos;); &#125; &#125;,components:&#123; &apos;v-footer&apos;:Footer &#125; &#125; 12&#123;&#123;$store.state.count&#125;&#125; -------&#123;&#123;$store.getters.countState&#125;state里面的属性 ------- 通过getters计算的属性 五、代码块 1.page.json 1234567891011121314151617181920212223242526272829303132333435363738 &#123; &quot;name&quot;: &quot;elm&quot;, &quot;description&quot;: &quot;A Vue.js project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;author&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --progress --hide-modules&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;css-loader&quot;: &quot;^0.25.0&quot;, &quot;element-ui&quot;: &quot;^1.3.7&quot;, &quot;file-loader&quot;: &quot;^0.9.0&quot;, &quot;style-loader&quot;: &quot;^0.18.2&quot;, &quot;url-loader&quot;: &quot;^0.5.9&quot;, &quot;vue&quot;: &quot;^2.3.3&quot;, &quot;vue-resource&quot;: &quot;^1.3.4&quot;, &quot;vue-router&quot;: &quot;^2.7.0&quot;, &quot;vuex&quot;: &quot;^2.3.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^7.1.2&quot;, &quot;babel-core&quot;: &quot;^6.0.0&quot;, &quot;babel-loader&quot;: &quot;^6.0.0&quot;, &quot;babel-preset-env&quot;: &quot;^1.5.1&quot;, &quot;cross-env&quot;: &quot;^3.0.0&quot;, &quot;css-loader&quot;: &quot;^0.25.0&quot;, &quot;file-loader&quot;: &quot;^0.9.0&quot;, &quot;node-sass&quot;: &quot;^4.5.0&quot;, &quot;postcss-loader&quot;: &quot;^2.0.6&quot;, &quot;sass-loader&quot;: &quot;^5.0.1&quot;, &quot;vue-loader&quot;: &quot;^12.1.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.3.3&quot;, &quot;webpack&quot;: &quot;^2.6.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.4.5&quot; &#125;&#125; 2.entry文件main.js 1234567891011121314151617181920212223242526272829303132333435import Vue from &apos;vue&apos;;import App from &apos;./App.vue&apos;;import ElementUI from &apos;element-ui&apos;;//引入element-uiimport &apos;element-ui/lib/theme-default/index.css&apos;;//引入element.css样式import Vuex from &apos;vuex&apos;;//引入vueximport VueResource from &apos;vue-resource&apos;;//引入vueResourceimport VueRouter from &apos;vue-router&apos;;//引入vuerouterVue.use(VueRouter)//使用vuerouterVue.use(Vuex)//使用vuxVue.use(ElementUI)//使用elementUiVue.use(VueResource)//使用vueresonrce//创建组件引入组件import Home from &apos;./conponents/home.vue&apos;; //配置路由const routes=[ &#123;path:&quot;/home&quot;,component: Home&#125;, &#123;path:&quot;/*&quot;,redirect: Home&#125;//重定向]//实例化vueRouterconst router= new VueRouter(&#123; routes//（缩写）相当于 routes: routes&#125;)//挂载到vue的实例上new Vue(&#123; router, el: &apos;#app&apos;, render: h =&gt; h(App)&#125;) 3.Store文件配置 123456789101112131415161718192021222324252627import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex);// 引入vue和vuex//定义state状态var state=&#123; storeList:[], msg:&quot;111&quot;&#125;//定义mutations方法var mutations=&#123; addData(state,data)&#123; console.log(data) state.storeList=data &#125;&#125;//暴露export default new Vuex.Store(&#123; state, mutations&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"webpack学习总结(一)","slug":"webpack","date":"2017-01-13T10:40:43.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2017/01/13/webpack/","link":"","permalink":"http://yoursite.com/2017/01/13/webpack/","excerpt":"声明 本教程整理于互联网 先看一个例子 123456789101112131415161718// webpack.config.jsmodule.exports = &#123; // 入口 entry: &#123; 'index': './index.js' &#125;, // 输出 output: &#123; path: './', /* [name] 是 entry 中的 key entry: &#123; key: value &#125; */ filename: \"[name].b.js\" &#125;&#125;; module.exports 是 CommonJS 规范中定义一个文件对外接口的语法，webpack.config.js 文件对外的接口是一个 object ，其中定义了一些配置参数。","text":"声明 本教程整理于互联网 先看一个例子 123456789101112131415161718// webpack.config.jsmodule.exports = &#123; // 入口 entry: &#123; 'index': './index.js' &#125;, // 输出 output: &#123; path: './', /* [name] 是 entry 中的 key entry: &#123; key: value &#125; */ filename: \"[name].b.js\" &#125;&#125;; module.exports 是 CommonJS 规范中定义一个文件对外接口的语法，webpack.config.js 文件对外的接口是一个 object ，其中定义了一些配置参数。 一、参数详解 1.1 entry 最初 webpack 是为了构建 SPA (Single Page Application) ，entry 是『入口』配置。在 entry 中的文件才会被编译。 1.2 output output 控制构建后的文件的存放位置和命名。 path 定义所有构建后文件的所在目录，本例中构建到当前文件夹。 1.3 filename filename 控制构建后文件的文件名 1.4 源码和构建结果 1234// index.jsvar content = require(\"./content.js\")document.body.innerHTML = document.body.innerHTML + content 12// content.jsmodule.exports = \"some string\" 1234&lt;body&gt;&lt;a target=\"_blank\" href=\"https://github.com/nimojs/webpack-book/blob/gh-pages/1-modules/README.md\"&gt;本例说明&lt;/a&gt;&lt;script src=\"index.b.js\"&gt;&lt;/script&gt;&lt;/body&gt; 建议尽量理解构建后的代码，这样有助于理解 webpack 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******/ // Check if module is in cache/******/ if(installedModules[moduleId])/******/ return installedModules[moduleId].exports;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ exports: &#123;&#125;,/******/ id: moduleId,/******/ loaded: false/******/ &#125;;/******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******/ // Flag the module as loaded/******/ module.loaded = true;/******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******/ // Load entry module and return exports/******/ return __webpack_require__(0);/******/ &#125;)/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; var content = __webpack_require__(1) document.body.innerHTML = document.body.innerHTML + content/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; module.exports = \"some string\"/***/ &#125;/******/ ]); 前面带 /******/的代码都是 webpack的模块化代码，它内置了一个模块加载器 模块 0 是 index.js 的代码，模块 1 是 require(&quot;./content.js&quot;) 的代码。如果你再 require 一个模块那么就会有模块 3。 二、JS包含样式 安装时间可能会比较久 123456# 安装所需 style-loader 和 css-loadernpm install css-loader style-loader -D# less 和 less-loader 可以选择不安装 （如果安装了请去掉 index.js 中引入 less 的注释）npm install less-loader -Dnpm install less -g 1webpack --watch 123456789101112131415161718192021module.exports = &#123; entry: &#123; 'index': './index.js' &#125;, output: &#123; path: './', filename: \"[name].b.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: \"style!css\" &#125;, &#123; test: /\\.less$/, loader: \"style!css!less\" &#125; ] &#125;&#125;; module.loaders 定义 require 的模块代码会被如何编译。 官方文档 using-loaders 2.1 module.loaders[].test test 参数是一个正则表达式，用于匹配模块。&#39;./index.css&#39;.test(/\\.css&amp;/) 2.2 module.loaders[].loader loader 参数定义被 test 匹配到的模块会执行哪些构建操作 本例中 .css 后缀的文件会被 style-loader 和 css-loader 构建 2.3 require 时配置 loader 如果你不想在 webpack.config.js 配置，你还可以在 require 时单独定义一个文件会使用哪些 loader 1require('!style!css!./index.css') 2.4 被嵌入 &lt;head&gt; 查看 在线预览构建结果页面 源码可以看到样式通过 JS 嵌入到 &lt;head&gt; 中使用的12345&lt;head&gt;&lt;style type=\"text/css\"&gt;body &#123; background-color:#ABCDEF;&#125;&lt;/style&gt;&lt;/head&gt; 三、JS包含图片 1npm install url-loader file-loader -D 1webpack --watch 代码解释待补充 四、使用全局变量 1webpack -w 五、暴露全局变量 有些模块依赖全局变量 windows.jQuery 才能使用，可以通过 expose-loader 暴露全局变量 12npm install jquery --savenpm install expose-loader -D 1webpack -w 六、提取单独样式文件 有时候我们需要编译单独的 CSS 文件，这就需要 extract-text-webpack-plugin 插件 12npm install extract-text-webpack-plugin -Dnpm install style-loader css-loader -D 1webpack -w 七、自动打包公用资源 1npm install jquery paging --save 1webpack -w 八、文件指纹 hash 1webpack --watch 九、异步加载 1webpack --watch","categories":[{"name":"Build","slug":"Build","permalink":"http://yoursite.com/categories/Build/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"JavaScript运动框架之速度时间版本","slug":"js-animate","date":"2017-01-12T07:50:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2017/01/12/js-animate/","link":"","permalink":"http://yoursite.com/2017/01/12/js-animate/","excerpt":"","text":"一、JavaScript运动框架之速度版 1.1 运动框架的实现思路 运动，其实就是在一段时间内改变 left 、 right 、 width 、 height 、 opactiy 的值，到达目的地之后停止 位移 top,left 折叠 width,height 淡入淡出 opacity 时间有关系 setInterval setTimeout 用javascript直接获取行间样式很容易，但如果要获取非行间样式那我们只能借助函数了。我这里编写了一个名为getStyle的函数，专门处理取非行间的样式 123function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 1.2 一些案例演示 1.2.1 运动之速 1&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567#box &#123; width: 100px; height: 100px; background: red; position: relative; left: 0;&#125; 123456789101112131415161718192021222324252627var box = document.getElementById(\"box\");var speed = 0; //步长var target = 600;var timer = null;timer = setInterval(function()&#123; var curr = parseInt(getStyle(box,\"left\")); //去除getStyle(box,\"left\")的单位 if(curr == target)&#123; clearInterval(timer); speed = 0; alert(\"运动结束\"); &#125;else&#123; speed +=10; box.style.left = speed + \"px\"; &#125; &#125;,1000/30);//监控left的值的变化 怎么样拿到left的值//alert(getComputedStyle(box)[\"width\"]);//alert(box.currentStyle[\"left\"]);// currentStyle --IE // getComputedStyle -- 非IEfunction getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 在线演示 1.2.2 运动速度之封装1 1&lt;div id=\"ball\"&gt;&lt;/div&gt; 12345#ball &#123; width: 100px; height: 100px; background: blue;&#125; 1234567891011121314151617181920212223242526272829303132333435var ball = document.getElementById(\"ball\");ball.onmouseover = function()&#123; //同时变换 用的最多 //move(this,\"width\",500,10); //move(this,\"height\",500,10); move(ball,&#123;\"width\":400,\"height\":300&#125;,10);&#125;ball.onmouseout = function()&#123; //move(this,\"width\",100,-10); //move(this,\"height\",100,-10); move(ball,&#123;\"width\":100,\"height\":100&#125;,-10);&#125;function move(obj,json,speed)&#123; clearInterval(obj.timer); var mark = true; obj.timer = setInterval(function()&#123; for(var attr in json)&#123; var curr = parseInt(getStyle(obj,attr)); var target = json[attr]; if(curr != target)&#123; obj.style[attr] = curr+speed+\"px\"; mark = false; &#125; &#125; if(mark)&#123; clearInterval(obj.timer); &#125; &#125;,1000/30);&#125;function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 需要注意的地方 当需要两个动画的时候，会执行后面一个，解决办法如下，回调函数 当需要两个以上的时候，需要考虑是否可写一行代码变换多个属性 变换不一致的时候，定时器被提前清除 在线演示 1.2.3 运动速度之封装2–增加opacity1&lt;div id=\"ball\"&gt;&lt;/div&gt; 123456789#ball &#123; position: relative; left: 0; top: 0; width: 100px; height: 100px; background: blue; opacity: 1;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243var ball = document.getElementById(\"ball\");ball.onmouseover = function()&#123; move(ball,&#123;\"width\":300,\"height\":300,\"opacity\":0.3&#125;);&#125;// ball.onmouseout = function()&#123;// move(ball,&#123;\"width\":100,\"height\":100&#125;,-10);// &#125;function move(obj,json)&#123; clearInterval(obj.timer); var mark = true; obj.timer = setInterval(function()&#123; for(var attr in json)&#123; var curr = null; var target = json[attr]; var speed = null; if(attr == \"opacity\")&#123; curr = getStyle(obj,attr)*100; speed = (target*100-curr)*0.15; &#125;else &#123; curr = parseInt(getStyle(obj,attr)); speed = (target - curr)*0.15; &#125; speed = speed&gt;0 ? Math.ceil(speed):Math.floor(speed); if(curr != target)&#123; if(attr == \"opacity\")&#123; obj.style[attr] = (curr+speed)/100; &#125;else &#123; obj.style[attr] = curr+speed+\"px\"; &#125; mark = false; &#125; &#125; if(mark)&#123; clearInterval(obj.timer); &#125; &#125;,1000/30);&#125;function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 在线演示 需要注意的地方 当需要两个动画的时候，会执行后面一个，解决办法如下，回调函数 当需要两个以上的时候，需要考虑是否可写一行代码变换多个属性 变换不一致的时候，定时器被提前清除 速度speed不要写死 1.3 运动框架之应用1.3.1 分享按钮1234&lt;div id=\"ball\"&gt;&lt;/div&gt;&lt;div id=\"box1\"&gt; &lt;div id=\"box2\"&gt;分享到&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var box1 = document.getElementById(\"box1\");var ball = document.getElementById(\"ball\");box1.onmouseover = function()&#123; move(this,\"left\",0,10);&#125;box1.onmouseout = function()&#123; move(this,\"left\",-100,-10);&#125;//问题一：当需要两个动画的时候，会执行后面一个，解决办法如下，回调函数ball.onmouseover = function()&#123; //同时变换 用的最多 //move(this,\"width\",500,10); //move(this,\"height\",500,10); //列队在执行 move(ball,\"width\",500,10,function()&#123; move(ball,\"height\",500,10); &#125;);&#125;ball.onmouseout = function()&#123; //move(this,\"width\",100,-10); //move(this,\"height\",100,-10); move(ball,\"width\",100,-10,function()&#123; move(ball,\"height\",100,-10); &#125;);&#125;var timer = null;function move(obj,attr,target,speed,callback)&#123; clearInterval(timer); //obj.timer缓存到各自的obj下 timer = setInterval(function()&#123; var curr = parseInt(getStyle(obj,attr)); if(curr == target)&#123; clearInterval(timer); callback &amp;&amp; callback(); &#125;else &#123; obj.style[attr] = curr+speed+\"px\"; &#125; &#125;,1000/30);&#125;function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125; 在线演示 1.3.2运动框架之轮播图应用 焦点轮播–基本版本–在线演示 焦点轮播–淡入淡出–在线演示 焦点轮播–左右–在线演示 焦点轮播–上下–在线演示 1.3.2.1 焦点轮播–左右-无缝-速度版实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=\"box\"&gt; &lt;ul id=\"imgBox\"&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-c72819402fb928e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-6830ca74fe1e6fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-5d38376e63ffd0b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-2aa932ffbba4091e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;li&gt;![](http://upload-images.jianshu.io/upload_images/1480597-c72819402fb928e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/li&gt; &lt;/ul&gt; &lt;ol id=\"btn\"&gt; &lt;li class=\"active\"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script src=\"http://7xq6al.com1.z0.glb.clouddn.com/Animate.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var box = document.querySelector(\"#box\"); var imgUl = document.querySelector(\"#imgBox\"); var btns = document.querySelector(\"#btn\").querySelectorAll(\"li\"); var len = btns.length; var lenImg = imgUl.querySelectorAll(\"li\").length; var index = 0; //控制img的索引 var cindex = 0;//控制按钮的索引 var timer = null; for (var i=0;i&lt;len;i++) &#123; (function(index)&#123; btns[index].onmouseover = function()&#123; for (var j=0;j&lt;len;j++)&#123; btns[j].className = \"\"; &#125; cindex = index;//保持索引同步 animateSpeed(imgUl,&#123;\"left\":-970*index&#125;); this.className = \"active\"; &#125; &#125;)(i); &#125; function autoPlay()&#123; index++; cindex++; cindex %=len;//限制长度 for (var j=0;j&lt;len;j++)&#123; btns[j].className = \"\"; &#125; animateSpeed(imgUl,&#123;\"left\":-970*index&#125;,function()&#123; if(index == lenImg-1)&#123; this.style.left = 0; index = 0; &#125; &#125;); btns[cindex].className = \"active\"; &#125; timer = setInterval(autoPlay,2000); box.onmouseover = function()&#123; clearInterval(timer); &#125; box.onmouseout = function()&#123; timer = setInterval(autoPlay,2000); &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354*&#123; padding: 0; margin: 0;&#125;body&#123; font-size: 14px; font-family: \"微软雅黑\";&#125;ul,li&#123; list-style: none;&#125;#box &#123; position: relative; width: 970px; height: 350px; margin: 30px auto; overflow: hidden;&#125;#imgBox &#123; width:1000%;/*自动计算百分比*/ position: absolute; left: 0;&#125;#imgBox li&#123; width: 970px; height: 350px; float: left;&#125;#imgBox li img &#123; width: 970px; height: 350px;&#125;#btn &#123; width: 120px; position: absolute; right: 10px; bottom: 10px;&#125;#btn li &#123; width: 20px; height: 20px; line-height: 20px; border-radius: 50%; text-align: center; cursor: pointer; background: #fff; margin: 0 2px; float: left;&#125;#btn li.active &#123; background: #F17A5C; color: #fff;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//速度版本(function(win)&#123; function move(obj,json,callback)&#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var mark = true; for(var attr in json)&#123; var cur = null; if(attr == \"opacity\")&#123; cur = getStyle(obj,attr)*100; &#125;else&#123; //如果没写 默认填充成0 cur = parseInt(getStyle(obj,attr))||0; &#125; var target = json[attr]; var speed = (target - cur)*0.2; speed = speed&gt;0?Math.ceil(speed):Math.floor(speed); if(cur != target)&#123; if(attr == \"opacity\")&#123; //IE opacity兼容问题 obj.style.filter = \"alpha(opacity=\"+(cur+speed)+\")\"; obj.style[attr] = (cur + speed)/100; &#125;else&#123; obj.style[attr] = cur + speed + \"px\"; &#125; mark = false; &#125;; &#125; if(mark)&#123; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; &#125;,1000/30); &#125; win.animateSpeed = move;&#125;)(window); function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125;function getId(id)&#123; return document.getElementById(id);&#125; 二、JavaScript运动框架之时间版 2.1 关于运动 速度的运动 通过速度来控制元素的 位移 / 折叠 / 淡入淡出 时间的运动 通过时间来控制元素的 位移 / 折叠 / 淡入淡出(jQuery) 时间的运动 基于一些数学公式 匀速运动 在路程的每一个点 速度都一样 2.2 一些案例演示 运动框架之时间版本-1 运动框架之时间版本-2 运动框架之时间版本-3 运动框架之时间版本-4 2.3 运动框架之时间版本-借助animate一些函数实现–综合完整版 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"box2\"&gt;&lt;/div&gt;&lt;div id=\"box3\"&gt;&lt;/div&gt;&lt;div id=\"box4\"&gt;&lt;/div&gt;&lt;div id=\"box5\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; //时间版本 getId(\"box2\").onclick = function()&#123; animateTime(getId(\"box2\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"elasticOut\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125;getId(\"box3\").onclick = function()&#123; animateTime(getId(\"box3\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"backIn\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125;getId(\"box4\").onclick = function()&#123; animateTime(getId(\"box4\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"bounceIn\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125;getId(\"box5\").onclick = function()&#123; animateTime(getId(\"box5\"),&#123; \"left\":500, \"opacity\":100 &#125;,1000,\"bounceBoth\",function()&#123; this.innerHTML = \"我是时间版本\"; &#125;); &#125; &lt;/script&gt; 1234567891011121314#box1,#box2,#box3,#box4,#box5 &#123; position: relative; width: 100px; height: 100px; line-height: 100px; text-align: center; background: red; color: #fff; font-size: 12px; opacity: 0.5; filter:alpha(opcity=20);/**兼容IE*/ margin: 10px; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/*t b c dt current time :nTime-sTimeb begining time :currc chang in value :变化量end-currd duration :持续时间 time *//*** * @param &#123;Object&#125; obj 元素对象* @param &#123;Object&#125; json 多个属性* @param &#123;Object&#125; time 变化时间* @param &#123;Object&#125; prop 运动函数* @param &#123;Object&#125; callback 回调函数*///时间版本(function(win)&#123; function move(obj,json,time,prop,callback)&#123;//一般定时器结束后最好清除clearInterval(obj.timer);var curr = &#123;&#125;;var end = &#123;&#125;;//通过for in 在上车前把所有东西装到包里for(var attr in json)&#123; if(attr == \"opacity\")&#123;//opacity特殊东西特殊对待 curr[attr] = getStyle(obj,attr)*100;//化为整数好计算 &#125;else&#123; curr[attr] = parseInt(getStyle(obj,attr))||0; &#125; end[attr] = json[attr]; &#125;//如果没写默认值 默认就是0 不然在IE出问题//var curr = parseInt(getStyle(obj,attr))||0;//var end = target;var sTime = new Date();//开始时间T0//开始变换了obj.timer = setInterval(function()&#123; var nTime = new Date();//当前时间Tt var t = nTime -sTime; var d = time; //St = (Tt-T0)/Time*(S-S0)+S0 //(nTime-sTime)/time 比例最多为1 /*var prop = (nTime-sTime)/time; */ if(t &gt;=d)&#123; t = d; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; for(var attr in json)&#123; var b = curr[attr]; var c = end[attr] - b; if(attr == \"opacity\")&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s/100; obj.style.filter = \"alpha(opacity=\"+s+\")\"; &#125;else&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s+\"px\"; &#125; &#125; &#125;,13);var Tween = &#123; linear: function (t, b, c, d)&#123; //匀速 return c*t/d + b; // t/d = prop; &#125;, easeIn: function(t, b, c, d)&#123; //加速曲线 return c*(t/=d)*t + b; &#125;, easeOut: function(t, b, c, d)&#123; //减速曲线 return -c *(t/=d)*(t-2) + b; &#125;, easeBoth: function(t, b, c, d)&#123; //加速减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t + b; &#125; return -c/2 * ((--t)*(t-2) - 1) + b; &#125;, easeInStrong: function(t, b, c, d)&#123; //加加速曲线 return c*(t/=d)*t*t*t + b; &#125;, easeOutStrong: function(t, b, c, d)&#123; //减减速曲线 return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125;, easeBothStrong: function(t, b, c, d)&#123; //加加速减减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t*t*t + b; &#125; return -c/2 * ((t-=2)*t*t*t - 2) + b; &#125;, elasticIn: function(t, b, c, d, a, p)&#123; //正弦衰减曲线（弹动渐入） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125;, elasticOut: function(t, b, c, d, a, p)&#123; //正弦增强曲线（弹动渐出） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b; &#125;, elasticBoth: function(t, b, c, d, a, p)&#123; if (t === 0) &#123; return b; &#125; if ( (t /= d/2) == 2 ) &#123; return b+c; &#125; if (!p) &#123; p = d*(0.3*1.5); &#125; if ( !a || a &lt; Math.abs(c) ) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; if (t &lt; 1) &#123; return - 0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125; return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b; &#125;, backIn: function(t, b, c, d, s)&#123; //回退加速（回退渐入） if (typeof s == 'undefined') &#123; s = 1.70158; &#125; return c*(t/=d)*t*((s+1)*t - s) + b; &#125;, backOut: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 3.70158; //回缩的距离 &#125; return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b; &#125;, backBoth: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 1.70158; &#125; if ((t /= d/2 ) &lt; 1) &#123; return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b; &#125; return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b; &#125;, bounceIn: function(t, b, c, d)&#123; //弹球减振（弹球渐出） return c - Tween['bounceOut'](d-t, 0, c, d) + b; &#125;, bounceOut: function(t, b, c, d)&#123; if ((t/=d) &lt; (1/2.75)) &#123; return c*(7.5625*t*t) + b; &#125; else if (t &lt; (2/2.75)) &#123; return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b; &#125; else if (t &lt; (2.5/2.75)) &#123; return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b; &#125; return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b; &#125;, bounceBoth: function(t, b, c, d)&#123; if (t &lt; d/2) &#123; return Tween['bounceIn'](t*2, 0, c, d) * 0.5 + b; &#125; return Tween['bounceOut'](t*2-d, 0, c, d) * 0.5 + c*0.5 + b; &#125;&#125;;&#125;win.animateTime = move; &#125;)(window); 在线演示 三、运动框架之时间速度版完整封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247/*t b c dt current time :nTime-sTimeb begining time :currc chang in value :变化量end-currd duration :持续时间 time *//** * * @param &#123;Object&#125; obj 元素对象 * @param &#123;Object&#125; json 多个属性 * @param &#123;Object&#125; time 变化时间 * @param &#123;Object&#125; prop 运动函数 * @param &#123;Object&#125; callback 回调函数 *///时间版本(function(win)&#123; function move(obj,json,time,prop,callback)&#123; //一般定时器结束后最好清除 clearInterval(obj.timer); var curr = &#123;&#125;; var end = &#123;&#125;; //通过for in 在上车前把所有东西装到包里 for(var attr in json)&#123; if(attr == \"opacity\")&#123;//opacity特殊东西特殊对待 curr[attr] = getStyle(obj,attr)*100;//化为整数好计算 &#125;else&#123; curr[attr] = parseInt(getStyle(obj,attr))||0; &#125; end[attr] = json[attr]; &#125; //如果没写默认值 默认就是0 不然在IE出问题 //var curr = parseInt(getStyle(obj,attr))||0; //var end = target; var sTime = new Date();//开始时间T0 //开始变换了 obj.timer = setInterval(function()&#123; var nTime = new Date();//当前时间Tt var t = nTime -sTime; var d = time; //St = (Tt-T0)/Time*(S-S0)+S0 //(nTime-sTime)/time 比例最多为1 /*var prop = (nTime-sTime)/time; */ if(t &gt;=d)&#123; t = d; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; for(var attr in json)&#123; var b = curr[attr]; var c = end[attr] - b; if(attr == \"opacity\")&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s/100; obj.style.filter = \"alpha(opacity=\"+s+\")\"; &#125;else&#123; //var s = prop*(end[attr]-curr[attr])+curr[attr]; var s = Tween[prop](t,b,c,d); obj.style[attr] = s+\"px\"; &#125; &#125; &#125;,13); var Tween = &#123; linear: function (t, b, c, d)&#123; //匀速 return c*t/d + b; // t/d = prop; &#125;, easeIn: function(t, b, c, d)&#123; //加速曲线 return c*(t/=d)*t + b; &#125;, easeOut: function(t, b, c, d)&#123; //减速曲线 return -c *(t/=d)*(t-2) + b; &#125;, easeBoth: function(t, b, c, d)&#123; //加速减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t + b; &#125; return -c/2 * ((--t)*(t-2) - 1) + b; &#125;, easeInStrong: function(t, b, c, d)&#123; //加加速曲线 return c*(t/=d)*t*t*t + b; &#125;, easeOutStrong: function(t, b, c, d)&#123; //减减速曲线 return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125;, easeBothStrong: function(t, b, c, d)&#123; //加加速减减速曲线 if ((t/=d/2) &lt; 1) &#123; return c/2*t*t*t*t + b; &#125; return -c/2 * ((t-=2)*t*t*t - 2) + b; &#125;, elasticIn: function(t, b, c, d, a, p)&#123; //正弦衰减曲线（弹动渐入） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125;, elasticOut: function(t, b, c, d, a, p)&#123; //正弦增强曲线（弹动渐出） if (t === 0) &#123; return b; &#125; if ( (t /= d) == 1 ) &#123; return b+c; &#125; if (!p) &#123; p=d*0.3; &#125; if (!a || a &lt; Math.abs(c)) &#123; a = c; var s = p / 4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b; &#125;, elasticBoth: function(t, b, c, d, a, p)&#123; if (t === 0) &#123; return b; &#125; if ( (t /= d/2) == 2 ) &#123; return b+c; &#125; if (!p) &#123; p = d*(0.3*1.5); &#125; if ( !a || a &lt; Math.abs(c) ) &#123; a = c; var s = p/4; &#125; else &#123; var s = p/(2*Math.PI) * Math.asin (c/a); &#125; if (t &lt; 1) &#123; return - 0.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; &#125; return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b; &#125;, backIn: function(t, b, c, d, s)&#123; //回退加速（回退渐入） if (typeof s == 'undefined') &#123; s = 1.70158; &#125; return c*(t/=d)*t*((s+1)*t - s) + b; &#125;, backOut: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 3.70158; //回缩的距离 &#125; return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b; &#125;, backBoth: function(t, b, c, d, s)&#123; if (typeof s == 'undefined') &#123; s = 1.70158; &#125; if ((t /= d/2 ) &lt; 1) &#123; return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b; &#125; return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b; &#125;, bounceIn: function(t, b, c, d)&#123; //弹球减振（弹球渐出） return c - Tween['bounceOut'](d-t, 0, c, d) + b; &#125;, bounceOut: function(t, b, c, d)&#123; if ((t/=d) &lt; (1/2.75)) &#123; return c*(7.5625*t*t) + b; &#125; else if (t &lt; (2/2.75)) &#123; return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b; &#125; else if (t &lt; (2.5/2.75)) &#123; return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b; &#125; return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b; &#125;, bounceBoth: function(t, b, c, d)&#123; if (t &lt; d/2) &#123; return Tween['bounceIn'](t*2, 0, c, d) * 0.5 + b; &#125; return Tween['bounceOut'](t*2-d, 0, c, d) * 0.5 + c*0.5 + b; &#125; &#125;; &#125; win.animateTime = move; &#125;)(window);//速度版本(function(win)&#123; function move(obj,json,callback)&#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var mark = true; for(var attr in json)&#123; var cur = null; if(attr == \"opacity\")&#123; cur = getStyle(obj,attr)*100; &#125;else&#123; //如果没写 默认填充成0 cur = parseInt(getStyle(obj,attr))||0; &#125; var target = json[attr]; var speed = (target - cur)*0.2; speed = speed&gt;0?Math.ceil(speed):Math.floor(speed); if(cur != target)&#123; if(attr == \"opacity\")&#123; //IE opacity兼容问题 obj.style.filter = \"alpha(opacity=\"+(cur+speed)+\")\"; obj.style[attr] = (cur + speed)/100; &#125;else&#123; obj.style[attr] = cur + speed + \"px\"; &#125; mark = false; &#125;; &#125; if(mark)&#123; clearInterval(obj.timer); callback &amp;&amp; callback.call(obj); &#125; &#125;,1000/30); &#125; win.animateSpeed = move;&#125;)(window); function getStyle(obj,attr)&#123; return getComputedStyle(obj)[attr]?getComputedStyle(obj)[attr]:obj.currentStyle[attr];&#125;function getId(id)&#123; return document.getElementById(id);&#125; 更多使用记录，详情 https://github.com/poetries/Animate","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"运动框架","slug":"运动框架","permalink":"http://yoursite.com/tags/运动框架/"}]},{"title":"HTML5之API总结","slug":"html5API","date":"2016-11-26T06:35:24.000Z","updated":"2018-03-29T15:16:14.900Z","comments":true,"path":"2016/11/26/html5API/","link":"","permalink":"http://yoursite.com/2016/11/26/html5API/","excerpt":"一、Canvas API canvas API是H5标准中最复杂的部分， 它提供几种属性和方法，可以在canvas元素上创建图形应用 方法","text":"一、Canvas API canvas API是H5标准中最复杂的部分， 它提供几种属性和方法，可以在canvas元素上创建图形应用 方法 以下方法专门用于调用canvas API getContext(context)创建可绘制图形的画布上下文，接受两个值，2d和3d fillRect(x,y,width,height)绘制实心矩形 strokeRect(x,y,width,height)绘制矩形轮廓 clearRect(x,y,width,height)清除画布指定区域内容 createLinearGradient(x1,y1,x2,y2)创建一个线性渐变效果 createRadialGradient(x1,y1,r1,x2,y2,r2)创建一个放射渐变效果 addColorStop(position,color)用于声明渐变颜色position范围是0.0-1.0 用于确定颜色开始变化位置 beginPath()开始一条新路径 closePath()在路径最后实现封闭该路径，它会生成一条直线，连接笔触的最后一个位置与路径的起点。如想要保持路径开放，使用fill()绘图，不用这个方法 stroke() 用于创建路径轮廓 fill()用于绘制实心形状 clip()用于创建一个由路径定义的裁剪区域，只有在落入形状内的内容才绘制到画布上 moveTo(x,y)将虚拟笔触移到新位置，下一个方法会从改点的开始继续设置路径 lineTo(x,y)在新路径上添加一条直线 rect(x,y,width,height)在路径为(x,y)位置上添加width和height矩形 arc(x,y,radius,startAngle,endAngle,direction)在路径上添加一条弧线 ,x,y指定弧线的中心，角度单位为弧度，direction是一个表示顺时针或逆时针的布尔值。使用公式 Math.PI/180x角度，将角度转换为半径 strokeText(text,x,y,max) 直接在画布上绘制文字轮廓。可选参数，max声明文字最大尺寸 fillText(text,x,y,max)直接在画布上绘制实心文字。可选参数，max声明文字最大尺寸 translate(x,y)将画布原点移到点(x,y)处，原点（0,0）初始位置位于canvas所在区域的左上角 rorate(angle)这个方法可以使画布原点为中心发生旋转，角度必须是弧度。使用公式Math.PI/180x 将角度转换为弧度 scale(x,y) 改变画布比例 默认值是（1.0,1.0）这些值可以是负值 transform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。新矩阵是基于之前的矩阵得到的 setTransform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。重置之前的值，声明新的值 save()保存画布状态，包括转换矩阵、样式属性、裁剪遮罩 restore() 恢复上一次保存的状态 drawImage() 在画布上绘制图像 属性 canvas API专用属性列表 rect( x, y, width, height ) 绘制矩形 fillRect( x, y, width, height ) 绘制被填充的矩形 strokeRect( x, y, width, height ) 绘制矩形（无填充） clearRect( x, y, width, height ) 清除指定的矩形内的像素 fill() 填充当前绘图（路径） stroke()绘制已定义的路径 beginPath() 起始（重置）当前路径 moveTo( x, y ) 将笔触移动到指定的坐标(x,y) lineTo( x, y ) 绘制一条从当前位置到指定的坐标(x,y)的直线 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次贝塞尔曲线 arc( x, y, radius, startAngle, endAngle, anticlockwise) 绘制圆或圆弧 arcTo( x1, y1, x2, y2, radius) 根据给定点画圆弧，再以直线连接两个点 isPointInPath( x, y ) 检测指定的点是否在当前路径中，在则返回true。 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影与形状的水平距离 shadowOffsetY 设置或返回阴影与形状的垂直距离 lineCap 设置或返回线条的结束点样式（butt、round、square） lineJoin 设置或返回当两条线交汇时，边角的类型（bevel、round、miter） lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 createLinearGradient( x0, y0, x1, y1 ) 创建线性渐变 createPattern( image/canvas/video, repeat ) 在指定的方向内重复绘制指定的元素 createRadialGradient( x0, y0, r0, x1, y1, r1 )创建径向渐变 addColorStop( stop, color ) 规定渐变对象中的颜色和停止位置 font 设置或返回文本内容的当前字体属性（和css的font一样） textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 fillText( text, x, y ) 在画布上绘制“被填充”的文本 strokeText( text, x, y ) 在画布上绘制文本（无填充） measureText( text ) 返回包含指定文本宽度的对象（属性width获取宽度） drawImage( image/canvas, x, y )、drawImage( image/canvas, x, y, width, height )、drawImage( image/canvas, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )` 在画布上绘制图像、画布或视频 createImageData( width, height )、createImageData(imageData) 绘制ImageData对象 getImageData( x, y, width, height ) 返回ImageData对象，该对象为画布上指定的矩形复制像素数据。 putImageData( ImageData, x, y )、putImageData( imageData, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 把图像数据放回画布上。 width 返回ImageData对象的宽度 height 返回ImageData对象的高度 data 返回一个对象，包含指定的ImageData对象的图像数据 globalAlpha 设置或返回绘图的当前alpha或透明度 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上。 scale( x, y ) 缩放当前绘图 translate( x, y ) 重新设置画布上的(0,0)位置 rotate( angle ) 选择当前绘图，单位为“弧度”，角度转弧度公式（ degrees*Math.PI/180） transform( m11, m12, m21, m22, dx, dy ) 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单元矩阵，然后运行transform() save() 保存当前环境的状态 restore() 恢复之前保存过的路径状态和属性 getContext(&#39;2d&#39;) 获取2d对象 toDataURL() 将canvas转换成图片，返回地址 canvas常用总结 标签 &lt;canvas&gt; 不支持canvas 的浏览器可以看到的内容 &lt;canvas&gt; 绘制环境 getContext(&quot;2d&quot;);目前支持2d的场景 绘制矩形 rect(L,T,W,H):创建一个矩形 fillRect(L,T,W,H):绘制填充的矩形 strokeRect(L,T,W,H)绘制矩形(无填充) 默认一像素黑色边框 设置绘图 fillStyle:填充颜色(绘制canvas是有顺序的) lineWidth:线宽度，笔迹粗细 strokeStyle:边线颜色 绘制路径 stroke ：绘制，划线(黑色默认) fill :填充(黑色默认) rect(矩形区域) clearRect 擦除一个矩形区域 save 进入到XXX（高逼格）状态 restore 退出xxx（高逼格）状态 绘制圆形 arc(x,y,半径,起始弧度,结束弧度,旋转方向) x，y起始位置 弧度与角度：弧度=角度 x π / 180 旋转方向：顺时针（默认：false），逆时针（true） 绘制字体 font：设置字体大小 fillText：填充字体 strokeText：绘制字体 二、视频音频 视频音频格式的简单介绍 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源) 常见的音频格式 视频编码：ACC、MP3、Vorbis HTML5能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。 支持的视频格式： Ogg=带有Theora视频编码+Vorbis音频编码的Ogg文件 MEPG4=带有H.264视频编码+AAC音频编码的MPEG4文件 WebM=带有VP8视频编码+Vorbis音频编码的WebM格式 Video的使用 单独用法 &lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 带提示用法 123&lt; video src=\"文件地址\" controls=\"controls\"&gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; 兼容用法 12345&lt; video controls=\"controls\" width=\"300\"&gt; &lt;source src=\"move.ogg\" type=\"video/ogg\" &gt; &lt;source src=\"move.mp4\" type=\"video/mp4\" &gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; Video的常见属性 属性 值 描述 Autoplay Autoplay 视频就绪自动播放 controls controls 向用户显示播放控件 Width Pixels(像素) 设置播放器宽度 Height Pixels(像素) 设置播放器高度 Loop Loop 播放完是否继续播放该视频，循环播放 Preload load{auto,meta,none} 规定是否预加载视频。 Src url 视频url地址 Poster Imgurl 加载等待的画面图片 Autobuffer Autobuffer 设置为浏览器缓冲方式，不设置autoply才有效 Video的API方法 方法 属性 事件 play() currentSrc play pause() currentTime pause load() videoWidth progress canPlayType() videoHeight error 三、地理信息与本地存储 地理位置 经度 : 南北极的连接线 纬度 : 东西连接的线 位置信息从何而来 IP地址 GPS全球定位系统 Wi-Fi无线网络 基站 avigator.geolocation 单次定位请求 ：getCurrentPosition(请求成功,请求失败,数据收集方式) 请求成功函数 经度 : coords.longitude 纬度 : coords.latitude 准确度 : coords.accuracy 海拔 : coords.altitude 海拔准确度 : coords.altitudeAcuracy 行进方向 : coords.heading 地面速度 : coords.speed 请求的时间: new Date(position.timestamp) 请求失败函数 失败编号 ：code 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 数据收集 : json的形式 enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 多次定位请求* : watchPosition 移动设备有用，位置改变才会触发 配置参数：frequency 更新的频率 关闭更新请求 : clearWatch 百度地图API 1&lt;script src=\"http://api.map.baidu.com/api?v=2.0&amp;ak=qZfInp9MaT9Qa0PoNy4Rmx3Y9W9ZXMfw\"&gt;&lt;/script&gt; 本地存储 Storage sessionStorage session临时回话，从页面打开到页面关闭的时间段 窗口的临时存储，页面关闭，本地存储消失 localStorage 永久存储（可以手动删除数据） Storage的特点 存储量限制 ( 5M ) 客户端完成，不会请求服务器处理 sessionStorage数据是不共享、 localStorage共享 Storage API setItem(): 设置数据，(key,value)类型，类型都是字符串 可以用获取属性的形式操作 getItem(): 获取数据，通过key来获取到相应的value removeItem(): 删除数据，通过key来删除相应的value clear(): 删除全部存储的值 存储事件: 当数据有修改或删除的情况下，就会触发storage事件 在对数据进行改变的窗口对象上是不会触发的` Key : 修改或删除的key值，如果调用clear(),key为null newValue : 新设置的值，如果调用removeStorage(),key为null oldValue : 调用改变前的value值 storageArea : 当前的storage对象 url : 触发该脚本变化的文档的url 注：session同窗口才可以,例子：iframe操作 四、HTML5拖拽 图片自带拖拽功能 其他元素可设置draggable属性 draggable ：true 拖拽元素(被拖拽元素对象)事件 : ondragstart : 拖拽前触发 ondrag :拖拽前、拖拽结束之间，连续触发 ondragend :拖拽结束触发 目标元素(拖拽元素被拖到的对象)事件 : ondragenter :进入目标元素触发 ondragover:进入目标、离开目标之间，连续触发 ondragleave :离开目标元素触发 ondrop :在目标元素上释放鼠标触发 需要在ondragover事件里面阻止默认事件 拖拽兼容问题 火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 dataTransfer对象 setData() : 设置数据 key和value(必须是字符串) getData() : 获取数据，根据key值，获取对应的value effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) setDragImage ：三个参数（指定的元素，坐标X，坐标Y） files： 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 读取文件信息 FileReader(读取文件信息) readAsDataURL 参数为要读取的文件对象 onload当读取文件成功完成的时候触发此事件 this. result 获取读取的文件数据 五、跨文档操作 跨文档请求 同域跨文档 iframe内页： 父页面操作子页面：contentWindow 子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面) 新窗口页： 父页面操作子页面：window.open 子页面操作父页面：window.opener 不同域跨文档 postMessage（“发送的数据”,”接收的域”） message事件监听 ev.origin发送数据来源的域 ev.data 发送的数据 通过判断发送的数据来执行相应的需求 ajax跨域 XMLHttpRequest 新增功能 跨域请求：修改服务端头信息 IE兼容：XDomaiRequest 进度事件： upload.onprogress(ev) 上传进度(实现文件上传进度条) ev.total 发送文件的总量 ev.loaded 已发送的量 FormData 构建提交二进制数据","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"HTML5之API总结","slug":"h5-api","date":"2016-11-26T06:35:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/11/26/h5-api/","link":"","permalink":"http://yoursite.com/2016/11/26/h5-api/","excerpt":"一、Canvas API canvas API是H5标准中最复杂的部分， 它提供几种属性和方法，可以在canvas元素上创建图形应用 方法","text":"一、Canvas API canvas API是H5标准中最复杂的部分， 它提供几种属性和方法，可以在canvas元素上创建图形应用 方法 以下方法专门用于调用canvas API getContext(context)创建可绘制图形的画布上下文，接受两个值，2d和3d fillRect(x,y,width,height)绘制实心矩形 strokeRect(x,y,width,height)绘制矩形轮廓 clearRect(x,y,width,height)清除画布指定区域内容 createLinearGradient(x1,y1,x2,y2)创建一个线性渐变效果 createRadialGradient(x1,y1,r1,x2,y2,r2)创建一个放射渐变效果 addColorStop(position,color)用于声明渐变颜色position范围是0.0-1.0 用于确定颜色开始变化位置 beginPath()开始一条新路径 closePath()在路径最后实现封闭该路径，它会生成一条直线，连接笔触的最后一个位置与路径的起点。如想要保持路径开放，使用fill()绘图，不用这个方法 stroke() 用于创建路径轮廓 fill()用于绘制实心形状 clip()用于创建一个由路径定义的裁剪区域，只有在落入形状内的内容才绘制到画布上 moveTo(x,y)将虚拟笔触移到新位置，下一个方法会从改点的开始继续设置路径 lineTo(x,y)在新路径上添加一条直线 rect(x,y,width,height)在路径为(x,y)位置上添加width和height矩形 arc(x,y,radius,startAngle,endAngle,direction)在路径上添加一条弧线 ,x,y指定弧线的中心，角度单位为弧度，direction是一个表示顺时针或逆时针的布尔值。使用公式 Math.PI/180x角度，将角度转换为半径 strokeText(text,x,y,max) 直接在画布上绘制文字轮廓。可选参数，max声明文字最大尺寸 fillText(text,x,y,max)直接在画布上绘制实心文字。可选参数，max声明文字最大尺寸 translate(x,y)将画布原点移到点(x,y)处，原点（0,0）初始位置位于canvas所在区域的左上角 rorate(angle)这个方法可以使画布原点为中心发生旋转，角度必须是弧度。使用公式Math.PI/180x 将角度转换为弧度 scale(x,y) 改变画布比例 默认值是（1.0,1.0）这些值可以是负值 transform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。新矩阵是基于之前的矩阵得到的 setTransform（m1,m2,m3,m4,dx,dy）修改画布的转换矩阵。重置之前的值，声明新的值 save()保存画布状态，包括转换矩阵、样式属性、裁剪遮罩 restore() 恢复上一次保存的状态 drawImage() 在画布上绘制图像 属性 canvas API专用属性列表 rect( x, y, width, height ) 绘制矩形 fillRect( x, y, width, height ) 绘制被填充的矩形 strokeRect( x, y, width, height ) 绘制矩形（无填充） clearRect( x, y, width, height ) 清除指定的矩形内的像素 fill() 填充当前绘图（路径） stroke()绘制已定义的路径 beginPath() 起始（重置）当前路径 moveTo( x, y ) 将笔触移动到指定的坐标(x,y) lineTo( x, y ) 绘制一条从当前位置到指定的坐标(x,y)的直线 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次贝塞尔曲线 arc( x, y, radius, startAngle, endAngle, anticlockwise) 绘制圆或圆弧 arcTo( x1, y1, x2, y2, radius) 根据给定点画圆弧，再以直线连接两个点 isPointInPath( x, y ) 检测指定的点是否在当前路径中，在则返回true。 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影与形状的水平距离 shadowOffsetY 设置或返回阴影与形状的垂直距离 lineCap 设置或返回线条的结束点样式（butt、round、square） lineJoin 设置或返回当两条线交汇时，边角的类型（bevel、round、miter） lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 createLinearGradient( x0, y0, x1, y1 ) 创建线性渐变 createPattern( image/canvas/video, repeat ) 在指定的方向内重复绘制指定的元素 createRadialGradient( x0, y0, r0, x1, y1, r1 )创建径向渐变 addColorStop( stop, color ) 规定渐变对象中的颜色和停止位置 font 设置或返回文本内容的当前字体属性（和css的font一样） textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 fillText( text, x, y ) 在画布上绘制“被填充”的文本 strokeText( text, x, y ) 在画布上绘制文本（无填充） measureText( text ) 返回包含指定文本宽度的对象（属性width获取宽度） drawImage( image/canvas, x, y )、drawImage( image/canvas, x, y, width, height )、drawImage( image/canvas, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )` 在画布上绘制图像、画布或视频 createImageData( width, height )、createImageData(imageData) 绘制ImageData对象 getImageData( x, y, width, height ) 返回ImageData对象，该对象为画布上指定的矩形复制像素数据。 putImageData( ImageData, x, y )、putImageData( imageData, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 把图像数据放回画布上。 width 返回ImageData对象的宽度 height 返回ImageData对象的高度 data 返回一个对象，包含指定的ImageData对象的图像数据 globalAlpha 设置或返回绘图的当前alpha或透明度 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上。 scale( x, y ) 缩放当前绘图 translate( x, y ) 重新设置画布上的(0,0)位置 rotate( angle ) 选择当前绘图，单位为“弧度”，角度转弧度公式（ degrees*Math.PI/180） transform( m11, m12, m21, m22, dx, dy ) 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单元矩阵，然后运行transform() save() 保存当前环境的状态 restore() 恢复之前保存过的路径状态和属性 getContext(&#39;2d&#39;) 获取2d对象 toDataURL() 将canvas转换成图片，返回地址 canvas常用总结 标签 &lt;canvas&gt; 不支持canvas 的浏览器可以看到的内容 &lt;canvas&gt; 绘制环境 getContext(&quot;2d&quot;);目前支持2d的场景 绘制矩形 rect(L,T,W,H):创建一个矩形 fillRect(L,T,W,H):绘制填充的矩形 strokeRect(L,T,W,H)绘制矩形(无填充) 默认一像素黑色边框 设置绘图 fillStyle:填充颜色(绘制canvas是有顺序的) lineWidth:线宽度，笔迹粗细 strokeStyle:边线颜色 绘制路径 stroke ：绘制，划线(黑色默认) fill :填充(黑色默认) rect(矩形区域) clearRect 擦除一个矩形区域 save 进入到XXX（高逼格）状态 restore 退出xxx（高逼格）状态 绘制圆形 arc(x,y,半径,起始弧度,结束弧度,旋转方向) x，y起始位置 弧度与角度：弧度=角度 x π / 180 旋转方向：顺时针（默认：false），逆时针（true） 绘制字体 font：设置字体大小 fillText：填充字体 strokeText：绘制字体 二、视频音频 视频音频格式的简单介绍 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源) 常见的音频格式 视频编码：ACC、MP3、Vorbis HTML5能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。 支持的视频格式： Ogg=带有Theora视频编码+Vorbis音频编码的Ogg文件 MEPG4=带有H.264视频编码+AAC音频编码的MPEG4文件 WebM=带有VP8视频编码+Vorbis音频编码的WebM格式 Video的使用 单独用法 &lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 带提示用法 123&lt; video src=\"文件地址\" controls=\"controls\"&gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; 兼容用法 12345&lt; video controls=\"controls\" width=\"300\"&gt; &lt;source src=\"move.ogg\" type=\"video/ogg\" &gt; &lt;source src=\"move.mp4\" type=\"video/mp4\" &gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; Video的常见属性 属性 值 描述 Autoplay Autoplay 视频就绪自动播放 controls controls 向用户显示播放控件 Width Pixels(像素) 设置播放器宽度 Height Pixels(像素) 设置播放器高度 Loop Loop 播放完是否继续播放该视频，循环播放 Preload load{auto,meta,none} 规定是否预加载视频。 Src url 视频url地址 Poster Imgurl 加载等待的画面图片 Autobuffer Autobuffer 设置为浏览器缓冲方式，不设置autoply才有效 Video的API方法 方法 属性 事件 play() currentSrc play pause() currentTime pause load() videoWidth progress canPlayType() videoHeight error 三、地理信息与本地存储 地理位置 经度 : 南北极的连接线 纬度 : 东西连接的线 位置信息从何而来 IP地址 GPS全球定位系统 Wi-Fi无线网络 基站 avigator.geolocation 单次定位请求 ：getCurrentPosition(请求成功,请求失败,数据收集方式) 请求成功函数 经度 : coords.longitude 纬度 : coords.latitude 准确度 : coords.accuracy 海拔 : coords.altitude 海拔准确度 : coords.altitudeAcuracy 行进方向 : coords.heading 地面速度 : coords.speed 请求的时间: new Date(position.timestamp) 请求失败函数 失败编号 ：code 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 数据收集 : json的形式 enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 多次定位请求* : watchPosition 移动设备有用，位置改变才会触发 配置参数：frequency 更新的频率 关闭更新请求 : clearWatch 百度地图API 1&lt;script src=\"http://api.map.baidu.com/api?v=2.0&amp;ak=qZfInp9MaT9Qa0PoNy4Rmx3Y9W9ZXMfw\"&gt;&lt;/script&gt; 本地存储 Storage sessionStorage session临时回话，从页面打开到页面关闭的时间段 窗口的临时存储，页面关闭，本地存储消失 localStorage 永久存储（可以手动删除数据） Storage的特点 存储量限制 ( 5M ) 客户端完成，不会请求服务器处理 sessionStorage数据是不共享、 localStorage共享 Storage API setItem(): 设置数据，(key,value)类型，类型都是字符串 可以用获取属性的形式操作 getItem(): 获取数据，通过key来获取到相应的value removeItem(): 删除数据，通过key来删除相应的value clear(): 删除全部存储的值 存储事件: 当数据有修改或删除的情况下，就会触发storage事件 在对数据进行改变的窗口对象上是不会触发的` Key : 修改或删除的key值，如果调用clear(),key为null newValue : 新设置的值，如果调用removeStorage(),key为null oldValue : 调用改变前的value值 storageArea : 当前的storage对象 url : 触发该脚本变化的文档的url 注：session同窗口才可以,例子：iframe操作 四、HTML5拖拽 图片自带拖拽功能 其他元素可设置draggable属性 draggable ：true 拖拽元素(被拖拽元素对象)事件 : ondragstart : 拖拽前触发 ondrag :拖拽前、拖拽结束之间，连续触发 ondragend :拖拽结束触发 目标元素(拖拽元素被拖到的对象)事件 : ondragenter :进入目标元素触发 ondragover:进入目标、离开目标之间，连续触发 ondragleave :离开目标元素触发 ondrop :在目标元素上释放鼠标触发 需要在ondragover事件里面阻止默认事件 拖拽兼容问题 火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 dataTransfer对象 setData() : 设置数据 key和value(必须是字符串) getData() : 获取数据，根据key值，获取对应的value effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) setDragImage ：三个参数（指定的元素，坐标X，坐标Y） files： 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 读取文件信息 FileReader(读取文件信息) readAsDataURL 参数为要读取的文件对象 onload当读取文件成功完成的时候触发此事件 this. result 获取读取的文件数据 五、跨文档操作 跨文档请求 同域跨文档 iframe内页： 父页面操作子页面：contentWindow 子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面) 新窗口页： 父页面操作子页面：window.open 子页面操作父页面：window.opener 不同域跨文档 postMessage（“发送的数据”,”接收的域”） message事件监听 ev.origin发送数据来源的域 ev.data 发送的数据 通过判断发送的数据来执行相应的需求 ajax跨域 XMLHttpRequest 新增功能 跨域请求：修改服务端头信息 IE兼容：XDomaiRequest 进度事件： upload.onprogress(ev) 上传进度(实现文件上传进度条) ev.total 发送文件的总量 ev.loaded 已发送的量 FormData 构建提交二进制数据","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"JavaScript常用的代码片段","slug":"JavaScript-code-snippets","date":"2016-10-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/10/27/JavaScript-code-snippets/","link":"","permalink":"http://yoursite.com/2016/10/27/JavaScript-code-snippets/","excerpt":"转义特殊字符为html实体 123HtmlEncode: function(str)&#123; return str.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;').replace(/'/g, ''');&#125;, 验证是否为有效的手机电话号码 1234IsMobile: function(str)&#123; var rp = /^1[3|4|5|7|8][0-9]\\d&#123;4,8&#125;$/; return rp.test(str);&#125;, 验证是否为有效的座机电话号码","text":"转义特殊字符为html实体 123HtmlEncode: function(str)&#123; return str.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;').replace(/'/g, ''');&#125;, 验证是否为有效的手机电话号码 1234IsMobile: function(str)&#123; var rp = /^1[3|4|5|7|8][0-9]\\d&#123;4,8&#125;$/; return rp.test(str);&#125;, 验证是否为有效的座机电话号码 1234IsTel: function(str)&#123; var rp = /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/; return rp.test(str);&#125;, 判断是那种类型的浏览器 123456789101112131415161718192021222324252627282930313233343536373839404142434445WhichBrowser: function()&#123; var userAgent = navigator.userAgent; var isOpera = userAgent.indexOf(\"Opera\") &gt; -1; var isIE = userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; userAgent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; !isOpera; var isFF = userAgent.indexOf(\"Firefox\") &gt; -1; var isCH = userAgent.indexOf(\"Chrome\") &gt; -1; var isSafari = userAgent.indexOf(\"Safari\") &gt; -1; if (isIE)&#123; var IE5 = IE55 = IE6 = IE7 = IE8 = false; var reIE = new RegExp(\"MSIE (\\\\d+\\\\.\\\\d+);\"); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[\"$1\"]); IE55 = fIEVersion == 5.5; IE6 = fIEVersion == 6.0; IE7 = fIEVersion == 7.0; IE8 = fIEVersion == 8.0; if (IE55) &#123; return \"IE55\"; &#125; if (IE6) &#123; return \"IE6\"; &#125; if (IE7) &#123; return \"IE7\"; &#125; if (IE8) &#123; return \"IE8\"; &#125; &#125; if (isFF) &#123; return \"Firefox\"; &#125; if (isCH) &#123; return \"Chrome\"; &#125; if (isOpera) &#123; return \"Opera\"; &#125; if (isSafari) &#123; return \"Safari\"; &#125;&#125;, 获取客户端浏览器cookie 123456789101112GetCookie: function(c_name)&#123; if(document.cookie.length&gt;0)&#123; c_start = document.cookie.indexOf(c_name + '='); if(c_start != -1)&#123; c_start = c_start + c_name.length + 1; c_end = document.cookie.indexOf(';',c_start); if (c_end==-1) c_end = document.cookie.length; return unescape(document.cookie.substring(c_start,c_end)); &#125; &#125; return '';&#125;, 设置客户端浏览器cookie 123456SetCookie: function(c_name, value, expiredays)&#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie = c_name + \"=\" + escape(value) + ((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());&#125;,&#125;; 字符串长度截取 1234567891011121314151617181920function cutstr(str, len) &#123; var temp, icount = 0, patrn = /[^\\x00-\\xff]/， strre = \"\"; for (var i = 0; i &lt; str.length; i++) &#123; if (icount &lt; len - 1) &#123; temp = str.substr(i, 1); if (patrn.exec(temp) == null) &#123; icount = icount + 1 &#125; else &#123; icount = icount + 2 &#125; strre += temp &#125; else &#123; break; &#125; &#125; return strre + \"...\"&#125; 替换全部 123String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, \"gm\"), s2)&#125; 清除空格 1234String.prototype.trim = function() &#123; var reExtraSpace = /^\\s*(.*?)\\s+$/; return this.replace(reExtraSpace, \"$1\")&#125; 清除左空格/右空格 12function ltrim(s)&#123; return s.replace( /^(\\s*| *)/, \"\"); &#125; function rtrim(s)&#123; return s.replace( /(\\s*| *)$/, \"\"); &#125; 判断是否以某个字符串开头 123String.prototype.startWith = function (s) &#123; return this.indexOf(s) == 0&#125; 判断是否以某个字符串结束 1234String.prototype.endWith = function (s) &#123; var d = this.length - s.length; return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)&#125; 转义html标签 123function HtmlEncode(text) &#123; return text.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;')&#125; 时间日期格式转换 123456789101112131415161718Date.prototype.Format = function(formatStr) &#123; var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : '0' + (this.getYear() % 100)); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/M/g, (this.getMonth() + 1)); str = str.replace(/w|W/g, Week[this.getDay()]); str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : '0' + this.getDate()); str = str.replace(/d|D/g, this.getDate()); str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : '0' + this.getHours()); str = str.replace(/h|H/g, this.getHours()); str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : '0' + this.getMinutes()); str = str.replace(/m/g, this.getMinutes()); str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : '0' + this.getSeconds()); str = str.replace(/s|S/g, this.getSeconds()); return str&#125; 判断是否为数字类型 12345678function isDigit(value) &#123; var patrn = /^[0-9]*$/; if (patrn.exec(value) == null || value == \"\") &#123; return false &#125; else &#123; return true &#125;&#125; 设置cookie值 123456789function setCookie(name, value, Hours) &#123; var d = new Date(); var offset = 8; var utc = d.getTime() + (d.getTimezoneOffset() * 60000); var nd = utc + (3600000 * offset); var exp = new Date(nd); exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + exp.toGMTString() + \";domain=360doc.com;\"&#125; 获取cookie值 12345function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\")); if (arr != null) return unescape(arr[2]); return null&#125; 加入收藏夹 1234567891011function AddFavorite(sURL, sTitle) &#123; try &#123; window.external.addFavorite(sURL, sTitle) &#125; catch(e) &#123; try &#123; window.sidebar.addPanel(sTitle, sURL, \"\") &#125; catch(e) &#123; alert(\"加入收藏失败，请使用Ctrl+D进行添加\") &#125; &#125;&#125; 设为首页 12345678910111213141516function setHomepage() &#123; if (document.all) &#123; document.body.style.behavior = 'url(#default#homepage)'; document.body.setHomePage('http://w3cboy.com') &#125; else if (window.sidebar) &#123; if (window.netscape) &#123; try &#123; netscape.security.PrivilegeManager.enablePrivilege(\"UniversalXPConnect\") &#125; catch(e) &#123; alert(\"该操作被浏览器拒绝，如果想启用该功能，请在地址栏内输入 about:config,然后将项 signed.applets.codebase_principal_support 值该为true\") &#125; &#125; var prefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefBranch); prefs.setCharPref('browser.startup.homepage', 'http://w3cboy.com') &#125;&#125; 加载样式文件 123456789101112function LoadStyle(url) &#123; try &#123; document.createStyleSheet(url) &#125; catch(e) &#123; var cssLink = document.createElement('link'); cssLink.rel = 'stylesheet'; cssLink.type = 'text/css'; cssLink.href = url; var head = document.getElementsByTagName('head')[0]; head.appendChild(cssLink) &#125;&#125; 返回脚本内容 123456789101112131415161718function evalscript(s) &#123; if(s.indexOf('&lt;script') == -1) return s; var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig; var arr = []; while(arr = p.exec(s)) &#123; var p1 = /&lt;script[^\\&gt;]*?src=\\\"([^\\&gt;]*?)\\\"[^\\&gt;]*?(reload=\\\"1\\\")?(?:charset=\\\"([\\w\\-]+?)\\\")?&gt;&lt;\\/script&gt;/i; var arr1 = []; arr1 = p1.exec(arr[0]); if(arr1) &#123; appendscript(arr1[1], '', arr1[2], arr1[3]); &#125; else &#123; p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i; arr1 = p1.exec(arr[0]); appendscript('', arr1[2], arr1[1].indexOf('reload=') != -1); &#125; &#125; return s;&#125; 清除脚本内容 123function stripscript(s) &#123; return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, '');&#125; 动态加载脚本文件 1234567891011121314151617181920212223242526272829303132function appendscript(src, text, reload, charset) &#123; var id = hash(src + text); if(!reload &amp;&amp; in_array(id, evalscripts)) return; if(reload &amp;&amp; $(id)) &#123; $(id).parentNode.removeChild($(id)); &#125; evalscripts.push(id); var scriptNode = document.createElement(\"script\"); scriptNode.type = \"text/javascript\"; scriptNode.id = id; scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset); try &#123; if(src) &#123; scriptNode.src = src; scriptNode.onloadDone = false; scriptNode.onload = function () &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125;; scriptNode.onreadystatechange = function () &#123; if((scriptNode.readyState == 'loaded' || scriptNode.readyState == 'complete') &amp;&amp; !scriptNode.onloadDone) &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125; &#125;; &#125; else if(text)&#123; scriptNode.text = text; &#125; document.getElementsByTagName('head')[0].appendChild(scriptNode); &#125; catch(e) &#123;&#125;&#125; 返回按ID检索的元素对象 123function $(id) &#123; return !id ? null : document.getElementById(id);&#125; 跨浏览器绑定事件 12345678910function addEventSamp(obj,evt,fn)&#123; if(!oTarget)&#123;return;&#125; if (obj.addEventListener) &#123; obj.addEventListener(evt, fn, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+evt,fn); &#125;else&#123; oTarget[\"on\" + sEvtType] = fn; &#125; &#125; 跨浏览器删除事件 12345678910function delEvt(obj,evt,fn)&#123; if(!obj)&#123;return;&#125; if(obj.addEventListener)&#123; obj.addEventListener(evt,fn,false); &#125;else if(oTarget.attachEvent)&#123; obj.attachEvent(\"on\" + evt,fn); &#125;else&#123; obj[\"on\" + evt] = fn; &#125;&#125; 为元素添加on方法 12345678Element.prototype.on = Element.prototype.addEventListener; NodeList.prototype.on = function (event, fn) &#123;、 []['forEach'].call(this, function (el) &#123; el.on(event, fn); &#125;); return this;&#125;; 为元素添加trigger方法 12345678910111213141516Element.prototype.trigger = function (type, data) &#123; var event = document.createEvent('HTMLEvents'); event.initEvent(type, true, true); event.data = data || &#123;&#125;; event.eventName = type; event.target = this; this.dispatchEvent(event); return this;&#125;; NodeList.prototype.trigger = function (event) &#123; []['forEach'].call(this, function (el) &#123; el['trigger'](event); &#125;); return this;&#125;; 检验URL链接是否有效 12345678910111213141516171819function getUrlState(URL)&#123; var xmlhttp = new ActiveXObject(\"microsoft.xmlhttp\"); xmlhttp.Open(\"GET\",URL, false); try&#123; xmlhttp.Send(); &#125;catch(e)&#123; &#125;finally&#123; var result = xmlhttp.responseText; if(result)&#123; if(xmlhttp.Status==200)&#123; return(true); &#125;else&#123; return(false); &#125; &#125;else&#123; return(false); &#125; &#125;&#125; 格式化CSS样式代码 123456789function formatCss(s)&#123;//格式化代码 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.replace(/\\,[\\s\\.\\#\\d]*&#123;/g, \"&#123;\"); s = s.replace(/([^\\s])\\&#123;([^\\s])/g, \"$1 &#123;\\n\\t$2\"); s = s.replace(/([^\\s])\\&#125;([^\\n]*)/g, \"$1\\n&#125;\\n$2\"); s = s.replace(/([^\\s]);([^\\s\\&#125;])/g, \"$1;\\n\\t$2\"); return s;&#125; 压缩CSS样式代码 12345678function compressCss (s) &#123;//压缩代码 s = s.replace(/\\/\\*(.|\\n)*?\\*\\//g, \"\"); //删除注释 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/\\,[\\s\\.\\#\\d]*\\&#123;/g, \"&#123;\"); //容错处理 s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.match(/^\\s*(\\S+(\\s+\\S+)*)\\s*$/); //去掉首尾空白 return (s == null) ? \"\" : s[1];&#125; 获取当前路径 123456var currentPageUrl = \"\";if (typeof this.href === \"undefined\") &#123; currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123; currentPageUrl = this.href.toString().toLowerCase();&#125; 判断是否移动设备 1234567891011121314151617function isMobile()&#123; if (typeof this._isMobile === 'boolean')&#123; return this._isMobile; &#125; var screenWidth = this.getScreenWidth(); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport ||rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(!fixViewPortsExperiment)&#123; if(!this.isAppleMobileDevice())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; &#125; var isMobileScreenSize = screenWidth &lt; 600; var isMobileUserAgent = false; this._isMobile = isMobileScreenSize &amp;&amp; this.isTouchScreen(); return this._isMobile;&#125; 判断是否移动设备访问 123function isMobileUserAgent()&#123; return (/iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase()));&#125; 判断是否苹果移动设备访问 123function isAppleMobileDevice()&#123; return (/iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否安卓移动设备访问 123function isAndroidMobileDevice()&#123; return (/android/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否Touch屏幕 123function isTouchScreen()&#123; return (('ontouchstart' in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch);&#125; 判断是否打开视窗 123function isViewportOpen() &#123; return !!document.getElementById('wixMobileViewport');&#125; 获取移动设备初始化大小 12345678910function getInitZoom()&#123; if(!this._initZoom)&#123; var screenWidth = Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; this._initZoom = screenWidth /document.body.offsetWidth; &#125; return this._initZoom;&#125; 获取移动设备最大化大小 12345678910111213function getZoom()&#123; var screenWidth = (Math.abs(window.orientation) === 90) ? Math.max(screen.height, screen.width) : Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; var FixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var FixViewPortsExperimentRunning = FixViewPortsExperiment &amp;&amp; (FixViewPortsExperiment === \"New\" || FixViewPortsExperiment === \"new\"); if(FixViewPortsExperimentRunning)&#123; return screenWidth / window.innerWidth; &#125;else&#123; return screenWidth / document.body.offsetWidth; &#125;&#125; 获取移动设备屏幕宽度 1234567891011function getScreenWidth()&#123; var smallerSide = Math.min(screen.width, screen.height); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(fixViewPortsExperiment)&#123; if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; smallerSide = smallerSide/window.devicePixelRatio; &#125; &#125; return smallerSide;&#125; 完美判断是否为网址 12345678function IsURL(strUrl) &#123; var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i if (regular.test(strUrl)) &#123; return true; &#125;else &#123; return false; &#125;&#125; 获取页面高度 123456function getPageHeight()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125; 获取页面scrollLeft 1234function getPageScrollLeft()&#123; var a = document; return a.documentElement.scrollLeft || a.body.scrollLeft;&#125; 获取页面可视宽度 123456function getPageViewWidth()&#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientWidth;&#125; 获取页面宽度 123456function getPageWidth()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125; 获取页面scrollTop 1234function getPageScrollTop()&#123; var a = document; return a.documentElement.scrollTop || a.body.scrollTop;&#125; 获取页面可视高度 123456function getPageViewHeight() &#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientHeight;&#125; 去掉url前缀 1234567function removeUrlPrefix(a)&#123; a=a.replace(/：/g,\":\").replace(/．/g,\".\").replace(/／/g,\"/\"); while(trim(a).toLowerCase().indexOf(\"http://\")==0)&#123; a=trim(a.replace(/http:\\/\\//i,\"\")); &#125; return a;&#125; 随机数时间戳 1234function uniqueId()&#123; var a=Math.random,b=parseInt; return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125; 全角半角转换 1234567891011121314151617181920212223242526272829//iCase: 0全到半，1半到全，其他不转化function chgCase(sStr,iCase)&#123; if(typeof sStr != \"string\" || sStr.length &lt;= 0 || !(iCase === 0 || iCase == 1))&#123; return sStr; &#125; var i,oRs=[],iCode; if(iCase)&#123;/*半-&gt;全*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 32)&#123; iCode = 12288; &#125;else if(iCode &lt; 127)&#123; iCode += 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125;else&#123;/*全-&gt;半*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 12288)&#123; iCode = 32; &#125;else if(iCode &gt; 65280 &amp;&amp; iCode &lt; 65375)&#123; iCode -= 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125; return oRs.join(\"\"); &#125; 确认是否键盘有效输入值 12345678910function checkKey(iKey)&#123; if(iKey == 32 || iKey == 229)&#123;return true;&#125;/*空格和异常*/ if(iKey&gt;47 &amp;&amp; iKey &lt; 58)&#123;return true;&#125;/*数字*/ if(iKey&gt;64 &amp;&amp; iKey &lt; 91)&#123;return true;&#125;/*字母*/ if(iKey&gt;95 &amp;&amp; iKey &lt; 108)&#123;return true;&#125;/*数字键盘1*/ if(iKey&gt;108 &amp;&amp; iKey &lt; 112)&#123;return true;&#125;/*数字键盘2*/ if(iKey&gt;185 &amp;&amp; iKey &lt; 193)&#123;return true;&#125;/*符号1*/ if(iKey&gt;218 &amp;&amp; iKey &lt; 223)&#123;return true;&#125;/*符号2*/ return false;&#125; 日期格式化函数+调用方法 12345678910111213141516171819Date.prototype.format = function(format)&#123; var o = &#123; \"M+\" : this.getMonth()+1, //month \"d+\" : this.getDate(), //day \"h+\" : this.getHours(), //hour \"m+\" : this.getMinutes(), //minute \"s+\" : this.getSeconds(), //second \"q+\" : Math.floor((this.getMonth()+3)/3), //quarter \"S\" : this.getMilliseconds() //millisecond &#125;; if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(format)) format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :(\"00\"+ o[k]).substr((\"\"+ o[k]).length)); &#125; return format;&#125;alert(new Date().format(\"yyyy-MM-dd hh:mm:ss\")); 常用的正则表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//正整数/^[0-9]*[1-9][0-9]*$/;//负整数/^-[0-9]*[1-9][0-9]*$/;//正浮点数/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/; //负浮点数/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; //浮点数/^(-?\\d+)(\\.\\d+)?$/;//email地址/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;//url地址/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&apos;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$ //年/月/日（年-月-日、年.月.日）/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;//匹配中文字符/[\\u4e00-\\u9fa5]/;//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;//匹配空白行的正则表达式/\\n\\s*\\r/;//匹配中国邮政编码/[1-9]\\d&#123;5&#125;(?!\\d)/;//匹配身份证/\\d&#123;15&#125;|\\d&#123;18&#125;/;//匹配国内电话号码/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;//匹配IP地址/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;//匹配首尾空白字符的正则表达式/^\\s*|\\s*$/;//匹配HTML标记的正则表达式&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;//sql 语句^(select|drop|delete|create|update|insert).*$//提取信息中的网络链接(h|H)(r|R)(e|E)(f|F) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)? //提取信息中的邮件地址\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* //提取信息中的图片链接(s|S)(r|R)(c|C) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)? //提取信息中的 IP 地址(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)//取信息中的中国手机号码(86)*0*13\\d&#123;9&#125; //提取信息中的中国邮政编码[1-9]&#123;1&#125;(\\d+)&#123;5&#125; //提取信息中的浮点数（即小数）(-?\\d*)\\.?\\d+ //提取信息中的任何数字(-?\\d*)(\\.\\d+)?//电话区号^0\\d&#123;2,3&#125;$//腾讯 QQ 号^[1-9]*[1-9][0-9]*$ //帐号（字母开头，允许 5-16 字节，允许字母数字下划线）^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ //中文、英文、数字及下划线^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$ 返回顶部的通用方法 1234567891011121314151617181920function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = \"none\"; btn.onclick = function() &#123; btn.style.display = \"none\"; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': \"none\" &#125;&#125;;backTop('goTop'); 获得URL中GET参数值 1234567891011121314// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[\"t1\"], GET[\"t2\"], GET[\"t3\"]function get_get()&#123; querystr = window.location.href.split(\"?\") if(querystr[1])&#123; GETs = querystr[1].split(\"&amp;\"); GET = []; for(i=0;i&lt;GETs.length;i++)&#123; tmp_arr = GETs.split(\"=\") key=tmp_arr[0] GET[key] = tmp_arr[1] &#125; &#125; return querystr[1];&#125; 打开一个窗体通用方法 1234567891011121314151617181920function openWindow(url,windowName,width,height)&#123; var x = parseInt(screen.width / 2.0) - (width / 2.0); var y = parseInt(screen.height / 2.0) - (height / 2.0); var isMSIE= (navigator.appName == \"Microsoft Internet Explorer\"); if (isMSIE) &#123; var p = \"resizable=1,location=no,scrollbars=no,width=\"; p = p+width; p = p+\",height=\"; p = p+height; p = p+\",left=\"; p = p+x; p = p+\",top=\"; p = p+y; retval = window.open(url, windowName, p); &#125; else &#123; var win = window.open(url, \"ZyiisPopup\", \"top=\" + y + \",left=\" + x + \",scrollbars=\" + scrollbars + \",dialog=yes,modal=yes,width=\" + width + \",height=\" + height + \",resizable=no\" ); eval(\"try &#123; win.resizeTo(width, height); &#125; catch(e) &#123; &#125;\"); win.focus(); &#125;&#125; 提取页面代码中所有网址 12var aa = document.documentElement.outerHTML.match(/(url\\(|src=|href=)[\\\"\\']*([^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)[\\\"\\'\\)]*|(http:\\/\\/[\\w\\-\\.]+[^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)/ig).join(\"\\r\\n\").replace(/^(src=|href=|url\\()[\\\"\\']*|[\\\"\\'\\&gt;\\) ]*$/igm,\"\");alert(aa); 清除相同的数组 12345678910String.prototype.unique=function()&#123; var x=this.split(/[\\r\\n]+/); var y=''; for(var i=0;i&lt;x.length;i++)&#123; if(!new RegExp(\"^\"+x.replace(/([^\\w])/ig,\"\\\\$1\")+\"$\",\"igm\").test(y))&#123; y+=x+\"\\r\\n\" &#125; &#125; return y&#125;; 按字母排序，对每行进行数组排序 12345function SetSort()&#123; var text=K1.value.split(/[\\r\\n]/).sort().join(\"\\r\\n\");//顺序 var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(\"\\r\\n\");//反序 K1.value=K1.value!=text?text:test;&#125; 清除html代码中的脚本 123456789101112function clear_script()&#123; K1.value=K1.value.replace(/&lt;script.*?&gt;[\\s\\S]*?&lt;\\/script&gt;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?\"[\\s\\S]*?\"|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?'[\\s\\S]*?'|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=[^ &gt;]+/ig,\"\");&#125;动态执行JavaScript脚本 function javascript()&#123; try&#123; eval(K1.value); &#125;catch(e)&#123; alert(e.message); &#125;&#125; 金额大写转换函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function transform(tranvalue) &#123; try &#123; var i = 1; var dw2 = new Array(\"\", \"万\", \"亿\"); //大单位 var dw1 = new Array(\"拾\", \"佰\", \"仟\"); //小单位 var dw = new Array(\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"); //整数部分用 //以下是小写转换成大写显示在合计大写的文本框中 //分离整数与小数 var source = splits(tranvalue); var num = source[0]; var dig = source[1]; //转换整数部分 var k1 = 0; //计小单位 var k2 = 0; //计大单位 var sum = 0; var str = \"\"; var len = source[0].length; //整数的长度 for (i = 1; i &lt;= len; i++) &#123; var n = source[0].charAt(len - i); //取得某个位数上的数字 var bn = 0; if (len - i - 1 &gt;= 0) &#123; bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字 &#125; sum = sum + Number(n); if (sum != 0) &#123; str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面 if (n == '0') sum = 0; &#125; if (len - i - 1 &gt;= 0) &#123; //在数字范围内 if (k1 != 3) &#123; //加小单位 if (bn != 0) &#123; str = dw1[k1].concat(str); &#125; k1++; &#125; else &#123; //不加小单位，加大单位 k1 = 0; var temp = str.charAt(0); if (temp == \"万\" || temp == \"亿\") //若大单位前没有数字则舍去大单位 str = str.substr(1, str.length - 1); str = dw2[k2].concat(str); sum = 0; &#125; &#125; if (k1 == 3)&#123; //小单位到千则大单位进一 k2++; &#125; &#125; //转换小数部分 var strdig = \"\"; if (dig != \"\") &#123; var n = dig.charAt(0); if (n != 0) &#123; strdig += dw[Number(n)] + \"角\"; //加数字 &#125; var n = dig.charAt(1); if (n != 0) &#123; strdig += dw[Number(n)] + \"分\"; //加数字 &#125; &#125; str += \"元\" + strdig; &#125; catch(e) &#123; return \"0元\"; &#125; return str;&#125;//拆分整数与小数function splits(tranvalue) &#123; var value = new Array('', ''); temp = tranvalue.split(\".\"); for (var i = 0; i &lt; temp.length; i++) &#123; value = temp; &#125; return value;&#125; 获取窗体可见范围的宽与高 1234567function getViewSize()&#123; var de=document.documentElement; var db=document.body; var viewW=de.clientWidth==0 ? db.clientWidth : de.clientWidth; var viewH=de.clientHeight==0 ? db.clientHeight : de.clientHeight; return Array(viewW ,viewH);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Snippet","slug":"Snippet","permalink":"http://yoursite.com/tags/Snippet/"}]},{"title":"15.Mongodb 与 Mongoose 的使用","slug":"nodeMongodb 与 Mongoose 的使用","date":"2016-07-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/07/20/nodeMongodb 与 Mongoose 的使用/","link":"","permalink":"http://yoursite.com/2016/07/20/nodeMongodb 与 Mongoose 的使用/","excerpt":"","text":"《Mongodb 与 Mongoose 的使用》目标无明确目标 知识点 了解 mongodb (http://www.mongodb.org/ ) 学习 mongoose 的使用 (http://mongoosejs.com/ ) 课程内容mongodbmongodb 这个名词相信大家不会陌生吧。有段时间 nosql 的概念炒得特别火，其中 hbase redis mongodb couchdb 之类的名词都相继进入了大众的视野。 hbase 和 redis 和 mongodb 和 couchdb 虽然都属于 nosql 的大范畴。但它们关注的领域是不一样的。hbase 是存海量数据的，redis 用来做缓存，而 mongodb 和 couchdb 则试图取代一些使用 mysql 的场景。 mongodb 的官网是这样介绍自己的： MongoDB (from “humongous”) is an open-source document database, and the leading NoSQL database. Written in C++ 开源、文档型、nosql。 其中文档型是个重要的概念需要理解。 在 sql 中，我们的数据层级是：数据库（db） -&gt; 表（table） -&gt; 记录（record）-&gt; 字段；在 mongodb 中，数据的层级是：数据库 -&gt; collection -&gt; document -&gt; 字段。这四个概念可以对应得上。 文档型数据这个名字中，“文档”两个字很容易误解。其实这个文档就是 bson 的意思。bson 是 json 的超集，比如 json 中没法储存二进制类型，而 bson 拓展了类型，提供了二进制支持。mongodb 中存储的一条条记录都可以用 bson 来表示。所以你也可以认为，mongodb 是个存 bson 数据的数据库，或是存哈希数据的数据库。 mongodb 相对于它的竞争对手们来说——比如 couchdb，它的一大优势就是尽可能提供与 sql 对应的概念。之前说了，sql 中的记录对应 mongodb 中的 document，记录这东西是一维的，而 document 可以嵌套很多层。在某些场景下，比如存储一个文章的 tags，mongodb 中的字段可以轻松存储数组类型，而 sql 中就需要设计个一对多的表关系出来。 假设有一个 blog 应用，其中有张 Post 表，表中有用户发表的一些博客内容（post）。 这些 post 文档的样子大概会是这样： 123456var post = &#123; title: '呵呵的一天', author: 'alsotang', content: '今天网速很差', tags: ['呵呵', '网速', '差'],&#125;; mongodb 中有个最亮眼的特性，就是 Auto-Sharding，sharding 的意思可以理解成我们 scale sql 时的分表。 在 mongodb 中，表与表之间是没有联系的，不像 sql 中一样，可以设定外键，可以进行表连接。mongodb 中，也无法支持事务。 所以这样的表，无债一身轻。可以很轻易地 scale 至多个实例（假设实例都有不同的物理位置）上。在 mongodb 中，实时的那些查询，也就只能进行条件查询：某某大于一个值或某某等于一个值。而 sql 中，如果一张表的数据存在了多个实例上的话，当与其他表 join 时候，表之间的运来运去会是个很慢的过程，具体我也不太懂。 反正使用 mongodb 时，一定要思考的两点就是：表 join 到底要不要，事务支持到底要不要。 mongodb 中的索引特性跟 sql 中差不多，只是它对于嵌套的数据类型也提供了支持。在建立复合索引时，mongodb 可以指定不同字段的排序，比如两个字段 is_top（置顶） 和 create_time（创建时间） 要建立复合索引，我们可以指定 is_top 按正序排，create_time 按逆序排。mysql 说是有计划支持这个特性，不过目前也没什么消息。不过这点不重要。 mongodb 中，collection 是 schema-less 的。在 sql 中，我们需要用建表语句来表明数据应该具有的形式，而 mongodb 中，可以在同一张里存各种各样不同的形式的数据。同一个 collection 中，可以有些 document 具有 100 个字段，而另一些，则只具有 5 个字段。如果你分不清这个特性的使用场景，那么请像使用 sql 一样的，尽可能保证一个 collection 中数据格式是统一的。这个 schema-less 的特性，有个比较典型的场景是用来存储日志类型的数据，可以搜搜看这方面的典型场景。 mongodb 和 mysql 要我选的话，无关紧要的应用我会选择 mongodb，就当个简单的存 json 数据的数据库来用；如果是线上应用，肯定还是会选择 mysql。毕竟 sql 比较成熟，而且各种常用场景的最佳实践都有先例了。 我所在的阿里巴巴数据平台，有各种各样的大数据系统。有些做离线计算，一算就是几个小时，算出来的结果被缓存起来，查询时候就可以实时得到结果，只是数据一致性上，不可避免会有 delay；有些做实时运算，可以在 1s 内从几千万条数据中算出一个复杂条件的结果。但它们都提供了 sql 的接口，也就是说，无论底层他们是如何让几百台机器 mapreduce，都让你可以用已有的 sql 知识进行查询。所以还是选择 sql 省事啊。 这里还有个很好玩的网站：http://www.mongodb-is-web-scale.com/ 顺便说说 mongodb 与 redis 的不同。mongodb 是用来存非临时数据的，可以认为是存在硬盘上，而 redis 的数据可以认为都在内存中，存储临时数据，丢了也无所谓。对于稍微复杂的查询，redis 支持的查询方式太少太少了，几乎可以认为是 key-value 的。据说 instagram 的数据就全部存在 redis 中，用了好几个几十 G 内存的 aws ec2 机器在存。redis 也是支持把数据写入硬盘的，aof 貌似都过时了，好久没关注了。 mongodb 与 hbase 的区别。如果说你已经在考虑使用 hbase 了的话，应该也不用我介绍它们的区别了吧.. 主题所限，就不展开讲了。这之间的选择和权衡，说起来真的是个很大的话题。 我对这方面的话题很感兴趣，如果要讨论这方面话题的话，可以去 https://cnodejs.org/ 发个帖，详细描述一下场景然后 at 我（@alsotang）。 mongodb 的官网中有一些特性介绍： 其中标有箭头的是基本概念，圆圈的是进阶概念，画叉的不必了解。 安装 mongodb课程到这，一直忘记说 mongodb 的安装了。 ubuntu: http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/ mac: $ brew install mongodb 装好以后，在命令行 $ mongod，然后另外开个 shell 窗口，输入 $ mongo 就能使用了。 mongoosemongoose 是个 odm。odm 的概念对应 sql 中的 orm。也就是 ruby on rails 中的 activerecord 那一层。orm 全称是 Object-Relational Mapping，对象关系映射；而 odm 是 Object-Document Mapping，对象文档映射。 它的作用就是，在程序代码中，定义一下数据库中的数据格式，然后取数据时通过它们，可以把数据库中的 document 映射成程序中的一个对象，这个对象有 .save .update 等一系列方法，和 .title .author 等一系列属性。在调用这些方法时，odm 会根据你调用时所用的条件，自动转换成相应的 mongodb shell 语句帮你发送出去。自然地，在程序中链式调用一个个的方法要比手写数据库操作语句具有更大的灵活性和便利性。 mongoose 的官网给出了类似这样一个示例，我改造了一下： 1234567891011121314151617181920212223242526272829303132// 首先引入 mongoose 这个模块var mongoose = require('mongoose');// 然后连接对应的数据库：mongodb://localhost/test// 其中，前面那个 mongodb 是 protocol scheme 的名称；localhost 是 mongod 所在的地址；// 端口号省略则默认连接 27017；test 是数据库的名称// mongodb 中不需要建立数据库，当你需要连接的数据库不存在时，会自动创建一个出来。// 关于 mongodb 的安全性，mongodb 我印象中安全机制很残废，用户名密码那套都做得不好，更// 别提细致的用户权限控制了。不过不用担心，mongodb 的默认配置只接受来自本机的请求，内网都连不上。// 当需要在内网中为其他机器提供 mongodb 服务时，或许可以去看看 iptables 相关的东西。mongoose.connect('mongodb://localhost/test');// 上面说了，我推荐在同一个 collection 中使用固定的数据形式。// 在这里，我们创建了一个名为 Cat 的 model，它在数据库中的名字根据传给 mongoose.model 的第一个参数决定，mongoose 会将名词变为复数，在这里，collection 的名字会是 `cats`。// 这个 model 的定义是，有一个 String 类型的 name，String 数组类型的 friends，Number 类型的 age。// mongodb 中大多数的数据类型都可以用 js 的原生类型来表示。至于说 String 的长度是多少，Number 的精度是多少。String 的最大限度是 16MB，Number 的整型是 64-bit，浮点数的话，js 中 `0.1 + 0.2` 的结果都是乱来的。。就不指望什么了。。// 这里可以看到各种示例：http://mongoosejs.com/docs/schematypes.htmlvar Cat = mongoose.model('Cat', &#123; name: String, friends: [String], age: Number,&#125;);// new 一个新对象，名叫 kitty// 接着为 kitty 的属性们赋值var kitty = new Cat(&#123; name: 'Zildjian', friends: ['tom', 'jerry']&#125;);kitty.age = 3;// 调用 .save 方法后，mongoose 会去你的 mongodb 中的 test 数据库里，存入一条记录。kitty.save(function (err) &#123; if (err) // ... console.log('meow');&#125;); 我们可以验证一下 1234567$ mongoMongoDB shell version: 2.6.4connecting to: test&gt; show dbs&gt; use test&gt; show collections&gt; db.cats.find() 会发现里面就有一条记录了。 设计个简单博客程序如果要写个博客程序练手。数据库可以这样设计 123456var Post = mongoose.model('Post', &#123; title: String, content: String, author: String, create_at: Date,&#125;); 评论就不要自己做了，接入多说：http://duoshuo.com/ 编辑器就纯文本好了，用 markdown 写。 用户系统也不做，硬编码几个管理员账号在配置文件中，然后用 http basic auth：https://github.com/jshttp/basic-auth 来做验证。 示例程序Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统 https://github.com/cnodejs/nodeclub 完。","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"10.测试用例：supertest","slug":"node测试用例：supertest","date":"2016-07-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/07/20/node测试用例：supertest/","link":"","permalink":"http://yoursite.com/2016/07/20/node测试用例：supertest/","excerpt":"","text":"《测试用例：supertest》目标建立一个 lesson8 项目，在其中编写代码。 app.js: 其中有个 fibonacci 接口。fibonacci 的介绍见：http://en.wikipedia.org/wiki/Fibonacci_number 。 fibonacci 函数的定义为 int fibonacci(int n)，调用函数的路径是 ‘/fib?n=10’，然后这个接口会返回 ‘55’。函数的行为定义如下： 当 n === 0 时，返回 0；n === 1时，返回 1; n &gt; 1 时，返回 fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)，如 fibonacci(10) === 55; n 不可大于10，否则抛错，http status 500，因为 Node.js 的计算性能没那么强。 n 也不可小于 0，否则抛错，500，因为没意义。 n 不为数字时，抛错，500。 test/main.test.js: 对 app 的接口进行测试，覆盖以上所有情况。 知识点 学习 supertest 的使用 (https://github.com/tj/supertest ) 复习 mocha，should 的使用 课程内容这是连续第三节课讲测试了..我自己都烦..看着烦的可以考虑跳下一课。 OK，基础知识前面都讲得很多了，这节课我不会事无巨细地写过程了。 噢，对了，说到 fibonacci，Node 中文圈的大神 @苏千(https://github.com/fengmk2 ) 写过一个页面，对各种语言的 fibonacci 效率进行了测试：http://fengmk2.cnpmjs.org/blog/2011/fibonacci/nodejs-python-php-ruby-lua.html 。其中，Node 的表现不知道比 Python 和 Ruby 高到哪里去了，与 CPU 谈笑风生。怀疑 js 的人啊，都 too simple，sometimes naive。 先来介绍一下 supertest。supertest 是 superagent 的孪生库。他的作者叫 tj，这是个在 Node.js 的历史上会永远被记住的名字，因为他一个人撑起了 npm 的半边天。别误会成他是 npm 的开发者，他的贡献是在 Node.js 的方方面面都贡献了非常高质量和口碑的库，比如 mocha 是他的，superagent 是他的，express 是他的，should 也是他的，还有其他很多很多，比如 koa，都是他的。如果你更详细点了解一些 Node 圈内的八卦，一定也会像我一样对 tj 佩服得五体投地。他的 github 首页是：https://github.com/tj 。 假使你作为一个有志之士，想要以他为榜样，跟随他前进的步伐，那么我指条明路给你，不收费的：http://tour.golang.org/ 为什么说 supertest 是 superagent 的孪生库呢，因为他们的 API 是一模一样的。superagent 是用来抓取页面用的，而 supertest，是专门用来配合 express （准确来说是所有兼容 connect 的 web 框架）进行集成测试的。 将使你有一个 app: var app = express();，想对它的 get 啊，post 接口啊之类的进行测试，那么只要把它传给 supertest：var request = require(&#39;supertest&#39;)(app)。之后调用 requset.get(&#39;/path&#39;) 时，就可以对 app 的 path 路径进行访问了。它的 API 参照 superagent 的来就好了：http://visionmedia.github.io/superagent/ 。 我们来新建一个项目 1$ npm init # ..一阵乱填 然后安装我们的依赖（记得去弄清楚 npm i --save 与 npm i --save-dev 的区别）： 12345678\"devDependencies\": &#123; \"mocha\": \"^1.21.4\", \"should\": \"^4.0.4\", \"supertest\": \"^0.14.0\"&#125;,\"dependencies\": &#123; \"express\": \"^4.9.6\"&#125; 接着，编写 app.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var express = require('express');// 与之前一样var fibonacci = function (n) &#123; // typeof NaN === 'number' 是成立的，所以要判断 NaN if (typeof n !== 'number' || isNaN(n)) &#123; throw new Error('n should be a Number'); &#125; if (n &lt; 0) &#123; throw new Error('n should &gt;= 0') &#125; if (n &gt; 10) &#123; throw new Error('n should &lt;= 10'); &#125; if (n === 0) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; return fibonacci(n-1) + fibonacci(n-2);&#125;;// END 与之前一样var app = express();app.get('/fib', function (req, res) &#123; // http 传来的东西默认都是没有类型的，都是 String，所以我们要手动转换类型 var n = Number(req.query.n); try &#123; // 为何使用 String 做类型转换，是因为如果你直接给个数字给 res.send 的话， // 它会当成是你给了它一个 http 状态码，所以我们明确给 String res.send(String(fibonacci(n))); &#125; catch (e) &#123; // 如果 fibonacci 抛错的话，错误信息会记录在 err 对象的 .message 属性中。 // 拓展阅读：https://www.joyent.com/developers/node/design/errors res .status(500) .send(e.message); &#125;&#125;);// 暴露 app 出去。module.exports 与 exports 的区别请看《深入浅出 Node.js》module.exports = app;app.listen(3000, function () &#123; console.log('app is listening at port 3000');&#125;); 好了，启动一下看看。 1$ node app.js 然后访问 http://localhost:3000/fib?n=10，看到 55 就说明启动成功了。再访问 http://localhost:3000/fib?n=111，会看到 n should &lt;= 10。 对了，大家去装个 nodemon https://github.com/remy/nodemon 。 $ npm i -g nodemon 这个库是专门调试时候使用的，它会自动检测 node.js 代码的改动，然后帮你自动重启应用。在调试时可以完全用 nodemon 命令代替 node 命令。 $ nodemon app.js 启动我们的应用试试，然后随便改两行代码，就可以看到 nodemon 帮我们重启应用了。 那么 app 写完了，接着开始测试，测试代码在 test/app.test.js。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var app = require('../app');var supertest = require('supertest');// 看下面这句，这是关键一句。得到的 request 对象可以直接按照// superagent 的 API 进行调用var request = supertest(app);var should = require('should');describe('test/app.test.js', function () &#123; // 我们的第一个测试用例，好好理解一下 it('should return 55 when n is 10', function (done) &#123; // 之所以这个测试的 function 要接受一个 done 函数，是因为我们的测试内容 // 涉及了异步调用，而 mocha 是无法感知异步调用完成的。所以我们主动接受它提供 // 的 done 函数，在测试完毕时，自行调用一下，以示结束。 // mocha 可以感知到我们的测试函数是否接受 done 参数。js 中，function // 对象是有长度的，它的长度由它的参数数量决定 // (function (a, b, c, d) &#123;&#125;).length === 4 // 所以 mocha 通过我们测试函数的长度就可以确定我们是否是异步测试。 request.get('/fib') // .query 方法用来传 querystring，.send 方法用来传 body。 // 它们都可以传 Object 对象进去。 // 在这里，我们等于访问的是 /fib?n=10 .query(&#123;n: 10&#125;) .end(function (err, res) &#123; // 由于 http 返回的是 String，所以我要传入 '55'。 res.text.should.equal('55'); // done(err) 这种用法写起来很鸡肋，是因为偷懒不想测 err 的值 // 如果勤快点，这里应该写成 /* should.not.exist(err); res.text.should.equal('55'); */ done(err); &#125;); &#125;); // 下面我们对于各种边界条件都进行测试，由于它们的代码雷同， // 所以我抽象出来了一个 testFib 方法。 var testFib = function (n, statusCode, expect, done) &#123; request.get('/fib') .query(&#123;n: n&#125;) .expect(statusCode) .end(function (err, res) &#123; res.text.should.equal(expect); done(err); &#125;); &#125;; it('should return 0 when n === 0', function (done) &#123; testFib(0, 200, '0', done); &#125;); it('should equal 1 when n === 1', function (done) &#123; testFib(1, 200, '1', done); &#125;); it('should equal 55 when n === 10', function (done) &#123; testFib(10, 200, '55', done); &#125;); it('should throw when n &gt; 10', function (done) &#123; testFib(11, 500, 'n should &lt;= 10', done); &#125;); it('should throw when n &lt; 0', function (done) &#123; testFib(-1, 500, 'n should &gt;= 0', done); &#125;); it('should throw when n isnt Number', function (done) &#123; testFib('good', 500, 'n should be a Number', done); &#125;); // 单独测试一下返回码 500 it('should status 500 when error', function (done) &#123; request.get('/fib') .query(&#123;n: 100&#125;) .expect(500) .end(function (err, res) &#123; done(err); &#125;); &#125;);&#125;); 完。 关于 cookie 持久化有两种思路 在 supertest 中，可以通过 var agent = supertest.agent(app) 获取一个 agent 对象，这个对象的 API 跟直接在 superagent 上调用各种方法是一样的。agent 对象在被多次调用 get 和 post 之后，可以一路把 cookie 都保存下来。 1234567var supertest = require('supertest');var app = express();var agent = supertest.agent(app);agent.post('login').end(...);// then ..agent.post('create_topic').end(...); // 此时的 agent 中有用户登陆后的 cookie 在发起请求时，调用 .set(&#39;Cookie&#39;, &#39;a cookie string&#39;) 这样的方式。 12345678910var supertest = require('supertest');var userCookie;supertest.post('login').end(function (err, res) &#123; userCookie = res.headers['set-cookie'] &#125;);// then ..supertest.post('create_topic') .set('cookie', userCookie) .end(...) 这里有个相关讨论：https://github.com/tj/supertest/issues/46 拓展学习Nodeclub 里面的测试使用的技术跟前面介绍的是一样的，should mocha supertest 那套，应该是很容易看懂的: https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"Javascript常用方法函数收集","slug":"Javascript常用方法函数收集","date":"2016-07-19T15:25:20.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/07/19/Javascript常用方法函数收集/","link":"","permalink":"http://yoursite.com/2016/07/19/Javascript常用方法函数收集/","excerpt":"字符串长度截取","text":"字符串长度截取 1234567891011121314151617181920function cutstr(str, len) &#123;var temp, icount = 0, patrn = /[^\\x00-\\xff]/， strre = \"\";for (var i = 0; i &lt; str.length; i++) &#123; if (icount &lt; len - 1) &#123; temp = str.substr(i, 1); if (patrn.exec(temp) == null) &#123; icount = icount + 1 &#125; else &#123; icount = icount + 2 &#125; strre += temp &#125; else &#123; break; &#125;&#125;return strre + \"...\"&#125; 替换全部123String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, \"gm\"), s2)&#125; 清除空格*1234String.prototype.trim = function() &#123; var reExtraSpace = /^\\s*(.*?)\\s+$/; return this.replace(reExtraSpace, \"$1\")&#125; 清除左空格/右空格*12function ltrim(s)&#123; return s.replace( /^(\\s*| *)/, \"\"); &#125; function rtrim(s)&#123; return s.replace( /(\\s*| *)$/, \"\"); &#125; 判断是否以某个字符串开头*123String.prototype.startWith = function (s) &#123; return this.indexOf(s) == 0&#125; 判断是否以某个字符串结束*1234String.prototype.endWith = function (s) &#123; var d = this.length - s.length; return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)&#125; 转义html标签*123function HtmlEncode(text) &#123; return text.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;')&#125; 时间日期格式转换*123456789101112131415161718Date.prototype.Format = function(formatStr) &#123; var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : '0' + (this.getYear() % 100)); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/M/g, (this.getMonth() + 1)); str = str.replace(/w|W/g, Week[this.getDay()]); str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : '0' + this.getDate()); str = str.replace(/d|D/g, this.getDate()); str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : '0' + this.getHours()); str = str.replace(/h|H/g, this.getHours()); str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : '0' + this.getMinutes()); str = str.replace(/m/g, this.getMinutes()); str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : '0' + this.getSeconds()); str = str.replace(/s|S/g, this.getSeconds()); return str&#125; 判断是否为数字类型*12345678function isDigit(value) &#123; var patrn = /^[0-9]*$/; if (patrn.exec(value) == null || value == \"\") &#123; return false &#125; else &#123; return true &#125;&#125; 设置cookie值*123456789function setCookie(name, value, Hours) &#123; var d = new Date(); var offset = 8; var utc = d.getTime() + (d.getTimezoneOffset() * 60000); var nd = utc + (3600000 * offset); var exp = new Date(nd); exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + exp.toGMTString() + \";domain=360doc.com;\"&#125; 获取cookie值*12345function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\")); if (arr != null) return unescape(arr[2]); return null&#125; 加入收藏夹*1234567891011function AddFavorite(sURL, sTitle) &#123; try &#123; window.external.addFavorite(sURL, sTitle) &#125; catch(e) &#123; try &#123; window.sidebar.addPanel(sTitle, sURL, \"\") &#125; catch(e) &#123; alert(\"加入收藏失败，请使用Ctrl+D进行添加\") &#125; &#125;&#125; 设为首页*12345678910111213141516function setHomepage() &#123; if (document.all) &#123; document.body.style.behavior = 'url(#default#homepage)'; document.body.setHomePage('http://w3cboy.com') &#125; else if (window.sidebar) &#123; if (window.netscape) &#123; try &#123; netscape.security.PrivilegeManager.enablePrivilege(\"UniversalXPConnect\") &#125; catch(e) &#123; alert(\"该操作被浏览器拒绝，如果想启用该功能，请在地址栏内输入 about:config,然后将项 signed.applets.codebase_principal_support 值该为true\") &#125; &#125; var prefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefBranch); prefs.setCharPref('browser.startup.homepage', 'http://w3cboy.com') &#125;&#125; 加载样式文件*123456789101112function LoadStyle(url) &#123; try &#123; document.createStyleSheet(url) &#125; catch(e) &#123; var cssLink = document.createElement('link'); cssLink.rel = 'stylesheet'; cssLink.type = 'text/css'; cssLink.href = url; var head = document.getElementsByTagName('head')[0]; head.appendChild(cssLink) &#125;&#125; 返回脚本内容123456789101112131415161718function evalscript(s) &#123; if(s.indexOf('&lt;script') == -1) return s; var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig; var arr = []; while(arr = p.exec(s)) &#123; var p1 = /&lt;script[^\\&gt;]*?src=\\\"([^\\&gt;]*?)\\\"[^\\&gt;]*?(reload=\\\"1\\\")?(?:charset=\\\"([\\w\\-]+?)\\\")?&gt;&lt;\\/script&gt;/i; var arr1 = []; arr1 = p1.exec(arr[0]); if(arr1) &#123; appendscript(arr1[1], '', arr1[2], arr1[3]); &#125; else &#123; p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i; arr1 = p1.exec(arr[0]); appendscript('', arr1[2], arr1[1].indexOf('reload=') != -1); &#125; &#125; return s;&#125; 清除脚本内容123function stripscript(s) &#123; return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, '');&#125; 动态加载脚本文件1234567891011121314151617181920212223242526272829303132function appendscript(src, text, reload, charset) &#123; var id = hash(src + text); if(!reload &amp;&amp; in_array(id, evalscripts)) return; if(reload &amp;&amp; $(id)) &#123; $(id).parentNode.removeChild($(id)); &#125; evalscripts.push(id); var scriptNode = document.createElement(\"script\"); scriptNode.type = \"text/javascript\"; scriptNode.id = id; scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset); try &#123; if(src) &#123; scriptNode.src = src; scriptNode.onloadDone = false; scriptNode.onload = function () &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125;; scriptNode.onreadystatechange = function () &#123; if((scriptNode.readyState == 'loaded' || scriptNode.readyState == 'complete') &amp;&amp; !scriptNode.onloadDone) &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125; &#125;; &#125; else if(text)&#123; scriptNode.text = text; &#125; document.getElementsByTagName('head')[0].appendChild(scriptNode); &#125; catch(e) &#123;&#125;&#125; 返回按ID检索的元素对象123function $(id) &#123; return !id ? null : document.getElementById(id);&#125; 跨浏览器绑定事件12345678910function addEventSamp(obj,evt,fn)&#123; if(!oTarget)&#123;return;&#125; if (obj.addEventListener) &#123; obj.addEventListener(evt, fn, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+evt,fn); &#125;else&#123; oTarget[\"on\" + sEvtType] = fn; &#125; &#125; 跨浏览器删除事件12345678910function delEvt(obj,evt,fn)&#123; if(!obj)&#123;return;&#125; if(obj.addEventListener)&#123; obj.addEventListener(evt,fn,false); &#125;else if(oTarget.attachEvent)&#123; obj.attachEvent(\"on\" + evt,fn); &#125;else&#123; obj[\"on\" + evt] = fn; &#125;&#125; 为元素添加on方法12345678Element.prototype.on = Element.prototype.addEventListener; NodeList.prototype.on = function (event, fn) &#123;、 []['forEach'].call(this, function (el) &#123; el.on(event, fn); &#125;); return this;&#125;; 为元素添加trigger方法12345678910111213141516Element.prototype.trigger = function (type, data) &#123; var event = document.createEvent('HTMLEvents'); event.initEvent(type, true, true); event.data = data || &#123;&#125;; event.eventName = type; event.target = this; this.dispatchEvent(event); return this;&#125;; NodeList.prototype.trigger = function (event) &#123; []['forEach'].call(this, function (el) &#123; el['trigger'](event); &#125;); return this;&#125;; 检验URL链接是否有效12345678910111213141516171819function getUrlState(URL)&#123; var xmlhttp = new ActiveXObject(\"microsoft.xmlhttp\"); xmlhttp.Open(\"GET\",URL, false); try&#123; xmlhttp.Send(); &#125;catch(e)&#123; &#125;finally&#123; var result = xmlhttp.responseText; if(result)&#123; if(xmlhttp.Status==200)&#123; return(true); &#125;else&#123; return(false); &#125; &#125;else&#123; return(false); &#125; &#125;&#125; 格式化CSS样式代码123456789function formatCss(s)&#123;//格式化代码 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.replace(/\\,[\\s\\.\\#\\d]*&#123;/g, \"&#123;\"); s = s.replace(/([^\\s])\\&#123;([^\\s])/g, \"$1 &#123;\\n\\t$2\"); s = s.replace(/([^\\s])\\&#125;([^\\n]*)/g, \"$1\\n&#125;\\n$2\"); s = s.replace(/([^\\s]);([^\\s\\&#125;])/g, \"$1;\\n\\t$2\"); return s;&#125; 压缩CSS样式代码12345678function compressCss (s) &#123;//压缩代码 s = s.replace(/\\/\\*(.|\\n)*?\\*\\//g, \"\"); //删除注释 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/\\,[\\s\\.\\#\\d]*\\&#123;/g, \"&#123;\"); //容错处理 s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.match(/^\\s*(\\S+(\\s+\\S+)*)\\s*$/); //去掉首尾空白 return (s == null) ? \"\" : s[1];&#125; 获取当前路径123456var currentPageUrl = \"\";if (typeof this.href === \"undefined\") &#123; currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123; currentPageUrl = this.href.toString().toLowerCase();&#125; 判断是否移动设备1234567891011121314151617function isMobile()&#123; if (typeof this._isMobile === 'boolean')&#123; return this._isMobile; &#125; var screenWidth = this.getScreenWidth(); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport ||rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(!fixViewPortsExperiment)&#123; if(!this.isAppleMobileDevice())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; &#125; var isMobileScreenSize = screenWidth &lt; 600; var isMobileUserAgent = false; this._isMobile = isMobileScreenSize &amp;&amp; this.isTouchScreen(); return this._isMobile;&#125; 判断是否移动设备访问123function isMobileUserAgent()&#123; return (/iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase()));&#125; 判断是否苹果移动设备访问123function isAppleMobileDevice()&#123; return (/iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否安卓移动设备访问123function isAndroidMobileDevice()&#123; return (/android/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否Touch屏幕123function isTouchScreen()&#123; return (('ontouchstart' in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch);&#125; 判断是否打开视窗123function isViewportOpen() &#123; return !!document.getElementById('wixMobileViewport');&#125; 获取移动设备初始化大小12345678910function getInitZoom()&#123; if(!this._initZoom)&#123; var screenWidth = Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; this._initZoom = screenWidth /document.body.offsetWidth; &#125; return this._initZoom;&#125; 取移动设备最大化大小12345678910111213function getZoom()&#123; var screenWidth = (Math.abs(window.orientation) === 90) ? Math.max(screen.height, screen.width) : Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; var FixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var FixViewPortsExperimentRunning = FixViewPortsExperiment &amp;&amp; (FixViewPortsExperiment === \"New\" || FixViewPortsExperiment === \"new\"); if(FixViewPortsExperimentRunning)&#123; return screenWidth / window.innerWidth; &#125;else&#123; return screenWidth / document.body.offsetWidth; &#125;&#125; 取移动设备屏幕宽度1234567891011function getScreenWidth()&#123; var smallerSide = Math.min(screen.width, screen.height); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(fixViewPortsExperiment)&#123; if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; smallerSide = smallerSide/window.devicePixelRatio; &#125; &#125; return smallerSide;&#125; 美判断是否为网址12345678function IsURL(strUrl) &#123; var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i if (regular.test(strUrl)) &#123; return true; &#125;else &#123; return false; &#125;&#125; etElementsByClassName12345678910111213141516function getElementsByClassName(name) &#123; var tags = document.getElementsByTagName('*') || document.all; var els = []; for (var i = 0; i &lt; tags.length; i++) &#123; if (tags.className) &#123; var cs = tags.className.split(' '); for (var j = 0; j &lt; cs.length; j++) &#123; if (name == cs[j]) &#123; els.push(tags); break &#125; &#125; &#125; &#125; return els&#125; 取页面高度123456function getPageHeight()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125; 取页面scrollLeft1234function getPageScrollLeft()&#123; var a = document; return a.documentElement.scrollLeft || a.body.scrollLeft;&#125; 取页面可视宽度123456function getPageViewWidth()&#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientWidth;&#125; 取页面宽度123456function getPageWidth()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125; 取页面scrollTop1234function getPageScrollTop()&#123; var a = document; return a.documentElement.scrollTop || a.body.scrollTop;&#125; 取页面可视高度123456function getPageViewHeight() &#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientHeight;&#125; 掉url前缀1234567function removeUrlPrefix(a)&#123; a=a.replace(/：/g,\":\").replace(/．/g,\".\").replace(/／/g,\"/\"); while(trim(a).toLowerCase().indexOf(\"http://\")==0)&#123; a=trim(a.replace(/http:\\/\\//i,\"\")); &#125; return a;&#125; 随机数时间戳1234function uniqueId()&#123; var a=Math.random,b=parseInt; return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125; 全角半角转换1234567891011121314151617181920212223242526272829//iCase: 0全到半，1半到全，其他不转化function chgCase(sStr,iCase)&#123; if(typeof sStr != \"string\" || sStr.length &lt;= 0 || !(iCase === 0 || iCase == 1))&#123; return sStr; &#125; var i,oRs=[],iCode; if(iCase)&#123;/*半-&gt;全*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 32)&#123; iCode = 12288; &#125;else if(iCode &lt; 127)&#123; iCode += 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125;else&#123;/*全-&gt;半*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 12288)&#123; iCode = 32; &#125;else if(iCode &gt; 65280 &amp;&amp; iCode &lt; 65375)&#123; iCode -= 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125; return oRs.join(\"\"); &#125; 确认是否键盘有效输入值12345678910function checkKey(iKey)&#123; if(iKey == 32 || iKey == 229)&#123;return true;&#125;/*空格和异常*/ if(iKey&gt;47 &amp;&amp; iKey &lt; 58)&#123;return true;&#125;/*数字*/ if(iKey&gt;64 &amp;&amp; iKey &lt; 91)&#123;return true;&#125;/*字母*/ if(iKey&gt;95 &amp;&amp; iKey &lt; 108)&#123;return true;&#125;/*数字键盘1*/ if(iKey&gt;108 &amp;&amp; iKey &lt; 112)&#123;return true;&#125;/*数字键盘2*/ if(iKey&gt;185 &amp;&amp; iKey &lt; 193)&#123;return true;&#125;/*符号1*/ if(iKey&gt;218 &amp;&amp; iKey &lt; 223)&#123;return true;&#125;/*符号2*/ return false;&#125; 获取网页被卷去的位置123456789function getScrollXY() &#123; return document.body.scrollTop ? &#123; x: document.body.scrollLeft, y: document.body.scrollTop &#125;: &#123; x: document.documentElement.scrollLeft, y: document.documentElement.scrollTop &#125;&#125; 日期格式化函数+调用方法12345678910111213141516171819Date.prototype.format = function(format)&#123; var o = &#123; \"M+\" : this.getMonth()+1, //month \"d+\" : this.getDate(), //day \"h+\" : this.getHours(), //hour \"m+\" : this.getMinutes(), //minute \"s+\" : this.getSeconds(), //second \"q+\" : Math.floor((this.getMonth()+3)/3), //quarter \"S\" : this.getMilliseconds() //millisecond &#125;; if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(format)) format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :(\"00\"+ o[k]).substr((\"\"+ o[k]).length)); &#125; return format;&#125;alert(new Date().format(\"yyyy-MM-dd hh:mm:ss\")); 时间个性化输出功能12345678910111213141516171819202122232425262728293031323334353637383940/*1、&lt; 60s, 显示为“刚刚”2、&gt;= 1min &amp;&amp; &lt; 60 min, 显示与当前时间差“XX分钟前”3、&gt;= 60min &amp;&amp; &lt; 1day, 显示与当前时间差“今天 XX:XX”4、&gt;= 1day &amp;&amp; &lt; 1year, 显示日期“XX月XX日 XX:XX”5、&gt;= 1year, 显示具体日期“XXXX年XX月XX日 XX:XX”*/function timeFormat(time)&#123; var date = new Date(time), curDate = new Date(), year = date.getFullYear(), month = date.getMonth() + 10, day = date.getDate(), hour = date.getHours(), minute = date.getMinutes(), curYear = curDate.getFullYear(), curHour = curDate.getHours(), timeStr; if(year &lt; curYear)&#123; timeStr = year +'年'+ month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else&#123; var pastTime = curDate - date, pastH = pastTime/3600000; if(pastH &gt; curHour)&#123; timeStr = month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else if(pastH &gt;= 1)&#123; timeStr = '今天 ' + hour +':'+ minute +'分'; &#125;else&#123; var pastM = curDate.getMinutes() - minute; if(pastM &gt; 1)&#123; timeStr = pastM +'分钟前'; &#125;else&#123; timeStr = '刚刚'; &#125; &#125; &#125; return timeStr;&#125; 解决offsetX兼容性问题1234567891011121314151617181920212223242526272829303132333435// 针对火狐不支持offsetX/Yfunction getOffset(e)&#123; var target = e.target, // 当前触发的目标对象 eventCoord, pageCoord, offsetCoord; // 计算当前触发元素到文档的距离 pageCoord = getPageCoord(target); // 计算光标到文档的距离 eventCoord = &#123; X : window.pageXOffset + e.clientX, Y : window.pageYOffset + e.clientY &#125;; // 相减获取光标到第一个定位的父元素的坐标 offsetCoord = &#123; X : eventCoord.X - pageCoord.X, Y : eventCoord.Y - pageCoord.Y &#125;; return offsetCoord;&#125; function getPageCoord(element)&#123; var coord = &#123; X : 0, Y : 0 &#125;; // 计算从当前触发元素到根节点为止， // 各级 offsetParent 元素的 offsetLeft 或 offsetTop 值之和 while (element)&#123; coord.X += element.offsetLeft; coord.Y += element.offsetTop; element = element.offsetParent; &#125; return coord;&#125; 常用的正则表达式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//正整数/^[0-9]*[1-9][0-9]*$/;//负整数/^-[0-9]*[1-9][0-9]*$/;//正浮点数/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/; //负浮点数/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; //浮点数/^(-?\\d+)(\\.\\d+)?$/;//email地址/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;//url地址/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\':+!]*([^&lt;&gt;\\\"\\\"])*$ //年/月/日（年-月-日、年.月.日）/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;//匹配中文字符/[\\u4e00-\\u9fa5]/;//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;//匹配空白行的正则表达式/\\n\\s*\\r/;//匹配中国邮政编码/[1-9]\\d&#123;5&#125;(?!\\d)/;//匹配身份证/\\d&#123;15&#125;|\\d&#123;18&#125;/;//匹配国内电话号码/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;//匹配IP地址/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;//匹配首尾空白字符的正则表达式/^\\s*|\\s*$/;//匹配HTML标记的正则表达式&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;//sql 语句^(select|drop|delete|create|update|insert).*$//提取信息中的网络链接(h|H)(r|R)(e|E)(f|F) *= *('|\")?(\\w|\\\\|\\/|\\.)+('|\"| *|&gt;)? //提取信息中的邮件地址\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* //提取信息中的图片链接(s|S)(r|R)(c|C) *= *('|\")?(\\w|\\\\|\\/|\\.)+('|\"| *|&gt;)? //提取信息中的 IP 地址(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)//取信息中的中国手机号码(86)*0*13\\d&#123;9&#125; //提取信息中的中国邮政编码[1-9]&#123;1&#125;(\\d+)&#123;5&#125; //提取信息中的浮点数（即小数）(-?\\d*)\\.?\\d+ //提取信息中的任何数字(-?\\d*)(\\.\\d+)?//电话区号^0\\d&#123;2,3&#125;$//腾讯 QQ 号^[1-9]*[1-9][0-9]*$ //帐号（字母开头，允许 5-16 字节，允许字母数字下划线）^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ //中文、英文、数字及下划线^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$ 返回顶部的通用方法1234567891011121314151617181920function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = \"none\"; btn.onclick = function() &#123; btn.style.display = \"none\"; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': \"none\" &#125;&#125;;backTop('goTop'); **获得URL中GET参数值 1234567891011121314// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[\"t1\"], GET[\"t2\"], GET[\"t3\"]function get_get()&#123; querystr = window.location.href.split(\"?\") if(querystr[1])&#123; GETs = querystr[1].split(\"&amp;\"); GET = []; for(i=0;i&lt;GETs.length;i++)&#123; tmp_arr = GETs.split(\"=\") key=tmp_arr[0] GET[key] = tmp_arr[1] &#125; &#125; return querystr[1];&#125; 打开一个窗体通用方法1234567891011121314151617181920function openWindow(url,windowName,width,height)&#123; var x = parseInt(screen.width / 2.0) - (width / 2.0); var y = parseInt(screen.height / 2.0) - (height / 2.0); var isMSIE= (navigator.appName == \"Microsoft Internet Explorer\"); if (isMSIE) &#123; var p = \"resizable=1,location=no,scrollbars=no,width=\"; p = p+width; p = p+\",height=\"; p = p+height; p = p+\",left=\"; p = p+x; p = p+\",top=\"; p = p+y; retval = window.open(url, windowName, p); &#125; else &#123; var win = window.open(url, \"ZyiisPopup\", \"top=\" + y + \",left=\" + x + \",scrollbars=\" + scrollbars + \",dialog=yes,modal=yes,width=\" + width + \",height=\" + height + \",resizable=no\" ); eval(\"try &#123; win.resizeTo(width, height); &#125; catch(e) &#123; &#125;\"); win.focus(); &#125;&#125; 提取页面代码中所有网址12var aa = document.documentElement.outerHTML.match(/(url\\(|src=|href=)[\\\"\\']*([^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)[\\\"\\'\\)]*|(http:\\/\\/[\\w\\-\\.]+[^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)/ig).join(\"\\r\\n\").replace(/^(src=|href=|url\\()[\\\"\\']*|[\\\"\\'\\&gt;\\) ]*$/igm,\"\");alert(aa); 清除相同的数组12345678910String.prototype.unique=function()&#123; var x=this.split(/[\\r\\n]+/); var y=''; for(var i=0;i&lt;x.length;i++)&#123; if(!new RegExp(\"^\"+x.replace(/([^\\w])/ig,\"\\\\$1\")+\"$\",\"igm\").test(y))&#123; y+=x+\"\\r\\n\" &#125; &#125; return y&#125;; 按字母排序，对每行进行数组排序12345function SetSort()&#123; var text=K1.value.split(/[\\r\\n]/).sort().join(\"\\r\\n\");//顺序 var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(\"\\r\\n\");//反序 K1.value=K1.value!=text?text:test;&#125; 字符串反序123function IsReverse(text)&#123; return text.split('').reverse().join('');&#125; 清除html代码中的脚本123456789101112function clear_script()&#123; K1.value=K1.value.replace(/&lt;script.*?&gt;[\\s\\S]*?&lt;\\/script&gt;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?\"[\\s\\S]*?\"|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?'[\\s\\S]*?'|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=[^ &gt;]+/ig,\"\");&#125;动态执行JavaScript脚本 function javascript()&#123; try&#123; eval(K1.value); &#125;catch(e)&#123; alert(e.message); &#125;&#125; 动态执行VBScript脚本123456789function vbscript()&#123; try&#123; var script=document.getElementById(\"K1\").value; if(script.trim()==\"\")return; window.execScript('On Error Resume Next \\n'+script+'\\n If Err.Number&lt;&gt;0 Then \\n MsgBox \"请输入正确的VBScript脚本!\",48,\"脚本错误!\" \\n End If',\"vbscript\") &#125;catch(e)&#123; alert(e.message); &#125;&#125; 金额大写转换函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function transform(tranvalue) &#123; try &#123; var i = 1; var dw2 = new Array(\"\", \"万\", \"亿\"); //大单位 var dw1 = new Array(\"拾\", \"佰\", \"仟\"); //小单位 var dw = new Array(\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"); //整数部分用 //以下是小写转换成大写显示在合计大写的文本框中 //分离整数与小数 var source = splits(tranvalue); var num = source[0]; var dig = source[1]; //转换整数部分 var k1 = 0; //计小单位 var k2 = 0; //计大单位 var sum = 0; var str = \"\"; var len = source[0].length; //整数的长度 for (i = 1; i &lt;= len; i++) &#123; var n = source[0].charAt(len - i); //取得某个位数上的数字 var bn = 0; if (len - i - 1 &gt;= 0) &#123; bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字 &#125; sum = sum + Number(n); if (sum != 0) &#123; str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面 if (n == '0') sum = 0; &#125; if (len - i - 1 &gt;= 0) &#123; //在数字范围内 if (k1 != 3) &#123; //加小单位 if (bn != 0) &#123; str = dw1[k1].concat(str); &#125; k1++; &#125; else &#123; //不加小单位，加大单位 k1 = 0; var temp = str.charAt(0); if (temp == \"万\" || temp == \"亿\") //若大单位前没有数字则舍去大单位 str = str.substr(1, str.length - 1); str = dw2[k2].concat(str); sum = 0; &#125; &#125; if (k1 == 3)&#123; //小单位到千则大单位进一 k2++; &#125; &#125; //转换小数部分 var strdig = \"\"; if (dig != \"\") &#123; var n = dig.charAt(0); if (n != 0) &#123; strdig += dw[Number(n)] + \"角\"; //加数字 &#125; var n = dig.charAt(1); if (n != 0) &#123; strdig += dw[Number(n)] + \"分\"; //加数字 &#125; &#125; str += \"元\" + strdig; &#125; catch(e) &#123; return \"0元\"; &#125; return str;&#125;//拆分整数与小数function splits(tranvalue) &#123; var value = new Array('', ''); temp = tranvalue.split(\".\"); for (var i = 0; i &lt; temp.length; i++) &#123; value = temp; &#125; return value;&#125; resize的操作12345678910111213141516171819(function()&#123; var fn = function()&#123; var w = document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth ,r = 1255 ,b = Element.extend(document.body) ,classname = b.className; if(w &lt; r)&#123; //当窗体的宽度小于1255的时候执行相应的操作 &#125;else&#123; //当窗体的宽度大于1255的时候执行相应的操作 &#125; &#125; if(window.addEventListener)&#123; window.addEventListener('resize', function()&#123; fn(); &#125;); &#125;else if(window.attachEvent)&#123; window.attachEvent('onresize', function()&#123; fn(); &#125;); &#125; fn();&#125;)(); 实现base64解码1234567891011121314151617181920212223242526function base64_decode(data)&#123; var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,ac = 0,dec = \"\",tmp_arr = []; if (!data) &#123; return data; &#125; data += ''; do &#123; h1 = b64.indexOf(data.charAt(i++)); h2 = b64.indexOf(data.charAt(i++)); h3 = b64.indexOf(data.charAt(i++)); h4 = b64.indexOf(data.charAt(i++)); bits = h1 &lt;&lt; 18 | h2 &lt;&lt; 12 | h3 &lt;&lt; 6 | h4; o1 = bits &gt;&gt; 16 &amp; 0xff; o2 = bits &gt;&gt; 8 &amp; 0xff; o3 = bits &amp; 0xff; if (h3 == 64) &#123; tmp_arr[ac++] = String.fromCharCode(o1); &#125; else if (h4 == 64) &#123; tmp_arr[ac++] = String.fromCharCode(o1, o2); &#125; else &#123; tmp_arr[ac++] = String.fromCharCode(o1, o2, o3); &#125; &#125; while (i &lt; data.length); dec = tmp_arr.join(''); dec = utf8_decode(dec); return dec;&#125; 实现utf8解码1234567891011121314151617181920function utf8_decode(str_data)&#123; var tmp_arr = [],i = 0,ac = 0,c1 = 0,c2 = 0,c3 = 0;str_data += ''; while (i &lt; str_data.length) &#123; c1 = str_data.charCodeAt(i); if (c1 &lt; 128) &#123; tmp_arr[ac++] = String.fromCharCode(c1); i++; &#125; else if (c1 &gt; 191 &amp;&amp; c1 &lt; 224) &#123; c2 = str_data.charCodeAt(i + 1); tmp_arr[ac++] = String.fromCharCode(((c1 &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = str_data.charCodeAt(i + 1); c3 = str_data.charCodeAt(i + 2); tmp_arr[ac++] = String.fromCharCode(((c1 &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return tmp_arr.join('');&#125; 获取窗体可见范围的宽与高1234567function getViewSize()&#123; var de=document.documentElement; var db=document.body; var viewW=de.clientWidth==0 ? db.clientWidth : de.clientWidth; var viewH=de.clientHeight==0 ? db.clientHeight : de.clientHeight; return Array(viewW ,viewH);&#125; 断鼠标是否移出事件12345678910function isMouseOut(e, handler) &#123; if (e.type !== 'mouseout') &#123; return false; &#125; var reltg = e.relatedTarget ? e.relatedTarget : e.type === 'mouseout' ? e.toElement : e.fromElement; while (reltg &amp;&amp; reltg !== handler) &#123; reltg = reltg.parentNode; &#125; return (reltg !== handler);&#125; 半角转换为全角函数1234567891011121314function ToDBC(str)&#123; var result = ''; for(var i=0; i &lt; str.length; i++)&#123; code = str.charCodeAt(i); if(code &gt;= 33 &amp;&amp; code &lt;= 126)&#123; result += String.fromCharCode(str.charCodeAt(i) + 65248); &#125;else if (code == 32)&#123; result += String.fromCharCode(str.charCodeAt(i) + 12288 - 32); &#125;else&#123; result += str.charAt(i); &#125; &#125; return result;&#125; 全角转换为半角函数1234567891011121314function ToCDB(str)&#123; var result = ''; for(var i=0; i &lt; str.length; i++)&#123; code = str.charCodeAt(i); if(code &gt;= 65281 &amp;&amp; code &lt;= 65374)&#123; result += String.fromCharCode(str.charCodeAt(i) - 65248); &#125;else if (code == 12288)&#123; result += String.fromCharCode(str.charCodeAt(i) - 12288 + 32); &#125;else&#123; result += str.charAt(i); &#125; &#125; return result;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Snippet","slug":"Snippet","permalink":"http://yoursite.com/tags/Snippet/"}]},{"title":"Web前端开发规范文档","slug":"Web前端开发规范文档","date":"2016-07-19T11:50:20.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/07/19/Web前端开发规范文档/","link":"","permalink":"http://yoursite.com/2016/07/19/Web前端开发规范文档/","excerpt":"通用规范： TAB键用两个空格代替（WINDOWS下TAB键占四个空格，LINUX下TAB键占八个空格）。 CSS样式属性或者JAVASCRIPT代码后加“;”方便压缩工具“断句”。文件内容编码均统一为UTF-8。 CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。","text":"通用规范： TAB键用两个空格代替（WINDOWS下TAB键占四个空格，LINUX下TAB键占八个空格）。 CSS样式属性或者JAVASCRIPT代码后加“;”方便压缩工具“断句”。文件内容编码均统一为UTF-8。 CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。 文件规范： 文件名用英文单词，多个单词用驼峰命名法。 一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS等所有命名避免以上词汇。 HTML书写规范： 为每个HTML页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现 &lt;!DOCTYPE html&gt; 文档类型声明统一为HTML5声明类型，编码统一为UTF-8 &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;HEAD&gt;中添加信息 12345678910&lt;meta name=\"author\" content=\"smile@kang.cool\"&gt;//作者&lt;meta name=\"description\" content=\"hello\"&gt;//网页描述&lt;meta name=\"keywords\" content=\"a,b,c\"&gt;//关键字,“，”分隔&lt;meta http-equiv=\"expires\" content=\"Wed, 26 Feb 1997 08：21：57 GMT\"&gt;//设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;//禁止浏览器从本地机的缓存中调阅页面内容&lt;meta http-equiv=\"Window-target\" content=\"_top\"&gt;//用来防止别人在框架里调用你的页面&lt;meta http-equiv=\"Refresh\" content=\"5;URL=http://kahn1990.com/\"&gt;//跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=\"robots\" content=\"none\"&gt;//content的参数有all,none,index,noindex,follow,nofollow，默认是all&lt;link rel=\"Shortcut Icon\" href=\"favicon.ico\"&gt;//收藏图标&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, must-revalidate\"&gt;//网页不会被缓存 IE支持通过特定标签来确定绘制当前页面所应该采用的IE版本。除非有强烈的特殊需求，否则最好是设置为edge mode ，从而通知IE采用其所支持的最新的模式。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 非特殊情况下CSS样式文件外链至HEAD之间，JAVASCRIPT文件外链至页面底部 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"css/main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 逻辑代码 --&gt; &lt;!-- 逻辑代码底部 --&gt; &lt;script src=\"lib/jquery/jquery-2.1.1.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引入JAVASCRIPT库文件，文件名须包含库名称及版本号及是否为压缩版 jQuery-1.8.3.min.js 引入JAVASCRIPT插件, 文件名格式为库名称+.+插件名称 jQuery.cookie.js HTML属性应当按照以下给出的顺序依次排列，来确保代码的易读性 123456classid 、 namedata-*src、for、 type、 hreftitle、altaria-*、 role 编码均遵循XHTML标准,标签、属性、属性命名由小写英文、数字和_组成，且所有标签必须闭合，属性值必须用双引号””,避免使用中文拼音尽量简易并要求语义化 1234CLASS --&gt; nHeadTitle --&gt; CLASS遵循小驼峰命名法（little camel-case）ID --&gt; n_head_title --&gt; ID遵循名称+_NAME --&gt; N_Head_Title --&gt; NAME属性命名遵循首个字母大写+_&lt;div class=\"nHeadTitle\" id=\"n_head_title\" name=\"N_Head_Title\"&gt;&lt;/div&gt; 当JAVASCRIPT获取单个元素时，通常使用document.getElementById来获取dom元素，document.getElementById兼容所有浏览器，但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名 1234&lt;input type=\"text\" name=\"test\"&gt;&lt;div id=\"test\"&gt;&lt;/div&gt;&lt;button onclick=\"alert(document.getElementById('test').tagName)\"&gt;&lt;/button&gt;&lt;!-- ie6下为INPUT --&gt; 特殊符号应使用转意符 123&lt; --&gt; &amp;lt;&gt; --&gt; &amp;gt;空格 --&gt; 含有描述性表单元素（INPUT，TEXTAREA）添加LABEL。 1234&lt;p&gt; &lt;label for=\"test\"&gt;测试&lt;/label&gt; &lt;input type=\"text\" id=\"test\" /&gt;&lt;/p&gt; 多用无兼容性问题的HTML内置标签,比如SPAN、EM、STRONG、OPTGROUP、LABEL等,需要自定义HTML标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有,可使用须以“data-”为前缀来添加自定义属性，避免使用其他命名方式。 语义化HTML。 尽可能减少嵌套。书写链接地址时避免重定向 href=&quot;http://www.kahn1990.com/&quot; //即在URL地址后面加“/” HTML中对于属性的定义，确保全部使用双引号，绝不要使用单引号 css书写规范： 为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合W3C的代码写到一个文件中,而一些IE中必须而又不能通过W3C验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入 123456&lt;!-- 放置所有浏览器样式--&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"\"&gt;&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;&lt;!--[if IE] &lt;link rel=\"stylesheet\" href=\"\"&gt;&lt;![endif]--&gt; CSS样式新建或修改尽量遵循以下原则 根据新建样式的适用范围分为三级：全站级、产品级、页面级。尽量通过继承和层叠重用已有样式。不要轻易改动全站级CSS。改动后，要经过全面测试。 CSS属性显示顺序 显示属性 元素位置 元素属性 元素内容属性 CSS书写顺序 1234567891011121314151617181920212223242526272829.header &#123;/* 显示属性 */ display || visibility list-style position top || right || bottom || left z-index clear float/* 自身属性 */ width max-width || min-width height max-height || min-height overflow || clip margin padding outline border background/* 文本属性 */ color font text-overflow text-align text-indent line-height white-space vertical-align cursor content &#125;; 兼容多个浏览器时，将标准属性写在底部 123-moz-border-radius: 15px; /* Firefox */-webkit-border-radius: 15px; /* Safari和Chrome */border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性 使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式 .hd,.bd,.td{};//如这些命名 可用上级节点进行限定 .recommend-mod .hd 多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。 123button.btn,input.btn,input[type=\"button\"] &#123;…&#125;; 优化CSS选择器 #header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/ 浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下 12345避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器不要限定id选择符，如div#header（提权的除外）不要限定类选择器，如ul.recommend（提权的除外）不要使用 ul li a 这样长的选择符避免使用标签子选择符，如#header &gt; li &gt; a 使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。尽量避免使用CSS Hack 12345678910111213property:value; /* 所有浏览器 */+property:value; /* IE7 */_property:value; /* IE6 */*property:value; /* IE6/7 */property:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\\* html selector &#123; … &#125;; /* IE6 */\\*:first-child+html selector &#123; … &#125;; /* IE7 */html&gt;body selector &#123; … &#125;; /* 非IE6 */@-moz-document url-prefix() &#123; … &#125;; /* firefox */@media all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* saf3+/chrome1+ */@media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* opera */@media screen and (max-device-width: 480px) &#123; … &#125;; /* iPhone/mobile webkit */ 避免使用低效的选择器 12345body &gt; * &#123;…&#125;;ul &gt; li &gt; a &#123;…&#125;;#footer &gt; h3 &#123;…&#125;;ul#top_blue_nav &#123;…&#125;;#searbar span.submit a &#123; … &#125;; /* 反面示例 */ 六个不要三个避免一个使用 12345678910不要在标签上直接写样式不要在CSS中使用expression不要在CSS中使用@import不要在CSS中使用!important不要在CSS中使用“*”选择符不要将CSS样式写为单行避免使用filter避免使用行内（inline）样式避免使用“*”设置&#123;margin: 0; padding: 0;&#125;使用after或overflow的方式清浮动 减少使用影响性能的属性 12position:absolute;float:left;//如这些定位或浮动属性 减少在CSS中使用滤镜表达式和图片repeat,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px javaScript书写规范：命名规范 1234567891011121314151617181920212223242526常量名 全部大写并单词间用下划线分隔 如：CSS_BTN_CLOSE、TXT_LOADING对象的属性或方法名 小驼峰式（little camel-case） 如：init、bindEvent、updatePosition 示例：Dialog.prototype = &#123; init: function () &#123;&#125;, bindEvent: function () &#123;&#125;, updatePosition: function () &#123;&#125; … &#125;;类名（构造器） --&gt;小驼峰式但首字母大写 --&gt;如：Current、DefaultConfig函数名 --&gt;小驼峰式 --&gt;如：current()、defaultConfig()变量名 --&gt;小驼峰式 --&gt;如：current、defaultConfig私有变量名 --&gt;小驼峰式但需要用_开头 --&gt;如：_current、_defaultConfig变量名的前缀 --&gt;续 代码格式 12345 &quot;()&quot;前后需要跟空格&quot;=&quot;前后需要跟空格&quot;,&quot;后面需要跟空格JSON对象需格式化对象参数if、while、for、do语句的执行体用&quot;&#123;&#125;&quot;括起来 “{}”格式如下 123if (a==1) &#123; //代码&#125;; 避免额外的逗号 var arr = [1,2,3,]; for-in循环体中必须用hasOwnProperty方法检查成员是否为自身成员，避免来自原型链上的污染。 长语句可考虑断行 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']) .replace('&#123;PREV_NUM&#125;', prev) .replace('&#123;NEXT_NUM&#125;', next) .replace('&#123;CURRENT_NUM&#125;', current) .replace('&#123;TOTAL_NUM&#125;', da.page_total); 为了避免和JSLint的检验机制冲突，“.”或“+”这类操作符放在行尾 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']). replace('&#123;PREV_NUM&#125;', prev). replace('&#123;NEXT_NUM&#125;', next). replace('&#123;CURRENT_NUM&#125;', current). replace('&#123;TOTAL_NUM&#125;', da.page_total); 如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入/global/声明。 /*global alert: true, console: true, top: true, setTimeout: true */ 使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱,在条件判断时，这样的一些值表示false 12345nullundefined与null相等字符串&apos;&apos;数字0NaN 在==时，则会有一些让人难以理解的陷阱 1234567891011(function () &#123; var undefined; undefined == null; // true 1 == true; //true 2 == true; // false 0 == false; // true 0 == ''; // true NaN == NaN;// false [] == false; // true [] == ![]; // true&#125;)(); 对于不同类型的 == 判断，有这样一些规则，顺序自上而下 12345undefined与null相等一个是number一个是string时，会尝试将string转换为number尝试将boolean转换为number0或1尝试将Object转换成number或string 而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用=== ===会先判断两边的值类型，类型不匹配时为false。下面类型的对象不建议用new构造 12345new Numbernew Stringnew Booleannew Object //用&#123;&#125;代替new Array //用[]代替 引用对象成员用obj.prop代替obj[“prop”]，除非属性名是变量。从number到string的转换。 123456789/** 推荐写法*/var a = 1;typeof(a); //\"number\"console.log(a); //1var aa=a+'';typeof(aa); //\"string\"console.log(aa); //'1'/** 不推荐写法*/new String(a)或a.toString() 从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。 1234567/** 推荐写法*/var a = '1';var aa = parseInt(a,10);typeof(a); //\"string\"console.log(a); //'1'typeof(aa); //\"number\"console.log(aa); //1 从float到integer的转换 1234/** 推荐写法*/Math.floor/Math.round/Math.ceil/** 不推荐写法*/parseInt 字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。 1234567891011121314/**推荐的拼接方式array的push、join*/var str=[], list=['测试A','测试B'];for (var i=0 , len=list.length; i &lt; len; i++) &#123; str.push( '&lt;div&gt;'+ list[i] + '&lt;/div&gt;');&#125;;console.log(str.join('')); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;/** 不推荐的拼接方式+=*/var str = '', list=['测试A','测试B'];for (var i = 0, len = list.length; i&lt; len; i++) &#123; str+='&lt;div&gt;' + list[i] + '&lt;/div&gt;';&#125;;console.log(str); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt; 尽量避免使用存在兼容性及消耗资源的方法或属性 不要使用with，void，evil，eval_r，innerText 注重HTML分离, 减小reflow, 注重性能 图片规范命名应用小写英文、数字、_组合，便于团队其他成员理解 12header_btn.gifheader_btn2.gif 页面元素类图片均放入img文件夹, 测试用图片放于img/testimg文件夹，psd源图放入img/psdimg文件夹。 图片格式仅限于gif、png、jpg等。 用png图片做图片时,要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果,请为ie-6单独定义背景，并尽量避免使用半透明的png图片。 背景图片请尽可能使用sprite技术, 减小http请求 注释规范： JAVASCRIPT、CSS文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。 /* * 注释块 */ 中间可添加如下信息 1234567891011121314151617181920212223@file 文件名@addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中@argument 用大括号中的自变量类型描述一个自变量@author 函数/类作者的姓名@base 如果类是继承得来，定义提供的类名称@class 用来给一个类提供描述，不能用于构造器的文档中@constructor 描述一个类的构造器@deprecated 表示函数/类已被忽略@exception 描述函数/类产生的一个错误@exec @extends 表示派生出当前类的另一个类@fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前@final 指出函数/类@ignore 让jsdoc忽视随后的代码@link 类似于@link标签，用于连接许多其它页面@member 定义随后的函数为提供的类名称的一个成员@param 用大括号中的参数类型描述一个参数@private 表示函数/类为私有，不应包含在生成的文档中@requires 表示需要另一个函数/类@return 描述一个函数的返回值@see 连接到另一个函数/类@throws 描述函数/类可能产生的错误@type 指定函数/成员的返回类型@version 函数/类的版本号 开发及测试工具约定： 编码格式化，三码统一 测试工具: 前期开发仅测试FireFox &amp; IE6 &amp; IE7 &amp; IE8 &amp; IE9 &amp; Opera &amp; Chrome &amp; Safari","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://yoursite.com/tags/规范/"}]},{"title":"Angular4.x模拟豆瓣电影","slug":"angular小demo","date":"2016-07-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/07/13/angular小demo/","link":"","permalink":"http://yoursite.com/2016/07/13/angular小demo/","excerpt":"","text":"前言 最近一段时间一直在学习Angular4.x的相关知识，，这次决定用Angular4.x去模仿一个豆瓣电影页面,写下这篇博客，记录实践中的心得体会 创建项目创建项目 ng new 项目名称 创建一个项目 ng new my-app进入刚才创建的项目里面启动服务 cd my-appcnpm installng serve –open 创建组件ng g component my-new-component指定目录创建 ：ng g component components/FooterDirective创建服务ng g directive my-new-directive 项目目录结构 node后台接口由于豆瓣电影的api没有jsonp所以通过fs模块的数据流进行模拟数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566pp.get(&apos;/movie&apos;,function(req,res)&#123; fs.readFile(&apos;./cache/movie.txt&apos;,function(err,data)&#123; if(err)&#123; var https=require(&apos;https&apos;); var url=&apos;https://api.douban.com/v2/movie/coming_soon&apos;; https.get(url, function(response) &#123; var data = &apos;&apos;; response.on(&apos;data&apos;, function(chunk) &#123; data += chunk; &#125;) response.on(&apos;end&apos;, function() &#123; //res.send(data); fs.writeFile(&apos;movie.txt&apos;,data,function()&#123; &#125;); res.jsonp(data); &#125;) &#125;); &#125;else&#123; res.jsonp(data.toString()); &#125; &#125;)&#125;)app.get(&apos;/movieinfo&apos;,function(req,res)&#123; //console.log(req.body); var id=req.query.id; fs.readFile(&apos;./cache/movieinfo&apos;+id+&apos;.txt&apos;,function(error,data)&#123; if(error)&#123; var https=require(&apos;https&apos;); var url=&apos;https://api.douban.com/v2/movie/subject/&apos;+id; https.get(url, function(response) &#123; var data = &apos;&apos;; response.on(&apos;data&apos;, function(chunk) &#123; data += chunk; &#125;) response.on(&apos;end&apos;, function() &#123; fs.writeFile(&apos;./cache/movieinfo&apos;+id+&apos;.txt&apos;,data,function()&#123; &#125;); res.jsonp(data); &#125;) &#125;); &#125;else&#123; res.jsonp(data.toString()); &#125; &#125;)&#125;) app.module.ts配置1234567891011121314151617181920212223242526272829import &#123; BrowserModule &#125; from &apos;@angular/platform-browser&apos;;import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; HttpModule, JsonpModule &#125; from &apos;@angular/http&apos;;//引入http和jsonp的模块import &#123; AppRoutingModule &#125; from &apos;./app-routing.module&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;import &#123; MovieComponent &#125; from &apos;./components/movie/movie.component&apos;;import &#123; MovieinfoComponent &#125; from &apos;./components/movieinfo/movieinfo.component&apos;;@NgModule(&#123; declarations: [ AppComponent, MovieComponent, MovieinfoComponent ], imports: [ BrowserModule, AppRoutingModule, HttpModule, JsonpModule ], providers: [], bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125; app.commpont.ts配置12345678910import &#123; Component &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;app-root&apos;, templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;]&#125;)export class AppComponent &#123; title = &apos;app&apos;;&#125; app.routing.module.ts配置ng new angulardemo02 –routing可以直接创建路由很方便 12345678910111213141516171819202122232425262728293031import &#123; NgModule &#125; from &apos;@angular/core&apos;;import &#123; Routes, RouterModule &#125; from &apos;@angular/router&apos;;import &#123; MovieComponent &#125; from &apos;./components/movie/movie.component&apos;;import &#123; MovieinfoComponent &#125; from &apos;./components/movieinfo/movieinfo.component&apos;;const routes: Routes = [ &#123; path: &apos;movie&apos;, component:MovieComponent &#125;, &#123; path: &apos;movieinfo/:id&apos;, component:MovieinfoComponent &#125;,//动态路由 &#123; path: &apos;&apos;, redirectTo: &apos;/movie&apos;, pathMatch: &apos;full&apos; &#125;];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule]&#125;)export class AppRoutingModule &#123; &#125; movie代码1.movie.component.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123; Http, Jsonp &#125; from &apos;@angular/http&apos;;@Component(&#123; selector: &apos;app-movie&apos;, templateUrl: &apos;./movie.component.html&apos;, styleUrls: [&apos;./movie.component.css&apos;]&#125;)export class MovieComponent implements OnInit &#123; public list:any[]; public msg:any=&apos;这是一个msg&apos;; constructor(private http:Http,private jsonp:Jsonp) &#123; &#125; ngOnInit() &#123; this.requestData(); /*请求数据*/ &#125; requestData()&#123; var _that=this; var url=&apos;http://127.0.0.1:3000/movie?callback=JSONP_CALLBACK&apos;; this.jsonp.get(url).subscribe(function(result)&#123; var data=JSON.parse(result[&apos;_body&apos;]); _that.list=data.subjects; console.log(_that.list); &#125;,function(error)&#123; console.log(error); &#125;) &#125;&#125; 2.movie.component.html123456789101112131415161718192021222324&lt;header class=&quot;header&quot;&gt; 电影列表&lt;/header&gt;&lt;div class=&quot;content&quot;&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;item&quot; *ngFor=&quot;let item of list&quot;&gt; &lt;a routerLink=&quot;/movieinfo/&#123;&#123;item.id&#125;&#125;&quot;&gt; &lt;img src=&quot;&#123;&#123;item.images.small&#125;&#125;&quot; alt=&quot;&#123;&#123;item.title&#125;&#125;&quot;&gt; &lt;div class=&quot;info&quot;&gt; &lt;h2&gt;&#123;&#123;item.title&#125;&#125;&lt;/h2&gt; &lt;p&gt;上映时间:&#123;&#123;item.year&#125;&#125;&lt;/p&gt; &lt;p&gt;主演: &lt;span *ngFor=&quot;let cast of item.casts&quot;&gt;&#123;&#123;cast.name&#125;&#125; &lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; movieinfo1.movieinfo.component.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123; ActivatedRoute &#125; from &apos;@angular/router&apos;;import &#123; Http, Jsonp &#125; from &apos;@angular/http&apos;;@Component(&#123; selector: &apos;app-movieinfo&apos;, templateUrl: &apos;./movieinfo.component.html&apos;, styleUrls: [&apos;./movieinfo.component.css&apos;]&#125;)export class MovieinfoComponent implements OnInit &#123; public item:any[]; constructor(private route:ActivatedRoute,private http:Http,private jsonp:Jsonp) &#123; &#125; ngOnInit() &#123; // console.log(.value.id); //获取动态路由的值 this.route.params.subscribe(function(data)&#123; console.log(data.id); this.requestData(data.id); &#125;.bind(this)) &#125; requestData(id)&#123; // &quot;http://127.0.0.1:3000/movieinfo?id=324324325&amp;callback=JSONP_CALLBACK&quot; var _that=this; var url=&apos;http://127.0.0.1:3000/movieinfo?id=&apos;+id+&apos;&amp;callback=JSONP_CALLBACK&apos;; this.jsonp.get(url).subscribe(function(result)&#123; var data=JSON.parse(result[&apos;_body&apos;]); _that.item=data; &#125;,function(error)&#123; console.log(error); &#125;) &#125;&#125; 2.movieinfo.component.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;header class=&quot;header&quot;&gt; &lt;a routerLink=&quot;/movie&quot;&gt; &lt;span class=&quot;back&quot;&gt;&lt;/span&gt; &lt;/a&gt; 详情&lt;/header&gt;&lt;div *ngIf=&quot;item&quot; class=&quot;content&quot;&gt; &lt;div class=&quot;topinfo&quot;&gt; &lt;div class=&quot;item&quot; &gt; &lt;img src=&quot;&#123;&#123;item.images.medium&#125;&#125;&quot; alt=&quot;&#123;&#123;item.title&#125;&#125;&quot;&gt; &lt;div class=&quot;info&quot;&gt; &lt;h2&gt;&#123;&#123;item.title&#125;&#125;&lt;/h2&gt; &lt;p&gt;&#123;&#123;item.countries[0]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;item.year&#125;&#125;上映&lt;/p&gt; &lt;p&gt;主演: &lt;span *ngFor=&quot;let cast of item.casts&quot;&gt;&#123;&#123;cast.name&#125;&#125; &lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;movieinfo&quot;&gt; &#123;&#123;item.summary&#125;&#125; &lt;/div&gt; &lt;div class=&quot;casts&quot;&gt; &lt;h3&gt;演员列表&lt;/h3&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li *ngFor=&quot;let cast of item.casts&quot;&gt; &lt;img src=&quot;&#123;&#123;cast.avatars.small&#125;&#125;&quot; /&gt; &lt;p&gt;&#123;&#123;cast.name&#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 页面详情 123456this.route.params.subscribe(function(data)&#123; console.log(data.id); this.requestData(data.id); &#125;.bind(this)) 点击通过this.router.params.subscribe实现获取urlID来请求api接口","categories":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Web前端开发规范文档","slug":"前端规范文档","date":"2016-07-10T06:50:20.000Z","updated":"2018-03-29T15:11:32.967Z","comments":true,"path":"2016/07/10/前端规范文档/","link":"","permalink":"http://yoursite.com/2016/07/10/前端规范文档/","excerpt":"通用规范： TAB键用两个空格代替（WINDOWS下TAB键占四个空格，LINUX下TAB键占八个空格）。 CSS样式属性或者JAVASCRIPT代码后加“;”方便压缩工具“断句”。文件内容编码均统一为UTF-8。 CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。","text":"通用规范： TAB键用两个空格代替（WINDOWS下TAB键占四个空格，LINUX下TAB键占八个空格）。 CSS样式属性或者JAVASCRIPT代码后加“;”方便压缩工具“断句”。文件内容编码均统一为UTF-8。 CSS、JAVASCRIPT中的非注释类中文字符须转换成unicode编码使用，以避免编码错误时乱码显示。 文件规范： 文件名用英文单词，多个单词用驼峰命名法。 一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS等所有命名避免以上词汇。 HTML书写规范： 为每个HTML页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现 &lt;!DOCTYPE html&gt; 文档类型声明统一为HTML5声明类型，编码统一为UTF-8 &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;HEAD&gt;中添加信息 12345678910&lt;meta name=\"author\" content=\"smile@kang.cool\"&gt;//作者&lt;meta name=\"description\" content=\"hello\"&gt;//网页描述&lt;meta name=\"keywords\" content=\"a,b,c\"&gt;//关键字,“，”分隔&lt;meta http-equiv=\"expires\" content=\"Wed, 26 Feb 1997 08：21：57 GMT\"&gt;//设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;//禁止浏览器从本地机的缓存中调阅页面内容&lt;meta http-equiv=\"Window-target\" content=\"_top\"&gt;//用来防止别人在框架里调用你的页面&lt;meta http-equiv=\"Refresh\" content=\"5;URL=http://kahn1990.com/\"&gt;//跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=\"robots\" content=\"none\"&gt;//content的参数有all,none,index,noindex,follow,nofollow，默认是all&lt;link rel=\"Shortcut Icon\" href=\"favicon.ico\"&gt;//收藏图标&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, must-revalidate\"&gt;//网页不会被缓存 IE支持通过特定标签来确定绘制当前页面所应该采用的IE版本。除非有强烈的特殊需求，否则最好是设置为edge mode ，从而通知IE采用其所支持的最新的模式。 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; 非特殊情况下CSS样式文件外链至HEAD之间，JAVASCRIPT文件外链至页面底部 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"css/main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 逻辑代码 --&gt; &lt;!-- 逻辑代码底部 --&gt; &lt;script src=\"lib/jquery/jquery-2.1.1.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 引入JAVASCRIPT库文件，文件名须包含库名称及版本号及是否为压缩版 jQuery-1.8.3.min.js 引入JAVASCRIPT插件, 文件名格式为库名称+.+插件名称 jQuery.cookie.js HTML属性应当按照以下给出的顺序依次排列，来确保代码的易读性 123456classid 、 namedata-*src、for、 type、 hreftitle、altaria-*、 role 编码均遵循XHTML标准,标签、属性、属性命名由小写英文、数字和_组成，且所有标签必须闭合，属性值必须用双引号””,避免使用中文拼音尽量简易并要求语义化 1234CLASS --&gt; nHeadTitle --&gt; CLASS遵循小驼峰命名法（little camel-case）ID --&gt; n_head_title --&gt; ID遵循名称+_NAME --&gt; N_Head_Title --&gt; NAME属性命名遵循首个字母大写+_&lt;div class=\"nHeadTitle\" id=\"n_head_title\" name=\"N_Head_Title\"&gt;&lt;/div&gt; 当JAVASCRIPT获取单个元素时，通常使用document.getElementById来获取dom元素，document.getElementById兼容所有浏览器，但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名 1234&lt;input type=\"text\" name=\"test\"&gt;&lt;div id=\"test\"&gt;&lt;/div&gt;&lt;button onclick=\"alert(document.getElementById('test').tagName)\"&gt;&lt;/button&gt;&lt;!-- ie6下为INPUT --&gt; 特殊符号应使用转意符 123&lt; --&gt; &amp;lt;&gt; --&gt; &amp;gt;空格 --&gt; 含有描述性表单元素（INPUT，TEXTAREA）添加LABEL。 1234&lt;p&gt; &lt;label for=\"test\"&gt;测试&lt;/label&gt; &lt;input type=\"text\" id=\"test\" /&gt;&lt;/p&gt; 多用无兼容性问题的HTML内置标签,比如SPAN、EM、STRONG、OPTGROUP、LABEL等,需要自定义HTML标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有,可使用须以“data-”为前缀来添加自定义属性，避免使用其他命名方式。 语义化HTML。 尽可能减少嵌套。书写链接地址时避免重定向 href=&quot;http://www.kahn1990.com/&quot; //即在URL地址后面加“/” HTML中对于属性的定义，确保全部使用双引号，绝不要使用单引号 css书写规范： 为了欺骗W3C的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对IE。即将所有符合W3C的代码写到一个文件中,而一些IE中必须而又不能通过W3C验证的代码（如:cursor:hand;）放到另一个文件中，再用下面的方法导入 123456&lt;!-- 放置所有浏览器样式--&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"\"&gt;&lt;!-- 只放置IE必须，而不能通过w3c的--&gt;&lt;!--[if IE] &lt;link rel=\"stylesheet\" href=\"\"&gt;&lt;![endif]--&gt; CSS样式新建或修改尽量遵循以下原则 根据新建样式的适用范围分为三级：全站级、产品级、页面级。尽量通过继承和层叠重用已有样式。不要轻易改动全站级CSS。改动后，要经过全面测试。 CSS属性显示顺序 显示属性 元素位置 元素属性 元素内容属性 CSS书写顺序 1234567891011121314151617181920212223242526272829.header &#123;/* 显示属性 */ display || visibility list-style position top || right || bottom || left z-index clear float/* 自身属性 */ width max-width || min-width height max-height || min-height overflow || clip margin padding outline border background/* 文本属性 */ color font text-overflow text-align text-indent line-height white-space vertical-align cursor content &#125;; 兼容多个浏览器时，将标准属性写在底部 123-moz-border-radius: 15px; /* Firefox */-webkit-border-radius: 15px; /* Safari和Chrome */border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性 使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式 .hd,.bd,.td{};//如这些命名 可用上级节点进行限定 .recommend-mod .hd 多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。 123button.btn,input.btn,input[type=\"button\"] &#123;…&#125;; 优化CSS选择器 #header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/ 浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下 12345避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器不要限定id选择符，如div#header（提权的除外）不要限定类选择器，如ul.recommend（提权的除外）不要使用 ul li a 这样长的选择符避免使用标签子选择符，如#header &gt; li &gt; a 使用z-index属性尽量z-index的值不要超过150（通用组的除外），页面中的元素内容的z-index不能超过10（提示框等模块除外但维持在150以下），不允许直接使用（999~9999）之间大值。尽量避免使用CSS Hack 12345678910111213property:value; /* 所有浏览器 */+property:value; /* IE7 */_property:value; /* IE6 */*property:value; /* IE6/7 */property:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\\* html selector &#123; … &#125;; /* IE6 */\\*:first-child+html selector &#123; … &#125;; /* IE7 */html&gt;body selector &#123; … &#125;; /* 非IE6 */@-moz-document url-prefix() &#123; … &#125;; /* firefox */@media all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* saf3+/chrome1+ */@media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) &#123; … &#125;; /* opera */@media screen and (max-device-width: 480px) &#123; … &#125;; /* iPhone/mobile webkit */ 避免使用低效的选择器 12345body &gt; * &#123;…&#125;;ul &gt; li &gt; a &#123;…&#125;;#footer &gt; h3 &#123;…&#125;;ul#top_blue_nav &#123;…&#125;;#searbar span.submit a &#123; … &#125;; /* 反面示例 */ 六个不要三个避免一个使用 12345678910不要在标签上直接写样式不要在CSS中使用expression不要在CSS中使用@import不要在CSS中使用!important不要在CSS中使用“*”选择符不要将CSS样式写为单行避免使用filter避免使用行内（inline）样式避免使用“*”设置&#123;margin: 0; padding: 0;&#125;使用after或overflow的方式清浮动 减少使用影响性能的属性 12position:absolute;float:left;//如这些定位或浮动属性 减少在CSS中使用滤镜表达式和图片repeat,尤其在body当中,渲染性能极差, 如果需要用repeat的话,图片的宽或高不能少于8px javaScript书写规范：命名规范 1234567891011121314151617181920212223242526常量名 全部大写并单词间用下划线分隔 如：CSS_BTN_CLOSE、TXT_LOADING对象的属性或方法名 小驼峰式（little camel-case） 如：init、bindEvent、updatePosition 示例：Dialog.prototype = &#123; init: function () &#123;&#125;, bindEvent: function () &#123;&#125;, updatePosition: function () &#123;&#125; … &#125;;类名（构造器） --&gt;小驼峰式但首字母大写 --&gt;如：Current、DefaultConfig函数名 --&gt;小驼峰式 --&gt;如：current()、defaultConfig()变量名 --&gt;小驼峰式 --&gt;如：current、defaultConfig私有变量名 --&gt;小驼峰式但需要用_开头 --&gt;如：_current、_defaultConfig变量名的前缀 --&gt;续 代码格式 12345 &quot;()&quot;前后需要跟空格&quot;=&quot;前后需要跟空格&quot;,&quot;后面需要跟空格JSON对象需格式化对象参数if、while、for、do语句的执行体用&quot;&#123;&#125;&quot;括起来 “{}”格式如下 123if (a==1) &#123; //代码&#125;; 避免额外的逗号 var arr = [1,2,3,]; for-in循环体中必须用hasOwnProperty方法检查成员是否为自身成员，避免来自原型链上的污染。 长语句可考虑断行 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']) .replace('&#123;PREV_NUM&#125;', prev) .replace('&#123;NEXT_NUM&#125;', next) .replace('&#123;CURRENT_NUM&#125;', current) .replace('&#123;TOTAL_NUM&#125;', da.page_total); 为了避免和JSLint的检验机制冲突，“.”或“+”这类操作符放在行尾 12345TEMPL_SONGLIST.replace('&#123;TABLE&#125;', da['results']). replace('&#123;PREV_NUM&#125;', prev). replace('&#123;NEXT_NUM&#125;', next). replace('&#123;CURRENT_NUM&#125;', current). replace('&#123;TOTAL_NUM&#125;', da.page_total); 如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入/global/声明。 /*global alert: true, console: true, top: true, setTimeout: true */ 使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱,在条件判断时，这样的一些值表示false 12345nullundefined与null相等字符串&apos;&apos;数字0NaN 在==时，则会有一些让人难以理解的陷阱 1234567891011(function () &#123; var undefined; undefined == null; // true 1 == true; //true 2 == true; // false 0 == false; // true 0 == ''; // true NaN == NaN;// false [] == false; // true [] == ![]; // true&#125;)(); 对于不同类型的 == 判断，有这样一些规则，顺序自上而下 12345undefined与null相等一个是number一个是string时，会尝试将string转换为number尝试将boolean转换为number0或1尝试将Object转换成number或string 而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用=== ===会先判断两边的值类型，类型不匹配时为false。下面类型的对象不建议用new构造 12345new Numbernew Stringnew Booleannew Object //用&#123;&#125;代替new Array //用[]代替 引用对象成员用obj.prop代替obj[“prop”]，除非属性名是变量。从number到string的转换。 123456789/** 推荐写法*/var a = 1;typeof(a); //\"number\"console.log(a); //1var aa=a+'';typeof(aa); //\"string\"console.log(aa); //'1'/** 不推荐写法*/new String(a)或a.toString() 从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。 1234567/** 推荐写法*/var a = '1';var aa = parseInt(a,10);typeof(a); //\"string\"console.log(a); //'1'typeof(aa); //\"number\"console.log(aa); //1 从float到integer的转换 1234/** 推荐写法*/Math.floor/Math.round/Math.ceil/** 不推荐写法*/parseInt 字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。 1234567891011121314/**推荐的拼接方式array的push、join*/var str=[], list=['测试A','测试B'];for (var i=0 , len=list.length; i &lt; len; i++) &#123; str.push( '&lt;div&gt;'+ list[i] + '&lt;/div&gt;');&#125;;console.log(str.join('')); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt;/** 不推荐的拼接方式+=*/var str = '', list=['测试A','测试B'];for (var i = 0, len = list.length; i&lt; len; i++) &#123; str+='&lt;div&gt;' + list[i] + '&lt;/div&gt;';&#125;;console.log(str); //&lt;div&gt;测试A&lt;/div&gt;&lt;div&gt;测试B&lt;/div&gt; 尽量避免使用存在兼容性及消耗资源的方法或属性 不要使用with，void，evil，eval_r，innerText 注重HTML分离, 减小reflow, 注重性能 图片规范命名应用小写英文、数字、_组合，便于团队其他成员理解 12header_btn.gifheader_btn2.gif 页面元素类图片均放入img文件夹, 测试用图片放于img/testimg文件夹，psd源图放入img/psdimg文件夹。 图片格式仅限于gif、png、jpg等。 用png图片做图片时,要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果,请为ie-6单独定义背景，并尽量避免使用半透明的png图片。 背景图片请尽可能使用sprite技术, 减小http请求 注释规范： JAVASCRIPT、CSS文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。 /* * 注释块 */ 中间可添加如下信息 1234567891011121314151617181920212223@file 文件名@addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中@argument 用大括号中的自变量类型描述一个自变量@author 函数/类作者的姓名@base 如果类是继承得来，定义提供的类名称@class 用来给一个类提供描述，不能用于构造器的文档中@constructor 描述一个类的构造器@deprecated 表示函数/类已被忽略@exception 描述函数/类产生的一个错误@exec @extends 表示派生出当前类的另一个类@fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前@final 指出函数/类@ignore 让jsdoc忽视随后的代码@link 类似于@link标签，用于连接许多其它页面@member 定义随后的函数为提供的类名称的一个成员@param 用大括号中的参数类型描述一个参数@private 表示函数/类为私有，不应包含在生成的文档中@requires 表示需要另一个函数/类@return 描述一个函数的返回值@see 连接到另一个函数/类@throws 描述函数/类可能产生的错误@type 指定函数/成员的返回类型@version 函数/类的版本号 开发及测试工具约定： 编码格式化，三码统一 测试工具: 前期开发仅测试FireFox &amp; IE6 &amp; IE7 &amp; IE8 &amp; IE9 &amp; Opera &amp; Chrome &amp; Safari","categories":[{"name":"前端规范","slug":"前端规范","permalink":"http://yoursite.com/categories/前端规范/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://yoursite.com/tags/规范/"}]},{"title":"Hexo持续集成自动部署到github","slug":"Hexo持续集成自动部署到github","date":"2016-07-02T16:41:12.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/07/03/Hexo持续集成自动部署到github/","link":"","permalink":"http://yoursite.com/2016/07/03/Hexo持续集成自动部署到github/","excerpt":"一、 新建新的分支","text":"一、 新建新的分支 master：博客的静态文件，也就是hexo生成后的HTML文件，因为要使用Gitpage服务，所以他规定的网页文件必须是在master分支 建新的分支：dev：存放博客的源代码 Git怎么推送本地分支到远程新分支上面去？ git push --force origin local_branch:remote_branch 这个操作，local_branch必须为你本地存在的分支，remote_branch为远程分支，如果remote_branch不存在则会自动创建分支。 类似，git push origin :remote_branch，local_branch留空的话则是删除远程remote_branch分支。 这里是分支常用命令： 列出所有本地分支$ git branch 列出所有远程分支$ git branch -r 列出所有本地分支和远程分支$ git branch -a 新建一个分支，但依然停留在当前分支$ git branch [branch-name] 新建一个分支，并切换到该分支$ git checkout -b [branch] 新建一个分支，指向指定commit$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区`$ git checkout [branch-name] 切换到上一个分支$ git checkout - 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支$ git merge [branch] 选择一个commit，合并进当前分支`$ git cherry-pick [commit] 删除分支$ git branch -d [branch-name] 删除远程分支 12$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 二、配置Travis 接入Travis CI 打开Travis CI网站，使用github账号登录。 将鼠标放在右上角的用户名上，点击Account选项，会显示github的项目。 找到博客项目，点击前面带有 X 符号的按钮，开启travis支持。 然后点击设置按钮，在项目的设置中开启Build only if .travis.yml is present这一项. 到这一步， 我们已经开启了要构建的仓库 在Travis CI配置Github的Access Token 在github上生成Access Token 首先我们来到github的设置界面，点击到Personal access tokens页面，点击右上角的Generate new token按钮会重新生成一个，点击后他会叫你输入密码，然后来到如下界面，给他去一个名字，下面是勾选一些权限 生成完后，你需要拷贝下来,接下来要用到 在Travis CI配置 配置界面还是在项目的setting里面，如下图 还需要在源代码的仓库里创建一个.travis.yml配置文件，放到源代码的根目录，如下图 其中内容如下： 1234567891011121314151617181920212223242526272829language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install#before_script: # - npm install -g gulpscript: - hexo gafter_script: - cd ./public - git init - git config user.name \"lifengsofts\" - git config user.email \"lifengsofts@gmail.com\" - git add . - git commit -m \"Update docs\" - git push --force --quiet \"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;\" master:master# E: Build LifeCyclebranches: only: - blog-sourceenv: global: - GH_REF: github.com/lifengsofts/lifengsofts.github.io.git 其中给你需要更换的又git config后面的配置信息GH_REF的值更改为你的仓库地址 到这一步我们配置已经完成了 三、本地操作 把远程仓库源码下载下来新建新的分支dev git clone -b dev https://github.com/poetries/poetries.github.io.git 切换到项目根目录下 开始写作 关联远程仓库 git remote add origin git@github.com:poetries/poetries.github.io.git 提交本地修改，推送至github仓库。 $ git add . $ git commit -m &quot;test travis&quot; $ git push origin dev:dev 以下是自己在Ubuntu下写的一个很简单很简单的脚本，用来方便写作部署博客 hexo-write.sh hexo-deploy.sh push本地的代码至远程仓库之后，在https://travis-ci.org后台查看相关情况。 下面是成功的结果： 参考：使用Travis自动部署Hexo(3)使用Travis自动部署Hexo(1)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"一键更新Hexo到github和coding","slug":"一键更新Hexo到github和coding","date":"2016-07-02T12:48:22.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/07/02/一键更新Hexo到github和coding/","link":"","permalink":"http://yoursite.com/2016/07/02/一键更新Hexo到github和coding/","excerpt":"一、 _config.yml配置","text":"一、 _config.yml配置 想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式 123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 我的配置 12345deploy: type: git repo: # 同时部署到github和coding github: https://github.com/poetries/poetries.github.io.git,master coding: git@git.coding.net:poetry/poetry.git,master 提交采用的SSH密钥，这个方法有个好处，提交的时候不用输入用户名和密码 二、coding上创建一个新项目创建后进入项目的代码模块，获取到这个项目的ssh地址 三、同步本地hexo到coding上把获取到了ssh配置在上面的_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心 本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成 添加后，在git bash命令输入： ssh -T git@git.coding.net 如果得到下面提示就表示公钥添加成功了： Coding.net Tips : [Hello ! You&#39;ve conected to Coding.net by SSH successfully! ] 最后使用部署命令就能把博客同步到coding上面： hexo deploy -g 四、pages服务方式部署部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单就是在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布 12cd source/touch Staticfile #名字必须是Staticfile 分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。 注意： 如果你的项目名称跟你coding的用户名一样，比如我的用户是叫tengj,博客项目名也叫tengj那直接访问 poetry.coding.me就能访问博客，否则就要带上项目名：poetry.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了 五、演示方式部署当你把你的静态网站上传到Coding之后，就可以着手部署演示了，Coding的演示平台支持静态网页，所以其实非常简单。在开启演示模式之前，会提醒你没有检测到环境，你直接强制开启就可以了。 部署版本我没有填，默认是master 运行环境一定要选择HTML 自动部署要勾上，为后面配置自动部署做准备 访问域名根据你自己喜爱填写，填好要点急后面的确认按钮 应用内存也根据自己喜好填写，填好要点急后面的确认按钮 以上都配置好了，就可以按下一键部署的按钮了，部署成功后输入地址：poetry.coding.io就能访问 六、设置自动部署如果你是演示方式的话，就需要设置自动部署，这样才能同步新发布的文章 要配置WebHook才行 找到项目设置那边的WebHook,然后点击新建 Hook 第一个输入框中是填你的博客域名，然后在后面加上 /_ 第二个输入框是输入一个 token ，我们直接填写 就可以了,TOKEN两边的大括号见的空格记得去掉 回到演示里，在左边的栏目中找到环境变量,变量名填写为 WEBHOOK_TOKEN ，值为 ，接着重新启动应用就 ok 了！","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Mongodb多表查询","slug":"Mongodb多表查询","date":"2016-06-26T06:35:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/06/26/Mongodb多表查询/","link":"","permalink":"http://yoursite.com/2016/06/26/Mongodb多表查询/","excerpt":"","text":"","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"HTML5+CSS3 最酷的 loading 效果收集","slug":"HTML5-CSS3-最酷的-loading-效果收集","date":"2016-05-20T01:11:44.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/20/HTML5-CSS3-最酷的-loading-效果收集/","link":"","permalink":"http://yoursite.com/2016/05/20/HTML5-CSS3-最酷的-loading-效果收集/","excerpt":"这里收集了几十个用 html5 和 css3 实现的 loading 效果，以供学习参考","text":"这里收集了几十个用 html5 和 css3 实现的 loading 效果，以供学习参考 01. CSS Rainbow Loader 演示 下载 02. Single element Slack loader 演示 下载 03. Pure CSS3 loader 演示 下载 04. CSS Cog loader 演示 下载 05. VSCO – CSS loader 演示 下载 06. Cube CSS Loader 演示 下载 07. CSS Loader 演示 下载 08. Tumblr-style cog loaders 演示 下载 09. CSS Weather Loader 演示 下载 10. Chrome Cast CSS Loader 演示 下载 11. CSS3 Loaders 演示 下载 12. Android 4.4 Kitkat loader 演示 下载 13. CSS loaders kit 演示 下载 14. CSS creative loading 演示 下载 15. CSS Loading Animation 演示 下载 16. Logo Loader 演示 下载 17. Loaders collection by Loaders.css 演示 下载 18. CSS Water filling Loader 演示 下载 19. CSS loader 演示 下载 20. Animated CSS3 Loading Bar 演示 下载 21. CSS loading text animation 演示 下载 22. Simple Loader 演示 下载 23. CSS Loading animation 演示 下载 24. CSS loader 演示 下载 25. Pushing pixels CSS loader 演示 下载 26. CSS Loader 演示 下载 27. CSS Loaders 演示 下载 ###28. Random Loader 演示 下载 29. Single element CSS spinners 演示 下载 30. Simple CSS loader 演示 下载 31. SpinKit – CSS loaders 演示 下载 32. Modern Google Loader 演示 下载 33. 2D and 3D Block Loaders 演示 下载 34. 12 free SVG loaders 演示 下载 35. Page Loading Effects 演示 下载 36. Pace.js – Page Load Progress Bars 演示 下载 37. Loading SVG loaders 演示 下载 38. Material Design preloader 演示 下载 93: https://github.com/tobiasahlin/SpinKit 92: http://tobiasahlin.com/spinkit/ 111: https://github.com/jxnblk/loading[110]: http://jxnblk.com/loading/","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"Vue基础代码整理","slug":"vue","date":"2016-05-12T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/vue/","link":"","permalink":"http://yoursite.com/2016/05/12/vue/","excerpt":"","text":"一、数据绑定 1.解析html标签使用三个 {{{html标签}}},{{msg}} 2.支持三元表达式 双向绑定{{name==='hello world'?'1':'2'}} 3.通过v-model实现双向数据绑定 &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; 二、vue暴露的方法 1. var vm = new Vue({ el:&apos;#app&apos;, data:message }); vm.$el//拿到的就是对应的#app vm.$data//拿到的就是对于的data数据 三、vue的生命周期 1. vm 1234567891011121314151617181920212223242526272829303132 data:&#123; name:&apos;hello&apos; &#125;, beforeCreate()&#123; console.log(&apos;实例刚刚被创建1&apos;); &#125;, created()&#123; console.log(&apos;实例已经创建完成2&apos;); &#125;, beforeMount()&#123; console.log(&apos;模板编译之前3&apos;); &#125;, mounted()&#123; /*请求数据放在这个里面 必须记住 mounted*/ console.log(&apos;模板编译完成4&apos;); &#125;, beforeUpdate()&#123; console.log(&apos;数据更新之前&apos;); &#125;, updated()&#123; console.log(&apos;数据更新完毕&apos;); &#125;, beforeDestroy()&#123; console.log(&apos;实例销毁之前&apos;); &#125;, destroyed()&#123; console.log(&apos;实例销毁完成&apos;); &#125;&#125;);//手动挂载指定元素vm.$mount(&apos;#app&apos;);//销毁实例//vm.$destroy(); 四、vue的计算属性 1. vm 12345678910111213 data:&#123; name:&apos;hello&apos; &#125;, computed:&#123; //有些数据是要根据我们的提供的数据计算出来的 //默认的是获取属性 在页面中获取属性b会调用对应的方法 b:function () &#123; //当前this是vue的实例 return this.name + &apos; world&apos; &#125; //有缓存 &#125;&#125;);vm.$mount(&apos;#app&apos;); 五、vue的set和get 1. vm 12345678910111213141516171819202122232425 data:&#123; name:&apos;hello&apos;, age:&apos;age&apos; &#125;, computed:&#123; b:&#123; //当给b设置属性的时候b立即会调用set方法 set: function (val) &#123; //在这里对设置的值进行后续的处理 //val是设置的具体内容 //可以改变原数据的属性 //当b更改的时候才触发事件 this.name = val; this.age = 500 &#125;, get:function () &#123; return this.name + &apos; world&apos; &#125; &#125; &#125;&#125;);vm.$mount(&apos;#app&apos;);//调用设置值setTimeout(function () &#123; vm.b = &apos;zfpx&apos;;&#125;,2000) 六、vue的v-if和v-show(v-if和v-else以及v-show和v-hide的区别解析用法) 1.v-if v-if接收bool类型。true的话则生成html，false则不生成。或者直接将元素remove掉。 2.v-else v-else紧跟在v-if或者v-show后边，否则将不被识别 3.v-show 通过此指令控制元素的显示隐藏，即控制元素的display。 4.v-hide 与v-show相反. 5. 123456789101.v-if&lt;div v-if=&quot;true&quot;&gt;你好&lt;/div&gt;2.v-else&lt;div v-if=&quot;flase&quot;&gt;错的&lt;/div&gt;&lt;div v-else&gt;不是错的&lt;/div&gt;3.v-show&lt;div v-show=&quot;true&quot; style=&quot;display:none&quot;&gt;我显示&lt;/div&gt;&lt;div v-show=&quot;false&quot; style=&quot;display:none&quot;&gt;我隐藏&lt;/div&gt; 七、vue的数据遍历 1.v-for=”book in books”(数组用$index,对象用$key) id12345678910111213141516171819202122 &lt;div v-for=&quot;book in books&quot;&gt; &#123;&#123;$index&#125;&#125;&#123;&#123;book.name&#125;&#125; &#123;&#123;book.price&#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; books:[ &#123;name:&apos;javascript&apos;,price:50&#125;, &#123;name:&apos;node&apos;,price:50&#125;, &#123;name:&apos;ajax&apos;,price:50&#125;, &#123;name:&apos;vue&apos;,price:50&#125;, ] &#125; &#125;) &lt;!--输出0javascript 50 1node 50 2ajax 50 3vue 50--&gt;&lt;/script&gt; 八、vue的双重循环 1.v-for=”(index,book) in books” id1234567891011121314151617181920212223 &lt;!--可以用括号的形式 第一个参数是当前索引 第二个是数组的每一项 index = $index--&gt; &lt;div v-for=&quot;(index,book) in books&quot;&gt; &#123;&#123;book.name&#125;&#125; &#123;&#123;index&#125;&#125; &lt;!--book代表数组的每一项--&gt; &lt;div v-for=&quot;b in book.name&quot;&gt; 父亲&#123;&#123;index&#125;&#125;&#123;&#123;$index&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; books:[ &#123;name:[&apos;a&apos;,&apos;e&apos;,&apos;f&apos;],price:50&#125;, &#123;name:[&apos;a&apos;],price:50&#125;, &#123;name:[&apos;a&apos;,&apos;e&apos;],price:50&#125;, &#123;name:[&apos;a&apos;,&apos;e&apos;,&apos;a&apos;,&apos;e&apos;],price:50&#125;, ] &#125; &#125;)&lt;/script&gt; 九、vue的v-bind 1.v-bind 绑定动态数据 简写: vm 123456789101112131415 el:&apos;#app&apos;, data:&#123; src:&apos;http://vuejs.org/images/logo.png&apos;, src1:&apos;http://www.baidu.com&apos; &#125;, //当前要执行的方法写在methods中 用@符号或者v-on进行绑定 //当我们不进行参数的传递 不用写()如果要传递参数 methods:&#123; //如果有参数 需要手动传递event dosome: function (e,ev) &#123; console.log(ev); alert(1); &#125; &#125;&#125;); 十、vue的class 1. id1234567891011121314151617181920212223242526 &lt;div class=&quot;&#123;&#123;style&#125;&#125;&quot;&gt;123&lt;/div&gt; //直接动态引入数据 &lt;div v-bind:class=&quot;style&quot;&gt;123&lt;/div&gt; //不是true就是false &lt;div v-bind:class=&quot;&#123;&apos;red&apos;:true,&apos;yellow&apos;:true&#125;&quot;&gt;123&lt;/div&gt; //绑定数组 &lt;div :class=&quot;[&apos;red&apos;,&apos;yellow&apos;]&quot;&gt;536&lt;/div&gt; //三元表达式写法 &lt;div :class=&quot;[&apos;red&apos;,flag?&apos;orange&apos;:&apos;yellow&apos;]&quot;&gt;536&lt;/div&gt; //最简单的用法 数组和对象并用 &lt;!--&lt;div class=&apos;color&apos; ng-class=&quot;&#123;red:flag&#125;&quot;&gt;&lt;/div&gt;--&gt; &lt;div :class=&quot;[&apos;red&apos;,&#123;yellow:flag&#125;,flag?&apos;orange&apos;:&apos;yellow&apos;]&quot;&gt;789&lt;/div&gt; &lt;!--class=&quot;&#123;&#123;className&#125;&#125;&quot; 和v:bind:class=&apos;obj&apos; 不要混用--&gt; &lt;!--class 可以和v-bind:class共存--&gt;&lt;/div&gt;&lt;body&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; style:&apos;red&apos;, flag:true &#125; &#125;);&lt;/script&gt; 十一、vue的表单 1.id1234567891011121314151617181920212223242526272829303132333435363738394041424344 //取value值 对应的checkbox 必须是数组 &lt;br&gt; &lt;input checked type=&quot;checkbox&quot; value=&quot;点击&quot; v-model=&quot;name&quot; name=&quot;all&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;点击1&quot; v-model=&quot;name&quot; name=&quot;all&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;点击2&quot; v-model=&quot;name&quot; name=&quot;all&quot;&gt; &#123;&#123;name&#125;&#125; &lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;man&quot; name=&quot;group&quot;&gt;男 &lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;woman&quot; name=&quot;group&quot;&gt;女 &#123;&#123;radio&#125;&#125; //取selects的值就是我们对应的当前选中的值 &lt;select v-model=&quot;selects&quot;&gt; &lt;option v-for=&quot;l in lists&quot; v-bind:value=&quot;l.name&quot;&gt;&#123;&#123;l.name&#125;&#125;&lt;/option&gt; &lt;!--&lt;option value=&quot;1&quot;&gt;hello&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;world&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;hello world&lt;/option&gt;--&gt; &lt;/select&gt;&lt;!-- &lt;select id=&quot;select&quot;&gt; &lt;option value=&quot;1&quot;&gt;4&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;3&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;2&lt;/option&gt; &lt;/select&gt;--&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;/* select.onchange = function () &#123; alert(this.value) &#125;*/ var vm = new Vue(&#123; el:&quot;#app&quot;, data:&#123; name:[], selects:&apos;jw2&apos;, lists:[ &#123;name:&apos;jw1&apos;&#125;, &#123;name:&apos;jw2&apos;&#125;, &#123;name:&apos;jw3&apos;&#125; ] &#125; &#125;)&lt;/script&gt; 十二、vue的语法糖父子组件传值验证 1. id12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 &lt;!--&lt;table&gt; &lt;tr is=&quot;parent&quot;&gt;&lt;/tr&gt; &lt;/table&gt;--&gt; //给parent 模板传递了一个msg变量 &lt;!--message = who ar you--&gt; &lt;!--:message=&quot;&apos;1&apos;&quot;--&gt; &lt;!--//这里是原本界面的data --&gt; 全局下的&lt;input type=&quot;text&quot; v-model=&quot;data&quot;&gt; &lt;!--//默认是单向数据流--&gt; &lt;parent :message.sync=&quot;data&quot;&gt;&lt;/parent&gt; &lt;template id=&quot;parent&quot;&gt;&lt;br&gt; parent&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;div&gt;parent &#123;&#123;message&#125;&#125; &#123;&#123;message2&#125;&#125;&lt;/div&gt; &lt;div&gt;parent&lt;/div&gt; &lt;ch&gt;&lt;/ch&gt; &lt;/template&gt; &lt;template id=&quot;child&quot;&gt; &lt;div&gt;child&lt;/div&gt; &lt;div&gt;child&lt;/div&gt; &lt;/template&gt;&lt;/div&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //我们想传递数据 先从属性 传递到props 在从props取出来绑定到组件里 //:message=&quot;1&quot; 是绑定的数字1 //message=&quot;1&quot; 绑定的字符串1 只能传递字符串1 //组件的嵌套 //先创建自组件，子组件创建后插到父组件里 //vuex Vue.component(&apos;parent&apos;,&#123; template:&apos;#parent&apos;, props:&#123; //对属性进行验证 &apos;message&apos;:&#123; type:[String], //只能传递字符串类型的 default: function () &#123; return 100 //默认值可以不符合type类型 &#125;, twoWay:true, //要求必须是双向的 validator: function (v) &#123;//不写的话没有校验器 //v就代表传进来的值 校验v的值是否是你的预期 return true //v===&apos;who are you6000&apos; &#125;, coerce: function (v) &#123; console.log(v); //传进来的值 强制进行改变 在验证之前 return v;//之后开始检测type是否符合 &#125; &#125;, &apos;message2&apos;:&#123; default: function () &#123; return 200 &#125;, coerce: function (v) &#123; console.log(v); //传进来的值 强制进行改变 在验证之前 return 2000;//之后开始检测type是否符合 &#125; &#125; &#125;, //属性 components:&#123; ch:&#123; template:&apos;#child&apos; &#125; &#125; &#125;); //组件和数据交互 /*var child = Vue.extend(&#123; template:&apos;&lt;div&gt;child&lt;/div&gt;&apos; &#125;); //只能在父组件里使用 var parent = Vue.extend(&#123; template:&apos;&lt;div&gt;parent&lt;/div&gt;&lt;ch&gt;&lt;/ch&gt;&apos;, components:&#123; ch:child &#125; &#125;); //只注册了父亲组件 Vue.component(&apos;parent&apos;,parent);*/ /*Vue.component(&apos;com&apos;,&#123; template:&apos;&lt;div&gt;hello&lt;/div&gt;&apos; &#125;);*/ var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; data:&apos;who are you&apos; &#125; &#125;);&lt;/script&gt; 十三、vue的组件 1. id123456789101112131415161718192021222324252627282930 &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;template id=&quot;tmpl&quot;&gt; &lt;ul&gt; &lt;li&gt;home &#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;li&gt;profile&lt;/li&gt; &lt;li&gt;concat&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //把html取出来当作模板，用数据渲染好，将我们的组件扔到页面里 //用extend方法创建出组建,在实例创建前 var hello = Vue.extend(&#123; //template就是组件的模板 template:&apos;#tmpl&apos; &#125;); var world = Vue.extend(&#123; //template就是组件的模板 template:&apos;&lt;div&gt;world&lt;/div&gt;&apos; &#125;); //注册组件 第一个参数是组件的名字，第二个参数是创建的组件 Vue.component(&apos;hello&apos;,hello); Vue.component(&apos;world&apos;,world); var vm = new Vue(&#123; el:&apos;#app&apos;, &#125;);&lt;/script&gt; 十四、vue的动态组件 1. id123456789101112131415161718192021 &lt;input type=&quot;radio&quot; value=&quot;home&quot; v-model=&quot;current&quot; name=&quot;rad&quot;&gt;home &lt;input type=&quot;radio&quot; value=&quot;page&quot; v-model=&quot;current&quot; name=&quot;rad&quot;&gt;page &lt;component :is=&quot;current&quot;&gt;&lt;/component&gt;&lt;/div&gt;&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, data:&#123; current:&apos;&apos; &#125;, components:&#123; home:&#123; template:&apos;&lt;div&gt;Hello&lt;/div&gt;&apos; &#125;, page:&#123; template:&apos;&lt;div&gt;world&lt;/div&gt;&apos; &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"React第七讲课堂笔记（组件嵌套）","slug":"React第七讲课堂笔记（组件嵌套）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第七讲课堂笔记（组件嵌套）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第七讲课堂笔记（组件嵌套）/","excerpt":"","text":"React第七讲课堂笔记（组件嵌套）组件间的嵌套是在开发过程中最为常用的，其中会有以下几种组件嵌套的方式。 1. 受限组件 &amp;&amp; 非受限组件受限组件示例：123render() &#123; return &lt;input type=&quot;text&quot; value=&quot;Hello!&quot; /&gt;;&#125; 非受限组件示例：123render() &#123; return &lt;input type=&quot;text&quot; /&gt;;&#125; 2. 使用自定义的组件1234567891011121314151617181920212223242526272829&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;class ComponentA extends Component &#123; render() &#123; return &lt;a href=&apos;#&apos;&gt;我是组件A&lt;br/&gt;&lt;/a&gt; &#125;&#125;class ComponentB extends Component &#123; render() &#123; return &lt;a href=&apos;#&apos;&gt;我是组件B&lt;/a&gt; &#125;&#125;class SelfCreateComponent extends Component &#123; render() &#123; return ( &lt;i&gt; &lt;ComponentA /&gt; &lt;ComponentB /&gt; &lt;/i&gt; ); &#125;&#125;export default SelfCreateComponent; 3. 使用 CHILDREN 组合自定义组件中可以通过 this.props.children 访问自定义组件的子节点123456789101112131415161718192021222324252627282930&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;// 定义一个组件，通过React.Children 拿到组件里面的子元素class ListComponent extends Component &#123; render()&#123; return &lt;ul&gt; &#123; React.Children.map( this.props.children, function(c)&#123; return &lt;li&gt;&#123;c&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ul&gt; &#125;&#125;class UseChildrenComponent extends Component &#123; render()&#123; return ( &lt;ListComponent&gt; &lt;a href=&quot;#&quot;&gt;Facebook&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;Google&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;SpaceX&lt;/a&gt; &lt;/ListComponent&gt; ) &#125;&#125;export default UseChildrenComponent;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第一讲课堂笔记（初识React）","slug":"React第一讲课堂笔记（初识React）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第一讲课堂笔记（初识React）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第一讲课堂笔记（初识React）/","excerpt":"","text":"React第一讲课堂笔记（初识React） React 是一个用于构建用户界面的JAVASCRIPT库 1. 初识React 只关注UI 许多人使用React作为MVC架构的V层。 尽管React并没有假设过你的其余技术栈， 但它仍可以作为一个小特征轻易地在已有项目中使用 虚拟DOM特性 React为了更高超的性能而使用虚拟DOM作为其不同的实现。 它同时也可以由服务端Node.js渲染 － 而不需要过重的浏览器DOM支持 单向数据流 React实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 2. 一个简单的React组件及其渲染React组件通过一个 render() 方法，接受输入的参数并返回展示的对象。 以下这个例子使用了JSX，它类似于XML的语法。输入的参数通过 render() 传入组件后，将存储在this.props ES5 写法123456789101112var React = require(&apos;react&apos;);var ReactDOM = require(&apos;react-dom&apos;);// 定义组件var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt; React，我们来了... &lt;/div&gt;; &#125;&#125;);// 组件渲染ReactDOM.render(&lt;HelloMessage /&gt;, rootElement); ES6 写法123456789101112import React, &#123; Component &#125; from &apos;react&apos;;import &#123; render &#125; from &apos;react-dom&apos;;// 定义组件class SimpleComponent extends Component &#123; render()&#123; return &lt;div&gt; React，我们来了... &lt;/div&gt;; &#125;&#125;// 组件渲染render(&lt;HelloMessage /&gt;, rootElement); 3. 了解顶层APIreact.js12345678910React.Children: ObjectReact.Component: ReactComponent(props, context, updater)React.DOM: ObjectReact.PropTypes: ObjectReact.cloneElement: (element, props, children)React.createClass: (spec)React.createElement: (type, props, children)React.createFactory: (type)React.createMixin: (mixin)React.isValidElement: (object) Component API12345this.context: Objectthis.props: Objectthis.refs: Objectthis.state: Objectthis.setState: Object react-dom.js123ReactDOM.findDOMNode: findDOMNode(componentOrElement)ReactDOM.render: ()ReactDOM.unmountComponentAtNode: (container) react-dom-server.js12ReactDOMServer.renderToStringReactDOMServer.renderToStaticMarkup","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第三讲课堂笔记（数据流）","slug":"React第三讲课堂笔记（数据流）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第三讲课堂笔记（数据流）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第三讲课堂笔记（数据流）/","excerpt":"","text":"React第三讲课堂笔记（数据流）1. state setState可以把组件当成一个状态机，我们给组件传入数据作为输入，组件在内部进行逻辑处理，之后返回一段HTML结构作为输出。 而传入的数据即为props，组件内部的状态控制即为state，每一次状态对应于组件的一个 ui 。 12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from &apos;react&apos;;class StateDemo extends Component &#123; state = &#123; secondsElapsed: 0 &#125; tick()&#123; this.setState(&#123; secondsElapsed: this.state.secondsElapsed + 1 &#125;); &#125; componentDidMount()&#123; this.interval = setInterval( this.tick.bind(this), 1000 ); &#125; componentWillUnmount()&#123; clearInterval(this.interval); &#125; render()&#123; return ( &lt;div&gt;目前已经计时：&#123;this.state.secondsElapsed&#125;秒&lt;/div&gt; ) &#125;&#125;export default StateDemo; 2. props通过 this.props 可以获取传递给该组件的属性值，还可以通过定义 getDefaultProps 来指定默认属性值（这是ES5的写法，ES6定义组件的默认props可以直接写props） 下面几个是props的常用API： this.props.children this.props.map this.props.filter props是调用组件的时候传递进去的数据，一般用于组件树数据传递 123456789101112131415161718import React, &#123; Component &#125; from &apos;react&apos;;class PropsDemo extends Component &#123; props = &#123; title: &apos;这是默认的title属性值&apos; &#125; render()&#123; console.log(this.props); return &lt;b&gt;&#123;this.props.title&#125;&lt;/b&gt; &#125;&#125;export default PropsDemo;// 组件调用方式// &lt;PropsDemo title=&quot;设置的标题&quot; /&gt; 3. propTypes通过指定 propTypes 可以校验props属性值的类型，校验可提升开发者体验，用于约定统一的接口规范。 123456789101112131415161718import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;class PropTypesDemo extends Component &#123; render()&#123; return &lt;b&gt;&#123;this.props.title&#125;&lt;/b&gt; &#125;&#125;PropTypesDemo.defaultProps= &#123; title: &apos;我是默认的title&apos;&#125;PropTypesDemo.propTypes = &#123; title: PropTypes.string.isRequired&#125;export default PropTypesDemo;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第五讲课堂笔记（DOM操作）","slug":"React第五讲课堂笔记（DOM操作）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第五讲课堂笔记（DOM操作）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第五讲课堂笔记（DOM操作）/","excerpt":"","text":"React第五讲课堂笔记（DOM操作）1. React 中获取DOM的两种方式 ReactDOM.findDOMNode this.refs.xxx 获取DOM后可以方便结合现有非 react 类库的使用，通过 ref/refs 可以取得组件实例，进而取得原生节点，不过尽量通过 state/props 更新组件，不要使用该功能去更新组件的DOM。 2. 示例一123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &apos;react&apos;;import ReactDOM, &#123; findDOMNode &#125; from &apos;react-dom&apos;;class HandleDOMComponent extends Component &#123; componentDidMount()&#123; // 两种方式都可以获取到元素 let ele = findDOMNode(this.refs.content); let ele2 = this.refs.content; // 如果想用 jquery，那么这是个好时机 console.log( ele ); console.log( ele.innerHTML ); console.log( ele2.innerHTML ); &#125; render()&#123; return ( &lt;div&gt; &lt;h3&gt;来吧，一起操作DOM&lt;/h3&gt; &lt;div ref=&apos;content&apos;&gt;这是我DOM元素里面的内容&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default HandleDOMComponent; 3. 示例二123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from &apos;react&apos;;import &#123; findDOMNode &#125; from &apos;react-dom&apos;;class Refs extends Component &#123; state = &#123; red: 0, green: 0, pink: 0 &#125; update = (e) =&gt; &#123; this.setState(&#123; red: findDOMNode(this.refs.red).value, green: findDOMNode(this.refs.green).value, pink: findDOMNode(this.refs.pink).value &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;Slider ref=&quot;red&quot; update=&#123;this.update&#125; /&gt; &#123;this.state.red&#125; &lt;br /&gt; &lt;Slider ref=&quot;green&quot; update=&#123;this.update&#125; /&gt; &#123;this.state.green&#125; &lt;br /&gt; &lt;Slider ref=&quot;pink&quot; update=&#123;this.update&#125; /&gt; &#123;this.state.pink&#125; &lt;/div&gt; ) &#125;&#125;class Slider extends Component &#123; render()&#123; return ( &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;255&quot; onChange=&#123;this.props.update&#125; /&gt; ) &#125;&#125;export default Refs;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第八讲课堂笔记（表单操作）","slug":"React第八讲课堂笔记（表单操作）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第八讲课堂笔记（表单操作）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第八讲课堂笔记（表单操作）/","excerpt":"","text":"React第八讲课堂笔记（表单操作）1. React表单组件和 html 的不同点 value/checked 属性设置后，用户输入无效 textarea 的值要设置在 value 属性 1&lt;textarea name=&quot;description&quot; value=&quot;This is a description.&quot; /&gt; select 的 value 属性可以是数组，不建议使用 option 的 selected 属性 12345&lt;select multiple=&#123;true&#125; value=&#123;[&apos;B&apos;, &apos;C&apos;]&#125;&gt; &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt; &lt;/select&gt; input/textarea 的 onChange 用户每次输入都会触发（即使不失去焦点） radio/checkbox/option 点击后触发 onChange 2. 综合表达组件示例 定义复选框组件Checkboxes 12345678910111213141516import React, &#123; Component &#125; from &apos;react&apos;;class Checkboxes extends Component &#123; render()&#123; return &lt;span&gt; A &lt;input onChange=&#123;this.props.handleCheck&#125; name=&quot;goodCheckbox&quot; type=&quot;checkbox&quot; value=&quot;A&quot;/&gt; B &lt;input onChange=&#123;this.props.handleCheck&#125; name=&quot;goodCheckbox&quot; type=&quot;checkbox&quot; value=&quot;B&quot; /&gt; C &lt;input onChange=&#123;this.props.handleCheck&#125; name=&quot;goodCheckbox&quot; type=&quot;checkbox&quot; value=&quot;C&quot; /&gt; &lt;/span&gt; &#125;&#125;export default Checkboxes; 定义单选框按钮组RadioButtons 1234567891011121314151617181920import React, &#123; Component &#125; from &apos;react&apos;;class RadioButtons extends Component &#123; saySomething()&#123; alert(&quot;我是一个很棒的单选框按钮组&quot;); &#125; render()&#123; return &lt;span&gt; A &lt;input onChange=&#123;this.props.handleRadio&#125; name=&quot;goodRadio&quot; type=&quot;radio&quot; value=&quot;A&quot;/&gt; B &lt;input onChange=&#123;this.props.handleRadio&#125; name=&quot;goodRadio&quot; type=&quot;radio&quot; defaultChecked value=&quot;B&quot;/&gt; C &lt;input onChange=&#123;this.props.handleRadio&#125; name=&quot;goodRadio&quot; type=&quot;radio&quot; value=&quot;C&quot;/&gt; &lt;/span&gt; &#125;&#125;export default RadioButtons; FormApp组件集成两个组件并处理表单逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import Checkboxes from &apos;./Checkboxes&apos;;import RadioButtons from &apos;./RadioButtons&apos;;class FormApp extends Component &#123; state = &#123; inputValue: &apos;请输入...&apos;, selectValue: &apos;A&apos;, radioValue:&apos;B&apos;, checkValues:[], textareaValue:&apos;请输入...&apos; &#125; handleSubmit = (e) =&gt; &#123; e.preventDefault(); let formData = &#123; input: this.refs.goodInput.value, select: this.refs.goodSelect.value, textarea: this.refs.goodTextarea.value, radio: this.state.radioValue, check: this.state.checkValues, &#125; alert(&apos;您即将提交表单&apos;) console.log(&apos;你提交的数据是:&apos;) console.log(formData); &#125; handleRadio = (e) =&gt; &#123; this.setState(&#123; radioValue: e.target.value, &#125;) &#125; handleCheck = (e) =&gt; &#123; let checkValues = this.state.checkValues.slice(); let newVal = e.target.value; let index = checkValues.indexOf(newVal); if( index == -1 )&#123; checkValues.push( newVal ) &#125;else&#123; checkValues.splice(index,1); &#125; this.setState(&#123; checkValues: checkValues, &#125;) &#125; render()&#123; return &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;h3&gt; 请输入内容 &lt;/h3&gt; &lt;input ref=&quot;goodInput&quot; type=&quot;text&quot; defaultValue=&#123;this.state.inputValue &#125;/&gt; &lt;br/&gt; &lt;h3&gt; 请选择 &lt;/h3&gt; &lt;select defaultValue=&#123; this.state.selectValue &#125; ref=&quot;goodSelect&quot;&gt; &lt;option value=&quot;A&quot;&gt;A&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;B&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;C&lt;/option&gt; &lt;option value=&quot;D&quot;&gt;D&lt;/option&gt; &lt;option value=&quot;E&quot;&gt;E&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;h3&gt; 单项选择 &lt;/h3&gt; &lt;RadioButtons ref=&quot;goodRadio&quot; handleRadio=&#123;this.handleRadio&#125; /&gt; &lt;br/&gt; &lt;h3&gt; 多选按钮 &lt;/h3&gt; &lt;Checkboxes handleCheck=&#123;this.handleCheck&#125; /&gt; &lt;br/&gt; &lt;h3&gt; 反馈建议 &lt;/h3&gt; &lt;textarea defaultValue=&#123;this.state.textareaValue&#125; ref=&quot;goodTextarea&quot;&gt;&lt;/textarea&gt; &lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;确认提交&lt;/button&gt; &lt;/form&gt; &#125;&#125;export default FormApp;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第六讲课堂笔记（事件）","slug":"React第六讲课堂笔记（事件）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第六讲课堂笔记（事件）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第六讲课堂笔记（事件）/","excerpt":"","text":"React第五讲课堂笔记（DOM操作）1. React 中获取DOM的两种方式 ReactDOM.findDOMNode this.refs.xxx 获取DOM后可以方便结合现有非 react 类库的使用，通过 ref/refs 可以取得组件实例，进而取得原生节点，不过尽量通过 state/props 更新组件，不要使用该功能去更新组件的 React第六讲课堂笔记（事件）可以通过设置原生 dom 组件的 onEventType 属性来监听 dom 事件，例如 onClick, onMouseDown，在加强组件内聚性的同时，避免了传统 html 的全局变量污染 123456789101112131415161718192021222324&apos;use strict&apos;;import React, &#123; Component &#125; from &apos;react&apos;;class HandleEvent extends Component &#123; state = &#123; liked: false &#125; handleClick = (event) =&gt; &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125; render() &#123; let text = this.state.liked ? &apos;喜欢&apos; : &apos;不喜欢&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; 我 &#123;text&#125; 你. &lt;/p&gt; ); &#125;&#125;export default HandleEvent; 注意：事件回调函数参数为标准化的事件对象，可以不用考虑 IE 更多事件我们可以一起看这里","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第二讲课堂笔记（JSX 语法）","slug":"React第二讲课堂笔记（JSX 语法）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第二讲课堂笔记（JSX 语法）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第二讲课堂笔记（JSX 语法）/","excerpt":"","text":"React第二讲课堂笔记（JSX 语法）1. 什么是 JSX类似 xml 的语法，用来描述组件树1234567var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);React.render(&lt;HelloMessage name=&quot;John&quot; /&gt;, mountNode); JSX是可选的，并不强制要求使用。如果不用JSX，用React提供的API写的话，应该是这样的，直接调用React的API来定义组件和DOM元素。 123456789var HelloMessage = React.createClass(&#123; displayName: &quot;HelloMessage&quot;, render: function() &#123; return React.createElement(&quot;div&quot;, null, &quot;Hello &quot;, this.props.name); &#125;&#125;);React.render(React.createElement(HelloMessage, &#123;name: &quot;John&quot;&#125;), mountNode); 2. 为什么要使用 JSX你不需要为了 React 使用 JSX，可以直接使用纯粹的 JS。但我们更建议使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。 3. 注释1234567891011121314151617import React, &#123; Component &#125; from &apos;react&apos;;const name = &apos;yongfeng&apos;;const MyComponent = () =&gt; &#123; &lt;Nav&gt; &#123;/* 一般注释, 用 &#123;&#125; 包围 */&#125; &lt;a /* 多 行 注释 */ className=&#123; name ? &apos;a&apos; : &apos;b&apos; &#125; // 行尾注释 href=&quot;http://guoyongfeng.github.io/idoc&quot; &gt; 注释 &lt;/a&gt; &lt;/Nav&gt;&#125;;export default MyComponent; 4. 命名12345678910import React, &#123; Component &#125; from &apos;react&apos;;// 1. 组件命名遵循驼峰命名，首字母大写class ComponentDemo extends Component &#123; render()&#123; return &lt;div&gt; 你好，兄弟... &lt;/div&gt; &#125;&#125;export default ComponentDemo; 5. 根元素个数123456789101112131415import React, &#123; Component &#125; from &apos;react&apos;;class ComponentDemo extends Component &#123; render()&#123; // 以下写法直接报错 return ( &lt;div&gt; hello &lt;/div&gt; &lt;h1&gt; hello h1 &lt;/h1&gt; ); &#125;&#125;export default ComponentDemo; React只有一个限制， 组件只能渲染单个根节点。如果你想要返回多个节点，它们必须被包含在同一个节点里。 6. 嵌入变量{}花括号内可以写JS逻辑，表达式和方法定义都可以 1let person = &lt;Person name=&#123;window.isLoggedIn ? window.name : &apos;&apos;&#125; /&gt;; 7. styles12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;;class StyleDemo extends Component &#123; render()&#123; // 5. 在JS文件里面给组件定义样式 var MyComponentStyles = &#123; color: &apos;blue&apos;, fontSize: &apos;28px&apos; &#125;; return ( &lt;div style=&#123;MyComponentStyles&#125;&gt; 可以直接这样写行内样式 &lt;/div&gt; ) &#125;&#125;export default StyleDemo; 8. JSX SPREAD可以通过 {...obj} 来批量设置一个对象的键值对到组件的属性 123456789101112import React, &#123; Component &#125; from &apos;react&apos;;class SpreadDemo extends Component &#123; componentWillMount()&#123; console.log(this.props); &#125; render()&#123; return &lt;h1&gt; &#123;this.props.name&#125; is a &#123;this.props.type&#125; &lt;/h1&gt;; &#125;&#125;export default SpreadDemo; 9. 属性名不能和 js 关键字冲突例如：className readOnly htmlfor","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第四讲课堂笔记（定义组件的方法以及理解组件生命周期）","slug":"React第四讲课堂笔记（定义组件的方法以及理解组件生命周期）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第四讲课堂笔记（定义组件的方法以及理解组件生命周期）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第四讲课堂笔记（定义组件的方法以及理解组件生命周期）/","excerpt":"","text":"React第四讲课堂笔记（定义组件的方法以及理解组件生命周期）用 React.createClass 或者 React.Component 定义组件时允许传入相应的配置及组件 API 的使用，包括组件生命周期提供的一系列钩子函数。 image 1. 组件初始定义 getDefaultProps 得到默认属性对象，这个在ES6的时候不需要这样定义 propTypes 属性检验规则 mixins 组件间公用方法 2. 初次创建组件时调用 getInitialState 得到初始状态对象 render 返回组件树. 必须设置 componentDidMount 渲染到 dom 树中是调用，只在客户端调用，可用于获取原生节点 3. 组件的属性值改变时调用 componentWillReceiveProps 属性改变调用 shouldComponentUpdate 判断是否需要重新渲染 render 返回组件树. 必须设置 componentDidUpdate 渲染到 dom 树中是调用, 可用于获取原生节点 4. 销毁组件 componentWillUnmount 组件从 dom 销毁前调用 5. 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from &apos;react&apos;;class LifeCycle extends Component &#123; props = &#123; value: &apos;开始渲染&apos; &#125; componentWillReceiveProps(nextProps)&#123; console.log(&apos;componentWillReceiveProps&apos;); this.setState(&#123; value: nextProps.value &#125;); &#125; shouldComponentUpdate(nextProps,nextState)&#123; console.log(&apos;shouldComponentUpdate&apos;); return true; &#125; componentWillUpdate(nextProps,nextState)&#123; console.log(&apos;componentWillUpdate&apos;); &#125; componentWillMount()&#123; console.log(&apos;componentWillMount&apos;); &#125; render() &#123; console.log(&apos;render&apos;); return &lt;span&gt;&#123;this.props.value&#125;&lt;/span&gt; &#125; componentDidMount() &#123; console.log(&apos;componentDidMount&apos;); &#125; componentDidUpdate(prevProps,prevState) &#123; console.log(&apos;componentDidUpdate&apos;); &#125; componentWillUnmount(prevProps,prevState) &#123; console.log(&apos;componentWillUnmount&apos;); &#125;&#125;export default LifeCycle; 调用组件并销毁组件示例1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from &apos;react&apos;;import LifeCycleDemo from &apos;./LifeCycleDemo&apos;;class DestroyComponent extends Component &#123; state = &#123; value:1, destroyed:false &#125; increase = () =&gt; &#123; this.setState(&#123; value: this.state.value + 1 &#125;); &#125; destroy = () =&gt; &#123; this.setState(&#123; destroyed: true &#125;); &#125; render() &#123; if(this.state.destroyed)&#123; return null; &#125; return &lt;div&gt; &lt;p&gt; &lt;button onClick=&#123;this.increase&#125;&gt;每次加1&lt;/button&gt; &lt;button onClick=&#123;this.destroy&#125;&gt;干掉这两个按钮&lt;/button&gt; &lt;/p&gt; &lt;LifeCycleDemo value=&#123;this.state.value&#125;/&gt; &lt;/div&gt;; &#125;&#125;export default DestroyComponent; 6. 回顾组件的渲染过程12345678910111213141516# 创建 -&gt; 渲染 -&gt; 销毁getDefaultProps()getInitialState()componentWillMount()render()componentDidMount()componentWillUnmount()# 更新组件componentWillReceiveProps()shouldComponentUpdate()componentWillUpdate()render()componentDidUpdate()","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React课堂笔记第十讲（编码规范）","slug":"React课堂笔记第十讲（编码规范）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React课堂笔记第十讲（编码规范）/","link":"","permalink":"http://yoursite.com/2016/05/12/React课堂笔记第十讲（编码规范）/","excerpt":"","text":"React课堂笔记第十讲（编码规范）Airbnb React/JSX Style Guide A mostly reasonable approach to React and JSX 目录 Basic Rules Class vs React.createClass vs stateless Naming Declaration Alignment Quotes Spacing Props Parentheses Tags Methods Ordering isMounted Basic Rules Only include one React component per file. However, multiple Stateless, or Pure, Components are allowed per file. eslint: react/no-multi-comp. Always use JSX syntax. Do not use React.createElement unless you’re initializing the app from a file that is not JSX. Class vs React.createClass vs stateless If you have internal state and/or refs, prefer class extends React.Component over React.createClass unless you have a very good reason to use mixins. eslint: react/prefer-es6-class react/prefer-stateless-function 123456789101112131415// badconst Listing = React.createClass(&#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125;);// goodclass Listing extends React.Component &#123; // ... render() &#123; return &lt;div&gt;&#123;this.state.hello&#125;&lt;/div&gt;; &#125;&#125; And if you don’t have state or refs, prefer normal functions (not arrow functions) over classes: 12345678910111213141516// badclass Listing extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.hello&#125;&lt;/div&gt;; &#125;&#125;// bad (relying on function name inference is discouraged)const Listing = (&#123; hello &#125;) =&gt; ( &lt;div&gt;&#123;hello&#125;&lt;/div&gt;);// goodfunction Listing(&#123; hello &#125;) &#123; return &lt;div&gt;&#123;hello&#125;&lt;/div&gt;;&#125; Naming Extensions: Use .jsx extension for React components. Filename: Use PascalCase for filenames. E.g., ReservationCard.jsx. Reference Naming: Use PascalCase for React components and camelCase for their instances. eslint: react/jsx-pascal-case 1234567891011// badimport reservationCard from './ReservationCard';// goodimport ReservationCard from './ReservationCard';// badconst ReservationItem = &lt;ReservationCard /&gt;;// goodconst reservationItem = &lt;ReservationCard /&gt;; Component Naming: Use the filename as the component name. For example, ReservationCard.jsx should have a reference name of ReservationCard. However, for root components of a directory, use index.jsx as the filename and use the directory name as the component name: 12345678// badimport Footer from './Footer/Footer';// badimport Footer from './Footer/index';// goodimport Footer from './Footer'; Declaration Do not use displayName for naming components. Instead, name the component by reference. 123456789// badexport default React.createClass(&#123; displayName: 'ReservationCard', // stuff goes here&#125;);// goodexport default class ReservationCard extends React.Component &#123;&#125; Alignment Follow these alignment styles for JSX syntax. eslint: react/jsx-closing-bracket-location 1234567891011121314151617181920// bad&lt;Foo superLongParam=\"bar\" anotherSuperLongParam=\"baz\" /&gt;// good&lt;Foo superLongParam=\"bar\" anotherSuperLongParam=\"baz\"/&gt;// if props fit in one line then keep it on the same line&lt;Foo bar=\"bar\" /&gt;// children get indented normally&lt;Foo superLongParam=\"bar\" anotherSuperLongParam=\"baz\"&gt; &lt;Quux /&gt;&lt;/Foo&gt; Quotes Always use double quotes (&quot;) for JSX attributes, but single quotes for all other JS. eslint: jsx-quotes Why? JSX attributes can’t contain escaped quotes, so double quotes make conjunctions like &quot;don&#39;t&quot; easier to type.Regular HTML attributes also typically use double quotes instead of single, so JSX attributes mirror this convention. 1234567891011// bad&lt;Foo bar='bar' /&gt;// good&lt;Foo bar=\"bar\" /&gt;// bad&lt;Foo style=&#123;&#123; left: \"20px\" &#125;&#125; /&gt;// good&lt;Foo style=&#123;&#123; left: '20px' &#125;&#125; /&gt; Spacing Always include a single space in your self-closing tag. 123456789101112// bad&lt;Foo/&gt;// very bad&lt;Foo /&gt;// bad&lt;Foo /&gt;// good&lt;Foo /&gt; Do not pad JSX curly braces with spaces. eslint: react/jsx-curly-spacing 12345// bad&lt;Foo bar=&#123; baz &#125; /&gt;// good&lt;Foo bar=&#123;baz&#125; /&gt; Props Always use camelCase for prop names. 1234567891011// bad&lt;Foo UserName=\"hello\" phone_number=&#123;12345678&#125;/&gt;// good&lt;Foo userName=\"hello\" phoneNumber=&#123;12345678&#125;/&gt; Omit the value of the prop when it is explicitly true. eslint: react/jsx-boolean-value 123456789// bad&lt;Foo hidden=&#123;true&#125;/&gt;// good&lt;Foo hidden/&gt; Always include an alt prop on &lt;img&gt; tags. If the image is presentational, alt can be an empty string or the &lt;img&gt; must have role=&quot;presentation&quot;. eslint: jsx-a11y/img-has-alt 1234567891011// bad&lt;img src=\"hello.jpg\" /&gt;// good&lt;img src=\"hello.jpg\" alt=\"Me waving hello\" /&gt;// good&lt;img src=\"hello.jpg\" alt=\"\" /&gt;// good&lt;img src=\"hello.jpg\" role=\"presentation\" /&gt; Do not use words like “image”, “photo”, or “picture” in &lt;img&gt; alt props. eslint: jsx-a11y/img-redundant-alt Why? Screenreaders already announce img elements as images, so there is no need to include this information in the alt text. 12345// bad&lt;img src=\"hello.jpg\" alt=\"Picture of me waving hello\" /&gt;// good&lt;img src=\"hello.jpg\" alt=\"Me waving hello\" /&gt; Use only valid, non-abstract ARIA roles. eslint: jsx-a11y/aria-role 12345678// bad - not an ARIA role&lt;div role=\"datepicker\" /&gt;// bad - abstract ARIA role&lt;div role=\"range\" /&gt;// good&lt;div role=\"button\" /&gt; Do not use accessKey on elements. eslint: jsx-a11y/no-access-key Why? Inconsistencies between keyboard shortcuts and keyboard commands used by people using screenreaders and keyboards complicate accessibility. 12345// bad&lt;div accessKey=\"h\" /&gt;// good&lt;div /&gt; Parentheses Wrap JSX tags in parentheses when they span more than one line. eslint: react/wrap-multilines 123456789101112131415161718192021// badrender() &#123; return &lt;MyComponent className=\"long body\" foo=\"bar\"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt;;&#125;// goodrender() &#123; return ( &lt;MyComponent className=\"long body\" foo=\"bar\"&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt; );&#125;// good, when single linerender() &#123; const body = &lt;div&gt;hello&lt;/div&gt;; return &lt;MyComponent&gt;&#123;body&#125;&lt;/MyComponent&gt;;&#125; Tags Always self-close tags that have no children. eslint: react/self-closing-comp 12345// bad&lt;Foo className=\"stuff\"&gt;&lt;/Foo&gt;// good&lt;Foo className=\"stuff\" /&gt; If your component has multi-line properties, close its tag on a new line. eslint: react/jsx-closing-bracket-location 12345678910// bad&lt;Foo bar=\"bar\" baz=\"baz\" /&gt;// good&lt;Foo bar=\"bar\" baz=\"baz\"/&gt; Methods Use arrow functions to close over local variables. 123456789101112function ItemList(props) &#123; return ( &lt;ul&gt; &#123;props.items.map((item, index) =&gt; ( &lt;Item key=&#123;item.key&#125; onClick=&#123;() =&gt; doSomethingWith(item.name, index)&#125; /&gt; ))&#125; &lt;/ul&gt; );&#125; Bind event handlers for the render method in the constructor. eslint: react/jsx-no-bind Why? A bind call in the render path creates a brand new function on every single render. 123456789101112131415161718192021222324252627// badclass extends React.Component &#123; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv.bind(this)&#125; /&gt; &#125;&#125;// goodclass extends React.Component &#123; constructor(props) &#123; super(props); this.onClickDiv = this.onClickDiv.bind(this); &#125; onClickDiv() &#123; // do stuff &#125; render() &#123; return &lt;div onClick=&#123;this.onClickDiv&#125; /&gt; &#125;&#125; Do not use underscore prefix for internal methods of a React component. 1234567891011121314151617// badReact.createClass(&#123; _onClickSubmit() &#123; // do stuff &#125;, // other stuff&#125;);// goodclass extends React.Component &#123; onClickSubmit() &#123; // do stuff &#125; // other stuff&#125; Be sure to return a value in your render methods. eslint: require-render-return 123456789// badrender() &#123; (&lt;div /&gt;);&#125;// goodrender() &#123; return (&lt;div /&gt;);&#125; Ordering Ordering for class extends React.Component: optional static methods constructor getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() Optional render methods like renderNavigation() or renderProfilePicture() render How to define propTypes, defaultProps, contextTypes, etc… 1234567891011121314151617181920212223242526import React, &#123; PropTypes &#125; from 'react';const propTypes = &#123; id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string,&#125;;const defaultProps = &#123; text: 'Hello World',&#125;;class Link extends React.Component &#123; static methodsAreOk() &#123; return true; &#125; render() &#123; return &lt;a href=&#123;this.props.url&#125; data-id=&#123;this.props.id&#125;&gt;&#123;this.props.text&#125;&lt;/a&gt; &#125;&#125;Link.propTypes = propTypes;Link.defaultProps = defaultProps;export default Link; Ordering for React.createClass: eslint: react/sort-comp displayName propTypes contextTypes childContextTypes mixins statics defaultProps getDefaultProps getInitialState getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() Optional render methods like renderNavigation() or renderProfilePicture() render isMounted Do not use isMounted. eslint: react/no-is-mounted Why? isMounted is an anti-pattern, is not available when using ES6 classes, and is on its way to being officially deprecated. ⬆ back to top","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React第九讲课堂笔记（mixin）","slug":"React第九讲课堂笔记（mixin）","date":"2016-05-12T05:22:01.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/12/React第九讲课堂笔记（mixin）/","link":"","permalink":"http://yoursite.com/2016/05/12/React第九讲课堂笔记（mixin）/","excerpt":"","text":"React第九讲课堂笔记（mixin）mixin 是一个普通对象，通过 mixin 可以在不同组件间共享代码，使你的React程序变得更为可重用。 注意，ES6语法不支持mixin写法，而是可以通过decorator去实现代码共享，这里使用ES5语法做示例说明。 1. ES5 语法实现 mixin1234567891011121314151617181920212223242526272829303132333435363738import React from &apos;react&apos;;var SetIntervalMixin = &#123; componentWillMount: function() &#123; this.intervals = []; &#125;, setInterval: function() &#123; this.intervals.push(setInterval.apply(null, arguments)); &#125;, componentWillUnmount: function() &#123; this.intervals.forEach(clearInterval); &#125;&#125;;var MixinDemo = React.createClass(&#123; // Use the mixin mixins: [SetIntervalMixin], getInitialState: function() &#123; return &#123;seconds: 0&#125;; &#125;, componentDidMount: function() &#123; // Call a method on the mixin this.setInterval(this.tick, 1000); &#125;, tick: function() &#123; this.setState(&#123;seconds: this.state.seconds + 1&#125;); &#125;, render: function() &#123; return ( &lt;p&gt; 计时器已经运行了： &#123;this.state.seconds&#125; 秒. &lt;/p&gt; ); &#125;&#125;);export default MixinDemo; 2. 用high-order component的方式实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; Component &#125; from &apos;react&apos;;let Mixin = MixinComponent =&gt; class extends Component &#123; constructor() &#123; super(); this.state = &#123; val: 0 &#125;; this.update = this.update.bind(this); &#125; update()&#123; this.setState(&#123;val: this.state.val + 1&#125;); &#125; componentWillMount()&#123; console.log(&apos;will mount...&apos;) &#125; render()&#123; return ( &lt;MixinComponent update=&#123;this.update&#125; &#123;...this.state&#125; &#123;...this.props&#125; /&gt; ) &#125; componentDidMount()&#123; console.log(&apos;mounted...&apos;) &#125;&#125;const Button = (props) =&gt; &#123; return ( &lt;button onClick=&#123;props.update&#125;&gt; &#123;props.txt&#125; - &#123;props.val&#125; &lt;/button&gt; )&#125;const Label = (props) =&gt; &#123; return ( &lt;label onMouseMove=&#123;props.update&#125;&gt; &#123;props.txt&#125; - &#123;props.val&#125; &lt;/label&gt; )&#125;let ButtonMixed = Mixin(Button);let LabelMixed = Mixin(Label);class Mixins extends Component &#123; render()&#123; return ( &lt;div&gt; &lt;ButtonMixed txt=&quot;button&quot; /&gt; &lt;LabelMixed txt=&quot;label&quot; /&gt; &lt;/div&gt; ) &#125;&#125;export default Mixins;","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Vue基础总结","slug":"vue总结","date":"2016-05-11T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/11/vue总结/","link":"","permalink":"http://yoursite.com/2016/05/11/vue总结/","excerpt":"","text":"Vue基础整理0.单文件组件的使用：一、全局安装 vue-cli$ npm install --global vue-cli 二、创建一个基于 webpack 模板的新项目$ vue init webpack-simple my-project 三、安装依赖，走你$ cd my-project $ npm install $ npm run dev 1.数据绑定 * {{name}} &lt;sapn v-text=&quot;name&quot;&gt;&lt;/span&gt; 绑定html： &lt;sapn v-html=&quot;name&quot;&gt;&lt;/span&gt; 2.定义数据 data * 组件里面注意 12345var vm=new Vue(&#123; data:&#123; msg:&apos;数据&apos; &#125;&#125;) 组件： 123456data()&#123; return &#123; msg:&apos;数据&apos; &#125;&#125; 3.定义方法 methods * 123456789var vm=new Vue(&#123; data:&#123; msg:&apos;数据&apos; &#125;,methods:&#123; getData:function()&#123; &#125; &#125;&#125;) 4.绑定 动态属性 * v-bind:src=&apos;src&apos; :src=&apos;src&apos; &lt;img :src=&quot;url&quot; alt=&quot;&quot;&gt; 5.执行事件的两种方式 * v-on:click=&quot;run()&quot; @click=&quot;run()&quot; 6.计算属性computed 12345678910111213141516171819&#123;&#123;&#123;a&#125;&#125; var vm=new Vue(&#123; data:&#123; msg:&apos;数据&apos;, list:[&apos;apple&apos;,&apos;bbbb&apos;,&apos;cccsss&apos;] &#125;,methods:&#123; getData:function()&#123; &#125; &#125;, computed:&#123; a:function()&#123; return this.msg+&apos;这是计算后的属性&apos; &#125; &#125; &#125;) 使用计算属性和使用data绑定的值一样 用到的data里面绑定的值变化 他就会变化 watch $watch 监听数据变化 12345678910111213141516171819202122232425262728293031323334353637383940 var vm=new Vue(&#123; el:&quot;#box&quot;, data:&#123; msg:&apos;this is a msg&apos;, name:&apos;&apos; &#125;, methods:&#123; getData:function()&#123; console.log(this.name); &#125; &#125; &#125;) vm.$watch(&apos;name&apos;,function(newValue,oldValue)&#123; console.log(newValue+&apos;---&apos;+oldValue); &#125;) var vm=new Vue(&#123; el:&apos;#box&apos;, data:&#123; msg:&apos;我是一个数据&apos; &#125;,methods:&#123; requestData:function()&#123; console.log(this.msg); /*请求数据*/ &#125; &#125;, watch:&#123; msg:function(newVal,oldVal)&#123; console.log(newVal+&apos;--&apos;+oldVal); &#125; &#125;&#125;); v-bind:class * 1&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; &apos;class-a&apos;: isA, &apos;class-b&apos;: isB &#125;&quot;&gt; 第一个元素加red的class list:[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;] &lt;li v-for=&quot;(item,key) in list&quot; :class={&quot;red&quot;:key==0}&gt;{{item}&lt;/li&gt; 9.v-if v-show v-if v-else * v-if dom操作 v-show 显示隐藏 10.数据循环 * 123 &lt;li v-for=&quot;(val,index) in list&quot;&gt; &#123;&#123;val&#125;&#125; ---&#123;&#123;index&#125;&#125;&lt;/li&gt; 1&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; 11.数据请求 插件必须记住 * vue-resource axios 12.事件对象 可以获取自定义属性的值 获取元素 * 1&lt;div class=&quot;button&quot; data-id=&quot;123&quot; data-aid=&quot;456&quot; @click=&quot;show()&quot;&gt; 这是一个div&lt;/div&gt; 13.键盘事件 可以用事件对象获取按的那个键盘 14.双向数据绑定 * 12345678input type=&quot;text&quot; v-model checkbox radio v-modelselect 值 15.生命周期函数 mounted * 123456789101112131415161718192021222324252627 new Vue(&#123; el:&apos;#box&apos;, data:&#123; msg:&apos;welcome vue2.0&apos; &#125;, methods:&#123; update:function()&#123; this.msg=&apos;大家好111&apos;; &#125;,add:function()&#123; &#125; &#125;,mounted:function()&#123; /*实例创建完成并且模板编译完成 加载的时候默认触发的方法*/ console.log(&apos;111111111111&apos;); this.update(); &#125;&#125;);componentDidMount react 16.组件是怎么理解的？ 定义注册组件的几种方式： 必须记住 1.定义组件 1234567891011121314var Header=&#123; template:&apos;&lt;h2&gt;这是一个头部组件&lt;/h2&gt;&apos;, /*模板里面必须有根元素*/ data:function()&#123; return:&#123; msg:&apos;xxx&apos; &#125; &#125;, methods:&#123; &#125; &#125; 2.注册组件 Vue.component(&apos;v-header&apos;,Header); 1234561.定义组件 注册组件放在一起 Vue.component(&apos;v-header&apos;,&#123; template:&apos;&lt;h2&gt;这是一个头部组件&lt;/h2&gt;&apos; &#125;); 1.定义组件 ************************最常用的方式 12345678910111213141516var Header=&#123; template:&apos;&lt;h2&gt;这是一个头部组件&lt;/h2&gt;&apos; &#125; 2.注册组件 var vm=new Vue(&#123; el:&apos;#box&apos;, data:&#123; name:&apos;zhangsan&apos; &#125;, components:&#123; /*2.注册组件*/ &apos;v-header&apos;:Header &#125; &#125;); 1.定义组件 注册组件放在一起 12345678910111213141516 var vm=new Vue(&#123; el:&apos;#box&apos;, data:&#123; name:&apos;zhangsan&apos; &#125;, components:&#123; /*2.注册组件*/ &apos;v-header&apos;:&#123; template:&apos;&lt;h2&gt;这是一个头部组件&lt;/h2&gt;&apos; &#125; &#125;props:[&apos;name&apos;,&apos;a&apos;]&#125;); 17.父子组件的通信 1.父组件给子组件传值： { 1.子组件定义props接收父亲组件传过来的值 props:[&apos;name&apos;,&apos;a&apos;] 2.父组件调用子组件的时候给定义的属性传值&lt;v-header :name=&quot;name&quot; :a=&quot;age&quot;&gt;&lt;/v-header&gt; } 2.子组件给父组件传值： { 1.子组件 this.$emit(&apos;parent&apos;,this.name) 子组件向父组件广播数据 2.父组件 调用子组件的时候 监听广播准备触发方法 &lt;v-nav @parent=&quot;getChildData&quot;&gt;&lt;/v-nav&gt; v-nav是父亲组件的子组件 3.父组件 getChildData:function(data){ /*子组件广播数据触发的方法*/ //alert(data); this.msg=data; } } 3.兄弟组件的传值 1.实例化vue var Event=new Vue(); 2.传值的话广播 A给B传值 A里面广播。 Event.$emit(&apos;to-b&apos;,数据) 3.A给B传值 A里面广播 B接收数据 注意：接收事件要注册到生命周期函数 mounted Event.$on(&apos;to-b&apos;,function(data){}) 4.父组件主动获取子组件的数据和方法 * 1.父组件调用子组件的时候定义有个 ref &lt;v-nav ref=&quot;myNav&quot;&gt;&lt;/v-nav&gt; 2.this.$refs.myNav.子组件数据 this.$refs.myNav.子组件方法 5..子组件主动获取父组件的数据和方法 * this.$parent.父组件的数据 this.$parent.父组件的方法 18.动画 div 或者路由显示 隐藏的时候会触发 &lt;button @click=&quot;flag=!flag&quot;&gt;点击显示隐藏&lt;/button&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div class=&quot;box&quot; v-if=&quot;flag&quot;&gt; 这是一个div &lt;/div&gt; &lt;/transition&gt; .fade-enter-active{ 帧动画 } .fade-leave-active{ 帧动画 } key：唯一 transition transition-group &lt;transition-group enter-active-class=&quot;animated zoomInLeft&quot; leave-active-class=&quot;animated zoomOutRight&quot;&gt; &lt;p v-show=&quot;show&quot; :key=&quot;1&quot;&gt;这是一个p标签&lt;/p&gt; &lt;p v-show=&quot;show&quot; :key=&quot;2&quot;&gt;这是一个p标签&lt;/p&gt; &lt;/transition-group&gt; 19.路由 //https://router.vuejs.org/zh-cn/ 1.安装vue-router npm install vue-router --save 2.引入vue-router import VueRouter from &apos;vue-router&apos; Vue.use(VueRouter) 3.创建组件，引入组件 4.配置路由 const routes = [ { path: &apos;/home&apos;, component: Home }, { path: &apos;/news&apos;, component: News } ] 5.实例化VueRouter const router = new VueRouter({ routes // （缩写）相当于 routes: routes }) 6.挂载到vue实例上面 new Vue({ el: &apos;#app&apos;, router, render: h =&gt; h(App) }) 7. App.vue一定注意配置 组件显示的视图 &lt;router-view&gt;&lt;/router-view&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/news&quot;&gt;新闻&lt;/router-link&gt; 路由嵌套 https://router.vuejs.org/zh-cn/essentials/nested-routes.html 12345678 &#123; path:&apos;/home&apos;, component:Home, children:[ /*定义Home路由的子路由*/ &#123;&apos;path&apos;:&apos;welcome&apos;,component:Welcome&#125;, &#123;&apos;path&apos;:&apos;homeinfo&apos;,component:HomeInfo&#125; ]&#125; 注意：父组件的视图里面要加入&lt;router-view&gt;&lt;/router-view&gt; Mint-UI移动端的组件库 http://mint-ui.github.io/#!/zh-cn Element UI http://element.eleme.io/#/zh-CN Mint-UI 安装使用 1.安装mint-ui npm install mint-ui -S / cnpm install mint-ui -S -S表示--save 2.引入mint-ui import MintUI from &apos;mint-ui&apos; import &apos;mint-ui/lib/style.css&apos; Vue.use(MintUI) 3.注意配置css-loader style-loader { test: /\\.css$/, use: [ { loader: &quot;style-loader&quot; }, { loader: &quot;css-loader&quot; } ] } 4.看文档使用。 https://github.com/ElemeFE/mint-ui 在 mintUi的组建上面出发方法 @click.native=”” vue路由js跳转 http://blog.csdn.net/sinat_17775997/article/details/68941091 this.$router.push({path: &apos;/login?url=&apos; + this.$route.path}); 首页： this.$router.push({path: &apos;/home&apos;});","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue基础整理","slug":"vue基础","date":"2016-05-11T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/05/11/vue基础/","link":"","permalink":"http://yoursite.com/2016/05/11/vue基础/","excerpt":"","text":"Vue基础整理 1、先看一个经典的例子&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot; v-on:click=&quot;fn1&quot; &gt;{{message}}&lt;/div&gt; &lt;script&gt; var app = new Vue({ el:&quot;#app&quot;, data:{ message: &apos;Hello Vue.js!&apos; }, methods:{ fn1: function(){ this.message = &apos;hello world&apos; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 运行上面的代码 页面上就会输出 “Hello Vue.js! “ 几个字，点击文字会变成”hello world” 1-1我们来理解一下vue的执行机制1234567891011121314&lt;div id=&quot;app&quot; v-on:click=&quot;fn1&quot; &gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:&quot;#app&quot;, //可以用id(#)、类(.)、标签(div) data:&#123; message: &apos;Hello Vue.js!&apos; &#125;, methods:&#123; fn1: function()&#123; this.message = &apos;hello world&apos; &#125; &#125;&#125;)&lt;/script&gt; 上面的代中，用new关键字实例化了一个Vue对象并传递了一个参数（对象）这个对象主要包括3个重要的方法(el,data,methods)el选择要渲染的元素，el:&quot;#app&quot; el:&quot;.app&quot; el:&quot;div&quot; 这些都是支持的data 是一个对象，里面存放数据（或者说变量）,他可以直接显示在页面上，可以在methods中被调用、修改。methods 这里面是一些方法的集合，把所有的方法都定义在mehtods中.，再通过v-on:click=&quot;fn1&quot;的方式调用mehtods中的fn1方法。 总结一下 1/首先得有一个标签（展示数据） 如: &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;2/其次得实例化一个vue对象 new Vue()3/在传入的对象中 3-1选择元素el:&quot;#app&quot; 3-2定义数据 123data:&#123; message: &apos;Hello Vue.js!&apos;&#125; 3-3定义方法 12345methods:&#123; fn1: function()&#123; this.message = &apos;hello world&apos; &#125;&#125; 1-2、数据绑定 &lt;!-- src 是 HTML的属性，{{}} 是 ng 的表达式, 表达式可用于很多地方，包含属性，所以直 接 src=&quot;{{vm.url}}&quot; 其实就是使用Vue的表达式给属性赋值，这种做法的缺点是当第一 次加载模板的时候浏览器会去请求 “{{vm.url}}” 的地址，当Vue编译模板后把 {{vm.url}} 替换成对应的URL后会再次请求真实的地址，所以为了避免第一次无效的 请求，Vue 自带了v-bind:src 指令，其实和v-bind:href的原理类似。 --&gt; 1.v-bind:id=&quot;id&quot;绑定id2.v-bind:title:&quot;msg“绑定title3.v-bind:src:&quot;url&quot;绑定src4.v-text:&quot;msg&quot;绑定文本简写：v-on:click------@clickv-bind:src------:src 1-3、事件绑定在vue中给一个元素绑定事件可以用 v-on:+事件名称（click、mouseover、mouseout、keyup、keydown 等），v-on:这种写法有些繁琐，v-on:可以用 @符代替 123&lt;div v-on:click=&quot;fn1&quot; &gt;&lt;/div&gt;&lt;div @click=&quot;fn1&quot; &gt;&lt;/div&gt;//以上两种绑定事件的方式是等价的 1-4、vue中event事件对象现在比如有这样一个需求，点击按钮要获取鼠标相对于浏览器的x和y坐标，原生js中只需要给点击方法传一个event对象，通过event对象来获取相应的值，vue中也提供了一个类似的方法 $event，vue多一个$符号。ev.cancelBubble = true阻止事件冒泡12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;app&quot; @click=&quot;fn1($event)&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/button&gt; //这里的fn1方法传递了一个$event参数,和原生event类似 &lt;script&gt; var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; message: &apos;点我&apos; &#125;, methods:&#123; fn1: function(ev)&#123; console.log(ev.clientX +&quot;:&quot;+ev.clientY ) //在控制台中查看x 和y坐标的值 &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1-5、vue中的keyCode在日常开发中，最常见的一个小需求（回车提交），当用户按了回车键就提交用户填写的数据，在原生js中还是要依靠event事件对象，通过event来获取keyCode，记住keyCode不是一件容易的事所以 Vue 为最常用的按键提供了别名，目前vue提供了下面这样键盘别名：12345678910.enter 回车键.tab tab切换.delete (捕获 “删除” 和 “退格” 键).esc esc键.space 空格键.up 键盘上键.down 键盘下键.left 键盘左键.right 键盘右键 1-6、vue中的表达式123&#123;&#123;number*20&#125;&#125; &#123;&#123;ok?&apos;111&apos;:&apos;222&apos;&#125;&#125;&#123;&#123;message.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125; 1-7、vue中的计算属性12345computed:&#123; a:function()&#123; retrurn this.msg+&quot;这是计算后的属性&quot; &#125;&#125;//写在methods的同级 使用计算属性和使用data绑定的值一样，用到的data里面绑定的值变化，他就会变化 1-8、vue中的$watch（watch） 监听数据变化 1.第一种写法 12345 vm.$watch(&apos;name&apos;,function(newValue,oldValue)&#123; //name是state里面的数据 //newValue是state变化后的新值 //oldValue是state变化之前的值&#125;) 2.第二种写法 12345watch:&#123; msg:function(newVal,oldVal)&#123; console.log(newVal+&apos;--&apos;+oldVal); &#125; &#125; 1-9、vue中的v-bind:class 可以通过布尔值来控制class 1&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; &apos;class-a&apos;: isA, &apos;class-b&apos;: isB &#125;&quot;&gt; 第一个元素加red的class 123list:[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]&lt;li v-for=&quot;(item,key) in list&quot; :class=&#123;&quot;red&quot;:key==0&#125;&gt;&#123;&#123;item&#125;&lt;/li&gt; 可以把一个数组传给v-bind:class，以应用一个class列表 12345678910&lt;div id=&quot;app&quot;&gt; &lt;label v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;测试&lt;/label&gt;&lt;/div&gt; var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; activeClass:&apos;active&apos;, errorClass:&apos;text-danger&apos; &#125; &#125;) 也可以使用三元表达式 1&lt;label v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;测试&lt;/label&gt; 始终添加一个和判断添加一个 1&lt;label v-bind:class=&quot;[&#123;active:isActive&#125;, errorClass]&quot;&gt;测试&lt;/label&gt; 可以绑定v-style 123456789101112 &lt;div id=&quot;app&quot;&gt; &lt;label v-bind:style=&quot;classObj&quot;&gt;测试&lt;/label&gt;&lt;/div&gt; var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; classObj: &#123; color: &apos;red&apos;, fontSize: &apos;30px&apos; &#125; &#125; &#125;) 1-10、vue中的数据请求插件vue-resource axios 1-11、vue中的双向绑定数据12345678input type=&quot;text&quot; v-model checkbox radio v-modelselect 值","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"React知识点小结","slug":"react","date":"2016-04-23T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/04/23/react/","link":"","permalink":"http://yoursite.com/2016/04/23/react/","excerpt":"","text":"1.react 和jq的区别？reactjs 是个mvc的组件化框架,jquery 只是个函数库。 2.为什么要用react 写项目？单页面应用 运行速度快 3.React 语法基于jsx 、 javascript xml （nodejs里面的模板ejs）jsx怎么理解？ javascript xml 混合写 ReactDOM.render( &lt;div&gt; &lt;h2&gt;你和React&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;列表1&lt;/li&gt; &lt;li&gt;列表1&lt;/li&gt; {/**/} &lt;li&gt;列表1&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; , document.getElementById(‘box’) ) 4. 模板里面渲染数据 {}5.定义数据es5 getInitialState:function(){ return{ msg:&apos;这是InitialState里面的数据&apos;, name:&apos;张三&apos;, list:&apos;&apos; } } 用这里的数据： this.state.数据名称 es6 constructor(props){ super(props); this.state={ msg:&apos;这是Life的msg&apos;, name:&apos;张三&apos;, list:&apos;&apos; } } 用这里的数据：this.state.数据名称 6.定义模板render(){ return( &lt;div&gt; &lt;h2&gt;这是一个内容组件-{this.state.msg}--{this.state.name}&lt;/h2&gt; &lt;/div&gt; ) } 6.定义组件es5 var Header=React.createClass({ getInitialState:function(){ return{ msg:&apos;这是InitialState里面的数据&apos;, name:&apos;张三&apos;, list:&apos;&apos; } }, render(){ return ( &lt;div&gt;&lt;/div&gt; ) } }) es6 class Header extends React.Component{ constructor(props){ super(props); //数据 this.state={ msg:&apos;这是一个头部组件&apos; } this.run=this.run.bind(this); } run(){ } render(){ return ( &lt;div&gt;&lt;/div&gt; ) } } 暴露: export default Header; 其他地方引入： import Header from &apos;./Header.js&apos;; //引入 js 7.模板里面执行方式onClick 注意大小写 注意不要写引号 不要写() onClick={this.run} onChange 传值： onClick={this.run.bind(this,&apos;传递的数据&apos;)} 8.获取数据 以及更改数据获取 this.state.数据 更改 this.setState({ msg:&apos;更改后的数据&apos; }) 9.input 框 onChange事件会传递一个事件对象&lt;input onChange={this.方法} /&gt; console.log(e); 方法(){ e.target.value } 10.ref 获取dom节点给元素加ref属性 比如： &lt;div ref=&apos;home&apos;&gt;&lt;/div&gt; this.refs.home 获取dom节点 11. 给模板里面的元素加属性注意： className 设置class htmlFor 设置for style=&quot;对象&quot; &lt;div&gt; &lt;label htmlFor=&quot;user&quot;&gt;用户名： &lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;user&quot; placeholder=&quot;用户名&quot; /&gt; &lt;/div&gt; 其他的以前怎么写还是怎么写 id 12.父子组件传值1.父组件给子组件传值，子组件获取父组件的数据和方法 1.父组件 调用子组件的时候传值 &lt;Header msg=&apos;这是一个数据&apos; h={this} /&gt; 2.子组件获取父亲组件的数据 this.props.msg 2.子组件给父组件传值 ，父组件获取子组件的数据和方法 1.父组件调用子组件的时候定义ref &lt;Header ref=&apos;header&apos; /&gt; 2.this.refs.header拿到了子组件的对象。可以获取子组件的数据和方法 13.父子给组件传值的时候 propTypes defaultProps子组件里面通过 propTypes 可以验证父组件传递数据的合法性 defaultProps 父组件不给子组件传值的时候的默认值 Header.propTypes = { text: PropTypes.string /*指定 text是字符串类型*/ }; //不传值的时候 给props一个默认值 Header.defaultProps = { username: &apos;张三&apos; }; 14.生命周期函数生命周期函数： 组件加载之前 加载完成 更新数据 销毁组件触发的一系列的方法就是生命周期函数 componentWillMount componentDidMount https://facebook.github.io/react/docs/react-component.html 15.axios请求数据https://github.com/mzabriskie/axios 1.安装 2.引入 3.使用 //1.cnpm install axios --save //2.import axios from &apos;axios&apos;; //3.看官方文档使用 16.创建单文件组件https://facebook.github.io/react/docs/installation.html 1.安装脚手架 （ 项目生成工具） 只需要安装一次 npm install -g create-react-app / cnpm install -g create-react-app 2.创建项目 （可以创建） create-react-app 项目名称 cd 项目名称 npm start 运行项目 例如: create-react-app reactdemo01 cd reactdemo01 npm start 执行项目 3.运行 打开项目 npm start 4.正式打包 npm run build 17.路由配置 坑 （老版本）1.安装react-router 注意要指定版本安装 npm info react-router 查看路由的版本 cnpm install react-router@2.8.1 老版本的稳定版本 2.引入import { Router, Route, Link } from &apos;react-router&apos; (index.js App.js) 3.定义组件 首页 Home组件 新闻 News组件 4.配置路由 （ index.js） / 加载APP组件 /home 加载Home组件 /news 加载News组件 ReactDOM.render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;home&quot; component={Home} /&gt; &lt;Route path=&quot;news&quot; component={Inbox}&gt; &lt;/Route&gt; &lt;Route path=&quot;newscontent/:aid&quot; component={NewsContent}&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt; ), document.body) 5.配置 加载的组件 的显示的地方 （App.js） {this.props.children} 6.页面跳转 （组件的跳转） (任何的组件里面都可以写) &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/inbox&quot;&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; 7.Link动态传值 &lt;li&gt;&lt;Link to={&apos;/newscontent/&apos;+aid}&gt;新闻详情&lt;/Link&gt;&lt;/li&gt; &lt;Link to={{pathname:'newscontent/'+this.state.aid,query:{name:'zhangsan'}}}&gt;跳转新闻详情&lt;/Link&gt; 8.获取动态传值 {this.props.params.aid} 18.模板上面解析htmlhttps://facebook.github.io/react/docs/dom-elements.html function createMarkup() { return {__html: &apos;&lt;h2&gt;这是一个h2&lt;/h2&gt;&apos;}; } render(){ return ( &lt;div&gt; &lt;div dangerouslySetInnerHTML={this.createMarkup()} /&gt;; &lt;/div&gt; ) } 19.父子路由、路由的嵌套嵌套路由 1.父路由下面配置子路由 &lt;Route path=&quot;add&quot; component={NewsAdd} /&gt; &lt;Route path=&quot;list&quot; component={NewsList} /&gt; &lt;/Route&gt; 2.父组件里面的模板上面加上 {this.props.children} 来显示子路由 */ import Home from ‘./components/Home.js’; import Welcome from ‘./components/Welcome.js’; import News from ‘./components/News.js’; import NewsList from ‘./components/NewsList.js’; import NewsAdd from ‘./components/NewsAdd.js’; ReactDOM.render( &lt;Router history={browserHistory}&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;IndexRedirect to=&quot;/home/welcome&quot; /&gt; &lt;Route path=&quot;home&quot; component={Home}&gt; &lt;IndexRoute component={Welcome}/&gt; &lt;Route path=&quot;welcome&quot; component={Welcome} /&gt; &lt;/Route&gt; &lt;Route path=&quot;news&quot; component={News}&gt; &lt;Route path=&quot;add&quot; component={NewsAdd} /&gt; &lt;Route path=&quot;list&quot; component={NewsList} /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;, 点击加class &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex={true} &gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/news&quot; activeClassName=&quot;active&quot; &gt;新闻&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; onlyActiveOnIndex={true} 如果加上这个数据 路由和设置的路由完全相等的情况选中 20.js跳转路由。browserHistory.push(&apos;home&apos;); 21.swiper的使用1.cnpm install swiper --save 2、import Swiper from &apos;swiper&apos;; 3.引入swiper.css 4.自己改变元素的高度 5.componentDidMount实例化Swiper componentDidMount(){ //DOM操作 var mySwiper = new Swiper(&apos;.swiper-container&apos;, { autoplay: 5000,//可选选项，自动滑动 }) } 22.ant desigin react的UI框架官网https://ant.design/index-cn 1.安装 cnpm install antd --save 2.引入 import { Button } from &apos;antd&apos;; 3.引入css 1.新建一个自己的css 2.在自己的css中引入 antd的css @import &apos;~antd/dist/antd.css&apos;; 4.看文档使用 报错怎么办？ 提取里面的antd.css ,自己引入 23.导航选中。&lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/home&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex={true} &gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/news&quot; activeClassName=&quot;active&quot; &gt;新闻&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; onlyActiveOnIndex={true} 如果加上这个数据 路由和设置的路由完全相等的情况选中","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"73条日常Linux shell命令汇总","slug":"73条日常Linux-shell命令汇总","date":"2016-04-17T01:32:41.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/04/17/73条日常Linux-shell命令汇总/","link":"","permalink":"http://yoursite.com/2016/04/17/73条日常Linux-shell命令汇总/","excerpt":"检查远程端口是否对bash开放：","text":"检查远程端口是否对bash开放： echo &gt;/dev/tcp/8.8.8.8/53 &amp;&amp; echo &quot;open&quot; 让进程转入后台：Ctrl + z 将进程转到前台：fg 产生随机的十六进制数，其中n是字符数：openssl rand -hex n 在当前shell里执行一个文件里的命令：source /home/user/file.name 截取前5个字符：${variable:0:5} SSH debug 模式:ssh -vvv user@ip_address SSH with pem key:ssh user@ip_address -i key.pem 用wget抓取完整的网站目录结构，存放到本地目录中：wget -r --no-parent --reject &quot;index.html*&quot; http://hostname/ -P /home/user/dirs 一次创建多个目录：mkdir -p /home/user/{test,test1,test2} 列出包括子进程的进程树：ps axwef 创建 war 文件:jar -cvf name.war file 测试硬盘写入速度：dd if=/dev/zero of=/tmp/output.img bs=8k count=256k; rm -rf /tmp/output.img 测试硬盘读取速度：hdparm -Tt /dev/sda 获取文本的md5 hash：echo -n &quot;text&quot; | md5sum 检查xml格式：xmllint --noout file.xml 将tar.gz提取到新目录里：tar zxvf package.tar.gz -C new_dir 使用curl获取HTTP头信息：curl -I http://www.example.com 修改文件或目录的时间戳(YYMMDDhhmm):touch -t 0712250000 file 用wget命令执行ftp下载：wget -m ftp://username:password@hostname 生成随机密码(例子里是16个字符长):LANG=c &lt; /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-16};echo; 快速备份一个文件：cp some_file_name{,.bkp} 访问Windows共享目录：smbclient -U &quot;DOMAIN\\user&quot; //dc.domain.com/share/test/dir 执行历史记录里的命令(这里是第100行):!100 解压:unzip package_name.zip -d dir_name 输入多行文字(CTRL + d 退出):cat &gt; test.txt 创建空文件或清空一个现有文件：\\&gt; test.txt 与Ubuntu NTP server同步时间：ntpdate ntp.ubuntu.com 用netstat显示所有tcp4监听端口：netstat -lnt4 | awk &apos;{print $4}&apos; | cut -f2 -d: | grep -o &apos;[0-9]*&apos; qcow2镜像文件转换：qemu-img convert -f qcow2 -O raw precise-server-cloudimg-amd64-disk1.img \\precise-server-cloudimg-amd64-disk1.raw 重复运行文件，显示其输出（缺省是2秒一次）：watch ps -ef 所有用户列表：getent passwd Mount root in read/write mode:mount -o remount,rw / 挂载一个目录（这是不能使用链接的情况）:mount --bind /source /destination 动态更新DNS server:nsupdate &lt; &lt;EOF update add $HOST 86400 A $IP send EOF 递归grep所有目录：grep -r &quot;some_text&quot; /path/to/dir 列出前10个最大的文件：lsof / | awk &apos;{ if($7 &gt; 1048576) print $7/1048576 &quot;MB &quot;$9 }&apos; | sort -n -u | tail 显示剩余内存(MB):free -m | grep cache | awk &apos;/[0-9]/{ print $4&quot; MB&quot; }&apos; 打开Vim并跳到文件末：vim + some_file_name Git 克隆指定分支(master):git clone git@github.com:name/app.git -b master Git 切换到其它分支(develop):git checkout develop Git 删除分支(myfeature):git branch -d myfeature Git 删除远程分支git push origin :branchName Git 将新分支推送到远程服务器：git push -u origin mynewfeature 打印历史记录中最后一次cat命令：!cat:p 运行历史记录里最后一次cat命令：!cat 找出/home/user下所有空子目录:find /home/user -maxdepth 1 -type d -empty 获取test.txt文件中第50-60行内容：&lt; test.txt sed -n &apos;50,60p&apos; 运行最后一个命令(如果最后一个命令是mkdir /root/test, 下面将会运行: sudo mkdir /root/test)：sudo !! 创建临时RAM文件系统 – ramdisk (先创建/tmpram目录):mount -t tmpfs tmpfs /tmpram -o size=512m Grep whole words:grep -w &quot;name&quot; test.txt 在需要提升权限的情况下往一个文件里追加文本：echo &quot;some text&quot; | sudo tee -a /path/file 列出所有kill signal参数:kill -l 在bash历史记录里禁止记录最后一次会话：kill -9 $$ 扫描网络寻找开放的端口：nmap -p 8081 172.20.0.0/16 设置git email:git config --global user.email &quot;me@example.com&quot; To sync with master if you have unpublished commits:git pull --rebase origin master 将所有文件名中含有”txt”的文件移入/home/user目录:find -iname &quot;*txt*&quot; -exec mv -v {} /home/user \\; 将文件按行并列显示：paste test.txt test1.txt shell里的进度条:pv data.log 使用netcat将数据发送到Graphite server:echo &quot;hosts.sampleHost 10 `date +%s`&quot; | nc 192.168.200.2 3000 将tabs转换成空格：expand test.txt &gt; test1.txt Skip bash history:&lt; space &gt;cmd 去之前的工作目录：cd - 拆分大体积的tar.gz文件(每个100MB)，然后合并回去：split –b 100m /path/to/large/archive /path/to/output/files cat files* &gt; archive 使用curl获取HTTP status code:curl -sL -w &quot;%{http_code}\\\\n&quot; www.example.com -o /dev/null 设置root密码，强化MySQL安全安装:/usr/bin/mysql_secure_installation 当Ctrl + c不好使时:Ctrl + \\ 获取文件owner:stat -c %U file.txt block设备列表：lsblk -f 找出文件名结尾有空格的文件：find . -type f -exec egrep -l &quot; +$&quot; {} \\; 找出文件名有tab缩进符的文件find . -type f -exec egrep -l $&apos;\\t&apos; {} \\; 用”=”打印出横线:全选复制放进笔记printf &apos;%100s\\n&apos; | tr &apos; &apos; =","categories":[{"name":"Back-end","slug":"Back-end","permalink":"http://yoursite.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"基于鸟哥linux私房菜整理的常用基本命令","slug":"基于鸟哥linux私房菜整理的常用基本命令","date":"2016-04-17T01:19:02.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2016/04/17/基于鸟哥linux私房菜整理的常用基本命令/","link":"","permalink":"http://yoursite.com/2016/04/17/基于鸟哥linux私房菜整理的常用基本命令/","excerpt":"1、显示日期的指令： date","text":"1、显示日期的指令： date 2、显示日历的指令：cal 3、简单好用的计算器：bc 怎么10/100会变成0呢？这是因为bc预设仅输出整数，如果要输出小数点下位数，那么就必须要执行 scale=number ，那个number就是小数点位数，例如： 4、重要的几个热键[Tab],[ctrl]-c, [ctrl]-d [Tab]按键—具有『命令补全』不『档案补齐』的功能 [Ctrl]-c按键—让当前的程序『停掉』 [Ctrl]-d按键—通常代表着：『键盘输入结束(End Of File, EOF 戒 End OfInput)』的意思；另外，他也可以用来取代exit 5、man 退出用q，man -f man 6、数据同步写入磁盘： sync 输入sync，那举在内存中尚未被更新的数据，就会被写入硬盘中；所以，这个挃令在系统关机戒重新启劢乀前， 径重要喔！最好多执行几次！ 7、惯用的关机指令：shutdown 此外，需要注意的是，时间参数请务必加入指令中，否则shutdown会自动跳到 run-level 1 (就是单人维护的登入情况)，这样就伤脑筋了！底下提供几个时间参数的例子吧： 重启，关机： reboot, halt,poweroff 8、切换执行等级： init Linux共有七种执行等级： –run level 0 :关机 –run level 3 :纯文本模式 –run level 5 :含有图形接口模式 –run level 6 :重新启动 使用init这个指令来切换各模式： 如果你想要关机的话，除了上述的shutdown -h now以及poweroff之外，你也可以使用如下的指令来关机： 9、改变文件的所属群组：chgrp 10、改变文件拥有者：chown 他还可以顸便直接修改群组的名称 11、改变文件的权限：chmod 权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。 –数字类型改变档案权限： –符号类型改变档案权限： 12、查看版本信息等 13、变换目录：cd 14、显示当前所在目录：pwd 15、建立新目录：mkdir 不建议常用-p这个选项，因为担心如果你打错字，那么目录名称就回变得乱七八糟的 16、删除『空』的目录：rmdir 17、档案与目录的显示：ls 18、复制档案或目录：cp 19、移除档案或目录：rm 20、移动档案与目录，或更名：mv 21、取得路径的文件名与目录名：basename，dirname 22、由第一行开始显示档案内容：cat 23、从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写） 24、显示的时候，顺道输出行号：nl 25、一页一页的显示档案内容：more 26、与 more 类似，但是比 more 更好的是，他可以往前翻页：less 27、只看头几行：head 28、只看尾几行：tail 29、以二进制的放置读取档案内容：od 30、修改档案时间或新建档案：touch 31、档案预设权限：umask 32、配置文件档案隐藏属性：chattr 33、显示档案隐藏属性：lsattr 34、观察文件类型：file 35、寻找【执行挡】：which 36、寻找特定档案：whereis 37、寻找特定档案：locate 38、寻找特定档案：find 39、压缩文件和读取压缩文件：gzip，zcat 40、压缩文件和读取压缩文件：bzip2，bzcat 41、压缩文件和读取压缩文件：tar 12: http://img.my.csdn.net/uploads/201303/22/1363936158_46941]: http://img.my.csdn.net/uploads/201303/22/1363936145_2758.png 58: http://img.my.csdn.net/uploads/201303/22/1363936923_33797]: http://img.my.csdn.net/uploads/201303/22/1363936910_4210.png","categories":[{"name":"Back-end","slug":"Back-end","permalink":"http://yoursite.com/categories/Back-end/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"vue加nodejs仿海底捞","slug":"vue加nodejs仿海底捞","date":"2016-04-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/04/13/vue加nodejs仿海底捞/","link":"","permalink":"http://yoursite.com/2016/04/13/vue加nodejs仿海底捞/","excerpt":"","text":"前言 最近一段时间一直在学习Vue2.0的相关知识，之前只是看过相关的视频教学，但是一直没有动手去实践自己的项目，这次决定用Vue2.0去模仿一个移动端App,看了很多自己用过的App,最后决定模仿做海底捞移动端App,写下这篇博客，记录实践中的心得体会 项目构建1.选用webpack、vue-cli脚手架来快速搭建我们的项目骨架。Vue创建项目命令： 12Vue init webpack hdlvue init webpack-simple hdl (没有语法检查) VUE components: 存放项目的主要组件 static:存放静态css js assets存放img Node model用于存放mongodb和静态地址和mongodb增删改查方法 public用于放后台js和css文件 router放路由器 view后台ejs 文件 项目目录 node后台目录 2.package依赖 12345678910111213&quot;dependencies&quot;: &#123; &quot;css-loader&quot;: &quot;^0.25.0&quot;, &quot;element-ui&quot;: &quot;^1.3.7&quot;, &quot;file-loader&quot;: &quot;^0.9.0&quot;, &quot;jquery&quot;: &quot;^3.2.1&quot;, &quot;mint-ui&quot;: &quot;^2.2.7&quot;, &quot;style-loader&quot;: &quot;^0.18.2&quot;, &quot;url-loader&quot;: &quot;^0.5.9&quot;, &quot;vue&quot;: &quot;^2.3.3&quot;, &quot;vue-resource&quot;: &quot;^1.3.4&quot;, &quot;vue-router&quot;: &quot;^2.7.0&quot;, &quot;vuex&quot;: &quot;^2.3.1&quot;&#125; npm i webpack配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107var path = require(&apos;path&apos;)var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &apos;./src/main.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: &apos;dist/&apos;, filename: &apos;build.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: &apos;vue-loader&apos;, options: &#123; loaders: &#123; // Since sass-loader (weirdly) has SCSS as its default parse mode, we map // the &quot;scss&quot; and &quot;sass&quot; values for the lang attribute to the right configs here. // other preprocessors should work out of the box, no loader config like this necessary. &apos;scss&apos;: &apos;vue-style-loader!css-loader!sass-loader&apos;, &apos;sass&apos;: &apos;vue-style-loader!css-loader!sass-loader?indentedSyntax&apos; &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/ &#125;, &#123; test: /\\.(png|jpg|gif|svg)$/, loader: &apos;file-loader&apos;, options: &#123; name: &apos;[name].[ext]?[hash]&apos; &#125; &#125;, &#123; test: /\\.json$/, loader: &apos;json-loader&apos; &#125;, &#123; test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;, &#123; test: /\\.(eot|svg|ttf|woff|woff2)(\\?\\S*)?$/, loader: &apos;file-loader&apos; &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?\\S*)?$/, loader: &apos;file-loader&apos;, query: &#123; name: &apos;[name].[ext]?[hash]&apos; &#125; &#125;, &#123; test: /.(jpg|png|gif|svg)$/, use: [&apos;url-loader?limit=8192&amp;name=./[name].[ext]&apos;] &#125;,/*解析图片*/ ] &#125;, resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, // &apos;assets&apos;: path.resolve(__dirname, &apos;../../src/assets&apos;) &apos;jquery&apos;:&apos;jquery&apos; &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;) ], devServer: &#123; historyApiFallback: true, noInfo: true &#125;, performance: &#123; hints: false &#125;, devtool: &apos;#eval-source-map&apos;&#125;if (process.env.NODE_ENV === &apos;production&apos;) &#123; module.exports.devtool = &apos;#source-map&apos; // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; NODE_ENV: &apos;&quot;production&quot;&apos; &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; 注意点 引入jq插件123456plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;) ], 这两个loader顺序不能反1&apos;style-loader!css-loader&apos; mui-ul必须配置字体loader 1234&#123; test: /\\.(eot|svg|ttf|woff|woff2)(\\?\\S*)?$/, loader: &apos;file-loader&apos; &#125;, main.js配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import Vue from &apos;vue&apos;;import App from &apos;./App.vue&apos;;import ElementUI from &apos;element-ui&apos;;//引入element-uiimport &apos;element-ui/lib/theme-default/index.css&apos;;//引入element.css样式import Vuex from &apos;vuex&apos;;//引入vueximport VueResource from &apos;vue-resource&apos;;//引入vueResourceimport VueRouter from &apos;vue-router&apos;;//引入vuerouterimport &apos;./components/static/css/reset.css&apos;;import &apos;./components/static/css/common.css&apos;;import &apos;./components/static/css/order.css&apos;;import &apos;./components/static/css/animate.css&apos;;import &apos;./components/static/css/cart.css&apos;;import &apos;./components/static/css/store.css&apos;;import &apos;./components/static/css/storedetail.css&apos;;import &apos;./components/static/css/ticket.css&apos;;import &apos;./components/static/css/adress.css&apos;;import &apos;./components/static/css/user.css&apos;;import MintUI from &apos;mint-ui&apos;import &apos;mint-ui/lib/style.css&apos;import $ from &apos;jquery&apos;;import &#123; InfiniteScroll &#125; from &apos;mint-ui&apos;; Vue.use(InfiniteScroll);Vue.use(VueRouter)//使用vuerouterVue.use(Vuex)//使用vuxVue.use(ElementUI)//使用elementUiVue.use(VueResource)//使用vueresonrce//创建组件引入组件import Home from &apos;./components/home.vue&apos;;import Goods from &apos;./components/goods.vue&apos;; import Store from &apos;./components/store.vue&apos;; import StoreDetail from &apos;./components/storedetail.vue&apos;; import Ticket from &apos;./components/ticket.vue&apos;; import Outsend from &apos;./components/order.vue&apos;; import User from &apos;./components/user.vue&apos;;//配置路由const routes=[ &#123;path:&quot;/home&quot;,component: Home&#125;, &#123;path:&quot;/&quot;,component: Home&#125;, &#123;path:&quot;/goods&quot;,component: Goods&#125;, &#123;path:&quot;/store&quot;,component: Store&#125;, &#123;path:&quot;/storeDetail&quot;,component: StoreDetail&#125;, &#123;path:&quot;/ticket&quot;,component: Ticket&#125;, &#123;path:&quot;/order&quot;,component: Outsend&#125;, &#123;path:&quot;/user&quot;,component: User&#125;, &#123;path:&quot;*&quot;,redirect: Home&#125;//重定向]//实例化vueRouterconst router= new VueRouter(&#123; routes//（缩写）相当于 routes: routes&#125;)//挂载到vue的实例上new Vue(&#123; router, el: &apos;#app&apos;, render: h =&gt; h(App)&#125;) 路由器配置好以后需要在app.js的template加上&lt;router-view&gt;&lt;/router-view&gt; 主页 flex布局 商品页面 弹出框用的mint-ui的messageBOX 数据结构 数据是从后台数据库vue-resource请求api接口拿到数据 加入购物车小球抛物线效果，使用css3动画大盒子嵌套小盒子，小盒子向左移动，父盒子向下移动实现的抛物线效果; 123456789101112131415161718192021222324var x=e.clientX; var y=e.clientY; var difX=x; /*获取小球距离左侧的距离*/ var difY=document.documentElement.clientHeight-y+20; var outer=document.createElement(&quot;div&quot;);//创建父盒子 outer.className=&quot;out&quot;; outer.style.top=(y-20)+&quot;px&quot;; outer.style.left=(x)+&quot;px&quot;;//设置父盒子的位置 var inner=document.createElement(&quot;div&quot;);//创建小盒子 inner.className=&quot;addcart&quot;; outer.appendChild(inner); document.body.appendChild(outer); var timer=setTimeout(function()&#123; outer.style.transform=&quot;translate(0,&quot;+difY+&quot;px)&quot;; //里层设置小黑子的translate inner.style.transform = &apos;translate(-&apos;+difX+&apos;px,0) rotate(720deg)&apos;; inner.style.zIndex=&apos;100&apos; clearTimeout(timer);//清除定时器 &#125;); var deleteTimer=setTimeout(function()&#123; document.body.removeChild(outer) &#125;,800); this.count=this.count+1; 购物车 用的是mint-ui的cart，结算点击以后会存入sessionStorage，跳转至付款页面，this.$router.go(-1)返回时在判断sessionStorage是否有值，有的话继续渲染到购物车里面，没有的话清空购物车； 用户填写地址页面 外送 从sessionStorage里面获取到数据 点击结算按钮是必须先填写地址和选择用餐人数不然会触发toast 信息填写完毕点击购买以后数据会传入mongodb用户数据表 外送地址添加界面 点击触发计数器，请求api接口服务器session保存用户名和验证码 点击确定在请求api接口，服务器接收用户输入验证码， 服务器从session获取用户信息和验证码，验证用户验证码是否正确在返回status 用餐人数选择弹窗框 用餐人数选择弹窗框，使用mint-ui的Picker和Button 自取选择弹窗框，使用mint-ui的Picker和Button，数据是从请求后台的api接口获取 自取界面 信息填写完毕以后会请求api接口加入用户后台订单数据库，状态为自取状态 添加验证码请求接口，防止用户频繁请求 门店订餐页面 通过从后台请求接口返回分页数据，使用下拉更新； 店铺详情页 &lt;router-link :to=&quot;{ path: &#39;/storeDetail&#39;, query: { id: item._id}}&quot;&gt;路由跳转传ip var id=this.$route.query.id;获取id请求api接口获取数据渲染页面 轮播图mint-ui swiper 订座页面确认以后会请求api接口把用户信息导入order表 小结子组件在props中创建一个属性，用来接受父组件传过来的数据。父组件中注册和引用子组件。在子组件变迁中添加子组件props中创建的属性。点击事件触发子组件show()方法时将数据一并赋值给改属性。父组件可以调用子组件中的方法。 Vue中transition过渡动画App很多地方会有点击后出现一个新的页面的操作，如果不做动画看起来会感觉差点什么，Vue中也提供了了过渡动画的API，官网教程：https://cn.vuejs.org/v2/guide/transitions.html。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"webstorm常用快捷键","slug":"webstorm使用总结","date":"2016-04-10T03:18:06.000Z","updated":"2018-03-22T11:04:04.000Z","comments":true,"path":"2016/04/10/webstorm使用总结/","link":"","permalink":"http://yoursite.com/2016/04/10/webstorm使用总结/","excerpt":"webstorm常用快捷键 查找/代替","text":"webstorm常用快捷键 查找/代替 ctrl+shift+N 通过文件名快速查找工程内的文件（必记） ctrl+shift+alt+N 通过一个字符快速查找位置（必记） ctrl+F 在文件内快速查找代码 F3 查找下一个 shift+F3 查找上一个 ctrl+R 文件内代码替换 ctrl+shift+R 指定目录内代码批量替换 ctrl+shift+F 指定目录内代码批量查找 ctrl+R 文件内代码替换 界面操作 ctrl+shift+A 快速查找并使用编辑器所有功能（必记） alt+[0-9] 快速拆合功能界面模块 ctrl+shift+F12 最大区域显示代码（会隐藏其他的功能界面模块） alt+shift+F 将当前文件加入收藏夹 ctrl+alt+s 打开配置窗口 ctrl+tab 切换代码选项卡（还要进行此选择，效率差些） ctrl+F4 关闭当前代码选项卡 代码编辑 ctrl+D 复制当前行 ctrl+W 选中单词 alt+Insert 新建一个文件或其他 ctrl+alt+L 格式化代码 shift+tab 减少（可以在代码中减少行缩进） tab 扩大缩进 ctrl+Y 删除一行 shift+enter 重新开始一行（无论光标在哪个位置） esc 进入代码编辑区域 alt+F1 查找代码在其他界面模块的位置，颇为有用 ctrl+G 到指定行的代码 ctrl+]/[ 光标到代码块的前面或后面 alt+up/down 上一个/下一个方法 建议配置版本控制快捷键 ctrl+C 提交代码 ctrl+p 向远程版本库推送更新 ctrl+G 到指定行的代码 常用 ctrl + shift + n: 打开工程中的文件 ctrl + j: 输出模板 ctrl + b: 跳到变量申明处 ctrl + alt + T: 围绕包裹代码(包括zencoding的Wrap with Abbreviation), - ctrl + []: 匹配 {}[] ctrl + F12: 可以显示当前文件的结构，快速跳转到目标函数 alt + left/right:标签切换 ctrl + r: 替换 ctrl + shift + r: 全局替换 ctrl + d: 行复制 ctrl + shift + ]/[: 选中块代码…. ctrl + / : 单行注释 ctrl + shift + / : 块注释 ctrl + shift + i : 显示当前class,function的详细信息 ctrl + p: 显示默认参数 ctrl + shift + v: 可以复制多个文本 shift + enter: 智能跳到下一行 ctrl + alt + enter: 在上一行添加空白行vb ctrl + k: svn 提交 ctrl + shift + u: 大小写 ctrl + ~ : 切换主题 ctrl + F11: 添加标签 ctrl + shift + 大键盘数字键, F11:添加空标签, shift+F11:显示标签列表，方便快捷跳转 ctrl + alt + F12: file path ctrl + alt + a: search keymap shift + F6: 重构标签名 Ctrl+delete 删除光标后面的单词 Ctrl+BackSpace 删除光标前面的单词 Ctrl+小键盘+/- 折叠/展开代码 Ctrl + Alt + V 快速引进一个变量 Ctrl+Alt + I 自动对齐格式 alt+j: 多选单个单词","categories":[{"name":"工欲善其事必先利其器","slug":"工欲善其事必先利其器","permalink":"http://yoursite.com/categories/工欲善其事必先利其器/"}],"tags":[{"name":"webstorm","slug":"webstorm","permalink":"http://yoursite.com/tags/webstorm/"}]},{"title":"web前端常用插件","slug":"web前端常用插件","date":"2016-03-19T04:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/03/19/web前端常用插件/","link":"","permalink":"http://yoursite.com/2016/03/19/web前端常用插件/","excerpt":"","text":"Web 前端常用插件目录 工具类 浏览器增强类 表单类 图片类 图标类 UI 框架 UI 组件类 用户体验增强 动画 SVG 测试 其他类 Bootstrap相关类 Vue.js 相关类 JS Plugins仓库 工具类 方便操作对象，数组等的工具库 underscore.js lo-dash 与underscore.js的api基本一致。与underscore比其优势是，效率高；可自定义构建 Sugar 在原生对象上增加一些工具方法 functional.js 提够了一些Curry的支持 bacon.js 函数式编程，cool streamjs 用流的方式来对数组，对象进行系列操作 数据类型 字符串 strman 字符串操作库。它为各种实用程序、格式选项和字符串转换，提供了超过 60 种实用的方法。 数字 BigDecimal.js 提高精度的数字操作 对象 Watch.js 监视对象或属性的变化 时间 moment datejs 正则 rewrap 正则工具库。相关插件regexp-frequent,rewrap-patch 异步流程控制 发布订阅 eventproxy 朴灵出品 Arbiter.js 详细 q Promise风格的 Async.js 加载器 little-loader JS 加载器。Webpack 不支持加载外部js，可用这个。 mock Mock.js 生成随机数据和mock Ajax 请求 jquery-mockjax mock ajax请求 浏览器探测 Bowser 探测具体浏览器和版本 ua-parser-js 探测具体浏览器和版本，操作系统，设备类型等 调试 vConsole 轻量、可拓展、针对手机网页的前端开发者调试面板插件。微信前端做。 console-polyfill 能放心的使用 console.log()之类的console方法 log 让控制台输出的log有样式 uri.js uri操作 Cookie 增删改cookie的工具库 store.js 对 localStorage 的封装。兼容 IE6+。 director 前端路由库 详细 JSDoc 根据javascript文件中注释的信息，生成API文档 详细 hotkeys 键盘事件的封装 MD5 用 MD5 的方式加密文件的库 Exif.js 读取 JPEG 图片的拍摄信息。可以通过拍摄信息中的 Orientation 来解决 ios 手机上传竖拍照片会逆时针旋转90度的问题。 浏览器增强类让一些旧浏览器变牛逼的库 Selectivizr 让IE 6-8一些的css3选择器 ieBetter 让ie6-8有高级浏览器的特性 ExplorerCanvas 让IE8-的浏览器支持canvas CSS3 Pie 让IE6-9支持border-radious,box-shadow,linear-gradient。 可以使用.htc文件（注意Mine type）或.js文件。在用Pie.js时，box-radious的元素有背景色时，不显示背景色。。。 formFive 让旧的浏览器支持HTML5表单的一些特性，如 placeholder,autofocus https://github.com/anselmh/object-fit 让浏览器支持object-fit这css规则 HTML5 Cross Browser Polyfills 一堆Polyfills flexibility 让旧的 IE 也支持 Flexbox 选择器增强 Lining.js 让浏览器实现类似::nth-line(), ::nth-last-line()的效果 CSS 兼容性 prefixfree 根据 caniuse.com 数据库自动补全 CSS 私有前缀 表单类 jquery-file-upload 上传文件组件 详细 zTree 文件树形视图控件 详细 Treed 树编辑器。感觉展示的感觉很像思维导图 FileAPI 对文件选择框内的文件的一些处理 表单验证 .Validate 详细 jQuery-Validation-Engine 表单元素美化 uniform 提供对下拉框，单，复选框，按钮等表单元素的美化 select2 多选下拉框 selectivity 和unfirom比较类似 DropKick 下拉框，单，多选。外观比uniform好 switchery ios7风格的开关组件 nouislider 用滚动条来设置/控制（音量等） range.css 美化input[type=range]元素的外观 Colorion 背景是渐变色的按钮。hover 时有动画效果。 图片类 holderjs 生成占位图片 lazyload imagesLoaded 选取的图片都加载好后执行调回 CSSgram 用CSS3的Filter实现Instagram滤镜的库 图标类 Icon Font汇总 SVG做的图标 svgicons iconic HYBICON 带交互效果。如 hover, click HTML字符实体图标 http://www.amp-what.com/ transformicons 图标点击时，会有一些变换效果。如，加号变成叉号 css3patterns css3 做的可平铺纹理。浏览器兼容性不好。 浏览图片 fancybox 弹出查看图片，视屏等等 demo yoxview 弹出查看图片，图片尺寸缩放很自然 图片墙 wookmark UI 框架 WeUI 由微信官方设计团队为微信 Web 开发量身设计。 Framework7 UI 组件类拖拽 dragula 支持Draggable，Dropable和Sortable。感觉比jqueryUI的轻量级，好用的样子 angular-dragula dragular 官方的 angular 版本 数据可视化(图表) Echarts 百度出品 D3.js 超灵活的做数据可视化的工具。 highcharts 功能强大。是收费的。 Plottable.JS 基于D3的一个图表库 flot 文档不给力 chartJs 中文文档 demo很漂亮，很清晰。比较轻量级。 ichartJs 中国的一个家伙搞的，感觉还不错。 时间选取组件 foundation-datepicker DatePicker 一个简单的日历 详细 full calendar 支持脱放的方式来改变待办事宜的时间 Simple Events Calendar 外观很喜欢。收费 5$ jQuery ui datepicker 经典，不是很好看 pickadate 轻量级，手机友好的，漂亮。但貌似只能在弹出层中显示，而没有下拉这种方式显示。 zebra-datepicker 可配置性很强。但貌似只能在弹出在右上方。。。 bootstrap-datepicker bootstrap风格。 dateRangePicker 选取时间段。bootstrap风格。该组件依赖Twitter Bootstrap, Moment.js和jQuery. 滚动无限加载 vue-recyclerview 高性能的滚动无限列表加载。为了提高性能，代码有重复利用 DOM。 自定义滚动条 perfect scrollbar 轻量级的滚动条。外观与mac上chrome的滚动条一样。 iscroll 在移动设备上用不错 加载(Loding)效果 CSS Spinners CSS做的 Loaders.css CSS做的 表格组件 jsGrid Data Grid。 详细 backgrid 基于Backbone.js的DataGrid excellentexport 把表格的内容生成excel。兼容 Firefox, Chrome, IE6+ datatables 表格可交互（对内容进行排序，删除等） handsontable 生成Excel外观的数据 JSpreadsheets 表格数据的组件库 jQuery Grid by gijgo.com 选取颜色 Spectrum 分享到SNS JiaThis 生成分享代码。 编辑器 ace 代码编辑器，可以用来做demo演示 ckeditor ueditor 百度做的 tinymce 对html内容进行实时的编辑 summernote 在移动设备上用不错 通知组件 notie.js HTML5播放器 jwplayer 被大量网站使用 html5media 简单的h5player，轻量级 jplayer 功能强大，可换肤 展示 Impress.js 各种旋转，和奇特的体验 fullPage 全屏显示。用滚轮来翻页 详细 zepto.fullpage 专注于移动端的fullPage.js，依赖Zepto pagePiling 和fullPage类似 turn.js 做一本书，带漂亮的翻页的效果 timelinejs 用时间轴方式展示信息。 coverflow 苹果上唱片封面的效果（Apple Cover Flow UI effect）。 幻灯 SuperSlide/TouchSlide 国产库！兼容IE6，焦点图/幻灯片/Tab标签切换/图片滚动/无缝滚动等常见效果，支持移动端 slidesjs 挺好用的，只是那幻灯导航的CSS都要自己写，呵呵 详细 iSlider 无任何插件依赖的手机平台javascript滑动组件 详细 bgstretcher 全屏幻灯，会随着页面大小的变化而变化。 Swiper 开源、免费、强大的移动端触摸滑动插件 Swiper中文网 coin-slider 兼容IE6，不过其切换方式是一块块的。不能配置切换方式 wowslider 幻灯切换时各种很炫的效果。收费。 cycle2 普通的幻灯，竟然不支持垂直滚动 jcarousel 普通的幻灯，不兼容IE6 reveal 3d滚动。做ppt相当不错 nodePPT 国人做的，做ppt也相当不错。有些方面比 reveal做的还好。但生成导出的html有些问题 roundabout 3d切换，看的后面图片的边 SmartPhoto 专为移动设备打造的响应式图像查看器，它易于使用，并支持手势触摸操作，例如捏合或者滑动。同时，它还具备对初学者友好的大量实用的事件处理器，以及用户自定义选项。 弹出框 Magnific-Popup 兼容PC，Mobile。还不错，有5k+的star layer 国人开发的，兼容ie6+。不喜欢其调用方式。 二维码 jquery-qrcode 生成二维码图片。基于jQuery，很好用。 动画效果 animate.css 预设了很多动画。 transformjs Made css3 transform super easy。腾讯出品。 mixitup 用漂亮的动画效果来完成排序和筛选 jQuery.Marquee 跑马灯效果 quickflip 卡片翻转效果 卡片翻转效果2 兼容性可以。写的比较简单：1，只支持x方向翻转 2,类名都是规定好的 3，只能被调用一次。 需要改写一下。我的改进版见这里 TheaterJS 模拟两个人在屏幕上对话 midnight.js 文字颜色随着背景变，屌炸了 color-animation jquery的颜色渐变动画插件。jquery的动画不支持颜色值的变化。改库提供了这个支持。 transit 对元素进行css的变换 tagcanvas 3D标签云效果 详细 iconate 图片切换动画 Snap.js 左/右侧导航的出现效果 CSS shake 抖动动画 ClickSpark.js 点击后的一些酷炫的效果 视觉差插件 ScrollMagic 对 superscrollorama 的重写。 scrollorama 比较简单 superscrollorama 能做的效果更多，但要用第三方Tween的库，使用起来比较复杂。 scrolldeck flash swfobj 能够自动检测PC、Mac机器上各种主流浏览器对Flash插件的支持情况。它使得插入Flash媒体资源尽量简捷、安全。而且它是非常符合搜索引擎优化的原则的。此外，它能够避免您的HTML、XHTML中出现object、embed等非标准标签，从而符合更加标准。 详细 抽奖 wScratchPad 刮刮卡刮奖效果 jqueryrotate 旋转插件。可以用来做转盘抽奖效果 用户体验增强类 Intro.js 用来介绍网站的功能很不错。也可以做新手引导。 blockUI Lolding组件。 simple-hint 提示信息。用css做的。兼容性IE 9+。 dotdotdot 文字溢出时，添加在文字末尾加省略号 jQuery-menu-aim 二级菜单的切换如Amazon主页上一样迅速 AnythingZoomer 放大镜功能 PRISM 代码语法高亮 please 按要求随机舒服的颜色 Awesomplete 输入的智能提示，自动补全 proTip 提示。感觉比 Bootstrap 的 tip 好 Hammerjs 手势库。封装了 Swipe, Tap, Pinch, Pan等手势 favico.js 动态改 favicon。牛逼是可以放视频~ 动画 velocity 提高Jquery动画的性能。以及颜色动画之类的新特性。 SVG Snap.svg 操作 SVG 的 JS 库。号称 SVG 的 jQuery。demo walkway 以动画的方式，渐渐地画出 SVG 的路径。 测试 Mocha Chai Should Snoion DeviceMock.js mock 设备。 其他类 ZeroClipboard 将内容复制到剪切板兼容主流浏览器的解决方案 详细 html2canvas html转化成canvas，可以用来做截图。详细 Ink 响应式html邮件框架 性能测试 抓取，解析RSS内容（不能跨域，所以后台要做代理，所谓的解析Rss其实就是解析xml） jFeed jRss 简单版的jFeed scriptcam 与摄像头交互 cylon.js 机器人框架，支持35个平台 Masonry 一个瀑布流框架 devices.css 移动设备边框的外观。做原型的时候用不错。 city 国家行政区划分数据。从国家统计局拿的。 城市数据 全栈JavaScript错误监控 提供监控报错的服务。 Bootstrap相关类 Bootbox.js 对bootstrap的弹出框做的一些封装 免费皮肤 AdminLTE Vue相关 手机 Mint UI Mobile UI elements for Vue.js。 vux vue-weui vue-resource The HTTP client for Vue.js, Ajax 数据交换 vue-router 官方提供的路由插件 PC Vue Admin element JS Plugins仓库 jQuery Cards 高质量的 jQuery 插件网站 jster node modules npmrank Sort npm packages by page rank YOU MIGHT NOT NEED JQUERY PLUGINS 不依赖 jQuery 的 js 插件。 awesome-nodejs Libraries.io 各种语言的库 OniUI 去哪儿网做的一套基于Avalon的框架","categories":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/categories/插件/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"弹性布局总结","slug":"flex","date":"2016-02-06T11:20:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/02/06/flex/","link":"","permalink":"http://yoursite.com/2016/02/06/flex/","excerpt":"","text":"以下6个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-items align-content 属性详解 flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 以下6个属性设置在项目上 order flex-grow flex-shrink flex-basis flex align-self 属性详解 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 图解flex布局","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"弹性布局","slug":"弹性布局","permalink":"http://yoursite.com/tags/弹性布局/"}]},{"title":"jQuery与原生JS的DOM操作对比","slug":"jQuery与原生JS的DOM操作对比","date":"2016-01-27T05:50:20.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/27/jQuery与原生JS的DOM操作对比/","link":"","permalink":"http://yoursite.com/2016/01/27/jQuery与原生JS的DOM操作对比/","excerpt":"1. 创建元素节点 原生JS创建元素节点: document.createElement(&quot;p&quot;); jQuery创建元素节点：$(&#39;&lt;p&gt;&lt;/p&gt;&#39;);","text":"1. 创建元素节点 原生JS创建元素节点: document.createElement(&quot;p&quot;); jQuery创建元素节点：$(&#39;&lt;p&gt;&lt;/p&gt;&#39;); 2. 创建并添加文本节点: 原生JS创建文本节点：document.createTextNode(&quot;Text Content&quot;); 通常创建文本节点和创建元素节点配合使用，比如： 123var textEl = document.createTextNode(\"Hello World.\");var pEl = document.createElement(\"p\");pEl.appendChild(textEl); jQuery创建并添加文本节点：var $p = $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 3. 复制节点 原生JS复制节点: var newEl = pEl.cloneNode(true); true和false的区别： true ：克隆整个&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;节点 false：只克隆&#39;&lt;p&gt;&lt;/p&gt;&#39;，不克隆文本&#39;Hello World.&#39; jQuery复制节点：$newEl = $(&#39;#pEl&#39;).clone(true); 注意：克隆节点要避免ID重复 4. 插入节点 原生JS向子节点列表的末尾添加新的子节点：El.appendChild(newNode); 原生JS在节点的已有子节点之前插入一个新的子节点：El.insertBefore(newNode, targetNode); 在jQuery中，插入节点的方法比原生JS多的多： $(&#39;#El&#39;).append(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素子节点列表结尾添加内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).appendTo(&#39;#El&#39;); 把匹配元素添加到目标元素子节点列表结尾 $(&#39;#El&#39;).prepend(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素子节点列表开头添加内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).prependTo(&#39;#El&#39;); 把匹配元素添加到目标元素子节点列表开头 $(&#39;#El&#39;).before(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素之前添加目标内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).insertBefore(&#39;#El&#39;); 把匹配元素添加到目标元素之前 $(&#39;#El&#39;).after(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 在匹配元素之后添加目标内容 $(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;).insertAfter(&#39;#El&#39;); 把匹配元素添加到目标元素之后 5. 删除节点 原生JS删除节点: El.parentNode.removeChild(El); jQuery删除节点:$(&#39;#El&#39;).remove(); 6. 替换节点 原生JS替换节点: El.repalceChild(newNode, oldNode);注意：oldNode必须是parentEl真实存在的一个子节点 jQuery替换节点:$(&#39;p&#39;).replaceWith(&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;); 7. 设置属性/获取属性 原生JS设置属性/获取属性: imgEl.setAttribute(&quot;title&quot;, &quot;logo&quot;); imgEl.getAttribute(&quot;title&quot;); checkboxEl.checked = true; checkboxEl.checked; jQuery设置属性/获取属性: -$(&quot;#logo&quot;).attr({&quot;title&quot;: &quot;logo&quot;}); $(&quot;#logo&quot;).attr(&quot;title&quot;); $(&quot;#checkbox&quot;).prop({&quot;checked&quot;: true}); $(&quot;#checkbox&quot;).prop(&quot;checked&quot;);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"JavaScript之捕捉模型与冒泡模型","slug":"JavaScript之捕捉模型与冒泡模型","date":"2016-01-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/27/JavaScript之捕捉模型与冒泡模型/","link":"","permalink":"http://yoursite.com/2016/01/27/JavaScript之捕捉模型与冒泡模型/","excerpt":"在w3c模型中 addEventListener支持第3个参数来声明事件的模型为冒泡还是捕捉，如果声明为false，则为冒泡方式","text":"在w3c模型中 addEventListener支持第3个参数来声明事件的模型为冒泡还是捕捉，如果声明为false，则为冒泡方式 123456window.onload = function ()&#123;//ev激发的过程自动为函数传一个参数 鼠标的一系列动作包装成对象自动传给函数 document.getElementById('par').addEventListener ('click',function (ev)&#123;alert(ev.pageX)&#125;,true); document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;); &#125; 捕捉模型与冒泡模型在IE下测试 123456window.onload = function ()&#123;//对于IE 当事件发生的瞬间 事件对象赋值给window.event属性 document.getElementById('par').attachEvent ('onclick',function (ev)&#123;alert(window.event)&#125;);//IE下不支持第三个参数 true document.getElementById('son').attachEvent ('onclick',function ()&#123;alert('son')&#125;); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"前端开发的一些实践规范","slug":"前端开发一些实践","date":"2016-01-23T08:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/23/前端开发一些实践/","link":"","permalink":"http://yoursite.com/2016/01/23/前端开发一些实践/","excerpt":"一、HTML实践 使用标准的HTML5简化的定义的方式 定义文档类型 &lt;!DOCTYPE html&gt; 定义页面的编码 &lt;meata charset=&quot;UTF-8&quot;&gt; 样式和页脚的引用，不需要写type类型，如link script 停止使用不标准的标签和属性，如mqrquee 不推荐在HTML标签中添加样式属性，如img标签中添加宽高 不要使用@import，此方式最大的缺点是引用css文件不能同时并行下载","text":"一、HTML实践 使用标准的HTML5简化的定义的方式 定义文档类型 &lt;!DOCTYPE html&gt; 定义页面的编码 &lt;meata charset=&quot;UTF-8&quot;&gt; 样式和页脚的引用，不需要写type类型，如link script 停止使用不标准的标签和属性，如mqrquee 不推荐在HTML标签中添加样式属性，如img标签中添加宽高 不要使用@import，此方式最大的缺点是引用css文件不能同时并行下载 增加JavaScript禁用的提示信息，最常用的方式是使用&lt;noscript&gt; 添加必要的meta标签 使用频率较高的语义化标签 p ul dl p em strong table site blockquote nav header footer article section aside hground 样式和结构的分离：把HTML中用于表达外观的部分从HTML中删除，并用css实现。如&lt;span&gt;|&lt;/span&gt;中的| 用css的伪类实现即可 如果图片作为页面内容的一部分，应该使用img标签，如果图片仅仅是装饰作用，应该使用背景图片方式 提高表单易用性的手段 使用label标签，并设置label标签的for属性 给输入控件设置合理的placehoder 如有必要，给输入控件设置tab顺序，tabindex用来设置输入控件的切换顺序 &lt;input type=&quot;text&quot; tabindex=&quot;2&quot;&gt; 使用HTML5中引入的表单控件url email date search 精简HTML代码 删除多余的容器 装饰性的元素使用css实现 避免使用table布局 二、CSS实践 推荐的css类的命名规则和元素的id命名规则相似，只是组成类名的关键字的连接符为中划线- .reder-content-title 为了避免class命名的重复，命名时取父元素的class作为前缀 使用css reset统一浏览器的显示效果 给css样式定义排序，最佳是按类型分组排序 显示与浮动、定位、尺寸、边框相关属性、字体样式、背景、其他样式 合理利用css的权重，提高代码的重用性 css样式中尽量不要使用ID选择器，最佳实践尽可能使用较低权重的选择器作为基础样式 减少自选择器的层级 使用组合的css选择器 em px % w3c把尺寸单位分为相对长度单位和绝对长度单位两种。 相对长度单位又分为字体相对单位和视窗相对单位 字体相对单位包括：em ex ch rem 视窗相对单位包括：vw vh vmin vmax 使用最广泛的是em px 百分比 em计算是相对自身元素的字体尺寸的，rem相对于根元素的字体大小计算， 百分比是相对于父元素的尺寸的 如何设置元素的尺寸和字体大小最佳实践 尽量设置相对尺寸（局部的尺寸要尽量使用相对尺寸，即局部自适应） 只有在可预知元素尺寸的情况下才使用绝对尺寸 使用em设置字体大小 css选择器定义最佳实践 避免使用通配符 避免使用标签选择器及单个属性选择器作为关键选择器 不要在id选择器前使用标签名 尽量不要使在选择符中定义过多的层级，最好不要超过三层 css相关图片处理 不要设置图片尺寸 使用css雪碧图技术 减少css代码量 定义简洁的css规则 合并相关的css规则 定义简洁的属性值合并相同的定义 三、JavaScript实践 避免定义全局变量或函数 使用var 使用JavaScript的严格模式use strict; 使用简化的编码方式 对象创建pserson={age:22,name:&quot;poetries&quot;} 数组创建list=[12,23,55] 使用===和!==而不是==和!= 避免使用with语句和eval() 使用更严格的编码格式 使用严格模式遵循： 不要在全局中启用严格模式 在已有代码中谨慎使用严格模式 严格模式主要对不合理的地方做了改进 禁用width关键字 防止意外的全局变量 函数中的this不在默认指向全局 防止函数参数重命名 更安全的使用eval() 事件处理和业务逻辑相分离 配置数据和代码逻辑相分离 逻辑与结构相似相分离 从JavaScript逻辑中分离css样式 从JavaScript中分离HTML结构 JavaScript模块化的开发，提高代码的可维护性 JavaScript的两种模块化规范 ComonJS AMD 两者的主要区别在加载模块的方式上 ComonJS 以同步的方式加载，使用require()方法来加载模块 AMD以异步的方式加载模块 合理使用Ajax技术，适合的使用场景有 前端会根据用户的需求动态取得后端数据，然后更新网页界面 期望通过不刷新页面取得任何资源或页面 动态进行用户输入的认证 四、附录 附录一 DIV命名规范 企业DIV使用频率高的命名方法 网页内容类 标题: title 摘要: summary 箭头： arrow 商标： label 网站标志： logo 转角/圆角：corner 横幅广告： banner 子菜单： subMenu 搜索： search 搜索框： searchBox 登录： login 登录条：loginbar 工具条： toolbar 下拉： drop 标签页： tab 当前的： current 列表： list 滚动： scroll 服务： service 提示信息： msg 热点：hot 新闻： news 小技巧： tips 下载： download 栏目标题： title 热点： hot 加入：joinus 注册： regsiter 指南： guide 友情链接： friendlink 状态： status 版权： copyright 按钮： btn 合作伙伴： partner 投票： vote 左右中：left right center 注释的写法: /* Footer */ 内容区/* End Footer */ id的命名: 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的:current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名: 颜色:使用颜色的名称或者16进制代码,如 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; } .font9px {font-size: 9pt; } 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } .bottom { float:bottom; } 标题栏样式,使用”类别+功能”的方式命名,如 .barnews { } .barproduct { } 注意事项:: 一律小写; 尽量用英文; 不加中杠和下划线; 尽量不缩写，除非一看就明白的单词. 推荐的 CSS 书写顺序： 显示属性 display list-style position float clear 自身属性 width height margin padding border background 文本属性 color font text-decoration text-align vertical-align white-space other text content 附录二 CSS精灵 CSS精灵原理以及应用 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。 该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。 一个简单的例子： 一张图片作出一个按钮的三个状态 一个链接用CSS做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，a:link，a:hover，a:active &lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt; 加入右侧的图片为：200px 65px的三个按钮图拼合而成的图片button.png，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用CSS进行定义。 12345678910111213141516171819a &#123; display:block; width:200px; height:65px; line-height:65px; /*定义状态*/ text-indent:-2015px; /*隐藏文字*/ background-image:url(button.png); /*定义背景图片*/ background-position:0 0; /*定义链接的普通状态，此时图像显示的是顶上的部分*/&#125;a:hover &#123; background-position:0 -66px; /*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/&#125;a:active &#123; background-position:0 -132px; /*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*/&#125; 更多的CSS雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值 如：background:url(nav.png) -180px 24pxno-repeat; 来达到更精确的定位 优点： 减少加载网页图片时对服务器的请求次数 可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。 提高页面的加载速度 sprite技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。 减少鼠标滑过的一些bug IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。 不足： CSS雪碧的最大问题是内存使用 影响浏览器的缩放功能 拼图维护比较麻烦 使CSS的编写变得困难 CSS 雪碧调用的图片不能被打印 错误得使用 Sprites 影响可访问性 附录三 一些tips解决方案 页面优化实践 从下面的几个方面可以进行页面的优化： 减少请求数 图片合并 CSS文件合并 减少内联样式 避免在 CSS中使用 import 减少文件大小 选择适合的图片格式 图片压缩 CSS 值缩写（Shorthand Property) 文件压缩 页面性能 调整文件加载顺序 减少标签数量 调整选择器长度 尽量使用CSS 制作显示表现 增强代码可读性与可维护性 规范化 语义化 模块化 写DIV+CSS 的一些常识 不要使用过小的图片做背景平铺 这就是为何很多人都不用 1px 的原因，这才知晓。宽高 1px 的图片平铺出一个宽高 200px 的区域，需要 200200=40, 000 次，占用资源 无边框 推荐的写法是 border:none;，哈哈，我一直在用这个。 border:0; 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源 慎用 通配符 所谓通配符，就是将CSS 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。 CSS的十六进制颜色代码缩写 习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。 样式放头上，脚本放脚下。不内嵌，只外链 坚决不用 CSS表达式 使用 引用样式表，而不是通过@import 导入。 一般来说，PNG比 GIF 要小，小得多。再者，GIF 中有多少颜色是被浪费的，很值得优化。 千万不要在 HTML中缩放图片，一者不好看，二者占资源。 正文字体最好用偶数 12px、14px、16px，效果非常好。特例，15px。 block、ul、ol等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。 段落之间，至少要有一倍行距 强行指定某些元素的 line-height，正文 1.6倍于文字大小，标题1.3倍。 中文标点用全角 英文夹杂在中文中，左右空格，半角。 中文字体的粗体和斜体，远离较好 [建议] HTML 标签的使用应该遵循标签的语义 下面是常见标签语义 p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr- 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表 常用代码片段 雅虎工程师提供的CSS初始化示例代码【仅供参考】 可以在html头文件中直接引用，从而避免浏览器的不兼容带来的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px;&#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption,cite, code, dfn, em, strong,th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none;&#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123; overflow-y: scroll;&#125; .clearfix:after &#123; content: \".\"; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 现代浏览器cssreset解决方案【推荐使用这个】 normalize.css mobile meta标签 1&lt;meta name=”viewport” content=”width=320,target-densitydpi=dpi_value,initial-scale=1, user-scalable=no”/&gt; 表格不被撑开 1table-layout: fixed; word-break: break-all;;border-collapse: collapse 不设宽高居中 12345&lt;div id=”abc” style=”display:table;text-align:center;width:100%;height:100%;”&gt; &lt;span style=”background:#f00; display:table-cell; vertical-align:middle;”&gt; &lt;input type=”button” value=”item1″ /&gt; &lt;/span&gt;&lt;/div&gt; 透明度的兼容代码 1234filter:alpha(opacity=50); /*1-100*/-moz-opacity:0.5; /*0-1.0*/-khtml-opacity:0.5; /*0-1.0*/opacity:0.5; /*0-1.0*/ 文本溢出的几种处理方法 简单隐藏 1div.hide&#123;overflow:hidden&#125; 使用滚动条 1div.scroll&#123;overflow:scroll&#125; 简单裁切 123456div.clip&#123; border:1px solid; overflow:hidden;/*超出隐藏*/ white-space:nowrap;/*强制在一行显示*/ text-overflow:clip;/*裁切*/&#125; 超出部分省略号 12345div.elli&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;/*使用省略号*/&#125; 清除浮动的几种方法 方法一：投机取巧法 – 不推荐 直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强 方法二：overflow + zoom方法 –不推荐 .fix{overflow:hidden; zoom:1;} 此方法优点在于代码简洁，涵盖所有浏览器 方法三：after + zoom方法 -推荐–此方法可以说是综合起来最好的方法了 clearfix只应用在包含浮动子元素的父级元素上 12345678.clearfix&#123;zoom:1;&#125;.clearfix:after&#123; display:block; content:'clear'; clear:both; line-height:0; visibility:hidden;&#125; 方法四 在方法三的基础上的最优雅的做法【推荐】 12345678.clearfix:after,.clearfix:before &#123;/*before 是为了防止浏览器顶部空白的崩溃*/ content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125; 清除浮动的原理是触发BFC，这里只有clear:both起清除浮动作用，其他的line-height:0; visibility:hidden;都是为了隐藏生的内容需要的 拓展阅读 CSS中的浮动和清除浮动 实用的60个CSS代码片段 一些总结 自动继承属性： color font text-align list-style… 非继承属性： background border position… 具有破坏性的元素： float display:none; position:absoblute/fixed/sticky; 具有包裹性的元素： display:inline-block/table-cell position:absolute/fixed/sticky overflow:hidden/scroll 消除图片底部间隙的方法 图片块状化-无基线对齐img{display:block;} 图片底线对齐img{vertical-align:bottom;} 行高足够小 - 基线位置上移.box{line-height:0;} 参考 web前端开发最佳实践","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"规则","slug":"规则","permalink":"http://yoursite.com/tags/规则/"},{"name":"实践","slug":"实践","permalink":"http://yoursite.com/tags/实践/"}]},{"title":"基于gulp的工作流配置","slug":"gulp-works","date":"2016-01-21T09:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/21/gulp-works/","link":"","permalink":"http://yoursite.com/2016/01/21/gulp-works/","excerpt":"配置一套基于gulp的工作流，满足日常的基本开发。","text":"配置一套基于gulp的工作流，满足日常的基本开发。 一、目录结构 一套基于gulp的工作流 二、 package.json 1234567891011121314151617181920212223242526272829&#123; \"name\": \"gulp-project\", \"scripts\": &#123; \"dev\": \"gulp dev\", //npm run dev 开发 \"build\": \"gulp build\", //npm run build 发布 \"upload\": \"gulp upload\", //npm run upload 上传服务器 \"zip\": \"gulp zip\" ////npm run zip 打包文件 &#125;, \"devDependencies\": &#123; \"babel-preset-es2015\": \"^6.22.0\", //编译es6 \"browser-sync\": \"^2.15.0\", //监听改动刷新 \"gulp\": \"^3.9.1\", //gulp \"gulp-autoprefixer\": \"^3.1.1\", //补齐css浏览器前缀 \"gulp-babel\": \"^6.1.2\", // Es6 \"gulp-clean\": \"^0.3.2\", //删除文件 \"gulp-clean-css\": \"^2.0.12\", //css压缩，gulp-minify-css不更新了 \"gulp-concat\": \"^2.6.0\",//合并文件 \"gulp-ftp\": \"^1.1.0\",//提交到ftp服务器 \"gulp-git\": \"^1.11.3\",//提交到git \"gulp-htmlmin\": \"^2.0.0\",//压缩html \"gulp-imagemin\": \"^3.0.3\",//压缩图片 \"gulp-rename\": \"^1.2.2\",//重命名文件 \"gulp-rev-append\": \"^0.1.6\", //添加MD5版本号，这里改成了时间戳 \"gulp-sass\": \"^2.3.2\",//编译SASS \"gulp-uglify\": \"^2.0.0\",//js压缩 \"gulp-util\": \"^3.0.7\", //说是ftp配套用的，看了下是包装了些常用函数 \"gulp-zip\": \"^3.2.0\" // 打包文件 &#125;&#125; 三、 gulpfile.js 1234567891011121314151617181920//组件let gulp = require('gulp'), browserSync = require('browser-sync').create(), //监听刷新 reload = browserSync.reload, ftp = require('gulp-ftp'), // ftp上传 gutil = require('gulp-util'), sass = require('gulp-sass'), // sass cleancss = require('gulp-clean-css'), // CSS压缩 autoprefixer = require(\"gulp-autoprefixer\"), uglify = require('gulp-uglify'), // js压缩 concat = require('gulp-concat'), // 合并文件 rename = require('gulp-rename'), // 重命名 clean = require('gulp-clean'), //清空文件夹 imagemin = require('gulp-imagemin'), //压缩图片 zip = require('gulp-zip'), //打包文件 rev = require('gulp-rev-append'), //添加MD5 htmlmin = require('gulp-htmlmin'), // 压缩html git = require('gulp-git'), //git babel = require(\"gulp-babel\"); //ES6 转es5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// =========== 开发构建流程 [多文件输出] ==============//devgulp.task('sass:dev', () =&gt; &#123; gulp.src('src/sass/*.scss') .pipe(sass()) .pipe(gulp.dest('src/css/')) .pipe(reload(&#123; stream: true &#125;))&#125;);// 合并、重命名cssgulp.task('css:dev', ['sass:dev'], () =&gt; &#123; gulp.src(['src/css/*.css', '!src/css/areaMap.css']) .pipe(concat('all.css')) .pipe(gulp.dest('dist/css/'))&#125;);// 合并、重命名jsgulp.task('js:dev', () =&gt; &#123; gulp.src('src/js/*.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) //ES6转ES5 //.pipe(concat('all.js')) 开发阶段分开输出js文件 .pipe(gulp.dest('dist/js/')) .pipe(reload(&#123; stream: true &#125;))&#125;);// HTMLgulp.task('html:dev', () =&gt; &#123; gulp.src('src/tpl/*.html') .pipe(gulp.dest('dist'))&#125;);// 将lib的库文件对应到指定位置gulp.task('lib:dev', () =&gt; &#123; gulp.src('./src/lib/*') .pipe(gulp.dest('./dist/lib/'));&#125;);//开发构建gulp.task('dev', ['css:dev', 'js:dev', 'html:dev', 'img','copyFonts','lib'], () =&gt; &#123; browserSync.init(&#123; server: &#123; baseDir: \"dist\" // 设置服务器的根目录为dist目录 &#125;, notify: false // 开启静默模式 &#125;); // 我们使用gulp的文件监听功能，来实时编译修改过后的文件 gulp.watch('src/js/*.js', ['js:dev']); gulp.watch('src/sass/*.scss', ['sass:dev']); gulp.watch('src/tpl/*.html', ['html:dev']); gulp.watch('src/fonts/**', ['copyFonts']); gulp.watch('src/images/**', ['img']); gulp.watch('src/lib/**', ['lib']);&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// =========== 正式构建 build [单文件输出] ==============// sass解析gulp.task('sass', () =&gt; &#123; gulp.src('src/sass/*.scss') //输出为压缩 .pipe(sass(&#123; outputStyle: 'compressed' &#125;)) .pipe(sass()) .pipe(gulp.dest('src/css/'))&#125;);// 合并、压缩、重命名cssgulp.task('css', ['sass'], () =&gt; &#123; gulp.src(['src/css/*.css', '!src/css/areaMap.css']) .pipe(concat('all.css')) .pipe(autoprefixer(&#123; browsers: ['last 2 versions', 'Android &gt;= 4.0'], cascade: true, //是否美化属性值 默认：true 像这样： remove: false //是否去掉不必要的前缀 默认：true &#125;)) .pipe(cleancss()) //压缩css .pipe(gulp.dest('dist/css'));&#125;);// 合并，压缩,重命名js文件gulp.task('js', () =&gt; &#123; gulp.src('src/js/*.js') .pipe(babel(&#123; presets: ['es2015'] &#125;)) //ES6转ES5 .pipe(concat('all.js')) .pipe(uglify()) .pipe(gulp.dest('dist/js'));&#125;);// 压缩HTMLgulp.task('html', () =&gt; &#123; gulp.src('src/tpl/*.html') .pipe(rev())//记得在引用地址后面加后缀，插件原本是ver=@@hash ,这里改成了v=@@hash //&lt;link rel=\"stylesheet\" href=\"css/all.css?v=@@hash\"&gt; //&lt;script src=\"js/all.js?v=@@hash\"&gt;&lt;/script&gt; .pipe(htmlmin(&#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" minifyJS: true, //压缩页面JS minifyCSS: true //压缩页面CSS &#125;)) .pipe(gulp.dest('dist'))&#125;);//压缩图片gulp.task('img', () =&gt; &#123; gulp.src('src/images/*.&#123;png,jpg,gif,ico&#125;') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('dist/images'));&#125;);//字体文件gulp.task('copyFonts', function () &#123; gulp.src('src/fonts/**/*') .pipe(gulp.dest('dist/fonts/'))&#125;);// 清空图片、样式、jsgulp.task('clean', () =&gt; &#123; gulp.src('dist', &#123; read: false &#125;) .pipe(clean(&#123; force: true &#125;));&#125;);// 将bower的库文件对应到指定位置gulp.task('lib', () =&gt; &#123; gulp.src('/src/lib/*') .pipe(gulp.dest('/dist/lib/'));&#125;); 12345678910111213141516171819202122// ================ 打包主体dist 文件夹 zip ====//打包主体dist 文件夹并按照时间重命名gulp.task(&apos;zip&apos;, function()&#123; function checkTime(i) &#123; if (i &lt; 10) &#123; i = &quot;0&quot; + i &#125; return i &#125; var d=new Date(); var year=d.getFullYear(); var month=checkTime(d.getMonth() + 1); var day=checkTime(d.getDate()); var hour=checkTime(d.getHours()); var minute=checkTime(d.getMinutes()); return gulp.src(&apos;./dist/**&apos;) .pipe(zip(year+month+day +hour+minute+&apos;.zip&apos;)) .pipe(gulp.dest(&apos;./zip&apos;));&#125;); 1234567891011121314151617//正式构建gulp.task('build', ['clean','css', 'js', 'img', 'html','copyFonts','lib']);// ================ 上传 upload ====gulp.task('upload', () =&gt; &#123; gulp.src('dist/**') .pipe(ftp(&#123; host: '8.8.8.8', // 远程主机ip port: 22, // 端口 user: 'username', // 帐号 pass: 'password', // 密码 remotePath: '/project' // 上传路径，不存在则新建 &#125;)) .pipe(gutil.noop())&#125;)","categories":[{"name":"Build","slug":"Build","permalink":"http://yoursite.com/categories/Build/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"JavaScript中的this的一些用法","slug":"JavaScript中this的一些用法","date":"2016-01-20T12:09:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/20/JavaScript中this的一些用法/","link":"","permalink":"http://yoursite.com/2016/01/20/JavaScript中this的一些用法/","excerpt":"一、global this 总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。 在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。 对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似 也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。 但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大的","text":"一、global this 总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。 在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。 对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似 也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。 但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大的 二、function this 如果不是用new调用，在函数里面使用this都是指代全局范围的this 函数里面的this其实相对比较好理解，如果我们在一个函数里面使用this，需要注意的就是我们调用函数的方式，如果是正常的方式调用函数，this指代全局的this 如果我们加一个new，这个函数就变成了一个构造函数，我们就创建了一个实例，this指代这个实例，这个和其他面向对象的语言很像 另外，写JavaScript很常做的一件事就是绑定事件处理程序，也就是诸如button.addEventListener(‘click’, fn, false)之类的，如果在fn里面需要使用this，this指代事件处理程序对应的对象，也就是button 三、prototype this 你创建的每一个函数都是函数对象。它们会自动获得一个特殊的属性prototype，你可以给这个属性赋值。当你用new的方式调用一个函数的时候，你就能通过this访问你给prototype赋的值了 12345678function Thing() &#123; console.log(this.foo); &#125; Thing.prototype.foo = \"bar\"; var thing = new Thing(); //logs \"bar\" console.log(thing.foo); //logs \"bar\" 当你使用new为你的函数创建多个实例的时候，这些实例会共享你给prototype设定的值。当你调用this.foo的时候，都会返回相同的值，除非你在某个实例里面重写了自己的this.foo 实例里面的this是一个特殊的对象。你可以把this想成一种获取prototype的值的一种方式。当你在一个实例里面直接给this添加属性的时候，会隐藏prototype中与之同名的属性。如果你想访问prototype中的这个属性值而不是你自己设定的属性值，你可以通过在实例里面删除你自己添加的属性的方式来实现 通过一个函数创建的实例会共享这个函数的prototype属性的值，如果你给这个函数的prototype赋值一个Array，那么所有的实例都会共享这个Array，除非你在实例里面重写了这个Array，这种情况下，函数的prototype的Array就会被隐藏掉 给一个函数的prototype赋值一个Array通常是一个错误的做法。如果你想每一个实例有他们专属的Array，你应该在函数里面创建而不是在prototype里面创建 实际上你可以通过把多个函数的prototype链接起来的从而形成一个原型链，因此this就会魔法般地沿着这条原型链往上查找直到找你你需要引用的值 123456789101112function Thing1() &#123; Thing1.prototype.foo = \"bar\";&#125;function Thing2() &#123;&#125; Thing2.prototype = new Thing1(); var thing = new Thing2(); console.log(thing.foo); //logs \"bar\" 四、object this 在一个对象的一个函数里，你可以通过this来引用这个对象的其他属性。这个用new来新建一个实例是不一样的 12345678var obj = &#123; foo: \"bar\", logFoo: function () &#123; console.log(this.foo); &#125; &#125;; obj.logFoo(); //logs \"bar\" 注意，没有使用new，没有使用Object.create，也没有使用函数调用创建一个对象。你也可以将对象当作一个实例将函数绑定到上面 123456789var obj = &#123; foo: \"bar\"&#125;;function logFoo() &#123; console.log(this.foo);&#125;logFoo.apply(obj); //logs \"bar\" 五、DOM event this 在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点 12345678910function Listener() &#123; document.getElementById(\"foo\").addEventListener(\"click\", this.handleClick); &#125; Listener.prototype.handleClick = function (event) &#123; console.log(this); //logs \"&lt;div id=\"foo\"&gt;&lt;/div&gt;\" &#125; var listener = new Listener(); document.getElementById(\"foo\").click(); 除非你自己通过bind切换了上下文 12345678910function Listener() &#123; document.getElementById(\"foo\").addEventListener(\"click\", this.handleClick.bind(this)); &#125; Listener.prototype.handleClick = function (event) &#123; console.log(this); //logs Listener &#123;handleClick: function&#125; &#125; var listener = new Listener(); document.getElementById(\"foo\").click(); 六、HTML this 在HTML节点的属性里面，你可以放置JavaScript代码，this指向了这个元素 1234&lt;div id=\"foo\" onclick=\"console.log(this);\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; document.getElementById(\"foo\").click(); //logs &lt;div id=\"foo\"... &lt;/script&gt; 七、override this 你不能重写this，因为它是保留字 1234function test () &#123; var this = &#123;&#125;; // Uncaught SyntaxError: Unexpected token this &#125;eval this 你可以通过eval来访问this 123456789101112function Thing () &#123;&#125;Thing.prototype.foo = \"bar\";Thing.prototype.logFoo = function () &#123; eval(\"console.log(this.foo)\"); //logs \"bar\"&#125;var thing = new Thing();thing.logFoo(); 这会造成一个安全问题，除非不用eval，没有其他方式来避免这个问题 八、with this 你可以通过with来将this添加到当前的执行环境，并且读写this的属性的时候不需要通过this 12345678910111213function Thing () &#123; &#125; Thing.prototype.foo = \"bar\"; Thing.prototype.logFoo = function () &#123; with (this) &#123; console.log(foo); foo = \"foo\"; &#125; &#125;var thing = new Thing();thing.logFoo(); // logs \"bar\"console.log(thing.foo); // logs \"foo\" 许多人认为这样使用是不好的因为with本身就饱受争议 九、jQuery this 和HTML DOM元素节点的事件处理程序一样，在许多情况下JQuery的this都指向HTML元素节点。这在事件处理程序和一些方便的方法中都是管用的，比如$.each 12345678910111213141516&lt;div class=\"foo bar1\"&gt;&lt;/div&gt;&lt;div class=\"foo bar2\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $(\".foo\").each(function () &#123; console.log(this); //logs &lt;div class=\"foo... &#125;); $(\".foo\").on(\"click\", function () &#123; console.log(this); //logs &lt;div class=\"foo... &#125;); $(\".foo\").each(function () &#123; this.click(); &#125;);&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jQuery笔记总结篇","slug":"review-jQuery","date":"2016-01-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/20/review-jQuery/","link":"","permalink":"http://yoursite.com/2016/01/20/review-jQuery/","excerpt":"原文链接 http://blog.poetries.top/2016/10/20/review-jQuery 首先，来了解一下jQuery学习的整体思路","text":"原文链接 http://blog.poetries.top/2016/10/20/review-jQuery 首先，来了解一下jQuery学习的整体思路 XMind源文件提供参考下载 第一节 jQuery初步认知 jQuery概述 JQuery概念 javascript概念 基于Js语言的API和语法组织逻辑，通过内置window和document对象，来操作内存中的DOM元素 JQuery概念 基于javascript的，同上，提高了代码的效率 jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。 它可以帮我们做什么(有什么优势) 轻量级、体积小，使用灵巧(只需引入一个js文件) 强大的选择器 出色的DOM操作的封装 出色的浏览器兼容性 可靠的事件处理机制 完善的Ajax 链式操作、隐式迭代 方便的选择页面元素(模仿CSS选择器更精确、灵活) 动态更改页面样式/页面内容(操作DOM，动态添加、移除样式) 控制响应事件(动态添加响应事件) 提供基本网页特效(提供已封装的网页特效方法) 快速实现通信(ajax) 易扩展、插件丰富 如何引入JQuery包 引入本地的JQuery 引入Google在线提供的库文件（稳定可靠高速） 使用Google提供的API导入 &lt;script type=“text/javascript” src=“jquery.js”&gt;&lt;/script&gt; 写第一个JQUery案例 解释:在JQuery库中，$是JQuery的别名，$()等效于就jQuery() 123456&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt; $(function()&#123; alert(“jQuery 你好!”); &#125;);&lt;/script&gt; 讲解$(function(){}); $是jQuery别名。如$()也可jQuery()这样写,相当于页面初始化函数，当页面加载完毕，会执行jQuery()。 希望在做所有事情之前，JQuery操作DOM文档。必须确保在DOM载入完毕后开始执行，应该用ready事件做处理HTML文档的开始 $(document).ready(function(){}); 类似于js的window.onload事件函数，但是ready事件要先于onload事件执行 window.onload = function(){}; 为方便开发，jQuery简化这样的方法，直接用$()表示 JQuery的ready事件不等于Js的load： 执行时机不同：load需要等外部图片和视频等全部加载才执行。ready是DOM绘制完毕后执行，先与外部文件 用法不同：load只可写一次，ready可以多次 window.onload与$(document).ready()对比 window.onload $(document).ready() 执行时机 必须等网页中所有内容加载完后(图片)才执行 网页中的DOM结构绘制完后就执行,可能DOM元素相关的东西并没有加载完 编写个数 不能同时执行多个 能同时执行多个 简化写法 无 $(document).ready(function(){ //.. });推荐写法：$(function(){ }); jQuery有哪些功能(API)： 选择器 过滤器 事件 效果 ajax 简单的JQuery选择器： JQuery基本选择器（ID选择器，标签选择器，类选择器，通配选择器和组选择器5种） ID选择器：document.getElementById(id)与$(&quot;#id&quot;)对比(改变文字大小)—id唯一，返回单个元素 标签选择器：document.getElementsByTagName(tagName)与$(&quot;tagname&quot;)对比—多个标签，返回数组 类选择器:$(&quot;.className&quot;)–多个classname（改变背景图片） 通配选择器：document.getElementsByTagName(&quot;*&quot;)与$(&quot;*&quot;)对比—指范围内的所有标签元素 组选择器：$(&quot;seletor1,seletor2,seletor3&quot;)—-无数量限制，用逗号分割 初步了解JQuery JQuery是什么 javascript用来干什么的： 操作DOM对象 动态操作样式css 数据访问 控制响应事件等 jQuery作用一样，只是更加快速简洁 如何引用JQuery 12345678&lt;script type=\"text/javascript\"&gt;&lt;/script&gt;写第一个JQUery案例&lt;script type=“text/javascript” src=“”&gt;&lt;/script&gt;&lt;script type=“text/javascript”&gt; $(function()&#123; alert(“jQuery 你好!”); &#125;);&lt;/script&gt; $()讲解 $在JQuery库中，$是JQuery的别名，$()等效于就jQuery(). $()是JQuery方法,赞可看作是JQuery的选择器，与css选择器相似（可做对比） var jQuery==$ =function(){} $()本质就是一个函数也就是 jQuery的核心函数 只要是jQuery的对象都这样变量加上一个符号$方便识别：var $div = $(&quot;#&quot;) 123function $(id)&#123; return document.getElementById(id); &#125; $()和document是相等的吗 12345&lt;div id=\"a\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"b\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"c\" class=\"aa\"&gt;&lt;/div&gt;alert(document.getElementById(\"id\") == $(\"#aa\"));//返回结果为falsealert(document.getElementById(\"id\") == $(\"#aa\").get(0));//返回true 代理对象$() jQuery中返回的是代理对象本身 jQuery的核心原理是通过选择器找到对应的代理对象 jQuery全都是通过方法操作 样式选择器$(&quot;.className&quot;) $(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;); id选择器(“”) $(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;); 标签选择器 $(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;); 组选择器 $(&quot;#b ul li&quot;).size(); 对象转换($(element)) 原生dom对象和jquery代理对象的相互转换 12345$(传入的原生对象);//原生对象转化成jQuery对象var nav = document.getElementById(\"nav\");var $nav = $(nav);alert($nav.get(0) == nav);//true 检索范围的限制（$(&#39;字符串&#39;,element)） 总结：三种写法对比： 方式一：不推荐 搜索速度最慢 $(&quot;#nav&quot;).css(); $(&quot;#nav li&quot;).css(); 方式二：搜索速度最快 链式操作 $(&quot;#nav&quot;).css().children().css(); 方式三：也常用 速度第二快 var $nav = $(&quot;#nav&quot;).css(); $(&quot;li&quot;,$nav).css(); $nav限制了搜索范围 速度快 总结： $() jquery核心方法的作用和使用场景 如果是一个字符串参数并且没有标签对（选择器）$(ul.nav&quot;) 如果是一个字符串参数并且有标签对（创建html标签）$(&quot;&lt;img&gt;&quot;) –最终加到DOM树中 $xx.append(&quot;&lt;img&gt;&quot;); 如果是传入一个element dom对象，直接包装为proxy对象返回 $(DOM对象) 如果第一个参数是字符串，第二个是element dom对象的话，那么就是在element这个dom对象里面寻找选择器对应的元素并且代理 $(&quot;li&quot;,$DOM对象) 代理模式以及代理内存结构 代理内存结构2 第二节 选择器 来回顾一下CSS常用的选择器 选择器 语法 描述 标签选择器 E{css规则} 以文档元素作为选择符 ID选择器 #ID{css规则} ID作为选择符 类选择器 E.className{css规则} class作为选择符 群组选择器 E1,E2,E3{css规则} 多个选择符应用同样的样式 后代选择器 E F{css规则} 元素E的任意后代元素F 选择器引擎规则($(&#39;字符串&#39;)) css选择器的规则 标签选择器 id选择器 类选择器 混合选择器 css3的选择器规则 状态和伪类（:even :odd :first :last :eq(index)） 属性（[attr=value]） 层级选择器:通过DOM的嵌套关系匹配元素 jQuery层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种 a.包含选择器：$(&quot;a b&quot;)在给定的祖先元素下匹配所有后代元素。(不受层级限制) b.子选择器：$(&quot;parent &gt; child&quot;)在给定的父元素下匹配所有子元素。 c.相邻选择器：$(&quot;prev + next&quot;) 匹配所有紧接在prev元素后的next元素。 d.兄弟选择器：$(&quot;prev ~ siblings&quot;) 匹配prev元素之后的所有sibling元素。 过滤选择器 基本过滤选择 选择器 说明 返回 :first 匹配找到的第1个元素 单个元素 :last 匹配找到的最后一个元素 单个元素 :eq 匹配一个给定索引值的元素 单个元素 :even 匹配所有索引值为偶数的元素 集合元素 : odd 匹配所有索引值为奇数的元素 集合元素 :gt(index) 匹配所有大于给定索引值的元素 集合元素 :lt(index) 匹配所有小于给定索引值的元素 集合元素 :not 去除所有与给定选择器匹配的元素 集合元素 :animated 选取当前正在执行动画的所有元素 集合元素 focus 选取当前正在获取焦点的元素 集合元素 内容过滤选择器 选择器 描述 返回 :contains(text) 选取含有文本内容为text的元素 集合元素 :empty 选取不包含子元素获取文本的空元素 集合元素 :has(selector) 选择含有选择器所匹配的元素的元素 集合元素 :parent 选取含有子元素或者文本的元素 集合元素 可见过滤选择器 选择器 描述 返回 :hidden 选择所有不可见的元素 集合元素 :visible 选取所有可见的元素 集合元素 属性过滤选择器 选择器 说明 返回 [attribute] 选取拥有此属性的元素 集合元素 [attribute=value] 选取属性值为value值的元素 集合元素 [attribue^=value] 选取属性的值以value开始的元素 集合元素 [attribue$=value] 选取属性的值以value结束的元素 集合元素 子元素过滤选择器 选择器 说明 返回 :nth-child(index/even/odd) 选取每个父元素下的第index个子元素或者奇偶元素（index从1算起） 集合元素 :first-child 选取每个元素的第一个子元素 集合元素 :last-child 选取每个元素的最后一个子元素 集合元素 :nth-child()选择器是很常用的子元素过滤选择器，如下 :nth-child(even)选择每个父元素下的索引值是偶数的元素 :nth-child(odd)选择每个父元素下的索引值是奇数的元素 :nth-child(2)选择每个父元素下的索引值是2的元素 :nth-child(3n)选择每个父元素下的索引值是3的倍数的元素 (n从1开始) 表单对象属性过滤选择器 选择器 说明 返回 :enabled 选取所有可用元素 集合元素 :disabled 选取所有不可用元素 集合元素 :checked 选取所有被选中的元素（单选框、复选框） 集合元素 :selected 选取所有被选中的元素（下拉列表） 集合元素 表单选择器 选择器 说明 :input 选取所有input textarea select button元素 :text 选取所有单行文本框 :password 选取所有密码框 :radio 选取所有单选框 :checkbox 选取所有多选框 :submit 选取所有的提交按钮 :image 选取所有的图像按钮 :reset 选取所有的重置按钮 :button 选取所有的按钮 :file 选取所有的上传域 :hidden 选取所有的不可见元素 特定位置选择器 :first :last :eq(index) 指定范围选择器 :even :odd :gt(index) :lt(index) 排除选择器 :not 非 第三节 选择器优化 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，ID选择器速度最快，其次是类型选择器。 a. 多用ID选择器 b. 少直接使用class选择器 c. 多用父子关系，少用嵌套关系 d. 缓存jQuery对象 使用过滤器 jQuery提供了2种选择文档元素的方式：选择器和过滤器 a. 类过虑器：根据元素的类属性来进行过滤操作。 hasClass(className)：判断当前jQuery对象中的某个元素是否包含指定类名，包含返回true，不包含返回false b. 下标过滤器：精确选出指定下标元素 eq(index)：获取第N个元素。index是整数值，下标从0开始 c. 表达式过滤器 filter(expr)/(fn)：筛选出与指定表达式/函数匹配的元素集合。 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式 d. 映射 map(callback)：将一组元素转换成其他数组 e. 清洗 not(expr)：删除与指定表达式匹配的元素 f. 截取 slice(start,end)：选取一个匹配的子集 查找 向下查找后代元素 children():取得所有元素的所有子元素集合（子元素） find():搜索所有与指定表达式匹配的元素(所有后代元素中查找) 查找兄弟元素 siblings()查找当前元素的兄弟 第四节 代理对象属性和样式操作 代理对象属性和样式操作 attr prop(一般属性值是boolean的值或者不用设置属性值，一般使用) css(最好不用，一般我用来做测试) addClass / removeClass 操作原生DOM的时候用的方式：一次只能操作一个 操作属性：setAttribute / getAttribute 操作样式：style.xx = value 操作类样式：className=&#39;&#39; 获取DOM的子元素children属性 DOM里面添加一个子元素appendChild() 操作jQuery代理对象的时候：批量操作DOM对象(全都是通过方法操作) 操作属性：attr()、prop() attr和prop区别：如果属性的值是布尔类型的值 用prop操作 反之attr 操作样式：css() 操作类样式：addClass() removeClass() 操作DOM子元素：children() 添加子元素：append() 第五节 jQuery中DOM操作 DOM是一种与浏览器、平台|语言无关的接口，使用该接口可以轻松的访问 页面中的所有的标准组件 DOM操作的分类 DOM Core DOM core并不专属于JavaScript，任何支持DOM的程序都可以使用 JavaScript 中的getElementByID() getElementsByTagName() getAttribute() setAttribute()等方法都是DOM Core的组成部分 HTML-DOM HTML -DOM的出现比DOM-Core还要早，它提供一些更简明的标志来描述HTML元素的属性 比如：使用HTML-DOM来获取某元素的src属性的方法 element.src CSS-DOM 针对CSS的操作。在JavaScript中，主要用于获取和设置style对象的各种属性，通过改变style对象的属性，使网页呈现不同的效果 查找节点 查找属性节点 attr() 可以获取各属性的值 创建节点 $(html)：根据传递的标记字符串，创建DOM对象 插入节点 方法 说明 append() 向每个匹配元素内部追加内容 appendTo() 颠倒append()的操作 prepend() 向每个匹配元素的内容内部前置内容 prependTo() 颠倒prepend()的操作 after() 向每个匹配元素之后插入内容 insertAfter() 颠倒after()的操作 before() 在每个匹配元素之前插入内容 insertBefore() 颠倒before()的操作 删除节点 jQuery提供了三种删除节点的方法 remove() detach() empty() remove()方法 当某个节点用此方法删除后，该节点所包含的所有后代节点将同时被删除，用remove()方法删除后，还是可以继续使用删除后的引用 detach() 和remove()方法一样，也是从DOM中去掉所有匹配的元素，与remove()不同的是，所有绑定的事件、附加的数据等，都会被保留下来 empty() empty()方法并不是删除节点，而是清空节点，它能清空元素中所有后代节点 复制节点 使用clone()方法来完成 在clone()方法中传递一个参数true，同时复制元素中所绑定的事件 替换节点 jQuery提供相应的方法 replaceWidth() 样式操作 获取样式和设置样式 attr() 追加样式 addClass() 移除样式 removeClass() 切换样式 toggle()方法只要是控制行为上的重复切换（如果元素是显示的，则隐藏；如果元素原来是隐藏的，则显示） toggleClass()方法控制样式上的重复切换（如何类名存在，则删除它，如果类名不存在，则添加它） 判断是否含有某个样式 hasClass()可以用来判断元素是否含有某个class,如有返回true 该方法等价于is() 设置和获取HTML、文本和值 html() 此方法类似JavaScript中innerHTML属性，可以用来读取和设置某个元素中的HTML内容 text()方法 此方法类型JavaScript中innerHTML，用来读取和设置某个元素中的文本内容 val()方法 此方法类似JavaScript中的value属性，用来设置获取元素的值。无论是文本框、下拉列表还是单选框，都可以返回元素的值，如果元素多选，返回一个包含所有选择的值的数组 遍历节点 children()方法 该方法用来取得匹配元素的子元素集合 childre()方法只考虑子元素而不考虑其他后代元素 next()方法 该方法用于取得匹配元素后面紧邻的同辈元素 prev()方法 用于匹配元素前面紧邻的同辈元素 siblings()方法 用于匹配元素前后所有的同辈元素 parent()方法 获得集合中每个 元素的父级元素 parents()方法 获得集合中每个元素的祖先元素 CSS DOM操作 CSS DOM技术简单的来说就是读取和设置style对象的各种属性 用css()方法获取元素的样式属性，可以同时设置多个样式属性 CSS DOM中关于元素定位有几个常用的方法 offset()方法 它的作用是获取元素在当前视窗的相对偏移其中返回的对象包含两个属性，即top和left，他只对可见元素有效 position()方法 获取相对于最近的一个position()样式属性设置为relative或者absolute的祖父节点的相对偏移，与offset()一样，他返回的对象也包括两个属性，即top和left scrollTop()方法和scrollLeft方法 这两个方法的作用分别是获取元素的滚动条距顶端的距离和距左侧的距离 一张图总结以上的位置关系(项目中很常用-必须要弄清楚) 第六节 jQuery动画 回顾上节 操作DOM a.什么是DOM：Document Object Model缩写，文档对象模型 b.理解页面的树形结构 c.什么是节点：是DOM结构中最小单元，包括元素、属性、文本、文档等。 一、创建节点 1.创建元素 语法：document.createElement(name); 12var div = document.createElement(\"div\");document.body.appendChild(div); $(html)：根据传递的标记字符串，创建DOM对象 2.创建文本 123456789101112131415161718192021var div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);var $div = = $(\"&lt;div&gt;DOM&lt;/div&gt;\");$(body).append($div);``` - 3.设置属性 - 语法：`e.setAttrbute(name,value)````javascriptvar div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);div.setAttribute(\"title\",\"盒子\");var $div = = $(\"&lt;div title='盒子'&gt;DOM&lt;/div&gt;\");$(body).append($div); 二、插入内容 内部插入 向元素最后面插入节点： append():向每个匹配的元素内部追加内容 appendTo():把所有匹配的元素追加到指定元素集合中，$(&quot;A&quot;).append(&quot;B&quot;)等效 $(&quot;B&quot;).appendTo(&quot;A&quot;) 向元素最前面插入节点： prepend（）：把每个匹配的元素内部前置内容 prependTo（）：把所有匹配的元素前置到另一个指定的元素集合中,$(&quot;A&quot;).prepend(&quot;B&quot;) 等效 $(&quot;B&quot;).prependTo(&quot;A&quot;) 外部插入 after():在每个匹配的元素之后插入内容 before()：在每个匹配想元素之前插入内容 insertAfter()：将所有匹配的元素插入到另一个指定的元素集合后面，$A.insert($B) 等效$B.insertAfter($A); insertBefore()：将所有匹配的元素插入到另一个指定的元素集合前面 $A.before($B) 等效 $B.insertBefore($A); 三、删除内容 移除 remove():从DOM中删除所有匹配元素 清空 empty():删除匹配的元素集合中所有子节点内容 四、克隆内容：创建指定节点副本 clone() 注意：若clone（true）则是包括克隆元素的属性，事件等 五、替换内容 replaceWith():将所有匹配的元素替换成指定的元素 replaceAll():用匹配的元素替换掉指定元素 注意：两者效果一致，只是语法不同 $A.replaceAll($B)等效于 $B.replaceWhith($A); 本节新知识 JavaScript语言本身不支持动画设计，必须通过改变CSS来实现动画效果 显隐动画 show():显示 hide():隐藏 原理：hide()通过改变元素的高度宽度和不透明度，直到这三个属性值到0 show()从上到下增加元素的高度，从左到右增加元素宽度，从0到1增加透明度，直至内容完全可见 参数： show(speed,callback) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） callback: 动画完成时执行的方法 显示和隐藏式一对密不可分的动画形式 显隐切换 toggle():切换元素的可见状态 原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将display设置为none 参数： toggle(speed) toggle(speed,callback) toggle(boolean) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） easing： 使用哪个缓冲函数来过渡的字符串(linear/swing) callback： 动画完成时执行的方法 boolean:true为显示 false为隐藏 滑动 显隐滑动效果 slideDown():滑动隐藏 slidUp():滑动显示 参数: slideDown(speed,callback) slidUp(speed,callback) 显隐切换滑动 slideToggle():显隐滑动切换 参数: slidUp(speed,callback) 渐变：通过改变不透明度 淡入淡出 fadeIn() fadeOut() 参数： fadeIn(speed,callback) fadeOut(speed,callback) 设置淡出透明效果 fadeTo()⁭：以渐进的方式调整到指定透明度 参数： fadeTo(speed,opacity,callback) 渐变切换:结合fadeIn和fadeOut fadeToggle() 参数: fadeOut(speed,callback) 自定义动画：animate() 注意：在使用animate方法之前，为了影响该元素的top left bottom right样式属性，必须先把元素的position样式设置为relative或者absolute 停止元素的动画 很多时候需要停止匹配正在进行的动画，需要使用stop() stop()语法结构：stop([clearQueue],[gotoEnd]); 都是可选参数，为布尔值 如果直接使用stop()方法，会立即停止当前正在进行的动画 判断元素是否处于动画状态 如果不处于动画状态，则为元素添加新的动画，否则不添加if(!$(element).is(&quot;:animated&quot;)){ //判断元素是否处于动画状态} 这个方法在animate动画中经常被用到，需要注意 延迟动画 在动画执行过程中，如果你想对动画进行延迟操作，那么使用delay() 用animate模拟show(): show: 表示由透明到不透明 toggle: 切换 hide:表示由显示到隐藏 动画方法总结 方法名 说明 hide()和show() 同时修改多个样式属性即高度和宽度和不透明度 fadeIn()和fadeOut() 只改变不透明度 slideUp()和slideDown() 只改变高度 fadeTo() 只改变不透明度 toggle() 用来代替show()和hide()方法，所以会同时修改多个属性即高度、宽度和不透明度 slideToggle() 用来代替slideUp和slideDown()方法，所以只能改变高度 fadeToggle() 用来代替fadeIn()和fadeOut方法，只能改变不透明度 animate() 属于自定义动画，以上各种动画方法都是调用了animate方法。此外，用animate方法还能自定义其他的样式属性，例如：left marginLeft `scrollTop`等 第七节 jQuery中的事件 事件对象的属性 event.type：获取事件的类型 event.target:获取到触发事件的元素 event.preventDefault方法 阻止默认事件行为 event.stopPropagation()阻止事件的冒泡 keyCode：只针对于keypress事件，获取键盘键数字 按下回车，13 event.pageX / event.pageY 获取到光标相对于页面的x坐标和y坐标 如果没有jQuery，在IE浏览器中用event.x / event.y;在Firefox浏览器中用event.pageX / event.pageY。如果页面上有滚动条还要加上滚动条的宽度和高度 event.clientX：光标对于浏览器窗口的水平坐标 浏览器 event.clientY：光标对于浏览器窗口的垂直坐标 event.screenX：光标对于电脑屏幕的水平坐标 电脑屏幕 event.screenY：光标对于电脑屏幕的水平坐标 event.which 该方法的作用是在鼠标单击事件中获取到鼠标的左、中、右键，在键盘事件中的按键 1代表左键 2代表中键 3代表右键 事件冒泡 什么是冒泡 在页面上可以有多个事件，也可以多个元素影响同一个元素 从里到外 嵌套关系 相同事件 其中的某一父类没有相同事件时,继续向上查找 停止事件冒泡 停止事件冒泡可以阻止事件中其他对象的事件处理函数被执行 在jQuery中提供了stopPropagation()方法 阻止默认行为 网页中元素有自己的默认行为，例如：单击超链接后会跳转、单击提交后表单会提交，有时需要阻止元素的默认行为 在jQuery中提供了preventDefault()方法来阻止元素的默认行为 事件捕获 事件捕获和冒泡是相反的过程，事件捕获是从最顶端往下开始触发 并非所有的浏览器都支持事件捕获，并且这个缺陷无法通过JavaScript来修复。jQuery不支持事件捕获，如需要用事件捕获，要用原生的JavaScript bind();绑定 为匹配元素绑定处理方法 需要给一个元素添加多个事件 ，事件执行一样时候 one()：只执行一次 绑定特定事件类型方法： 分类 方法名称 说明 页面载入 ready(fn) 当DOM载入就绪可以绑定一个要执行的函数 事件绑定 blind(type,[data],fn) 为每个匹配元素的特定事件绑定一个事件处理函数 事件绑定 unblind() 解除绑定 事件绑定 on(events,[,selector[,]data],handler) 在选择元素上绑定一个或者多个事件处理函数 事件绑定 off() 移除on绑定的事件 事件绑定 delegate(selector,eventType,handler) 为所有选择匹配元素附加一个或多个事件处理函数 事件绑定 undelegate() 移除绑定 事件动态 live(type,fn) 对动态生成的元素进行事件绑定 事件动态 die(type,fn) 移除live()绑定的事件 交互事件 hover() 鼠标移入移出 交互事件 toggle(fn1,fn2,[fn3],[fn4]) 每单击后依次调用函数 交互事件 blur(fn) 触发每一个匹配元素的blur事件 交互事件 change() 触发每一个匹配元素的change事件 交互事件 click() 触发每一个匹配元素的click事件 交互事件 focus() 触发每一个匹配元素的focus事件 交互事件 submit() 触发每一个匹配元素的submit事件 键盘事件 keydown() 触发每一个匹配元素的keydown事件 键盘事件 keypress() 触发每一个匹配元素的keypress事件 键盘事件 keyup() 触发每一个匹配元素的keyup事件 鼠标事件 mousedown(fn) 绑定一个处理函数 鼠标事件 mouseenter(fn) 绑定一个处理函数 键盘事件 mouseleave(fn) 绑定一个处理函数 键盘事件 mouseout(fn) 绑定一个处理函数 键盘事件 mouseover(fn) 绑定一个处理函数 窗口操作 resize(fn) 绑定一个处理函数 窗口操作 scroll(fn) 绑定一个处理函数 第八节 jQuery与Ajax Ajax简介 : Asynchronous Javascript And XML （异步的JavaScript和XML） 它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体 Ajax优势与不足 Ajax优势 优秀的用户体验 这是Ajax下最大的有点，能在不刷新整个页面前提下更新数据 提高web程序的性能 与传统模式相比，Ajax模式在性能上最大的区别在于传输数据的方式，在传统模式中，数据的提交时通过表单来实现的。Ajax模式只是通过XMLHttpRequest对象向服务器提交希望提交的数据，即按需发送 减轻服务器和带宽的负担 Ajax的工作原理相当于在用户和服务器之间加了一个中间层，似用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器负担的工作转移到客户端，便于客户端资源来处理，减轻服务器和带宽的负担 Ajax的不足 浏览器对XMLHttpRequest对象的支持度不足 破坏浏览器前进、后退按钮的正常功能 对搜索引擎的支持的不足 开发和调试工具的缺乏 创建一个Ajax请求 Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成 创建ajax对象 var xhr = new XMLHttpRequest(); 准备发送请求 get / post get 传递的数据放在URL后面 中文编码 encodeURI( &#39;&#39; ); 缓存 在数据后面加上随机数或者日期对象或者…… post 传递的数据放在send()里面，并且一定要规定数据格式 没有缓存问题 form表单中: action: method: (默认是get) get: 会在url里面以 name=value , 两个数据之间用 &amp; 连接 post: enctype: &quot;application/x-www-form-urlencoded&quot; url 是否异步 同步(false)：阻塞 异步(true)：非阻塞 正式发送请求 ajax请求处理过程 123456xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4) &#123; alert( xhr.responseText ); &#125;&#125;; onreadystatechange ：当处理过程发生变化的时候执行下面的函数 readyState ：ajax处理过程 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 responseText ：请求服务器返回的数据存在该属性里面 status : http状态码 HTTP状态码 案例：ajax封装案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ajax请求后台数据var btn = document.getElementsByTagName(\"input\")[0];btn.onclick = function()&#123; ajax(&#123;//json格式 type:\"post\", url:\"post.php\", data:\"username=poetries&amp;pwd=123456\", asyn:true, success:function(data)&#123; document.write(data); &#125; &#125;);&#125;//封装ajaxfunction ajax(aJson)&#123; var ajx = null; var type = aJson.type || \"get\"; var asyn = aJson.asyn || true; var url = aJson.url; // url 接收 传输位置 var success = aJson.success;// success 接收 传输完成后的回调函数 var data = aJson.data || '';// data 接收需要附带传输的数据 if(window.XMLHttpRequest)&#123;//兼容处理 ajx = new XMLHttpRequest();//一般浏览器 &#125;else &#123; ajx = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE6+ &#125; if (type == \"get\" &amp;&amp; data) &#123; url +=\"/?\"+data+\"&amp;\"+Math.random(); &#125; //初始化ajax请求 ajx.open( type , url , asyn ); //规定传输数据的格式 ajx.setRequestHeader('content-type','application/x-www-form-urlencoded'); //发送ajax请求（包括post数据的传输） type == \"get\" ?ajx.send():ajx.send(aJson.data); //处理请求 ajx.onreadystatechange = function(aJson)&#123; if(ajx.readState == 4)&#123; if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码 &#123; //请求成功处理数据 success &amp;&amp; success(ajx.responseText); &#125;else&#123; alert(\"请求出错\"+ajx.status); &#125; &#125; &#125;; jQuery中的Ajax [补充部分–来自锋利的jQuery] jquery对Ajax操作进行了封装，在jquery中的$.ajax()方法属于最底层的方法，第2层是load()、$.get()、$.post();第3层是$.getScript()、$.getJSON()，第2层使用频率很高 load()方法 load()方法是jquery中最简单和常用的ajax方法，能载入远程HTML代码并插入DOM中 结构为：load(url,[data],[callback]) 使用url参数指定选择符可以加载页面内的某些元素 load方法中url语法：url selector 注意：url和选择器之间有一个空格 传递方式 load()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，采用POST 回调参数 必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、XMLHttpRequest对象 只要请求完成，回调函数就会被触发 12345$(\"#testTest\").load(\"test.html\",function(responseText,textStatus,XMLHttpRequest)&#123; //respnoseText 请求返回的内容 //textStatus 请求状态 ：sucess、error、notmodified、timeout //XMLHttpRequest &#125;) load方法参数 参数名称 类型 说明 url String 请求HTML页面的URL地址 data(可选) Object 发送至服务器的key / value数据 callback(可选) Function 请求完成时的回调函数，无论是请求成功还是失败 $.get()和$.post()方法 load()方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用$.get()和$.post()或$.ajax()方法 注意：$.get()和$.post()方法是jquery中的全局函数 $.get()方法 $.get()方法使用GET方式来进行异步请求 结构为：$.get(url,[data],callback,type) 如果服务器返回的内容格式是xml文档，需要在服务器端设置Content-Type类型 代码如下：header(&quot;Content-Type:text/xml:charset=utf-8&quot;) //php $.get()方法参数解析 参数 类型 说明 url String 请求HTML页的地址 data(可选) Object 发送至服务器的key/ value 数据会作为QueryString附加到请求URL中 callback(可选) Function 载入成功的回调函数（只有当Response的返回状态是success才调用该方法） type(可选) String 服务器返回内容的格式，包括xml、html、script、json、text和_default $.post()方法 它与$.get()方法的结构和使用方式相同，有如下区别 GET请求会将参数跟张乃URL后进行传递，而POST请求则是作为Http消息的实体内容发送给web服务器，在ajax请求中，这种区别对用户不可见 GET方式对传输数据有大小限制（通常不能大于2KB），而使用POST方式传递的数据量要比GET方式大得多（理论不受限制） GET方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，GET方式会带来严重的安全问题，而POST相对来说可以避免这些问题 GET和POST方式传递的数据在服务端的获取也不相同。在PHP中，GET方式用$_GET[]获取；POST方式用$_POST[]获取;两种方式都可用$_REQUEST[]来获取 总结 使用load()、$.get()和$.post()方法完成了一些常规的Ajax程序，如果还需要复杂的Ajax程序，就需要用到$.ajax()方式 $.ajax()方法 $.ajax()方法是jquery最底层的Ajax实现，它的结构为$.ajax(options) 该方法只有一个参数，但在这个对象里包含了$.ajax()方式所需要的请求设置以及回调函等信息，参数以key / value存在，所有参数都是可选的 $.ajax()方式常用参数解析 参数 类型 说明 url String (默认为当前页地址)发送请求的地址 type String 请求方式（POST或GET）默认为GET timeout Number 设置请求超时时间（毫秒） dataType String 预期服务器返回的类型。可用的类型如下 xml:返回XML文档，可用jquery处理html:返回纯文本的HTML信息，包含的script标签也会在插入DOM时执行script：返回纯文本的javascript代码。不会自动缓存结果，除非设置cache参数。注意：在远程请求时，所有的POST请求都将转为GET请求json:返回JSON数据jsonp:JSONP格式，使用jsonp形式调用函数时，例如：myurl?call back=?,jquery将自动替换后一个？为正确的函数名，以执行回调函数text:返回纯文本字符串 beforeSend Function 发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次Ajax请求。XMLHttpRequest对象是唯一的参数 function(XMLHttpRequest){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this;//调用本次Ajax请求时传递的options参数} complete Function 请求完成后的回调函数（请求成功或失败时都调用） 参数：XMLHttpRequest对象和一个描述成功请求类型的字符串function(XMLHttpRequest,textStatus){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this;//调用本次Ajax请求时传递的options参数} success Function 请求成功后调用的回调函数，有两个参数(1)由服务器返回，并根据dataTyppe参数进行处理后的数据(2)描述状态的字符串function(data,textStatus){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//data可能是xmlDoc、`jsonObj、html、text等&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this;//调用本次Ajax请求时传递的options`参数} error Function 请求失败时被调用的函数 global Boolean 默认为true。表示是否触发全局Ajax事件，设置为false将不会触发。AjaxStart或AjaxStop可用于控制各种Ajax事件 第九节 插件 什么是插件 插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过js文件的方式引用。 插件分为哪几类 UI类、表单及验证类、输入类、特效类、Ajax类、滑动类、图形图像类、导航类、综合工具类、动画类等等 引入插件的步骤 引入jquery.js文件，而且在所以插件之前引入 引入插件 引入插件相关文件，比如皮肤、中文包 如何自定义插件： 插件形式分为3类： 封装对象方法插件 封装全局函数插件 选择器插件(类似于.find()) 自定义插件的规范（解决各种插件的冲突和错误，增加成功率） 命名：jquery.插件名.js 所有的新方法附加在jquery.fn对象上面，所有新功能附加在jquery上 所有的方法或插件必须用分号结尾，避免出问题 插件必须返回jQuery对象，便于链式连缀 避免插件内部使用$，如果要使用，请传递jQuery($并不是总等于jQuery，另外其他js框架也可能使用$) 插件中的this应该指向jQuery对象 使用this.each()迭代元素 自定义插件案例 为了方便用户创建插件，jQuery提供了 jQuery.extend() 和 jQuery.fn.extend() jQuery.extend()：创建工具函数或者是选择器 jQuery.fn.extend()：创建jQuery对象命令 （fn相当于prototype的别名） jQuery官方提供的插件开发模板 1234567891011121314;(function($)&#123; $.fn.plugin=function(options)&#123; var defaults = &#123; //各种参数 各种属性 &#125; var options = $.extend(defaults,options); this.each(function()&#123; //实现功能的代码 &#125;); return this; &#125;&#125;)(jQuery); 自定义jQuery函数： 1234567(function($)&#123; $.extend(&#123; test: function()&#123; alert(\"hello plugin\"); &#125; &#125;) &#125;)(jQuery); 自定义jQuery命令： 形式1： 1234567(function($)&#123; $.fn.extend(&#123; say : function()&#123; alert(\"hello plugin\"); &#125; &#125;)&#125;)(jQuery); 形式2： 123456(function($)&#123; $.fn.say = function()&#123; alert(\"hello plugin\"); &#125;; &#125;)(jQuery); 附录一 jQuery各个版本新增的一些常用的方法 jQuery1.3新增常用的方法 方法 说明 .closest() 从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素 die() 从元素中删除先前用live()方法绑定的所有的事件 live() 附加一个事件处理器到符合目前选择器的所有元素匹配 jQuery1.4新增常用的方法 方法 说明 .first() 获取集合中第一个元素 last() 获取集合中最后一个元素 has(selector) 保留包含特定后代的元素，去掉那些不含有指定后代的元素 detach() 从DOM中去掉所有匹配的元素。detach()和remov()一样，除了detach()保存了所有jquery数据和被移走的元素相关联。当需要移走一个元素，不久又将该元素插入DOM时，这种方法很有用 delegate() 为所有选择器匹配的元素附加一个处理一个或多个事件 undelegate() 为所有选择器匹配的元素删除一个处理一个或多个事件 jQuery1.6新增常用的方法 方法 说明 prop(proptyName) 获取在匹配元素集合中的第一个元素的属性值 removeProp(proptyName,value) 为匹配的元素删除设置的属性 :focus 选择当前获取焦点的元素 附录二 jQuery性能优化 性能优化 使用最新版的jQuery类库 使用合适的选择器 $(#id) 使用id来定位DOM元素是最佳的方式，为了提高性能，建议从最近的ID元素开始往下搜索 $(&quot;p&quot;) , $(&quot;div&quot;) , $(&quot;input&quot;) 标签选择器性能也不错，它是性能优化的第二选择。因为jQuery将直接调用本地方法document.getElementsByTagName()来定位DOM元素 $(&quot;.class&quot;) 建议有选择性的使用 $(&quot;[attribute=value]&quot;) 对这个利用属性定位DOM元素，本地JavaScript并没有直接实现。这种方式性能并不是很理想。建议避免使用。 $(&quot;:hidden&quot;) 和上面利用属性定位DOM方式类似，建议尽量不要使用 注意的地方 尽量使用ID选择器 尽量给选择器指定上下文 缓存对象 如果你需要在其他函数中使用jQuery对象，你可以把他们缓存在全局环境中 数组方式使用jQuery对象 使用jQuery选择器获取的结果是一个jQuery对象。在性能方面，建议使用for或while循环来处理，而不是$.each() 事件代理 每一个JavaScript事件（如：click、mouseover）都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点很有用。比如，我们要为一个表单绑定这样的行为：点击td后，把背景颜色设置为红色 $(&quot;#myTable td&quot;).click(function(){$(this).css(&quot;background&quot;,&quot;red&quot;);}); 假设有100个td元素，在使用以上的方式时，绑定了100个事件，将带来性能影响 代替这种多元素的事件监听方法是，你只需向他们的父节点绑定一次事件，然后通过event.target获取到点击的当前元素 $(&quot;#myTable td&quot;).click(function({$(e.target).css(&quot;background&quot;,&quot;red&quot;)}); e.target捕捉到触发的目标 在jQuery1.7中提供了一个新的方法on()，来帮助你将整个事件监听封装到一个便利的方法中 $(&quot;#myTable td&quot;).on(&quot;click&quot;,&#39;td&#39;,function(){$(this).css(&quot;background&quot;,&quot;red&quot;);}); 将你的代码转化成jQuery插件 它能够使你的代码有更好的重用性，并且能够有效的帮助你组织代码 使用join()方法来拼接字符串 也许你之前使用+来拼接字符串，现在可以改了。它确实有助于性能优化，尤其是长字符串处理的时候 合理使用HTML5和Data属性 HTML5的data属性可以帮助我们插入数据，特别是后端的数据交换。jQuery的Data()方法有效利用HTML5的属性 例如：&lt;div id=&quot;dl&quot; data-role=&quot;page&quot; data-list-value=&quot;43&quot; data-options=&#39;{&quot;name:&quot;&quot;John&quot;}&#39;&gt; 为了读取数据，你需要使用如下代码 $(&quot;#dl&#39;).data(&quot;role&#39;;//page) $(&quot;#dl&#39;).data(&quot;lastValue&#39;;//43) $(&quot;#dl&#39;).data(&quot;options&#39;;//john) 尽量使用原生的JavaScript方法 压缩JavaScript代码 一方面使用Gzip；另一方面去除JavaScript文件里面的注释、空白 附录三 常用的jQuery代码片段 禁用页面的右键菜单 12345$(document).ready(functuion()&#123; $(document).bind(\"contextmenu\",function(e)&#123; return false; &#125;); &#125;); 新窗口打开页面 1234567891011$(document).ready(function()&#123; //例子1：href=\"http://\"的链接将会在新窗口打开链接 $('a[href=^=\"http://\"]').attr(\"target\",\"_blank\"); //例子2：rel=\"external\"的超链接将会在新窗口打开链接 $(\"a[rel$='external']\").click(function()&#123; this.target = \"_blank\"; &#125;);&#125;);//use&lt;a href=\"http://baidu.com\" rel=\"external\"&gt;open&lt;/a&gt; 判断浏览器类型 123456789101112131415161718192021222324252627282930313233$(document).reday(function()&#123; //Firefox2 and above if( $.browser.mozilla &amp;&amp; $.browser.version&gt;=\"1.8\")&#123; //do something &#125; // Safari if($.browser.safari)&#123; //do something &#125; // Chrome if($.browser.chrome)&#123; //do something &#125; // Opera if($.browser.opera)&#123; //do something &#125;&#125;) // IE6 and blow if($.browser.msie &amp;&amp; $.browser.version&lt;=6)&#123; //do something &#125; // anything above IE6 if($.browser.msie &amp;&amp; $.browser.version &gt; 6)&#123; //do something &#125; 输入框文字获取和失去焦点 123456789101112131415161718$(document).ready(function()&#123; $(\"input.text1\").val(\"Enter you search text here\"); textFill($('input.text1'));&#125;);function textFill(input)&#123;//input focus text function var originvalue = input.val(); input.focus(funtion()&#123; if($.trim(input.val())== originvalue)&#123; input.val(' '); &#125; &#125;).blur(function()&#123; if($.trim(input.val()) == ' ')&#123; input.val(originalvalue); &#125; &#125;)&#125; 获取鼠标位置 123456$(document).ready(function()&#123; $(document).mousemove(function(e)&#123; $(\"#XY\").html(\"X:\" + e.pageX+ \"| Y\" + e.pageY); &#125;);&#125;); 判断元素是否存在 12345$(document).ready(function()&#123; if($(\"#id\").length)&#123; // do some thing &#125;&#125;) 点击div也可以跳转 1234567$(\"div\").click(function()&#123; window.location = $(this).find(\"a\").attr(\"href\");&#125;)//use&lt;div&gt;&lt;a href=\"index.html\"&gt;home&lt;/a&gt;&lt;/div&gt; 设置div在屏幕中央 1234567891011$(document).ready(function()&#123; jQuery.fn.center = function()&#123; this.css(\"position\",\"absolute\"); this.css(\"top\",($(window).height() - this.lenght()) / 2 +$(window).scrollTop() + \"px\"); this.css(\"left\",($(window).height() - this.lenght()) / 2 +$(window).scrollLeft() + \"px\"); return this; &#125;//use $(\"#XY\").center();&#125;); 关闭所有动画效果 123$(document).ready(function()&#123; jQuery.fx.off = true;&#125;); 检测鼠标的右键和左键 12345$(document).ready(function()&#123; $(\"#xy\").mousedown(function(e)&#123; alert(e.which);//1 = 鼠标左键 2= 鼠标中间 3 = 鼠标右键 &#125;);&#125;); 回车提交表单 1234567$(document).ready(function()&#123; $(\"input\").keyup(function(e)&#123; if(e.which == \"13\")&#123; alert(\"回车提交\"); &#125; &#125;)&#125;); 设置全局的Ajax参数 12345678$(\"#load\").ajaxStart(function()&#123; showLoading();//显示loading disableButtons() //禁用按钮&#125;) $(\"#load\").ajaxComplete(function()&#123; hideLoading();//隐藏loading enableButtons();//启用按钮&#125;) 获取选中的下拉框 12$(\"#someElement\").find('option:selected');$(\"#someElement option:selected\"); 切换复选框 12345var tog = false;$(\"button\").click(function()&#123; $(\"input[type=checkbox]').attr(\"checked\",!tog); tog = !tog;&#125;); 个性化链接 12345$(document).ready(function()&#123; $(\"a[href$='pdf']\").addClass(\"pdf\"); $(\"a[href$='zip']\").addClass(\"zip\"); $(\"a[href$='psd']\").addClass(\"psd\");&#125;); 在一段时间后自动隐藏或关闭元素 123456setTimeOut(function()&#123; $(\"div\").fadeIn(400); &#125;,3000);//而在1.4之后的版本可以用delay()来实现$(\"div\").slideUp(300).delay(3000).fadeIn(400); 使用事件代理绑定元素 123456789101112131415161718 //为table里面的td元素绑定click事件，不管td是一直存在还是动态创建的 //jQuery 1.4.2之前使用这种方式 $(\"table\").each(function()&#123; $(\"td\",this).live(\"click\",function()&#123; $(this).toggleClass(\"hover\"); &#125;);&#125;);//jquery 1.4.2使用的方式$(\"table\").delegate(\"td\",\"click\",function()&#123; $(this).toggleClass(\"hover\");&#125;);//jQuery1.7.1使用的方式$(\"table\").on(\"click\",\"td\",function()&#123; $(this).toggleClass(\"hover\"); &#125;) 预加载图片 123456789101112(function($) &#123; var cache = []; // Arguments are image paths relative to the current page. $.preLoadImages = function() &#123; var args_len = arguments.length; for (var i = args_len; i--;) &#123; var cacheImage = document.createElement('img'); cacheImage.src = arguments[i]; cache.push(cacheImage); &#125; &#125;jQuery.preLoadImages(\"image1.gif\", \"/path/to/image2.png\"); 让页面中的每个元素都适合在移动设备上展示 1234567891011var scr = document.createElement('script');scr.setAttribute('src', 'https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js');document.body.appendChild(scr);scr.onload = function()&#123; $('div').attr('class', '').attr('id', '').css(&#123; 'margin' : 0, 'padding' : 0, 'width': '100%', 'clear':'both' &#125;);&#125;; 图像等比例缩放 1234567891011121314151617181920212223242526$(window).bind(\"load\", function() &#123; // IMAGE RESIZE $('#product_cat_list img').each(function() &#123; var maxWidth = 120; var maxHeight = 120; var ratio = 0; var width = $(this).width(); var height = $(this).height(); if(width &gt; maxWidth)&#123; ratio = maxWidth / width; $(this).css(\"width\", maxWidth); $(this).css(\"height\", height * ratio); height = height * ratio; &#125; var width = $(this).width(); var height = $(this).height(); if(height &gt; maxHeight)&#123; ratio = maxHeight / height; $(this).css(\"height\", maxHeight); $(this).css(\"width\", width * ratio); width = width * ratio; &#125; &#125;); //$(\"#contentpage img\").show(); // IMAGE RESIZE&#125;); 返回页面顶部 12345678// Back To Top$(document).ready(function()&#123; $('.top').click(function() &#123; $(document).scrollTo(0,500); &#125;);&#125;); //Create a link defined with the class .top&lt;a href=\"#\" class=\"top\"&gt;Back To Top&lt;/a&gt; 使用jQuery打造手风琴式的折叠效果 1234567891011121314151617181920212223var accordion = &#123; init: function()&#123; var $container = $('#accordion'); $container.find('li:not(:first) .details').hide(); $container.find('li:first').addClass('active'); $container.on('click','li a',function(e)&#123; e.preventDefault(); var $this = $(this).parents('li'); if($this.hasClass('active'))&#123; if($('.details').is(':visible')) &#123; $this.find('.details').slideUp(); &#125; else &#123; $this.find('.details').slideDown(); &#125; &#125; else &#123; $container.find('li.active .details').slideUp(); $container.find('li').removeClass('active'); $this.addClass('active'); $this.find('.details').slideDown(); &#125; &#125;); &#125;&#125;; 使用jQuery和Ajax自动填充选择框 12345678910111213$(function()&#123;$(\"select#ctlJob\").change(function()&#123;$.getJSON(\"/select.php\",&#123;id: $(this).val(), ajax: 'true'&#125;, function(j)&#123;var options = '';for (var i = 0; i &lt; j.length; i++) &#123;options += '' + j[i].optionDisplay + '';&#125;$(\"select#ctlPerson\").html(options);&#125;)&#125;)&#125;) 自动替换丢失的图片 12345678// Safe Snippet$(\"img\").error(function () &#123; $(this).unbind(\"error\").attr(\"src\", \"missing_image.gif\");&#125;);// Persistent Snipper$(\"img\").error(function () &#123; $(this).attr(\"src\", \"missing_image.gif\");&#125;); 预防对表单进行多次提交 123456789101112131415$(document).ready(function() &#123; $('form').submit(function() &#123; if(typeof jQuery.data(this, \"disabledOnSubmit\") == 'undefined') &#123; jQuery.data(this, \"disabledOnSubmit\", &#123; submited: true &#125;); $('input[type=submit], input[type=button]', this).each(function() &#123; $(this).attr(\"disabled\", \"disabled\"); &#125;); return true; &#125; else &#123; return false; &#125; &#125;);&#125;); 动态添加表单元素 12345//change event on password1 field to prompt new input$('#password1').change(function() &#123; //dynamically create new input and insert after password1 $(\"#password1\").append(\"\");&#125;); 在窗口滚动时自动加载内容 123456789101112131415161718var loading = false;$(window).scroll(function()&#123; if((($(window).scrollTop()+$(window).height())+250)&gt;=$(document).height())&#123; if(loading == false)&#123; loading = true; $('#loadingbar').css(\"display\",\"block\"); $.get(\"load.php?start=\"+$('#loaded_max').val(), function(loaded)&#123; $('body').append(loaded); $('#loaded_max').val(parseInt($('#loaded_max').val())+50); $('#loadingbar').css(\"display\",\"none\"); loading = false; &#125;); &#125; &#125;&#125;);$(document).ready(function() &#123; $('#loaded_max').val(50);&#125;); 导航菜单背景切换效果 1234567891011121314&lt;ul id='nav'&gt; &lt;li&gt;导航一&lt;/li&gt; &lt;li&gt;导航二&lt;/li&gt; &lt;li&gt;导航三&lt;/li&gt;&lt;/ul&gt;//注意：代码需要修饰完善$('#nav').click(function(e) &#123; // 要知道siblings的使用 $(e.target).addClass('tclass').siblings('.tclass').removeClass('tclass');; &#125;); 解决jQuery, prototype共存，$全局变量冲突问题 12345&lt;script src=\"prototype.js\"&gt;&lt;/script&gt;&lt;script src=\"http://blogbeta.blueidea.com/jquery.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; jQuery.noConflict();&lt;/script&gt; 注意：一定要先引入prototype.js 再引入jquery.js，先后顺序不可错 jQuery 判断元素上是否绑定了事件 12345//jQuery event封装支持判断元素上是否绑定了事件，此方法只适用于jQuery绑定的事件var $events = $(\"#foo\").data(\"events\");if( $events &amp;&amp; $events[\"click\"] )&#123; //your code&#125; 如何正确地使用toggleClass 12345//切换（toggle）类允许你根据某个类的//是否存在来添加或是删除该类。//这种情况下有些开发者使用：a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton');//toggleClass允许你使用下面的语句来很容易地做到这一点a.toggleClass('blueButton'); 如何设置IE特有的功能 123if ($.browser.msie) &#123; // Internet Explorer就是个虐待狂&#125; 如何验证某个元素是否为空 12345678// 方法一if (! $('#keks').html()) &#123; //什么都没有找到;&#125;// 方法二if ($('#keks').is(\":empty\")) &#123; //什么都没有找到;&#125; 访问IFrame里的元素 123var iFrameDOM = $(\"iframe#someID\").contents();//然后，就可以通过find方法来遍历获取iFrame中的元素了iFrameDOM.find(\".message\").slideUp(); 管理搜索框的值 现在各大网站都有搜索框，而搜索框通常都有默认值，当输入框获取焦点时，默认值消失。而一旦输入框失去焦点，而输入框里又没有输入新的值，输入框里的值又会恢复成默认值，如果往输入框里输入了新值，则输入框的值为新输入的值。这种特效用JQuery很容易实现 1234567$(\"#searchbox\") .focus(function()&#123; $(this).val('')&#125;) .blur(function()&#123; var $this = $(this); // '请搜索...'为搜索框默认值 ($this.val() === '')? $this.val('请搜索...') : null; &#125;); 部分页面加载更新 为了提高web性能，有更新时我们通常不会加载整个页面，而只是仅仅更新部分页面内容，如图片的延迟加载等。页面部分刷新的特效在JQuery中也很容易实现 1234setInterval(function() &#123; //每隔5秒钟刷新页面内容 //获取的内容将增加到 id为content的元素后 $(\"#content\").load(url); &#125;, 5000); 采配置JQuery与其它库的兼容性 如果在项目中使用JQuery，$ 是最常用的变量名，但JQuery并不是唯一一个使用$作为变量名的库，为了避免命名冲突，你可以按照下面方式来组织你的代码 12345678//方法一： 为JQuery重新命名为 $jvar $j = jQuery.noConflict();$j('#id').... //方法二： 推荐使用的方式(function($)&#123; $(document).ready(function()&#123; //这儿，你可以正常的使用JQuery语法 &#125;);&#125;)(jQuery); 测试密码的强度 在某些网站注册时常常会要求设置密码，网站也会根据输入密码的字符特点给出相应的提示，如密码过短、强度差、强度中等、强度强等。这又是怎么实现的呢？看下面代码： 1&lt;input type=\"password\" name=\"pass\" id=\"pass\" /&gt; &lt;span id=\"passstrength\"&gt;&lt;/span&gt; 1234567891011121314151617181920212223242526//下面的正则表达式建议各位收藏哦，项目上有可能会用得着$('#pass').keyup(function(e) &#123; //密码为八位及以上并且字母数字特殊字符三项都包括 var strongRegex = new RegExp(\"^(?=.&#123;8,&#125;)(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*\\\\W).*$\", \"g\"); //密码为七位及以上并且字母、数字、特殊字符三项中有两项，强度是中等 var mediumRegex = new RegExp(\"^(?=.&#123;7,&#125;)(((?=.*[A-Z])(?=.*[a-z]))|((?=.*[A-Z])(?=.*[0-9]))|((?=.*[a-z])(?=.*[0-9]))).*$\", \"g\"); var enoughRegex = new RegExp(\"(?=.&#123;6,&#125;).*\", \"g\"); if (false == enoughRegex.test($(this).val())) &#123; $('#passstrength').html('More Characters'); &#125; else if (strongRegex.test($(this).val())) &#123; $('#passstrength').className = 'ok'; $('#passstrength').html('Strong!'); &#125; else if (mediumRegex.test($(this).val())) &#123; $('#passstrength').className = 'alert'; $('#passstrength').html('Medium!'); &#125; else &#123; $('#passstrength').className = 'error'; $('#passstrength').html('Weak!'); &#125; return true;&#125;); 附录四 常见CND加速服务 Bootstrap中文网开源项目免费 CDN 服务 百度静态资源公共库 360网站卫士常用前端公共库CDN服务–已停止服务 开放静态文件 CDN 微软CDN服务 阿里云 百度开放云平台 jQuery CDN jQuery cdn加速 新浪CDN 附录五 jQuery的一些资源 速查手册 jQuery API 中文文档–css88 jQuery-overapi 在线桌面版API 更多详情—一份实用的API参考手册集合 jQuery插件 基础常用 滚动固定在某个位置 jQuery图片滚动插件全能版 jQuery Wookmark Load 瀑布流布局 jQuery Jcrop 图像裁剪 jQuery kxbdMarquee 无缝滚动 jQuery lightBox 灯箱效果 Lazy Load Plugin for jQuery 更多插件-动效库整理 插件动效库 常用组件 扩展阅读 jQuery源码分析系列 参考 锋利的jQuery 本文md源文件","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"express、express-session实现了简易的登录","slug":"express、express-session实现了简易的登录","date":"2016-01-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/20/express、express-session实现了简易的登录/","link":"","permalink":"http://yoursite.com/2016/01/20/express、express-session实现了简易的登录/","excerpt":"","text":"文档概览本文基于express、express-session实现了简易的登录/登出功能，完整的代码示例可以在这里找到。 环境初始化首先，初始化项目 1express -e 然后，安装依赖。 1npm install 接着，安装session相关的包。 1npm install --save express-session session-file-store session相关配置配置如下，并不复杂，可以见代码注释，或者参考官方文档。 1234567891011121314151617var express = require('express');var app = express();var session = require('express-session');var FileStore = require('session-file-store')(session);var identityKey = 'skey';app.use(session(&#123; name: identityKey, secret: 'chyingp', // 用来对session id相关的cookie进行签名 store: new FileStore(), // 本地存储session（文本文件，也可以选择其他store，比如redis的） saveUninitialized: false, // 是否自动保存未初始化的会话，建议false resave: false, // 是否每次都重新保存会话，建议false cookie: &#123; maxAge: 10 * 1000 // 有效期，单位是毫秒 &#125;&#125;)); 实现登录/登出接口创建测试账户数据首先，在本地创建个文件，来保存可用于登录的账户信息，避免创建链接数据库的繁琐。 123456// users.jsmodule.exports = &#123; items: [ &#123;name: 'chyingp', password: '123456'&#125; ]&#125;; 登录、登出接口实现实现登录、登出接口，其中： 登录：如果用户存在，则通过req.regenerate创建session，保存到本地，并通过Set-Cookie将session id保存到用户侧； 登出：销毁session，并清除cookie； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var users = require('./users').items;var findUser = function(name, password)&#123; return users.find(function(item)&#123; return item.name === name &amp;&amp; item.password === password; &#125;);&#125;;// 登录接口app.post('/login', function(req, res, next)&#123; var sess = req.session; var user = findUser(req.body.name, req.body.password); if(user)&#123; req.session.regenerate(function(err) &#123; if(err)&#123; return res.json(&#123;ret_code: 2, ret_msg: '登录失败'&#125;); &#125; req.session.loginUser = user.name; res.json(&#123;ret_code: 0, ret_msg: '登录成功'&#125;); &#125;); &#125;else&#123; res.json(&#123;ret_code: 1, ret_msg: '账号或密码错误'&#125;); &#125; &#125;);// 退出登录app.get('/logout', function(req, res, next)&#123; // 备注：这里用的 session-file-store 在destroy 方法里，并没有销毁cookie // 所以客户端的 cookie 还是存在，导致的问题 --&gt; 退出登陆后，服务端检测到cookie // 然后去查找对应的 session 文件，报错 // session-file-store 本身的bug req.session.destroy(function(err) &#123; if(err)&#123; res.json(&#123;ret_code: 2, ret_msg: '退出登录失败'&#125;); return; &#125; // req.session.loginUser = null; res.clearCookie(identityKey); res.redirect('/'); &#125;);&#125;); 登录态判断用户访问 http://127.0.0.1:3000 时，判断用户是否登录，如果是，则调到用户详情界面（简陋无比）；如果没有登录，则跳到登录界面； 12345678910app.get('/', function(req, res, next)&#123; var sess = req.session; var loginUser = sess.loginUser; var isLogined = !!loginUser; res.render('index', &#123; isLogined: isLogined, name: loginUser || '' &#125;);&#125;); UI界面最后，看下登录、登出UI相关的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;会话管理&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;会话管理&lt;/h1&gt;&lt;% if(isLogined)&#123; %&gt; &lt;p&gt;当前登录用户：&lt;%= name %&gt;，&lt;a href=\"/logout\" id=\"logout\"&gt;退出登陆&lt;/a&gt;&lt;/p&gt;&lt;% &#125;else&#123; %&gt; &lt;form method=\"POST\" action=\"/login\"&gt; &lt;input type=\"text\" id=\"name\" name=\"name\" value=\"chyingp\" /&gt; &lt;input type=\"password\" id=\"password\" name=\"password\" value=\"123456\" /&gt; &lt;input type=\"submit\" value=\"登录\" id=\"login\" /&gt; &lt;/form&gt;&lt;% &#125; %&gt; &lt;script type=\"text/javascript\" src=\"/jquery-3.1.0.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $('#login').click(function(evt)&#123; evt.preventDefault(); $.ajax(&#123; url: '/login', type: 'POST', data: &#123; name: $('#name').val(), password: $('#password').val() &#125;, success: function(data)&#123; if(data.ret_code === 0)&#123; location.reload(); &#125; &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 相关链接https://github.com/expressjs/session","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"Nodejs实现文件上传","slug":"nodejs文件上传","date":"2016-01-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/20/nodejs文件上传/","link":"","permalink":"http://yoursite.com/2016/01/20/nodejs文件上传/","excerpt":"","text":"关于作者正在填坑：《Nodejs学习笔记》 / 《Express学习笔记》 社区链接：云栖社区 / github / 新浪微博 / 知乎 / Segmentfault / 博客园 / 站酷 概览图片上传是web开发中经常用到的功能，node社区在这方面也有了相对完善的支持。 常用的开源组件有multer、formidable等，借助这两个开源组件，可以轻松搞定图片上传。 本文主要讲解以下内容，后续章节会对技术实现细节进行深入挖掘。本文所有例子均有代码示例，可在这里查看。 基础例子：借助express、multer实现单图、多图上传。 常用API：获取上传的图片的信息。 进阶使用：自定义保存的图片路径、名称。 环境初始化非常简单，一行命令。 1npm install express multer multer --save 每个示例下面，都有下面两个文件 1234➜ upload-custom-filename git:(master) ✗ tree -L 1.├── app.js # 服务端代码，用来处理文件上传请求├── form.html # 前端页面，用来上传文件 基础例子：单图上传完整示例代码请参考这里。 app.js。 123456789101112131415161718var fs = require('fs');var express = require('express');var multer = require('multer')var app = express();var upload = multer(&#123; dest: 'upload/' &#125;);// 单图上传app.post('/upload', upload.single('logo'), function(req, res, next)&#123; res.send(&#123;ret_code: '0'&#125;);&#125;);app.get('/form', function(req, res, next)&#123; var form = fs.readFileSync('./form.html', &#123;encoding: 'utf8'&#125;); res.send(form);&#125;);app.listen(3000); form.html。 12345&lt;form action=\"/upload-single\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;h2&gt;单图上传&lt;/h2&gt; &lt;input type=\"file\" name=\"logo\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 运行服务。 1node app.js 访问 http://127.0.0.1:3000/form ，选择图片，点击“提交”，done。然后，你就会看到 upload 目录下多了个图片。 基础例子：多图上传完整示例代码请参考这里。 代码简直不能更简单，将前面的 upload.single(‘logo’) 改成 upload.array(‘logo’, 2) 就行。表示：同时支持2张图片上传，并且 name 属性为 logo。 app.js。 123456789101112131415161718var fs = require('fs');var express = require('express');var multer = require('multer')var app = express();var upload = multer(&#123; dest: 'upload/' &#125;);// 多图上传app.post('/upload', upload.array('logo', 2), function(req, res, next)&#123; res.send(&#123;ret_code: '0'&#125;);&#125;);app.get('/form', function(req, res, next)&#123; var form = fs.readFileSync('./form.html', &#123;encoding: 'utf8'&#125;); res.send(form);&#125;);app.listen(3000); form.html。 123456&lt;form action=\"/upload-multi\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;h2&gt;多图上传&lt;/h2&gt; &lt;input type=\"file\" name=\"logos\"&gt; &lt;input type=\"file\" name=\"logos\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 同样的测试步骤，不赘述。 获取上传的图片的信息完整示例代码请参考这里。 很多时候，除了将图片保存在服务器外，我们还需要做很多其他事情，比如将图片的信息存到数据库里。 常用的信息比如原始文件名、文件类型、文件大小、本地保存路径等。借助multer，我们可以很方便的获取这些信息。 还是单文件上传的例子，此时，multer会将文件的信息写到 req.file 上，如下代码所示。 app.js。 12345678910111213141516171819202122232425var fs = require('fs');var express = require('express');var multer = require('multer')var app = express();var upload = multer(&#123; dest: 'upload/' &#125;);// 单图上传app.post('/upload', upload.single('logo'), function(req, res, next)&#123; var file = req.file; console.log('文件类型：%s', file.mimetype); console.log('原始文件名：%s', file.originalname); console.log('文件大小：%s', file.size); console.log('文件保存路径：%s', file.path); res.send(&#123;ret_code: '0'&#125;);&#125;);app.get('/form', function(req, res, next)&#123; var form = fs.readFileSync('./form.html', &#123;encoding: 'utf8'&#125;); res.send(form);&#125;);app.listen(3000); form.html。 12345&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;h2&gt;单图上传&lt;/h2&gt; &lt;input type=\"file\" name=\"logo\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 启动服务，上传文件后，就会看到控制台下打印出的信息。 1234文件类型：image/png原始文件名：1.png文件大小：18379文件保存路径：upload/b7e4bb22375695d92689e45b551873d9 自定义文件上传路径、名称有的时候，我们想要定制文件上传的路径、名称，multer也可以方便的实现。 自定义本地保存的路径非常简单，比如我们想将文件上传到 my-upload 目录下，修改下 dest 配置项就行。 1var upload = multer(&#123; dest: &apos;upload/&apos; &#125;); 在上面的配置下，所有资源都是保存在同个目录下。有时我们需要针对不同文件进行个性化设置，那么，可以参考下一小节的内容。 自定义本地保存的文件名完整示例代码请参考这里。 代码稍微长一点，单同样简单。multer 提供了 storage 这个参数来对资源保存的路径、文件名进行个性化设置。 使用注意事项如下： destination：设置资源的保存路径。注意，如果没有这个配置项，默认会保存在 /tmp/uploads 下。此外，路径需要自己创建。 filename：设置资源保存在本地的文件名。 app.js。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var fs = require(&apos;fs&apos;);var express = require(&apos;express&apos;);var multer = require(&apos;multer&apos;)var app = express();var createFolder = function(folder)&#123; try&#123; fs.accessSync(folder); &#125;catch(e)&#123; fs.mkdirSync(folder); &#125; &#125;;var uploadFolder = &apos;./upload/&apos;;createFolder(uploadFolder);// 通过 filename 属性定制var storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, uploadFolder); // 保存的路径，备注：需要自己创建 &#125;, filename: function (req, file, cb) &#123; // 将保存文件名设置为 字段名 + 时间戳，比如 logo-1478521468943 cb(null, file.fieldname + &apos;-&apos; + Date.now()); &#125;&#125;);// 通过 storage 选项来对 上传行为 进行定制化var upload = multer(&#123; storage: storage &#125;)// 单图上传app.post(&apos;/upload&apos;, upload.single(&apos;logo&apos;), function(req, res, next)&#123; var file = req.file; res.send(&#123;ret_code: &apos;0&apos;&#125;);&#125;);app.get(&apos;/form&apos;, function(req, res, next)&#123; var form = fs.readFileSync(&apos;./form.html&apos;, &#123;encoding: &apos;utf8&apos;&#125;); res.send(form);&#125;);app.listen(3000); form.html。 12345&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;h2&gt;单图上传&lt;/h2&gt; &lt;input type=\"file\" name=\"logo\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 测试步骤不赘述，访问一下就知道效果了。 写在后面本文对multer的基础用法进行了介绍，并未涉及过多原理性的东西。俗话说 授人以渔不如授人以渔，在后续的章节里，会对文件上传的细节进行挖掘，好让读者朋友对文件上传加深进一步的认识。 相关链接multer官方文档：https://github.com/expressjs/multer","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"Nodejs的async","slug":"nodejs的async","date":"2016-01-20T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/20/nodejs的async/","link":"","permalink":"http://yoursite.com/2016/01/20/nodejs的async/","excerpt":"","text":"async模块是为了解决嵌套金字塔,和异步流程控制而生.常用的方法介绍1.安装 npm install async --save2.引入 var async = require(&#39;async&#39;) 1var async = require(&apos;async&apos;) //series: 串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。 //parallel：并行(parallel) 并行无关联 一个函数数组中的每个函数同步执行。 没有使用async的串行查询数据库123456789101112131415161718DB.find(&apos;user&apos;,function()&#123; DB.find(&apos;admin&apos;,function()&#123; DB.find(&apos;admin&apos;,function()&#123; DB.find(&apos;admin&apos;,function()&#123; res.render(&apos;index&apos;，&#123; &#125;) &#125;) &#125;) &#125;)&#125;) 使用async的串行查询数据库串行series1.数组方式 console.time()console.timeEnd()//打印执行时间123456789101112131415161718192021222324252627282930313233343536console.time(&apos;test&apos;);async.series([ function(callback)&#123; /*异步*/ setTimeout(function()&#123; callback(null,&apos;one&apos;) &#125;,2000) &#125;, function(callback)&#123; /*异步*/ setTimeout(function()&#123; callback(null,&apos;two&apos;) &#125;,3000) &#125; , function(callback)&#123; /*异步*/ setTimeout(function()&#123; callback(null,&apos;three&apos;) &#125;,1000) &#125;],function(err,data)&#123; console.timeEnd(&apos;test&apos;) console.log(data);&#125;) 2.对象方式 123456789101112131415161718192021222324252627282930console.time(&apos;list&apos;);async.series(&#123; list:function(callback)&#123; //新闻列表 setTimeout(function()&#123; callback(null,&apos;新闻列表&apos;) &#125;,1000) &#125;, cate:function(callback)&#123; //分类 setTimeout(function()&#123; callback(null,&apos;新闻分类&apos;) &#125;,1000) &#125;&#125;,function(err,data)&#123; console.timeEnd(&apos;list&apos;); console.log(data);&#125;) 并行 paraller123456789101112131415161718192021222324252627//并行console.time(&apos;list&apos;);async.parallel(&#123; list:function(callback)&#123; //新闻列表 setTimeout(function()&#123; callback(null,&apos;新闻列表&apos;) &#125;,3000) &#125;, cate:function(callback)&#123; //分类 setTimeout(function()&#123; callback(null,&apos;新闻分类&apos;) &#125;,2000) &#125;&#125;,function(err,data)&#123; console.timeEnd(&apos;list&apos;); console.log(data);&#125;)","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"jQuery之DOM操作小结","slug":"jQuery-dom","date":"2016-01-14T02:20:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/14/jQuery-dom/","link":"","permalink":"http://yoursite.com/2016/01/14/jQuery-dom/","excerpt":"一、过滤器 1 匹配指定元素的父 elem.parent([exp]) 2 匹配指定元素的子元素","text":"一、过滤器 1 匹配指定元素的父 elem.parent([exp]) 2 匹配指定元素的子元素 elem.children([exp]) 3 匹配指定元素的父、祖元素… elem.parents([exp]) 4 匹配指定元素的子、孙元素… elem.find([exp]) 5 匹配指定元素的后一个兄弟元素 elem.next([exp]) 6 匹配指定元素的后面所有兄弟元素 elem.nextAll([exp]) 7 匹配指定元素的前一个兄弟元素 elem.prev([exp]) 8 匹配指定元素的前面所有兄弟元素 elem.prevAll([exp]) 9 匹配指定元素的所有兄弟元素 elem.siblings([exp]) 10 匹配指定以外的元素 elem.not(exp) 11 包括自身在内的全部元素 elem.andSelf() 12 返回指定索引值的元素 elem.eq(index) 13 判断元素是否包含指定的类 elem.hasClass(className) 二、文档处理 1 在指定元素内的未尾追加一个子元素 语法 :Elem.append(ele) 2 把元素的追加到指定父级元素内的末尾 语法 : ele.appendTo(Elem) 说明 : 要求ele必须为JQuery元素，可以通过Elem.children(‘:last’)引用 3 在指定元素内的开始添加一个子元素 语法 : Elem.prepend(ele) 4 把元素的加入指定父级元素内的开始 语法 : ele.prependTo(Elem) 说明 : 要求ele必须为JQuery元素，可以通过Elem.children().eq(0)引用 5 使元素逐一被指定的HTML标记包裹起来 语法 : Elem.wrap(Tag) 说明: Tag将成为元素的父元素，可以通过Elem.parent()引用 6 使元素集合被指定的HTML标记包裹起来 语法 :Elem.wrapAll(Tag) 说明:wrap把每个子元素逐一都包裹起来，wrapAll是把所有的子元素作为整体包裹起来。 7 包裹指定元素的子元素，相当于在元素和子元素中间加了隔离层 语法 : elem.wrapInner(Tag) 8 在元素之后添加兄弟元素。新添加的元素可以通过elem.next() 引用。 语法 : elem.after(ele) 9 在元素之前添加兄弟元素。新添加的元素可以通过elem.prev() 引用。 语法 : elem.before(ele) 10 将元素A移动到元素B之后 语法 : elA.insertAfter(elB) 11 将元素A移动到元素B之前 语法 : elA.insertBefore(elB) 12 清空元素的子节点(元素本身及其属性仍然存在) 语法 : elem.empty() 13 从DOM中删除所有匹配的元素 语法 : elems.remove([条件]) 14 将元素A替换为B 语法 : elA.replaceWith(elB);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"javascript常用积累","slug":"js-snippets-summary","date":"2016-01-14T00:20:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/14/js-snippets-summary/","link":"","permalink":"http://yoursite.com/2016/01/14/js-snippets-summary/","excerpt":"一、JS动画与动作不一致解决: 123if(!$( \"#handle\").is(\":animated\"))&#123; //判断元素是否处于动画状态&#125;","text":"一、JS动画与动作不一致解决: 123if(!$( \"#handle\").is(\":animated\"))&#123; //判断元素是否处于动画状态&#125; 二、停止事件冒泡 1234567891011event.stopPropagation();- 禁止JS报错 window.onerror = function()&#123; return true ; &#125;try &#123;/*try to do*/&#125; catch(e)&#123;/*do this if try error */&#125; 三、查看JS对象属性 1234567 var res = '' ; var obj = eval( obj ); for( var p in eval( obj ) )&#123; var prop = p + ':' + obj[p] + '\\n' ; res += prop ; &#125; alert( res ); 四、页面刷新时禁用提交按钮 123window.onbeforeunload = function()&#123; $(':submit').attr('disabled',true);&#125; 注意：Opera 浏览器不支持，其他浏览器避免在同一页面中使用 &quot;javascrpt:&quot; 等伪协议 五、获取事件 123456789var getEvent = function()&#123; var ieEvent = window.event ; var ffEvent = arguments.callee.caller.arguments[0] ; //arguments.callee 当前执行函数 //arguments.callee.caller 当前执行函数的调用者 //arguments.callee.caller.arguments[0] 当前函数调用者的第一个参数 var e = ieEvent || ffEvent ; return e ;&#125; 获取鼠标距离浏览器顶部 左侧的实际距离 兼容IE 12345678910111213141516171819202122function getXY(ev)&#123; var ev = ev || window.event; var xx = 0; var yy = 0; if(ev.pageX)&#123; //iE9+ xx = ev.pageX; yy = ev.pageY; &#125;else&#123; //IE678 clientX,clientY + scroll var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//IE9+ var scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;//IE9+ xx = ev.clientX + scrollLeft; yy = ev.clientY + scrollTop; &#125; return &#123; x:xx, y:yy &#125;; &#125; 六、获取键盘码 1234567var getKCode = function()&#123; var ieEvent = window.event ; var ffEvent = arguments.callee.caller.arguments[0] ; var e = ieEvent || ffEvent ; var kCode = e.keyCode || e.which ; return kCode ; &#125; 七、 鼠标滑入/滑出样式切换 123$(\"div\").on(\"mouseover mouseout\", function()&#123; $(this).toggleClass(\"over\"); &#125;); 八、点击鼠标,显示/隐藏切换 1234567$(\"#panel h5.head\").toggle(function()&#123; $(this).toggleClass(\"highlight\"); $(this).next().toggle();&#125;,function()&#123; $(this).toggleClass(\"highlight\"); $(this).next().toggle();&#125;); 九、JS 调试 12345console.log() ; //打印变量console.dir() ; //打印对象console.dirxml() ; //打印节点console.trace() ; //打印函数调用轨迹window.document.title = str; 十、为子元素集合绑定事件 123$(\"div\").delegate(\"button\",\"click\",function()&#123; $(\"p\").slideToggle();&#125;); 十一、自定义IE浏览器渲染方式(解决IE10下JS或插件失效): 如果安装了Chrome内核，则使用Chrome内核来渲染页面[chrome=1]，如果未安装，则使用最高版本的IE内核进行渲染[IE=edge]: 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; 十二、注册事件 12345// 标准浏览器form1.addEventListener('submit', function(e)&#123; e.preventDefault(); //阻止浏览器默认动作 e.stopPropagation(); //阻止事件流产生&#125;); 12345// IE8及更早版本IE浏览器form1.attachEvent('submit', function()&#123; event.cancelBubble = true; //阻止浏览器默认动作--IE8及更早版本IE浏览器 event.returnValue = false; //阻止事件流产生--IE8及更早版本IE浏览器&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Snippet","slug":"Snippet","permalink":"http://yoursite.com/tags/Snippet/"}]},{"title":"gulp学习总结篇","slug":"gulp","date":"2016-01-13T10:20:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/13/gulp/","link":"","permalink":"http://yoursite.com/2016/01/13/gulp/","excerpt":"声明 本教程整理于互联网 一、gulp 入门简介 gulp 是基于 node 实现Web 前端自动化开发的工具，利用它能够极大的提高开发效率。 在 Web 前端开发工作中有很多“重复工作”，比如压缩CSS/JS文件。而这些工作都是有规律的。找到这些规律，并编写 gulp 配置代码,让 gulp 自动执行这些“重复工作”。","text":"声明 本教程整理于互联网 一、gulp 入门简介 gulp 是基于 node 实现Web 前端自动化开发的工具，利用它能够极大的提高开发效率。 在 Web 前端开发工作中有很多“重复工作”，比如压缩CSS/JS文件。而这些工作都是有规律的。找到这些规律，并编写 gulp 配置代码,让 gulp 自动执行这些“重复工作”。 将规律转换为 gulp 代码 现有目录结构如下： 12└── js/ └── a.js 1.1 规律 找到 js/目录下的所有 .js 文件 压缩这些 js 文件 将压缩后的代码另存在 dist/js/ 目录下 1.2 编写 gulp 代码 123456789// 压缩 JavaScript 文件gulp.task('script', function() &#123; // 1. 找到 gulp.src('js/*.js') // 2. 压缩 .pipe(uglify()) // 3. 另存 .pipe(gulp.dest('dist/js'));&#125;); 1.3 代码执行结果 代码执行后文件结构 12345└── js/│ └── a.js└── dist/ └── js/ └── a.js a.js 压缩前12345function demo (msg) &#123; alert(&apos;--------\\r\\n&apos; + msg + &apos;\\r\\n--------&apos;)&#125;demo(&apos;Hi&apos;) a.js 压缩后1function demo(n)&#123;alert(&quot;--------\\r\\n&quot;+n+&quot;\\r\\n--------&quot;)&#125;demo(&quot;Hi&quot;); 此时 dist/js 目录下的 .js 文件都是压缩后的版本。 你还可以监控 js/ 目录下的 js 文件，当某个文件被修改时，自动压缩修改文件。启动 gulp 后就可以让它帮助你自动构建 Web 项目。 gulp 还可以做很多事，例如： 压缩CSS 压缩图片 编译Sass/LESS 编译CoffeeScript markdown转换为 html 二、安装 Node 和 gulp gulp 是基于 node 实现的，那么我们就需要先安装 node。 Node 是一个基于Chrome JavaScript V8引擎建立的一个平台，可以利用它实现 Web服务，做类似PHP的事。 打开 https://nodejs.org/ 点击绿色的 INSTALL 按钮下载安装 node。 2.1 命令行 在 Windows 中可按 &lt;kbd&gt;徽标键&lt;/kbd&gt;（alt键左边）+ R 打开输入 cmd + Enter 打开命令行。 2.2 终端(Mac) 打开 Launchpad（像火箭一样的图标），在屏幕上方搜索框中输入 终端 + Enter 打开终端。 2.3 查看 node 版本号 在终端/命令行中输入 node -v 检测node是否安装成功，安装成功会显示出node 的版本号。 2.4 跳转目录 终端/命令行 中可使用 cd 目录名 跳转至指定目录，Mac 中还可以使用 ls 查看当前目录下的文件列表。 2.5 Windows Windows 下可使用如下命令跳转至指定目录： 123456// 跳转至 C 盘根目录cd c:\\// 跳转至当前目录的 demo 文件夹cd demo// 跳转至上一级cd .. 2.6 Mac Mac中建议只在 Documents目录下进行文件操作。 123456789101112// 跳转至文档目录cd /Users/你的用户名/Documents/// 或第一次打开终端时直接输入cd Documents// 查看目录下文件列表ls// 创建文件夹mkdir demo// 跳转至当前目录下的 demo 文件夹cd demo// 跳转至上级目录cd .. 2.7 退出运行状态 如果你在命令行中启动了一些一直运行的命令，你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 Ctrl + C 停止 gulp。（Mac 中使用 control + C） 后面的章节中如果代码中存在 gulp.watch 并在命令行运行了 gulp 则需要使用 Ctrl + C 退出任务。 2.8 npm 模块管理器 如果你了解 npm 则跳过此章节 若你不了解npm 请阅读 npm模块管理器 2.9 安装 gulp npm 是 node 的包管理工具，可以利用它安装 gulp 所需的包。（在安装 node 时已经自动安装了 npm） 在命令行输入 1npm install -g gulp 若一直没安装成功，请使用 cnpm 安装(npm的国内加速镜像) 意思是：使用 npm 安装全局性的(-g) gulp 包。 如果你安装失败，请输入sudo npm install -g gulp使用管理员权限安装。（可能会要求输入密码） 安装时请注意命令行的提示信息，安装完成后可在命令行输入 gulp -v 以确认安装成功。 至此，我们完成了准备工作。接着让 gulp开始帮我们干活吧！ 三、使用 gulp 压缩 JS 压缩js 代码可降低 js 文件大小，提高页面打开速度。在不利用 gulp 时我们需要通过各种工具手动完成压缩工作。 所有的 gulp 代码编写都可以看做是将规律转化为代码的过程。 规律 找到 js/ 目录下的所有js 文件，压缩它们，将压缩后的文件存放在 dist/js/ 目录下。 gulp 代码 gulp 的所有配置代码都写在 gulpfile.js 文件。 3.1 新建一个 gulpfile.js 文件 12chapter2└── gulpfile.js 3.2 在 gulpfile.js 中编写代码 12// 获取 gulpvar gulp = require('gulp') require() 是 node （CommonJS）中获取模块的语法。 在 gulp 中你只需要理解 require() 可以获取模块。 3.3 获取 gulp-uglify 组件 12// 获取 uglify 模块（用于压缩 JS）var uglify = require('gulp-uglify') 3.4 创建压缩任务 12345678910// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task('script', function() &#123; // 1. 找到文件 gulp.src('js/*.js') // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest('dist/js'))&#125;) gulp.task(name, fn) - 定义任务，第一个参数是任务名，第二个参数是任务内容。 gulp.src(path) - 选择文件，传入参数是文件路径。 gulp.dest(path) - 输出文件 gulp.pipe() - 管道，你可以暂时将 pipe 理解为将操作加入执行队列 参考：gulp API文档 3.5 跳转至 gulpfile.js 所在目录 打开命令行使用 cd 命令跳转至 gulpfile.js 文件所在目录。 例如我的 gulpfile.js 文件保存在 C:\\gulp-book\\demo\\chapter2\\gulpfile.js。 那么就需要在命令行输入1cd C:\\gulp-book\\demo\\chapter2 Mac 用户可使用 cd Documents/gulp-book/demo/chapter2/ 跳转 3.6 使用命令行运行 script 任务 在控制台输入 gulp 任务名 可运行任务，此处我们输入 gulp script 回车。 注意：输入 gulp script 后命令行将会提示错误信息123456// 在命令行输入gulp scriptError: Cannot find module &apos;gulp-uglify&apos; at Function.Module._resolveFilename (module.js:338:15) at Function.Module._load (module.js:280:25) Cannot find module &#39;gulp-uglify&#39; 没有找到 gulp-uglify 模块。 3.7 安装 gulp-uglify 模块 因为我们并没有安装 gulp-uglify 模块到本地，所以找不到此模块。 使用 npm 安装 gulp-uglify 到本地 1npm install gulp-uglify 安装成功后你会看到如下信息：1234567gulp-uglify@1.1.0 node_modules/gulp-uglify├── deepmerge@0.2.7├── uglify-js@2.4.16 (uglify-to-browserify@1.0.2, async@0.2.10, source-map@0.1.34, optimist@0.3.7)├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, object-assign@2.0.0, lodash._reinterpolate@3.0.0, lodash._reescape@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, chalk@1.0.0, lodash.template@3.3.2, vinyl@0.4.6, multipipe@0.1.2, dateformat@1.0.11)chapter2 $ 在你的文件夹中会新增一个 node_modules 文件夹，这里面存放着 npm 安装的模块。 目录结构：123├── gulpfile.js└── node_modules └── gulp-uglify 接着输入 gulp script 执行任务 1234gulp script[13:34:57] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js[13:34:57] Starting &apos;script&apos;...[13:34:57] Finished &apos;script&apos; after 6.13 ms 3.8 编写 js 文件 我们发现 gulp 没有进行任何压缩操作。因为没有js这个目录，也没有 js 目录下的 .js 后缀文件。 创建 a.js 文件，并编写如下内容 123456// a.jsfunction demo (msg) &#123; alert(&apos;--------\\r\\n&apos; + msg + &apos;\\r\\n--------&apos;)&#125;demo(&apos;Hi&apos;) 目录结构：12345├── gulpfile.js├── js│ └── a.js└── node_modules └── gulp-uglify 接着在命令行输入 gulp script 执行任务 gulp 会在命令行当前目录下创建 dist/js/ 文件夹，并创建压缩后的 a.js 文件。 目录结构：12345678├── gulpfile.js├── js│ └── a.js├── dist│ └── js│ └── a.js└── node_modules └── gulp-uglify dist/js/a.js1function demo(n)&#123;alert(\"--------\\r\\n\"+n+\"\\r\\n--------\")&#125;demo(\"Hi\"); 3.9 检测代码修改自动执行任务 js/a.js一旦有修改 就必须重新在命令行输入 gulp script ，这很麻烦。 可以使用 gulp.watch(src, fn) 检测指定目录下文件的修改后执行任务。 在 gulpfile.js 中编写如下代码：12// 监听文件修改，当文件被修改则执行 script 任务gulp.watch(&apos;js/*.js&apos;, [&apos;script&apos;]); 但是没有命令可以运行 gulp.watch()，需要将 gulp.watch() 包含在一个任务中。 12345// 在命令行使用 gulp auto 启动此任务gulp.task(&apos;auto&apos;, function () &#123; // 监听文件修改，当文件被修改则执行 script 任务 gulp.watch(&apos;js/*.js&apos;, [&apos;script&apos;])&#125;) 接着在命令行输入 gulp auto，自动监听 js/*.js 文件的修改后压缩js。 1234$gulp auto[21:09:45] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js[21:09:45] Starting &apos;auto&apos;...[21:09:45] Finished &apos;auto&apos; after 9.19 ms 此时修改 js/a.js 中的代码并保存。命令行将会出现提示，表示检测到文件修改并压缩文件。 12[21:11:01] Starting &apos;script&apos;...[21:11:01] Finished &apos;script&apos; after 2.85 ms 至此，我们完成了 gulp 压缩 js 文件的自动化代码编写。 注意：使用 gulp.watch 后你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 Ctrl + C 停止 gulp。 Mac 下使用 control + C 停止 gulp 3.10 使用 gulp.task(‘default’, fn) 定义默认任务 增加如下代码 1gulp.task('default', ['script', 'auto']); 此时你可以在命令行直接输入 gulp +回车，运行 script 和 auto 任务。 最终代码如下： 123456789101112131415161718192021222324252627// 获取 gulpvar gulp = require('gulp')// 获取 uglify 模块（用于压缩 JS）var uglify = require('gulp-uglify')// 压缩 js 文件// 在命令行使用 gulp script 启动此任务gulp.task('script', function() &#123; // 1. 找到文件 gulp.src('js/*.js') // 2. 压缩文件 .pipe(uglify()) // 3. 另存压缩后的文件 .pipe(gulp.dest('dist/js'))&#125;)// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 script 任务 gulp.watch('js/*.js', ['script'])&#125;)// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 script 任务和 auto 任务gulp.task('default', ['script', 'auto']) 去除注释后，你会发现只需要 11 行代码就可以让 gulp 自动监听 js 文件的修改后压缩代码。但是还有还有一些性能问题和缺少容错性，将在后面的章节详细说明。 你可以访问 gulp-uglify 以查看更多用法。 四、使用 gulp 压缩 CSS 压缩 css 代码可降低 css 文件大小，提高页面打开速度。 我们接着将规律转换为 gulp 代码 规律 找到 css/ 目录下的所有 css 文件，压缩它们，将压缩后的文件存放在 dist/css/ 目录下。 4.1 安装 gulp-minify-css模块 提示：你需要使用命令行的 cd 切换到对应目录后进行安装操作。 在命令行输入 1npm install gulp-minify-css 安装成功后你会看到如下信息：(安装时间可能会比较长) 1234567gulp-minify-css@1.0.0 node_modules/gulp-minify-css├── object-assign@2.0.0├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)├── clean-css@3.1.8 (commander@2.6.0, source-map@0.1.43)├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)├── vinyl-bufferstream@1.0.1 (bufferstreams@1.0.1)└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, multipipe@0.1.2, vinyl@0.4.6, chalk@1.0.0, lodash.template@3.3.2, dateformat@1.0.11) 4.2 参照 [使用 gulp 压缩 JS]创建 gulpfile.js 文件编写代码 在对应目录创建 gulpfile.js 文件并写入如下内容： 1234567891011121314151617181920212223242526// 获取 gulpvar gulp = require('gulp')// 获取 minify-css 模块（用于压缩 CSS）var minifyCSS = require('gulp-minify-css')// 压缩 css 文件// 在命令行使用 gulp css 启动此任务gulp.task('css', function () &#123; // 1. 找到文件 gulp.src('css/*.css') // 2. 压缩文件 .pipe(minifyCSS()) // 3. 另存为压缩文件 .pipe(gulp.dest('dist/css'))&#125;)// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 css 任务 gulp.watch('css/*.css', ['css'])&#125;);// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 css 任务和 auto 任务gulp.task('default', ['css', 'auto']) 你可以访问 gulp-minify-css 以查看更多用法。 4.3 创建 css 文件 在 gulpfile.js 对应目录创建 css 文件夹，并在 css/ 目录下创建 a.css 文件。 1234/* a.css */body a&#123; color:pink;&#125; 4.4 运行 gulp 查看效果 在命令行输入 gulp +回车 你将看到命令行出现如下提示 12345678gulp[17:01:19] Using gulpfile ~/Documents/code/gulp-book/demo/chapter3/gulpfile.js[17:01:19] Starting &apos;css&apos;...[17:01:19] Finished &apos;css&apos; after 6.21 ms[17:01:19] Starting &apos;auto&apos;...[17:01:19] Finished &apos;auto&apos; after 5.42 ms[17:01:19] Starting &apos;default&apos;...[17:01:19] Finished &apos;default&apos; after 5.71 μs gulp 会创建 dist/css 目录，并创建 a.css 文件，此文件存放压缩后的 css 代码。dist/css/a.css 五、使用 gulp 压缩图片 压缩 图片文件可降低文件大小，提高图片加载速度。 找到规律转换为 gulp 代码 规律 找到 images/ 目录下的所有文件，压缩它们，将压缩后的文件存放在 dist/images/ 目录下。 5.1 安装 gulp-imagemin 模块 提示：你需要使用命令行的 cd 切换至对应目录再进行安装操作和 gulp 启动操作。 在命令行输入 1npm install gulp-imagemin 安装成功后你会看到如下信息：(安装时间可能会比较长) 1234567gulp-imagemin@2.2.1 node_modules/gulp-imagemin├── object-assign@2.0.0├── pretty-bytes@1.0.3 (get-stdin@4.0.1)├── chalk@1.0.0 (escape-string-regexp@1.0.3, ansi-styles@2.0.1, supports-color@1.3.1, has-ansi@1.0.3, strip-ansi@2.0.1)├── through2-concurrent@0.3.1 (through2@0.6.3)├── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reevaluate@3.0.0, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, vinyl@0.4.6, through2@0.6.3, multipipe@0.1.2, lodash.template@3.3.2, dateformat@1.0.11)└── imagemin@3.1.0 (get-stdin@3.0.2, optional@0.1.3, vinyl@0.4.6, through2@0.6.3, stream-combiner@0.2.1, concat-stream@1.4.7, meow@2.1.0, vinyl-fs@0.3.13, imagemin-svgo@4.1.2, imagemin-optipng@4.2.0, imagemin-jpegtran@4.1.0, imagemin-pngquant@4.0.0, imagemin-gifsicle@4.1.0) 5.2 创建 gulpfile.js 文件编写代码 在对应目录创建 gulpfile.js 文件并写入如下内容： 12345678910111213141516171819202122232425262728// 获取 gulpvar gulp = require('gulp');// 获取 gulp-imagemin 模块var imagemin = require('gulp-imagemin')// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src('images/*.*') // 2. 压缩图片 .pipe(imagemin(&#123; progressive: true &#125;)) // 3. 另存图片 .pipe(gulp.dest('dist/images'))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 images 任务 gulp.watch('images/*.*)', ['images'])&#125;);// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 images 任务和 auto 任务gulp.task('default', ['images', 'auto']) 你可以访问 gulp-imagemin 以查看更多用法。 5.3 在 images/ 目录下存放图片 在 gulpfile.js 对应目录创建 images 文件夹，并在 images/ 目录下存放图片。 5.4 运行 gulp 查看效果 在命令行输入 gulp +回车 你将看到命令行出现如下提示 123456789gulp[18:10:42] Using gulpfile ~/Documents/code/gulp-book/demo/chapter4/gulpfile.js[18:10:42] Starting &apos;images&apos;...[18:10:42] Finished &apos;images&apos; after 5.72 ms[18:10:42] Starting &apos;auto&apos;...[18:10:42] Finished &apos;auto&apos; after 6.39 ms[18:10:42] Starting &apos;default&apos;...[18:10:42] Finished &apos;default&apos; after 5.91 μs[18:10:42] gulp-imagemin: Minified 3 images (saved 25.83 kB - 5.2%) 使用 gulp 编译 LESS Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护。 安装1npm install gulp-less 基本用法12345678910111213141516171819202122232425// 获取 gulpvar gulp = require('gulp')// 获取 gulp-less 模块var less = require('gulp-less')// 编译less// 在命令行输入 gulp less 启动此任务gulp.task('less', function () &#123; // 1. 找到 less 文件 gulp.src('less/**.less') // 2. 编译为css .pipe(less()) // 3. 另存文件 .pipe(gulp.dest('dist/css'))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 less 任务 gulp.watch('less/**.less', ['less'])&#125;)// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 less 任务和 auto 任务gulp.task('default', ['less', 'auto']) 你可以访问 gulp-less 以查看更多用法。 LESS 代码和编译后的CSS代码less/a.less 12345.less&#123; a&#123; color:pink; &#125;&#125; less/import.less 123456@import \"a.less\";.import&#123; a&#123; color:red; &#125;&#125; less/a.css 123.less a &#123; color: pink;&#125; less/import.css 123456.less a &#123; color: pink;&#125;.import a&#123; color: red;&#125; 六、使用 gulp 编译 Sass 无论是 node-sass 还是 ruby-sass 使用 npm 安装都非常的慢，甚至会装不上。及其不利于团队协作。建议使用 less 作为 css 预处理器。如果因为 less 不支持自定义函数选择用 sass 可以使用 less-plugin-functions 让 less 支持自定义函数。 6.1 gulp-sass 本章使用的是 ruby-sass 如果你不方便安装 ruby 或编译速度慢，建议使用 gulp-sass Sass 是一种 CSS 的开发工具，提供了许多便利的写法，大大节省了开发者的时间，使得 CSS 的开发，变得简单和可维护。 本章使用 ruby-sass 编译 css,若你没有安装 ruby 和 sass 请移步 使用ruby.taobao安装 Sass 6.2 安装 1npm install gulp-ruby-sass 6.3 基本用法 12345678910111213141516171819202122232425// 获取 gulpvar gulp = require('gulp')// 获取 gulp-ruby-sass 模块var sass = require('gulp-ruby-sass')// 编译sass// 在命令行输入 gulp sass 启动此任务gulp.task('sass', function() &#123; return sass('sass/') .on('error', function (err) &#123; console.error('Error!', err.message); &#125;) .pipe(gulp.dest('dist/css'))&#125;);// 在命令行使用 gulp auto 启动此任务gulp.task('auto', function () &#123; // 监听文件修改，当文件被修改则执行 images 任务 gulp.watch('sass/**/*.scss', ['sass'])&#125;);// 使用 gulp.task('default') 定义默认任务// 在命令行使用 gulp 启动 sass 任务和 auto 任务gulp.task('default', ['sass', 'auto']) Sass 代码和编译后的 CSS 代码 sass/a.scss 12345.sass&#123; a&#123; color:pink; &#125;&#125; sass/import.scss 123456@import \"a.scss\";.import&#123; a&#123; color:red; &#125;&#125; sass/a.css 123.sass a &#123; color: pink;&#125; sass/import.css 123456.sass a &#123; color: pink;&#125;.import a&#123; color: red;&#125; 七、使用 gulp 构建一个项目 本章将介绍 gulp-watch-path stream-combiner2 gulp-sourcemaps gulp-autoprefixer 并将之前所有章节的内容组合起来编写一个前端项目所需的 gulp 代码。 若你不了解npm 请务必阅读 npm模块管理器 7.1 package.json 如果你熟悉 npm 则可以利用 package.json 保存所有 npm install --save-dev gulp-xxx 模块依赖和模块版本。 在命令行输入 1npm init 会依次要求补全项目信息，不清楚的可以直接回车跳过12345678name: (gulp-demo) version: (1.0.0) description: entry point: (index.js) test command: ......Is this ok? (yes) 最终会在当前目录中创建 package.json 文件并生成类似如下代码：123456789101112131415161718192021&#123; \"name\": \"gulp-demo\", \"version\": \"0.0.0\", \"description\": \"\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/nimojs/gulp-demo.git\" &#125;, \"keywords\": [ \"gulp\", ], \"author\": \"nimojs &lt;nimo.jser@gmail.com&gt;\", \"license\": \"MIT\", \"bugs\": &#123; \"url\": \"https://github.com/nimojs/gulp-demo/issues\" &#125;, \"homepage\": \"https://github.com/nimojs/gulp-demo\"&#125; 7.2 安装依赖 安装 gulp 到项目（防止全局 gulp 升级后与此项目 gulpfile.js 代码不兼容）1npm install gulp --save-dev 此时打开 package.json 会发现多了如下代码 123\"devDependencies\": &#123; \"gulp\": \"^3.8.11\"&#125; 声明此项目的开发依赖 gulp 接着安装其他依赖： 安装模块较多，请耐心等待，若一直安装失败可使用npm.taobao.org 1npm install gulp-uglify gulp-watch-path stream-combiner2 gulp-sourcemaps gulp-minify-css gulp-autoprefixer gulp-less gulp-ruby-sass gulp-imagemin gulp-util --save-dev 此时，package.json 将会更新12345678910111213\"devDependencies\": &#123; \"colors\": \"^1.0.3\", \"gulp\": \"^3.8.11\", \"gulp-autoprefixer\": \"^2.1.0\", \"gulp-imagemin\": \"^2.2.1\", \"gulp-less\": \"^3.0.2\", \"gulp-minify-css\": \"^1.0.0\", \"gulp-ruby-sass\": \"^1.0.1\", \"gulp-sourcemaps\": \"^1.5.1\", \"gulp-uglify\": \"^1.1.0\", \"gulp-watch-path\": \"^0.0.7\", \"stream-combiner2\": \"^1.0.2\"&#125; 当你将这份 gulpfile.js 配置分享给你的朋友时，就不需要将 node_modules/ 发送给他，他只需在命令行输入1npm install 就可以检测 package.json 中的 devDependencies 并安装所有依赖。 7.3 设计目录结构 我们将文件分为2类，一类是源码，一类是编译压缩后的版本。文件夹分别为 src 和 dist。(注意区分 dist 和 ·dest 的区别) 123└── src/│└── dist/ dist/ 目录下的文件都是根据 src/ 下所有源码文件构建而成。 在 src/ 下创建前端资源对应的的文件夹 12345678└── src/ ├── less/ *.less 文件 ├── sass/ *.scss *.sass 文件 ├── css/ *.css 文件 ├── js/ *.js 文件 ├── fonts/ 字体文件 └── images/ 图片└── dist/ 7.4 让命令行输出的文字带颜色 gulp 自带的输出都带时间和颜色，这样很容易识别。我们利用 gulp-util 实现同样的效果。 12345678var gulp = require('gulp')var gutil = require('gulp-util')gulp.task('default', function () &#123; gutil.log('message') gutil.log(gutil.colors.red('error')) gutil.log(gutil.colors.green('message:') + \"some\")&#125;) 使用 gulp 启动默认任务以测试 gulp-util 7.5 配置 JS 任务7.5.1 gulp-uglify检测src/js/目录下的 js 文件修改后，压缩 js/ 中所有 js 文件并输出到 dist/js/ 中 1234567891011var uglify = require('gulp-uglify')gulp.task('uglifyjs', function () &#123; gulp.src('src/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('dist/js'))&#125;)gulp.task('default', function () &#123; gulp.watch('src/js/**/*.js', ['uglifyjs'])&#125;) src/js/**/*.js 是 glob 语法。百度百科：glob模式 、node-glob 在命令行输入 gulp 后会出现如下消息，表示已经启动。123[20:39:50] Using gulpfile ~/Documents/code/gulp-book/demo/chapter7/gulpfile.js[20:39:50] Starting 'default'...[20:39:50] Finished 'default' after 13 ms 此时编辑 src/js/log.js 文件并保存，命令行会出现如下消息，表示检测到 src/js/**/*.js 文件修改后重新编译所有 js。 12[20:39:52] Starting 'js'...[20:39:52] Finished 'js' after 14 ms 7.5.2gulp-watch-path 此配置有个性能问题，当 gulp.watch 检测到 src/js/ 目录下的js文件有修改时会将所有文件全部编译。实际上我们只需要重新编译被修改的文件。 简单介绍 gulp.watch 第二个参数为 function 时的用法。 123456789101112gulp.watch('src/js/**/*.js', function (event) &#123; console.log(event); /* 当修改 src/js/log.js 文件时 event &#123; // 发生改变的类型，不管是添加，改变或是删除 type: 'changed', // 触发事件的文件路径 path: '/Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.js' &#125; */&#125;) 我们可以利用 event 给到的信息，检测到某个 js 文件被修改时，只编写当前修改的 js 文件。 可以利用 gulp-watch-path 配合 event 获取编译路径和输出路径。 123456789101112131415161718192021222324var watchPath = require('gulp-watch-path')gulp.task('watchjs', function () &#123; gulp.watch('src/js/**/*.js', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') /* paths &#123; srcPath: 'src/js/log.js', srcDir: 'src/js/', distPath: 'dist/js/log.js', distDir: 'dist/js/', srcFilename: 'log.js', distFilename: 'log.js' &#125; */ gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(uglify()) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('default', ['watchjs']) use-gulp-watch-path 完整代码 7.5.3 watchPath(event, search, replace, distExt) 参数 说明 event gulp.watch 回调函数的 event search 需要被替换的起始字符串 replace 第三个参数是新的的字符串 distExt 扩展名(非必填) 此时编辑 src/js/log.js 文件并保存，命令行会出现消息，表示检测到 src/js/log.js 文件修改后只重新编译 log.js。 12[21:47:25] changed src/js/log.js[21:47:25] Dist dist/js/log.js 你可以访问 gulp-watch-path 了解更多。 7.5.4 stream-combiner2 编辑 log.js 文件时，如果文件中有 js 语法错误时，gulp 会终止运行并报错。 当 log.js 缺少 )1log('gulp-book' 并保存文件时出现如下错误，但是错误信息不全面。而且还会让 gulp 停止运行。 12345678910events.js:85 throw er; // Unhandled &apos;error&apos; event ^Error at new JS_Parse_Error (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:189:18)......js_error (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp--book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:1165:20) at maybe_unary (/Users/nimojs/Documents/code/gulp-book/demo/chapter7/node_modules/gulp-uglify/node_modules/uglify-js/lib/parse.js:1328:19) 应对这种情况，我们可以使用 Combining streams to handle errors 文档中推荐的 stream-combiner2 捕获错误信息。 1234567891011121314151617181920212223242526272829303132333435var handleError = function (err) &#123; var colors = gutil.colors; console.log('\\n') gutil.log(colors.red('Error!')) gutil.log('fileName: ' + colors.red(err.fileName)) gutil.log('lineNumber: ' + colors.red(err.lineNumber)) gutil.log('message: ' + err.message) gutil.log('plugin: ' + colors.yellow(err.plugin))&#125;var combiner = require('stream-combiner2')gulp.task('watchjs', function () &#123; gulp.watch('src/js/**/*.js', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') /* paths &#123; srcPath: 'src/js/log.js', srcDir: 'src/js/', distPath: 'dist/js/log.js', distDir: 'dist/js/', srcFilename: 'log.js', distFilename: 'log.js' &#125; */ gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) var combined = combiner.obj([ gulp.src(paths.srcPath), uglify(), gulp.dest(paths.distDir) ]) combined.on('error', handleError) &#125;)&#125;) 此时当编译错误的语法时，命令行会出现错误提示。而且不会让 gulp 停止运行。 12345678changed:src/js/log.jsdist:dist/js/log.js--------------Error!fileName: /Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.jslineNumber: 7message: /Users/nimojs/Documents/code/gulp-book/demo/chapter7/src/js/log.js: Unexpected token eof «undefined», expected punc «,»plugin: gulp-uglify 7.5.5 gulp-sourcemaps JS 压缩前和压缩后比较1234567891011// 压缩前var log = function (msg) &#123; console.log('--------'); console.log(msg) console.log('--------');&#125;log(&#123;a:1&#125;)log('gulp-book')// 压缩后var log=function(o)&#123;console.log(\"--------\"),console.log(o),console.log(\"--------\")&#125;;log(&#123;a:1&#125;),log(\"gulp-book\"); 压缩后的代码不存在换行符和空白符，导致出错后很难调试，好在我们可以使用 sourcemap 帮助调试 12345678910var sourcemaps = require('gulp-sourcemaps')// ...var combined = combiner.obj([ gulp.src(paths.srcPath), sourcemaps.init(), uglify(), sourcemaps.write('./'), gulp.dest(paths.distDir)])// ... 此时 dist/js/ 中也会生成对应的 .map 文件，以便使用 Chrome 控制台调试代码 在线文件示例：src/js/ 至此，我们完成了检测文件修改后压缩 JS 的 gulp 任务配置。 有时我们也需要一次编译所有 js 文件。可以配置 uglifyjs 任务。 12345678910gulp.task('uglifyjs', function () &#123; var combined = combiner.obj([ gulp.src('src/js/**/*.js'), sourcemaps.init(), uglify(), sourcemaps.write('./'), gulp.dest('dist/js/') ]) combined.on('error', handleError)&#125;) 在命令行输入 gulp uglifyjs 以压缩 src/js/ 下的所有 js 文件。 7.6 配置 CSS 任务 有时我们不想使用 LESS 或 SASS而是直接编写 CSS，但我们需要压缩 CSS 以提高页面加载速度。 7.6.1 gulp-minify-css 按照本章中压缩 JS 的方式，先编写 watchcss 任务 123456789101112131415161718var minifycss = require('gulp-minify-css')gulp.task('watchcss', function () &#123; gulp.watch('src/css/**/*.css', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('default', ['watchjs','watchcss']) 7.6.2 gulp-autoprefixerautoprefixer 解析 CSS 文件并且添加浏览器前缀到CSS规则里。通过示例帮助理解 autoprefixer 处理前：123.demo &#123; display:flex;&#125; autoprefixer 处理后：12345.demo &#123; display:-webkit-flex; display:-ms-flexbox; display:flex;&#125; 你只需要关心编写标准语法的 css，autoprefixer 会自动补全。 在 watchcss 任务中加入 autoprefixer: 1234567891011121314151617gulp.task('watchcss', function () &#123; gulp.watch('src/css/**/*.css', function (event) &#123; var paths = watchPath(event, 'src/', 'dist/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(sourcemaps.init()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;) 更多 autoprefixer 参数请查看 gulp-autoprefixer 有时我们也需要一次编译所有 css 文件。可以配置 minifyss 任务。 12345678910gulp.task('minifycss', function () &#123; gulp.src('src/css/**/*.css') .pipe(sourcemaps.init()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(minifycss()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('dist/css/'))&#125;) 在命令行输入 gulp minifyss 以压缩 src/css/ 下的所有 .css 文件并复制到 dist/css 目录下 7.7 配置 Less 任务 参考配置 JavaScript 任务的方式配置 less 任务 123456789101112131415161718192021222324252627282930313233343536373839var less = require('gulp-less')gulp.task('watchless', function () &#123; gulp.watch('src/less/**/*.less', function (event) &#123; var paths = watchPath(event, 'src/less/', 'dist/css/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) var combined = combiner.obj([ gulp.src(paths.srcPath), sourcemaps.init(), autoprefixer(&#123; browsers: 'last 2 versions' &#125;), less(), minifycss(), sourcemaps.write('./'), gulp.dest(paths.distDir) ]) combined.on('error', handleError) &#125;)&#125;)gulp.task('lesscss', function () &#123; var combined = combiner.obj([ gulp.src('src/less/**/*.less'), sourcemaps.init(), autoprefixer(&#123; browsers: 'last 2 versions' &#125;), less(), minifycss(), sourcemaps.write('./'), gulp.dest('dist/css/') ]) combined.on('error', handleError)&#125;)gulp.task('default', ['watchjs', 'watchcss', 'watchless']) 7.8 配置 Sass 任务 参考配置 JavaScript 任务的方式配置 Sass 任务 1234567891011121314151617181920212223242526272829303132333435gulp.task('watchsass',function () &#123; gulp.watch('src/sass/**/*', function (event) &#123; var paths = watchPath(event, 'src/sass/', 'dist/css/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) sass(paths.srcPath) .on('error', function (err) &#123; console.error('Error!', err.message); &#125;) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(sourcemaps.write('./')) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('sasscss', function () &#123; sass('src/sass/') .on('error', function (err) &#123; console.error('Error!', err.message); &#125;) .pipe(sourcemaps.init()) .pipe(minifycss()) .pipe(autoprefixer(&#123; browsers: 'last 2 versions' &#125;)) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('dist/css'))&#125;)gulp.task('default', ['watchjs', 'watchcss', 'watchless', 'watchsass', 'watchsass']) 7.9 配置 image 任务 123456789101112131415161718192021222324var imagemin = require('gulp-imagemin')gulp.task('watchimage', function () &#123; gulp.watch('src/images/**/*', function (event) &#123; var paths = watchPath(event,'src/','dist/') gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(imagemin(&#123; progressive: true &#125;)) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('image', function () &#123; gulp.src('src/images/**/*') .pipe(imagemin(&#123; progressive: true &#125;)) .pipe(gulp.dest('dist/images'))&#125;) 7.10 配置文件复制任务 复制 src/fonts/ 文件到 dist/ 中 123456789101112131415161718gulp.task('watchcopy', function () &#123; gulp.watch('src/fonts/**/*', function (event) &#123; var paths = watchPath(event) gutil.log(gutil.colors.green(event.type) + ' ' + paths.srcPath) gutil.log('Dist ' + paths.distPath) gulp.src(paths.srcPath) .pipe(gulp.dest(paths.distDir)) &#125;)&#125;)gulp.task('copy', function () &#123; gulp.src('src/fonts/**/*') .pipe(gulp.dest('dist/fonts/'))&#125;)gulp.task('default', ['watchjs', 'watchcss', 'watchless', 'watchsass', 'watchimage', 'watchcopy'])","categories":[{"name":"Build","slug":"Build","permalink":"http://yoursite.com/categories/Build/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"react加node仿饿了么","slug":"react加node仿饿了么","date":"2016-01-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/13/react加node仿饿了么/","link":"","permalink":"http://yoursite.com/2016/01/13/react加node仿饿了么/","excerpt":"","text":"前言 最近一段时间一直在学习React的相关知识，，这次决定用React去模仿一个移动端App,看了很多自己用过的App,最后决定模仿做饿了么移动端App,写下这篇博客，记录实践中的心得体会 项目构建基于react、react-redux、react-router、antd、mongodb实现单个商家页部分，后台数据通过nodejs模拟实现。1.安装脚手架工具 （单文件组件项目生成工具） 只需要安装一次 1npm install -g create-react-app / cnpm install -g create-react-app 2.创建项目 （可能创建多次） 找到项目要创建的目录： create-react-app reactdemo 3.cd 到项目里面 cd reactdemo npm start 运行项目 npm run build 生成项目 项目目录文件使用插件 1、react（组件编写） 2、react-router（控制路由3.x） 3、react-dom（渲染dom） 4、redux（控制状态） 5、react-redux（更新组件状态） 6、react-promise（异步处理） 7、react-tap-event-plugin（手机tap事件） 8、ant-design-mobile（移动端ui组件） 9、better-scroll（页面滚动）1.package.json 12345678910&quot;dependencies&quot;: &#123; &quot;antd&quot;: &quot;^2.11.2&quot;, &quot;antd-mobile&quot;: &quot;^1.4.1&quot;, &quot;axios&quot;: &quot;^0.16.2&quot;, &quot;md5&quot;: &quot;^2.2.1&quot;, &quot;react&quot;: &quot;^15.6.1&quot;, &quot;react-dom&quot;: &quot;^15.6.1&quot;, &quot;react-router-scroll&quot;: &quot;^0.4.2&quot;, &quot;touchjs&quot;: &quot;^0.2.14&quot; &#125;, 2.入口app.js 123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;;import &apos;./component/static/css/antd.css&apos;;import &quot;./component/static/css/reset.css&quot;;import &quot;./component/static/css/common.css&quot;;import $ from &quot;jquery&quot;;import Footer from &quot;./component/footer&quot;;import Order from &apos;./component/order&apos;;import User from &apos;./component/user&apos;;import Find from &apos;./component/find&apos;;import Home from &quot;./component/home&quot;;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;export default App; 3.index.js路由配置界面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import &quot;./component/static/css/index.css&quot;;import App from &apos;./App&apos;;import registerServiceWorker from &apos;./registerServiceWorker&apos;;import &#123;Router,Route,Link,IndexRoute,browserHistory&#125; from &apos;react-router&apos;import Order from &apos;./component/order&apos;;import User from &apos;./component/user&apos;;import Collection from &apos;./component/user/collection&apos;;import Login from &apos;./component/user/Login&apos;;import Reg from &quot;./component/user/Reg&quot;;import Reg1 from &quot;./component/user/Reg1&quot;;import Reg2 from &quot;./component/user/Reg2&quot;;import Find from &apos;./component/find&apos;;import Search from &apos;./component/search&apos;;import Home from &quot;./component/home&quot;;import Seller from &quot;./component/home/seller&quot;;import Detail from &quot;./component/detail&quot;;import Collect from &quot;./component/collect&quot;;ReactDOM.render(&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path=&quot;home&quot; component=&#123;Home&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;find&quot; component=&#123;Find&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;order&quot; component=&#123;Order&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;user&quot; component=&#123;User&#125;&gt; &lt;/Route&gt; &lt;Route path=&quot;user/collection&quot; component=&#123;Collection&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;user/login&quot; component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;login&quot; component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;reg&quot; component=&#123;Reg&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;user/reg&quot; component=&#123;Reg&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;reg1&quot; component=&#123;Reg1&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;user/reg1&quot; component=&#123;Reg1&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;reg2&quot; component=&#123;Reg2&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;user/reg2&quot; component=&#123;Reg2&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;user/collect&quot; component=&#123;Collect&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;/quite&quot; component=&#123;User&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;seller/:aid&quot; component=&#123;Seller&#125;&gt;&lt;/Route&gt; &#123;/*&lt;Route path=&quot;seller&quot; component=&#123;Seller&#125;&gt;&lt;/Route&gt;*/&#125; &lt;Route path=&quot;search&quot; component=&#123;Search&#125;&gt;&lt;/Route&gt; &lt;Route path=&quot;detail&quot; component=&#123;Detail&#125;&gt;&lt;/Route&gt; &lt;/Route&gt;&lt;/Router&gt;, document.getElementById(&apos;root&apos;));registerServiceWorker(); browserHistory去路径的#号IndexRoute设置默认路由4.storage.js 1234567891011121314151617181920212223242526272829var app=&#123; set:function(key,value)&#123; localStorage.setItem(key,JSON.stringify(value)); &#125;, get:function(key)&#123; return JSON.parse(localStorage.getItem(key)); &#125;, hasCollectionData(aid,collectdata)&#123; /*判断collectdata里面有没有数据*/ //forEach是个异步 for(var i=0;i&lt;collectdata.length;i++)&#123; if(aid==collectdata[i].aid)&#123; return true; &#125; &#125; return false; &#125;&#125;export default app; localstorage方法封装 项目详情主页 使用Swiper实现轮播图效果flex布局 商家列表 商家列表通过下拉更新请求pai接口从数据库获取模拟数据渲染页面 搜索页面 历史搜索使用localstorage保存本地进行渲染 1234567891011121314router.post(&quot;/search&quot;,function(req,res,next)&#123; var keyword=req.body.data DB.Find(&quot;trade&quot;,&#123;$or:[&#123;&quot;title&quot;:&#123; $regex:new RegExp(keyword)&#125;&#125;,&#123;&quot;name&quot;:&#123; $regex:new RegExp(keyword)&#125;&#125;]&#125;,function(err,data)&#123; if(data.length&gt;0)&#123; res.json(data) &#125;else &#123; res.json(404) &#125; &#125;)&#125;) 服务端通过nodejs的模糊匹配搜索数据库符合的商家进行调整至商家详情页面 用户个人中心 用户注册页面 1.通过验证码点击事件判断，获取用户输入的账号，查询数据库是否已经存在，如果不存在会返回验证码信息2.通过确认点击事件，获取用户输入的账号信息和验证码是否正确，如果正确保存在数据库，提示注册成功。 12345678910111213141516171819202122router.post(&apos;/doReg1&apos;, function(req, res, next) &#123; Rphone = req.body.getphone; var longstr = &apos;1,2,3,4,5,6,7,8,9,0,A,B,C,D,E,F,G,H,I,G,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&apos;; var str = longstr.split(&apos;,&apos;); var prevNum = &apos;&apos;; for(var i = 0; i &lt; 6; i++) &#123; prevNum += str[Math.floor(Math.random() * 36)]; &#125; DB.Find(&quot;user&quot;,&#123;phone&#125;,function(err,data)&#123; if(err)&#123; console(&apos;error&apos;); &#125;else &#123; phone=Rphone if(data==&quot;&quot;)&#123; res.json(&#123;&apos;msg&apos;:&quot;手机号可用&quot;,&quot;status&quot;:&quot;1&quot;,&quot;prevNum&quot;:prevNum&#125;) &#125;else&#123; res.json(&#123;&apos;msg&apos;:&quot;手机号已被注册&quot;,&quot;status&quot;:&quot;0&quot;&#125;) &#125; &#125; &#125;)&#125;) 用户登录页面 用户订单页面 用户已经登录未购买商品页面 用户未登录页面 用户登录并且购买过商品页面通过判断localstorage的是否存在来判断用户是否登录，如果登录通过localstorage的信息查询数据来改变state的状态并且显示不同的页面。 loading加载页面 12345678910111213141516171819202122232425262728293031323334353637383940.load-top&#123;background: url(&quot;../img/loading.png&quot;) no-repeat;width:.5rem;height:.5rem;background-size: 100% auto;position:absolute;background-size: 100% auto;transform-origin: 50% 50%;animation: change 3.6s infinite steps(6),trans .3s ease-in-out infinite alternate;&#125;.w12&#123;width:.22rem;border-radius: 30%;&#125;.load-bot&#123;background: url(&quot;../img/load.png&quot;) no-repeat;top: 50%;width:.5rem;height:.5rem;background-size: 100% auto;position:absolute;background-size: 100% auto;transform-origin: 50% 50%;background-position-y: .2rem;animation: scale .3s ease-in-out infinite alternate;&#125;@keyframes scale&#123;100%&#123;transform: scale(.3);&#125;&#125;@keyframes change&#123;100%&#123;background-position: 0 -3rem;&#125;&#125;@keyframes trans&#123;100%&#123;transform: translateY(-2.5em)&#125; 通过css3动画实现 商家商品详情页面 使用fly实现购物车飞入效果，右上角为用户收藏事件，通过storage拿到用户信息查询数据库搜索用户收藏列表返回状态改变，用户点击以后再更改用户收藏店铺表的状态。 购物车和付款页面，通过redux实现用户跳转订单页面没有购买调回，用户购物车信息不丢失，如果用户付款成功清空rendux的购物车，并且跳转至订单页面； 订单页面 用户收藏页面","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"JavaScript作用域分析总结","slug":"js-scope","date":"2016-01-10T04:50:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/10/js-scope/","link":"","permalink":"http://yoursite.com/2016/01/10/js-scope/","excerpt":"原文链接 http://blog.poetries.top/2017/01/10/js-scope 一、JS解析顺序和作用域： 解析顺序： 定义（先找var function） 执行 ( 在逐步执行 ) 注意:如果函数名和var定义的变量相同，var会被函数覆盖 作用域： 每个script是一个作用域 每个函数{}是一个作用域 程序每执行到一个作用域，都是按照解析顺序解析代码； 作用域链:从内往外找要找函数内的变量；","text":"原文链接 http://blog.poetries.top/2017/01/10/js-scope 一、JS解析顺序和作用域： 解析顺序： 定义（先找var function） 执行 ( 在逐步执行 ) 注意:如果函数名和var定义的变量相同，var会被函数覆盖 作用域： 每个script是一个作用域 每个函数{}是一个作用域 程序每执行到一个作用域，都是按照解析顺序解析代码； 作用域链:从内往外找要找函数内的变量； 二、案例分析 分析前请记住这段话 解析顺序： 定义（先找var function） 执行 ( 在逐步执行 ) 注意:如果函数名和var定义的变量相同，var会被函数覆盖 举例1 12345678910alert( a );var a = 10;alert( a );function a()&#123;alert(20)&#125;;alert( a );var a = 30;alert( a );function a()&#123;alert(40)&#125;;alert( a );// 函数块 10 10 30 30 分析 1:找定义 function a(){alert(40)}; 2:执行 alert( a ) //函数块a = 10; alert( a ); // 10 alert( a ); // 10 a = 30; alert( a ); // 30 alert( a ); // 30 举例2 12345678a();var a = function()&#123;alert( 1 );&#125;a();function a()&#123;alert(2);&#125;a();var a = function()&#123;alert(3);&#125;a();//2 1 1 3 分析 1:找定义function a(){alert(2);} 2:执行a(); //2 a = function(){alert( 1 );} a(); //1 a(); //1 a = function b(){alert(3);}; a();//3 举例3 12345678 var a = 0; function fn()&#123; alert( a ); var a = 1; alert( a ); &#125; alert(a);fn(); 分析 1:找定义var a function fn(){} 2:执行a = 0; fn(); ===&gt; 1:找定义 2:执行 alert(a); //undefined a = 1; alert(a); //1 举例4 12345678910fn()();var a = 0;function fn()&#123; alert( a ); var a = 3; function c()&#123; alert( a ); &#125; return c;&#125;; 分析 1:找定义var a function fn 2:执行fn() ===&gt; 1:找定义 function c 2:执行 alert(a); //undefined a = 3 return function c fn()() ==&gt;1:找定义 function c 2:alert(a);//undefined 3 a = 0; 举例5 1234567891011121314var a = 5;function fn()&#123; var a = 10; alert(a); function b()&#123; a++; alert(a); &#125;; return b;&#125;;var c = fn();c();fn()();c(); 分析 1:找定义 var afunction fn var c 2:执行 a = 5;c = fn(); === &gt; 1:找定义 var a function b 2:执行 a = 10; alert(a); //10 return function b(){}; c();=========&gt; 1:找定义 2:执行 a++; //11 alert(a);//11 fn()(); //10 11 c() ========&gt; 1:找定义 2:执行 a++;//11+1; alert(a); //12 举例6 12345678910111213//alert(x);//9:执行弹出x,结果x没定义,错误.alert(i);//9:执行弹出i,然而i之前已经定义,只不过没地址,因此是undefiendvar i = 10;//1:var i; 10:把常量池中10的地址赋给栈中的ivar j = \"你好\";//2:var j; 11:把常量池中 你好 的地址复给栈中的jvar k = z = null;//3:var k,z; 12:把堆中null的地址赋值给z和kvar m = function()&#123;//4:var m; 5:function匿名函数 13:把匿名函数在堆中的地址赋给栈中的m alert(2);&#125;var b = document.body;//6:var b; 14:把堆中document.body对象的地址赋给栈中的bvar f = true;//7:var f; 15:把常量池中true的地址赋给栈中的变量ffunction m()&#123;//8:function m; alert(1);&#125; 举例7 12345678910function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); //var c;&#125;var c = 150; // 函数m()还未执行到 还没被销毁 此时全局c的值c=50m();var c = 20;//到这里一步 m()已经执行完了 函数已经销毁了 这里的c还是20alert(c);//20 举例8 1234567891011121314function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); function inner()&#123; c = 30; alert('嘻嘻'); &#125; inner();//c在函数内部找不到定义 所以沿着作用域链找到了全局的c&#125;var c = 20;//到这里一步 m()还没执行 函数没被销毁 这里的c是30m();alert(c);//30 三、闭包 3.1 概念 其实是函数嵌套函数 每个函数都是一个独立的作用域 每个都有自己的生命周期 延长局部变量的生命周期 3.2 例子 123456 &lt;ul id=\"list\"&gt; &lt;li&gt;01&lt;/li&gt; &lt;li&gt;02&lt;/li&gt; &lt;li&gt;03&lt;/li&gt; &lt;li&gt;04&lt;/li&gt;&lt;/ul&gt; 12345678var liDoms = document.getElementById(\"list\").getElementsByTagName(\"li\"); for(var i=0;i&lt;liDoms.length;i++)&#123; (function(a)&#123; liDoms[a].onclick = function()&#123; alert(a); &#125; &#125;)(i) &#125; 1234567891011121314151617181920212223242526//函数也是一种数据类型 它和 number string boolean object 特殊在可以打括号去执行它 //函数中的循环 function test()&#123; var arr = [],i; for(i=0;i&lt;3;i++)&#123; // arr[i] = (function fn(a)&#123; // return a; // &#125;)(i); arr[i] = fn(i); &#125; return arr; &#125; function fn(a)&#123; return a; &#125; var c = test(); //alert(c); for(var i=0;i&lt;c.length;i++)&#123; var value = c[i]; alert(value); &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"作用域","slug":"作用域","permalink":"http://yoursite.com/tags/作用域/"}]},{"title":"web Socket和Socket.IO框架","slug":"web Socket和Socket.IO框架","date":"2016-01-10T04:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/10/web Socket和Socket.IO框架/","link":"","permalink":"http://yoursite.com/2016/01/10/web Socket和Socket.IO框架/","excerpt":"","text":"web Socket和Socket.IO框架####HTTP无法轻松实现实时应用：● HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。● 我们可以非常轻松的捕获浏览器上发生的事件（比如用户点击了盒子），这个事件可以轻松产生与服务器的数据交互（比如Ajax）。但是，反过来却是不可能的：服务器端发生了一个事件，服务器无法将这个事件的信息实时主动通知它的客户端。只有在客户端查询服务器的当前状态的时候，所发生事件的信息才会从服务器传递到客户端。 但是，确实聊天室确实存在。 方法：● 长轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 ● 长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果（想象一下我们没有写res.end()时，浏览器一直转小菊花）。服务器有了新数据，就将数据发回来，又有了新数据，就将数据发回来，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。 WebSocket协议能够让浏览器和服务器全双工实时通信，互相的，服务器也能主动通知客户端了。 ● WebSocket的原理非常的简单：利用HTTP请求产生握手，HTTP头部中含有WebSocket协议的请求，所以握手之后，二者转用TCP协议进行交流（QQ的协议）。现在的浏览器和服务器之间，就是QQ和QQ服务器的关系了。所以WebSocket协议，需要浏览器支持，更需要服务器支持。 ● 支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5 ● 支持WebSocket协议的服务器有：Node 0、Apach7.0.2、Nginx1.3 Node.js上需要写一些程序，来处理TCP请求。● Node.js从诞生之日起，就支持WebSocket协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库Socket.IO。 ● Socket.IO是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持WebSocket协议的浏览器，提供了长轮询的透明模拟机制。 ● Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。 网址：http://socket.io/ 先要npm下载这个库 npm install socket.io 1.写原生的JS，搭建一个服务器，server创建好之后，创建一个io对象 scoket.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by Administrator on 2017/7/19 0019. */var app = require(&apos;http&apos;);var fs=require(&apos;fs&apos;);var server=app.createServer(function(req,res)&#123; res.writeHead(200,&#123;&quot;Content-Type&quot;:&quot;text/html;charset=&apos;uft-8&apos;&quot;&#125;); if(req.url==&apos;/&apos;)&#123; fs.readFile(&apos;./socket_io.html&apos;,function(err,data)&#123; res.end(data); &#125;) &#125;&#125;);var io = require(&apos;socket.io&apos;)(server);//connection有客户端连接io.on(&apos;connection&apos;, function(socket)&#123; //console.log(&apos;connection&apos;); socket.on(&apos;to-server&apos;,function(data)&#123; console.log(data); //socket.emit(&apos;to-client&apos;,&apos;你好：&apos;+data) /*端对端*/ io.emit(&apos;to-client&apos;,&apos;广播：&apos;+data); &#125;)&#125;);server.listen(3000); scoket.html 123456789101112131415161718192021222324252627282930313233343536373839404142- &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我是index页面，我引用了秘密script文件&lt;/h1&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;message&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;发送给服务端&quot; id=&quot;btn&quot;/&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; iosocket = io(); iosocket.on(&apos;connect&apos;, function () &#123; /*连接*/ console.log(&apos;client--connect&apos;); &#125;) iosocket.on(&apos;disconnect&apos;, function () &#123; /*断开连接*/ console.log(&apos;服务端关闭&apos;); &#125;) //接收服务器的广播 iosocket.on(&apos;to-client&apos;, function (data) &#123; /*断开连接*/ console.log(data); &#125;) var input =document.getElementById(&apos;message&apos;); document.getElementById(&quot;btn&quot;).onclick = function()&#123; iosocket.emit(&apos;to-server&apos;, input.value); /*发送数据*/ &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/categories/NodeJS/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"jQuery基础之Ajax（六）","slug":"jQuery基础之Ajax（六）","date":"2016-01-07T14:30:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/07/jQuery基础之Ajax（六）/","link":"","permalink":"http://yoursite.com/2016/01/07/jQuery基础之Ajax（六）/","excerpt":"ajax : Asynchronous Javascript And XML （异步的JavaScript和XML） 创建ajax对象 var xhr = new XMLHttpRequest();","text":"ajax : Asynchronous Javascript And XML （异步的JavaScript和XML） 创建ajax对象 var xhr = new XMLHttpRequest(); 准备发送请求 get 传递的数据放在URL后面 中文编码 encodeURI( &#39;&#39; ); 缓存 在数据后面加上随机数或者日期对象或者……; post 传递的数据放在send()里面，并且一定要规定数据格式 没有缓存问题 form表单中: action: method:(默认是get) get: 会在url里面以 name=value , 两个数据之间用 &amp; 连接 post: enctype: &quot;application/x-www-form-urlencoded&quot; url 是否异步 同步(false)：阻塞 异步(true)：非阻塞 正式发送请求 ajax请求处理过程 案列： 1234567891011121314151617181920212223242526var ajx = null;if(window.XMLHttpRequest)&#123;//兼容处理 var ajx = new XMLHttpRequest();//一般浏览器&#125;else&#123; ajx = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE6+&#125;//准备发送请求ajx.open(\"get\",\"ajax.txt\",true);//正式发送请求ajx.send();//处理请求ajx.onreadystatechange = function()&#123; if(ajx.readState == 4)&#123; if (ajx.status == 200)//200是HTTP 请求成功的状态码 &#123; console.log(ajx.responseText); &#125;else&#123; alert(\"请求出错\"); &#125; &#125;&#125; onreadystatechange ：当处理过程发生变化的时候执行下面的函数 readyState ：ajax处理过程 0：请求未初始化（还没有调用open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 responseText：请求服务器返回的数据存在该属性里面 status : http状态码","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery基础之Event（五）","slug":"jQuery基础之Event（五）","date":"2016-01-07T14:10:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/07/jQuery基础之Event（五）/","link":"","permalink":"http://yoursite.com/2016/01/07/jQuery基础之Event（五）/","excerpt":"什么是Event？","text":"什么是Event？ Event属性： type：获取事件类型名称 target:发生事件的节点 keyCode：只针对于keypress事件，获取键盘键数字 按下回车，13 pageX:光标对于页面原点的水平坐标 pageY：光标对于页面原点的垂直坐标 浏览器 clientX：光标对于浏览器窗口的水平坐标 clientY：光标对于浏览器窗口的垂直坐标 电脑屏幕 screenX：光标对于电脑屏幕的水平坐标 screenY：光标对于电脑屏幕的水平坐标 stopPropagation()：阻止冒泡 从里到外 嵌套关系 相同事件 其中的某一父类没有相同事件时,继续向上查找 bind();绑定 为匹配元素绑定处理方法 需要给一个元素添加多个事件 ，事件执行一样时候 one()：只执行一次 绑定特定事件类型方法： blur() focus() mousedown() resize() change() keydown() mousemove() scroll() click() keypress() mouseout() select() dblclick() keyup() mouseover() submit() error() load() mouseup() unload()","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery基础之插件（六）","slug":"jQuery基础之插件（六）","date":"2016-01-07T14:10:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/07/jQuery基础之插件（六）/","link":"","permalink":"http://yoursite.com/2016/01/07/jQuery基础之插件（六）/","excerpt":"什么是插件插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过`js文件的方式引用。","text":"什么是插件插件(Plugin)也称为jQuery的扩展。以jQuery核心代码为基础编写的符合一定规范的应用程序。通过`js文件的方式引用。 插件分为哪几类 UI类、表单及验证类、输入类、特效类、Ajax类、滑动类、图形图像类、导航类、综合工具类、动画类等等 引入插件的步骤 a.引入jquery.js文件，而且在所以插件之前引入 b.引入插件 c.引入插件相关文件，比如皮肤、中文包 使用插件（验证demo） 如何自定义插件： 插件形式分为3类： a. 封装对象方法插件 b. 封装全局函数插件 c. 选择器插件(类似于.find()) 自定义插件的规范（解决各种插件的冲突和错误，增加成功率） 命名：jquery.插件名.js 所有的新方法附加在jquery.fn对象上面，所有新功能附加在jquery上 所有的方法或插件必须用分号结尾，避免出问题 插件必须返回jQuery对象，便于链式连缀 避免插件内部使用$，如果要使用，请传递jQuery($并不是总等于jQuery，另外其他js框架也可能使用$) 插件中的this应该指向jQuery对象 使用this.each()迭代元素 自定义插件案例 为了方便用户创建插件，jQuery提供了 jQuery.extend() 和 jQuery.fn.extend() jQuery.extend()：创建工具函数或者是选择器 jQuery.fn.extend()：创建jQuery对象命令 （fn相当于prototype的别名） 自定义jQuery函数： 1234567(function($)&#123; $.extend(&#123; test: function()&#123; alert(\"hello plugin\"); &#125; &#125;) &#125;)(jQuery); 自定义jQuery命令： 形式1： 1234567(function($)&#123; $.fn.extend(&#123; say : function()&#123; alert(\"hello plugin\"); &#125; &#125;) &#125;)(jQuery); 形式2： 123456(function($)&#123; $.fn.say = function()&#123; alert(\"hello plugin\"); &#125;; &#125;)(jQuery);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery操作DOM（三）","slug":"jQuery操作DOM（三）","date":"2016-01-07T13:10:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/07/jQuery操作DOM（三）/","link":"","permalink":"http://yoursite.com/2016/01/07/jQuery操作DOM（三）/","excerpt":"操作DOM","text":"操作DOM 什么是DOM：Document Object Model缩写，文档对象模型 理解页面的树形结构 什么是节点：是DOM结构中最小单元，包括元素、属性、文本、文档等。 创建节点 创建元素 语法： 1234document.createElement(name);var div = document.createElement(\"div\");document.body.appendChild(div); $(html)：根据传递的标记字符串，创建DOM对象 创建文本 1234567var div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);var $div = = $(\"&lt;div&gt;DOM&lt;/div&gt;\");$(body).append($div); 设置属性 语法：setAttrbute(name,value) 12345678var div = document.createElement(\"div\");var txt = document.createTextNode(\"DOM\");div.appendChild(txt);document.body.appendChild(div);div.setAttribute(\"title\",\"盒子\");var $div = = $(\"&lt;div title='盒子'&gt;DOM&lt;/div&gt;\");$(body).append($div); 插入内容 内部插入 向元素最后面插入节点： append():向每个匹配的元素内部追加内容 appendTo():把所有匹配的元素追加到指定元素集合中，$(&quot;A&quot;).append(&quot;B&quot;) 等效 $(&quot;B&quot;).appendTo(&quot;A&quot;) 向元素最前面插入节点： prepend（）：把每个匹配的元素内部前置内容 prependTo（）：把所有匹配的元素前置到另一个指定的元素集合中,$(&quot;A&quot;).prepend(&quot;B&quot;) 等效$(&quot;B&quot;).prependTo(&quot;A&quot;) 外部插入 after():在每个匹配的元素之后插入内容 before()：在每个匹配想元素之前插入内容 insertAfter()：将所有匹配的元素插入到另一个指定的元素集合后面，$A.insert($B)等效 $B.insertAfter($A); insertBefore()：将所有匹配的元素插入到另一个指定的元素集合前面 $A.before($B) 等效 $B.insertBefore($A); 删除内容 移除 remove():从DOM中删除所有匹配元素 清空 empty():删除匹配的元素集合中所有子节点内容 克隆内容：创建指定节点副本 clone() 注意：若clone（true）则是包括克隆元素的属性，事件等 替换内容 replaceWith():将所有匹配的元素替换成指定的元素 replaceAll():用匹配的元素替换掉指定元素 注意：两者效果一致，只是语法不同 $A.replaceAll($B) 等效于 $B.replaceWhith($A);","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery动画基础（四）","slug":"jQuery动画基础（四）","date":"2016-01-07T13:10:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/07/jQuery动画基础（四）/","link":"","permalink":"http://yoursite.com/2016/01/07/jQuery动画基础（四）/","excerpt":"介绍jQuery动画 JavaScript语言本身不支持动画设计，必须通过改变`CSS来实现动画效果。","text":"介绍jQuery动画 JavaScript语言本身不支持动画设计，必须通过改变`CSS来实现动画效果。 显隐 显隐动画 show():显示 show()从上到下增加元素的高度，从左到右增加元素宽度，从0到1增加透明度，直至内容完全可见 hide():隐藏 hide()通过改变元素的高度宽度和不透明度，直到这三个属性值到0 参数： show() show(speed,callback) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） callback: 动画完成时执行的方法 显示和隐藏式一对密不可分的动画形式。 显隐切换 toggle():切换元素的可见状态 原理：匹配元素的宽度、高度以及不透明度，同时进行动画，隐藏动画后将display设置为none 参数： toggle(speed) toggle(speed,callback) toggle(boolean) speed: 字符串或数字，表示动画将运行多久（slow=0.6/normal=0.4/fast=0.2） easing： 使用哪个缓冲函数来过渡的字符串(linear/swing) callback： 动画完成时执行的方法 boolean:true为显示 false为隐藏 滑动 显隐滑动效果 slideDown():滑动隐藏 slidUp():滑动显示 参数: slideDown(speed,callback) slidUp(speed,callback) 显隐切换滑动 slideToggle():显隐滑动切换 参数: slidUp(speed,callback) 渐变：通过改变不透明度 淡入淡出 fadeIn() fadeOut() 参数 fadeIn(speed,callback) fadeOut(speed,callback) 设置淡出透明效果 fadeTo()⁭：以渐进的方式调整到指定透明度 参数： fadeTo(speed,opacity,callback) 渐变切换: 结合fadeIn和fadeOut fadeToggle() 参数: fadeOut(speed,callback) 自定义： 自定义动画：animate() 用animate模拟show(): show: 表示由透明到不透明 toggle: 切换 hide:表示由显示到隐藏","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery选择器及优化（二）","slug":"jQuery选择器及优化（二）","date":"2016-01-07T13:05:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/07/jQuery选择器及优化（二）/","link":"","permalink":"http://yoursite.com/2016/01/07/jQuery选择器及优化（二）/","excerpt":"层级选择器:通过DOM的嵌套关系匹配元素","text":"层级选择器:通过DOM的嵌套关系匹配元素 jQuery层级选择器—-包含选择器、子选择器、相邻选择器、兄弟选择器4种 包含选择器：$(&quot;a b&quot;)在给定的祖先元素下匹配所有后代元素。(不受层级限制) 子选择器：$(&quot;parent &gt; child&quot;) 在给定的父元素下匹配所有子元素。 相邻选择器：$(&quot;prev + next&quot;) 匹配所有紧接在prev元素后的next元素。 兄弟选择器：$(&quot;prev ~ siblings&quot;) 匹配prev元素之后的所有sibling元素。 案例： 12345678910111213141516171819202122&lt;BODY&gt; &lt;!--包含选择器/子选择器/兄弟选择器/相邻选择器--&gt; &lt;div class=\"main\"&gt; &lt;span&gt;1&lt;img src=\"images/1.jpg\"/&gt;&lt;/span&gt; 2&lt;img src=\"images/1.jpg\"/&gt; &lt;/div&gt; 3&lt;img src=\"images/1.jpg\"&gt; 4&lt;img src=\"images/1.jpg\"&gt; &lt;div&gt; 5&lt;img src=\"images/1.jpg\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; //$(\".main img\").css(\"border\",\"5px solid red\"); //$(\".main &gt; img\").css(\"border\",\"5px solid blue\"); //$(\".main + img\").css(\"border\",\"5px solid blue\"); $(\".main ~ img\").css(\"border\",\"5px solid blue\"); &#125;); &lt;/script&gt; &lt;/BODY&gt; 综合应用： 1234567891011121314151617181920212223242526&lt;body&gt; &lt;h1&gt;沁园春·雪&lt;/h1&gt; &lt;h2&gt;毛泽东&lt;/h2&gt; &lt;div&gt; &lt;span&gt;&lt;div&gt;北国风光，千里冰封，万里雪飘。 &lt;div&gt;望长城内外，惟余莽莽；大河上下，顿失滔滔。&lt;/div&gt; &lt;p&gt;山舞银蛇，原驰蜡象，欲与天公试比高。&lt;/p&gt; &lt;p&gt;须晴日，看红装素裹，分外妖娆。&lt;/p&gt; &lt;/div&gt;&lt;/span&gt; &lt;p id=\"mp\"&gt;江山如此多娇，引无数英雄竞折腰。&lt;/p&gt; &lt;/div&gt; &lt;p class=\"c1\"&gt;惜秦皇汉武，略输文采；唐宗宋祖，稍逊风骚。&lt;/p&gt; &lt;p class=\"c1\"&gt;一代天骄，成吉思汗，只识弯弓射大雕。&lt;/p&gt; &lt;p&gt;俱往矣，数风流人物，还看今朝。&lt;/p&gt;&lt;/body&gt;&lt;!-- 1. 让id为mp的元素文字大小变成30px 2. 让class名为.c1的元素背景为#CCFF99 3. 将所有的div和p，统一显示间距 4. 将所有的div增加 2像素 实线 红色 5. 将div下的所有子div中文字变蓝色blue 6. 将div中包含的div颜色变成#FF99FF 7. 将div的所有兄弟标签p的字体颜色变成蓝色 8. 将紧跟着div的p标签的边框设为2像素 实线 #009900 --&gt; 常用伪类选择器:可以看作是一种特殊的类选择符 选择器 :first 匹配找到的第1个元素 :last 匹配找到的最后一个元素 :eq 匹配一个给定索引值的元素 :even 匹配所有索引值为偶数的元素 :odd 匹配所有索引值为奇数的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :not 去除所有与给定选择器匹配的元素 特定位置选择器 :first/:last/:eq(index) 例： 12345&lt;table&gt; &lt;tr&gt;&lt;th&gt;特定位置选择器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:first&lt;/td&gt;&lt;td&gt;匹配找到的第一个元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:last&lt;/td&gt;&lt;td&gt;匹配找到的最后一个元素&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 指定范围选择器 :even/:odd/:gt(index)/:lt(index) 例： 123456789&lt;table&gt; &lt;tr&gt;&lt;th&gt;指定范围选择器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:first&lt;/td&gt;&lt;td&gt;匹配找到的第一个元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:last&lt;/td&gt;&lt;td&gt;匹配找到的最后一个元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:even&lt;/td&gt;&lt;td&gt;匹配所有索引值为偶数的元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:odd&lt;/td&gt;&lt;td&gt;匹配所有索引值为奇数的元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:gt(index)&lt;/td&gt;&lt;td&gt;匹配所有索引大于给定索引值的元素&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:lt(index)&lt;/td&gt;&lt;td&gt;匹配所有索引小于给定索引值的元素&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 排除选择器 :not 非 例： 1234&lt;table&gt; &lt;tr&gt;&lt;th&gt;排除选择器&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;:not&lt;/td&gt;&lt;td&gt;排除符合特定匹配规则的元素&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 选择器优化： 使用合适的选择器表达式可以提高性能、增强语义并简化逻辑。常用的选择器中，ID选择器速度最快，其次是类型选择器。 多用ID选择器 少直接使用class选择器 多用父子关系，少用嵌套关系 缓存jQuery对象 使用过滤器 jQuery提供了2种选择文档元素的方式：选择器和过滤器 类过虑器：根据元素的类属性来进行过滤操作。 hasClass(className)：判断当前jQuery对象中的某个元素是否包含指定类名，包含返回true，不包含返回false 下标过滤器：精确选出指定下标元素 eq(index)：获取第N个元素。index是整数值，下标从0开始 表达式过滤器 filter(expr)/(fn)：筛选出与指定表达式/函数匹配的元素集合。 功能最强大的表达式过滤器，可接收函数参数，也可以是简单的选择器表达式 映射 map(callback)：将一组元素转换成其他数组 清洗 not(expr)：删除与指定表达式匹配的元素 截取 slice(start,end)：选取一个匹配的子集 查找 向下查找后代元素 children():取得所有元素的所有子元素集合（子元素） find():搜索所有与指定表达式匹配的元素(所有后代元素中查找) 查找兄弟元素siblings()查找当前元素的兄弟","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery概述（一）","slug":"jQuery概述及学习纲要j（一）","date":"2016-01-07T11:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2016/01/07/jQuery概述及学习纲要j（一）/","link":"","permalink":"http://yoursite.com/2016/01/07/jQuery概述及学习纲要j（一）/","excerpt":"jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。","text":"jQuery是什么: 是一个javascript代码仓库，我们称之为javascript框架。 是一个快速的简洁的javascript框架，可以简化查询DOM对象、处理事件、制作动画、处理Ajax交互过程。 jQuery可以帮我们做什么(有什么优势)、 体积小，使用灵巧(只需引入一个js文件) 方便的选择页面元素(模仿CSS选择器更精确、灵活) 动态更改页面样式/页面内容(操作DOM，动态添加、移除样式) 控制响应事件(动态添加响应事件) 提供基本网页特效(提供已封装的网页特效方法) 快速实现通信(ajax) 易扩展、插件丰富 javascript用来干什么的： 操作DOM对象 动态操作样式css 数据访问 控制响应事件等 讲解$(function(){}) $是jQuery别名。如$()也可jQuery()这样写,相当于页面初始化函数，当页面加载完毕，会执行jQuery()。 希望在做所有事情之前，JQuery操作DOM文档。必须确保在DOM载入完毕后开始执行，应该用ready事件做处理HTML文档的开始。 $(document).ready(function(){}) 类似于js的window.onload事件函数，但是ready事件要先于onload事件执行。 window.onload = function(){} 为方便开发，jQuery简化这样的方法，直接用$()表示 JQuery的ready事件不等于Js的load ： 执行时机不同：load需要等外部图片和视频等全部加载才执行。ready是DOM绘制完毕后执行，先与外部文件。 用法不同：load只可写一次，ready可以多次。 $()和document是相等的吗 12345&lt;div id=\"a\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"b\" class=\"aa\"&gt;&lt;/div&gt;&lt;div id=\"c\" class=\"aa\"&gt;&lt;/div&gt;alert(document.getElementById(\"id\") == $(\"#aa\"));//返回结果为falsealert(document.getElementById(\"id\") == $(\"#aa\").get(0));//返回true 样式选择器$(&quot;.className&quot;) $(&quot;.aa&quot;).css(&quot;color&quot;,&quot;green&quot;) id选择器 $(&quot;#a&quot;).css(&quot;background-color&quot;,&quot;#ff0066&quot;) 标签选择器 $(&quot;p&quot;).css(&quot;color&quot;,&quot;#cc3366&quot;) 组选择器 $(&quot;#b ul li&quot;).size(); jQuery有哪些功能(API)： a.选择器 b.过滤器 c.事件 d.效果 e.ajax 简单的JQuery选择器： JQuery基本选择器（ID选择器，标签选择器，类选择器，通配选择器和组选择器5种） ID选择器：document.getElementById(id)与$(&quot;#id&quot;)对比(改变文字大小)—id唯一，返回单个元素 标签选择器：document.getElementsByTagName(tagName)与$(&quot;tagname&quot;)对比—多个标签，返回数组 类选择器:$(&quot;.className&quot;)–多个classname（改变背景图片） 通配选择器：document.getElementsByTagName(&quot;*&quot;)与$(&quot;*&quot;)对比—指范围内的所有标签元素 组选择器：$(&quot;seletor1,seletor2,seletor3&quot;)—-无数量限制，用逗号分割。 附录： 简易jQuery内存图 jQuery学习大纲","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"JavaScript及jQuery中的各种宽高属性图解","slug":"js-props","date":"2015-12-13T15:35:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-props/","link":"","permalink":"http://yoursite.com/2015/12/13/js-props/","excerpt":"原文链接 http://blog.poetries.top/2016/12/13/js-props声明：本文根据慕课网学习视频整理 强烈建议打开控制台自己动手练习一遍，这样印象才会深刻 第一部分 JavaScript中的宽高属性 一、与window相关的宽高属性 1.1 window.location和document.location window对象的location属性引用的是location对象，表示该窗口中当前显示文档的URL document的对象的location属性也是引用location对象 所以 window.location === document.location //true","text":"原文链接 http://blog.poetries.top/2016/12/13/js-props声明：本文根据慕课网学习视频整理 强烈建议打开控制台自己动手练习一遍，这样印象才会深刻 第一部分 JavaScript中的宽高属性 一、与window相关的宽高属性 1.1 window.location和document.location window对象的location属性引用的是location对象，表示该窗口中当前显示文档的URL document的对象的location属性也是引用location对象 所以 window.location === document.location //true 1.2 window.screen window.screen包含有关用户屏幕的信息。它包括： window.screen.width window.screen.height window.screen.availHeight window.screen.availWidth window.screenTop window.screenLeft 1.3 与window相关的宽高 window.innerWidth 内部的宽度 window.innerHeight 内部的高度 window.outWidth 外部的宽度 window.outHeight 外部的高度 二、与document相关的宽高属性 2.1与client相关的宽高 document.body.clientWidth 元素宽度（可视内容区+内边距） document.body.clientHeight元素高度（可视内容区+内边距） 该属性指的是元素的可视部分宽度和高度，即padding+content如果没有滚动条，即为元素设定的宽度和高度如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高 example1： 1234567891011body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; console.log(document.body.clientWidth); // 350+padding(80) = 430console.log(document.body.clientHeight); // 500 + padding(80) = 580 example2: 在div中添加文字， 指导出现滚动条 123456789101112#exp2 &#123; width:200px; height:200px; background:red; border:1px solid #000; overflow:auto;&#125;var test = document.getElementById(\"exp2\");console,log(test.clientHeight); // 200console.log(test.clientWidth); // window7下test.clientWidth 小结clientWidth和clientHeight 无padding无滚动 ： clientWidth = 盒子的width 有padding无滚动 ： clientWidth = 盒子的width + 盒子的padding * 2 有padding有滚动 ： clientWidth = 盒子和width + 盒子的padding * 2- 滚动轴宽度 document.body.clientLeft document.body.clientTop 这两个返回的是元素周围边框的厚度，如果不指定一个边框或者不定位该元素，它的值就是0 例： 1234567891011body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; console.log(document.body.clientLeft); // 20console.log(document.body.clientTop); // 20 小结clientLeft和clientTop 这一对属性是用来读取元素的border的宽度和高度的 clientTop = border-top clientLeft = border-left 2.2 与offset相关的宽高 document.body.offsetWidth（元素的border+padding+content的宽度） document.body.offsetHeight（元素的border+padding+content的高度） 该属性和其内部的内容是否超出元素大小无关，只和本来设定的border以及width和height有关 例： 1234567891011body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; console.log(document.body.offsetWidth); // 470 = padding*2 + 350 + border*2console.log(document.body.offsetHeight); // 620 = padding*2 + 500 + border*2 小结offsetWidth和offsetHeight 无padding无滚动无border offsetWidth = clientWidth = 盒子的宽度 有padding无滚动有border offsetWidth = 盒子的宽度 + 盒子padding2 + 盒子边框2 = clientWidth + 边框宽度*2 有padding有滚动，且滚动是显示的，有border offsetWidth = 盒子宽度 + 盒子padding2 + 盒子边框2 = clientWidth + 滚动轴宽度 + 边框宽度*2 document.offsetLeft document.offsetTop 了解这两个属性我们必须先了解它，什么是offsetParent 如果当前元素的父级元素没有进行CSS定位（position为absolute或relative）,offsetParent为body. 假如当前元素的父级元素中有CSS定位，offsetParent取最近的那个父级元素 offsetLeft的兼容性问题： 在IE6/7中 offsetLeft = offsetParent的padding-left + 当前元素的margin-left 在IE8/9/10以及chrome中 offsetLeft = offsetParent的margin-left + offsetParent的border宽度 + offsetParent的padding-left + 当前元素的margin-left 在FireFox中 offsetLeft = offsetParent的margin-left + 当前元素的margin-left + offsetParent的padding-left 例： 1234567891011121314151617181920body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125; #exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow:auto;&#125;var div = document.getElementById(\"exp\"); 在IE8/9/10以及chrome中： div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80 div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 + border20 = 80 在FireFox：（相比chrome中少了border） div.offsetLeft = 本身的margin10 + 父级元素的padding40 + margin10 = 60 div.offsetTop = 本身的margin10 + 父级元素的padding40 + margin10 = 60 在IE6/7中：（相比在FireFox，不但少了border还少了父级元素的margin） div.offsetLeft = 本身的margin10 + 父级元素的padding40 = 50 div.offsetTop = 本身的margin10 + 父级元素的padding40 = 50 2.3与scroll相关的宽高 (实际项目中用的最多) document.body.scrollWidth document.body.scrollHeight document.body的scrollWidth和scrollHeight与div的scrollWidth和scrollHeight是有区别的 例： 123456789101112body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125;document.body.scrollHeight; // document.body.scrollWidth; // 当给定宽高小于浏览器窗口的宽高 scrollWidth = 通常是浏览器窗口的宽度 scrollHeight = 通常是浏览器窗口的高度 当给定宽高大于浏览器窗口的宽高，且内容小于给定宽高的时候 scrollWidth = 给定宽度 + 其所有的padding + margin + border scrollHeight = 给定高度 + 其所有的padding + margin + border 当给定宽高大于浏览器窗口宽高，且内容大于给定宽高 scrollWidth = 内容宽度 + 其所有的padding + margin + border scrollHeight = 内容高度 + 其所有的padding + margin + border 在某div中的scrollWidth和scrollHeight 无滚动轴时： scrollWidth = clientWidth = 盒子宽度 + 盒子padding*2 有滚动轴时： scrollWidth = 实际内容的宽度 + padding*2 scrollHeight = 实际内容的高度 + padding*2 document.body.scrollLeft document.body.scrollTop 与前面不同的是，这对属性是可读写的，指的是当元素其中的超出其宽高的时候，元素被卷起来的高度和宽度 12345678910111213141516171819#exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow-y:scroll;&#125;var mydiv = document.getElementById(\"exp\");mydiv.scrollTop ; //默认情况下是0 mydiv.scrollLeft ; //默认情况下是0 //可以改写它mydiv.scrollTop = 20;console.log(mydiv.scrollTop) scrollTop和scrollLeft obj.style.width和obj.style.height 对于一个DOM元素，它的style属性返回的是一个对象，这个对象的任意一个属性是可读写的，style.width等于css属性中的宽度。style.height等于css属性中的高度 2.4 documentElement和body的关系 是父子级的关系 1234567891011121314151617181920212223body&#123; border: 20px solid #000; margin: 10px; padding: 40px; background: #eee; height: 350px; width: 500px; overflow: scroll; &#125;#exp &#123; width:400px; height:200px; padding:20px; margin:10px; background:red; border:20px solid #000; overflow-y:scroll;&#125;console.log(document); //documentconsole.log(document.documentElement); //htmlconsole.log(document.body); //body Paste_Image.png 兼容问题推荐使用 获取浏览器窗口可视区域大小 12document.body.clientWidth || document.documentElement.clientWidth;document.body.clientHeight || document.documentElement.clientHeight; 三、Event对象的5种坐标 Event对象的5种坐标 例： 12&lt;div id=\"example\" style=\"width: 200px;height: 200px;background: red;margin: 100px auto;\"&gt;&lt;/div&gt; 12345678var example = document.getElementById(\"example\");example.onclick = function(e)&#123; console.log(\"clientX \"+e.clientX + \" : \" + \" clientY \"+e.clientY); console.log(\"screenX \"+e.screenX + \" : \" + \" screenY \"+e.screenY); console.log(\"offsetX \"+e.offsetX + \" : \" + \" offsetY \"+e.offsetY); console.log(\"pageX \"+e.pageX + \" : \" + \" pageY \"+e.pageY); console.log(\"x \"+e.x + \" : \" + \" y \"+e.y);&#125; Event对象的5种坐标 四、 js各种宽高的应用 example1：可视区域加载 1&lt;div id=\"example1\" &gt;&lt;/div&gt; 123456789101112131415161718192021#example1 &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto; &#125; @-webkit-keyframes fadeInLeft&#123; 0%&#123; opacity: 0; transform: translate3d(-100%,0,0); &#125; 100%&#123; opacity: 1; transform: none; &#125; &#125; .fadeInLeft &#123; animation-name: fadeInLeft; animation-duration: 2s; &#125; 123456789101112function showDiv()&#123; var example = document.getElementById(\"example\"); var clients = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;//可视区域的高度 var divTop = example.getBoundingClientRect().top; if(divTop &lt;= clients)&#123; example.classList.add(\"fadeInLeft\"); // 这里可以通过setAttribute设置图片的src按需加载 &#125; document.title = clients+\"---\"+divTop; &#125; window.onscroll = showDiv; 在线演示 example2：网页滚动到顶部或者底部 1&lt;div id=\"example2\" &gt;&lt;/div&gt; 123456#example2 &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto;&#125; 12345678910111213141516function scrollTopOrBottom()&#123; var example2 = document.getElementById(\"example\"); var clients = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;//可视区域的高度，兼容性写法 var scrollTop = document.body.scrollTop; var wholeHeight = document.body.scrollHeight; if(clients + scrollTop &gt;= wholeHeight)&#123; alert(\"我已经到了底部!\"); // 这里可以调用Ajax分页加载到页面中，实现多页加载功能 &#125;else if(scrollTop == 0)&#123; alert(\"我已经到了顶部了!\"); &#125; document.title = (clients + scrollTop)+\"---\"+wholeHeight+\"--\"+scrollTop; &#125; window.onscroll = scrollTopOrBottom; 在线演示 example3：DIV滚动到底部加载 12345678&lt;div id=\"example3\" &gt; DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载 DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载DIV滚动到底部加载&lt;/div&gt; 12345678#example3 &#123; width: 500px; height: 400px; background: red; margin: 10px auto; padding: 10px; overflow-y: scroll;&#125; 123456789101112131415161718var div = document.getElementById(\"example3\"); function divScroll()&#123; var wholeHeight = div.scrollHeight;//滚动区域高度 var divScrollTop = div.scrollTop;//卷上去的那部分高度 var divHeight = div.clientHeight; //div的可视区域的高度 if(divScrollTop + divHeight &gt;= wholeHeight)&#123; alert(\"我已经到了底部!\"); // 这里可以在div中通过滚动加载分页按需显示 &#125;else if(divScrollTop == 0)&#123; alert(\"我已经到了顶部了!\"); &#125; document.title = (divScrollTop + divHeight)+\"---\"+wholeHeight+\"--\"+divScrollTop;&#125; div.onscroll = divScroll; 在线演示 example4：计算滚动轴的宽度 123456789101112131415161718//获取滚动轴的宽度 function getScrollBar()&#123; var el = document.createElement(\"p\"); var styles = &#123; width:\"100px\", height:\"100px\", overflowY:\"scroll\" &#125;; for (var prop in styles)&#123; el.style[prop] = styles[prop];//把 styles上的属性全部遍历拷贝到el.style上 &#125; document.body.appendChild(el); var scrollBarWidth = el.offsetWidth - el.clientWidth; el.remove(); return scrollBarWidth; &#125; alert(getScrollBar());//17 在线演示 五、js中的宽高属性总结 Paste_Image.png document相关的宽高 第二部分 jQuery中的宽高属性 一、jquery相关宽高介绍 1.1 width() 特殊元素window.document只可以读，普通元素可以读写，width()返回结果无单位，css(&quot;width&quot;)的结果有单位 width 1.2 innerWidth() 包含padding（不推荐window,document调用） 1.3 innerHeight() innerWidth--innerHeight innerWidth 1.4 outerWidth() 包含padding和border，当传true时包含marging，不传时不包含marging（不推荐window,document调用） 1.5 outerHeight() outerWidth--outerHeight outerWidth 1.6 scrollLeft(): 相对于水平滚动条左边的距离，如果滚动条非常左、或者元素不能被滚动，这个值为0； 1.7 scrollTop(): 相对于垂直滚动条上边的距离，如果滚动条非常上、或者元素不能被滚动，这个值为0； 1.8 .offset(): 相对于document的当前坐标值(相对于body左上角的left,top的值)； 1.9 .position(): 相对于offset parent的当前坐标值(相对于offset parent元素的左上角的left、top的值) 二、jquery相关宽高举例 2.1 exmaple1 example1 123&lt;div class=\"parentDiv\"&gt; &lt;div class=\"childrenDiv\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122html,body &#123; margin:10px; border:5px solid red; padding:20px;&#125;.parentDiv &#123; width:800px; height:500px; margin:5px auto; background:#FF6600; border:5px dashed green;padding:30px;position:relative;&#125;.childrenDiv &#123; width:300px; height:500px; margin:5px auto; background:yellow; border:5px solid black; padding:5px; box-sizing:border-box;/*包括padding和border的值*/&#125; 1234567891011121314151617181920212223242526272829303132333435//特殊元素的高度//window documentconsole.log(\"$(window).height()\"+$(window).height());console.log(\"$(document).height()\"+$(document).height());//innerHeight console.log(\"$(window).innerHeight()\"+$(window).innerHeight());console.log(\"$(document).innerHeight()\"+$(document).innerHeight());//普通child元素的高度//480 = 500 - border*2 - padding*2 (因为设置了box-sizing，box-sizing把border和padding的值计算了进去)console.log('$(\".childrenDiv\").height()'+ $(\".childrenDiv\").height());//490 = 500 - border*2 - padding*2（innerHeight不包括padding）console.log('$(\".childrenDiv\").innerHeight()'+ $(\".childrenDiv\").innerHeight());//500 = 500 不包括marginconsole.log('$(\".childrenDiv\").outerHeight()'+ $(\".childrenDiv\").outerHeight());//510 = 500 + margin true包括marginconsole.log('$(\".childrenDiv\").outerHeight()'+ $(\".childrenDiv\").outerHeight(true));//scrollTop$(window).scroll(function()&#123; document.title = \"scrollTop \"+$(this).scrollTop();&#125;);// jquery宽高演示之offset和positionconsole.log('$(\".childrenDiv\").offset().top '+$(\".childrenDiv\").offset().top);console.log('$(\".childrenDiv\").offset().left '+$(\".childrenDiv\").offset().left);console.log('$(\".childrenDiv\").position().top '+$(\".childrenDiv\").position().top);console.log('$(\".childrenDiv\").position().top '+$(\".childrenDiv\").position().left); Paste_Image.png offset-position 在线演示 三、jquery各种宽高应用 3.1 jquery可视区域加载 1&lt;div id=\"example\" &gt;&lt;/div&gt; 123456789101112131415161718192021#example &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto; &#125; @-webkit-keyframes fadeInLeft&#123; 0%&#123; opacity: 0; transform: translate3d(-100%,0,0); &#125; 100%&#123; opacity: 1; transform: none; &#125; &#125; .fadeInLeft &#123; animation-name: fadeInLeft; animation-duration: 2s; &#125; 12345678910$(window).scroll(function()&#123; var ks_area = $(window).height();//可视区域高度 var scrollHeight = $(window).scrollTop();//被卷上去的那部分 var divTop = $(\"#example\").offset().top;//盒子距离浏览器顶部的距离 if(ks_area + scrollHeight &gt;= divTop)&#123; $(\"#example\").addClass(\"fadeInLeft\"); &#125; document.title = ks_area+'-'+scrollHeight+'-'+divTop;&#125;); 在线演示 3.2 jquery滚动到底部和顶部加载 12&lt;div id=\"example\" &gt;&lt;/div&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt; 123456#example &#123; width: 500px; height: 350px; background: red; margin: 1000px auto 0 auto;&#125; 1234567891011$(window).scroll(function()&#123; var ks_area = $(window).height(); var scrollTop = $(window).scrollTop(); var wholeHeight = $(document).height(); if(ks_area + scrollTop &gt;=wholeHeight )&#123; alert(\"已经到底部了\"); &#125;else if(scrollTop == 0)&#123; alert(\"已经到头部了\"); &#125;&#125;) 在线演示 （完）","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS 中的事件绑定、事件监听、事件委托","slug":"js-event-listener","date":"2015-12-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-event-listener/","link":"","permalink":"http://yoursite.com/2015/12/13/js-event-listener/","excerpt":"事件绑定 要想让 JavaScript对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称","text":"事件绑定 要想让 JavaScript对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称 在JavaScript中，有三种常用的绑定事件的方法 在DOM元素中直接绑定； 在JavaScript代码中绑定； 绑定事件监听函数 在DOM中直接绑定事件1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclick=&quot;hello()&quot;&gt;&lt;script&gt;function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 在JavaScript代码中绑定事件 在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发 1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 使用事件监听绑定事件 关于事件监听，W3C规范中定义了3个事件阶段，依次是捕获阶段、目标阶段、冒泡阶段 起初Netscape制定了JavaScript的一套事件驱动机制（即事件捕获）。随即IE也推出了自己的一套事件驱动机制（即事件冒泡）。最后W3C规范了两种事件机制，分为捕获阶段、目标阶段、冒泡阶段。IE8以前IE一直坚持自己的事件机制（前端人员一直头痛的兼容性问题），IE9以后IE也支持了W3C规范 W3C规范 语法 1element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有DOM事件。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false 注：IE8 以下不支持 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn1&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn1&quot;).addEventListener(&quot;click&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; IE标准 语法： 1element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数 12345678&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn2&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn2&quot;).attachEvent(&quot;onclick&quot;,hello);function hello()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 事件监听的优点 可以绑定多个事件 1234567891011&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn3&quot;&gt;&lt;script&gt;var btn3 = document.getElementById(&quot;btn3&quot;);btn3.onclick = function()&#123; alert(&quot;hello 1&quot;); //不执行&#125;btn3.onclick = function()&#123; alert(&quot;hello 2&quot;); //执行&#125;&lt;/script&gt; 常规的事件绑定只执行最后绑定的事件 1234567891011121314&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn4&quot;&gt;&lt;script&gt;var btn4 = document.getElementById(&quot;btn4&quot;);btn4.addEventListener(&quot;click&quot;,hello1);btn4.addEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 两个事件都执行了 可以解除相应的绑定 123456789101112131415&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;&lt;script&gt;var btn5 = document.getElementById(&quot;btn5&quot;);btn5.addEventListener(&quot;click&quot;,hello1);//执行了btn5.addEventListener(&quot;click&quot;,hello2);//不执行btn5.removeEventListener(&quot;click&quot;,hello2);function hello1()&#123; alert(&quot;hello 1&quot;);&#125;function hello2()&#123; alert(&quot;hello 2&quot;);&#125;&lt;/script&gt; 封装事件监听 12345678910111213141516171819202122232425&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn5&quot;&gt;//绑定监听事件function addEventHandler(target,type,fn)&#123; if(target.addEventListener)&#123; target.addEventListener(type,fn); &#125;else&#123; target.attachEvent(&quot;on&quot;+type,fn); &#125;&#125;//移除监听事件function removeEventHandler(target,type,fn)&#123; if(target.removeEventListener)&#123; target.removeEventListener(type,fn); &#125;else&#123; target.detachEvent(&quot;on&quot;+type,fn); &#125;&#125;//测试var btn5 = document.getElementById(&quot;btn5&quot;);addEventHandler(btn5,&quot;click&quot;,hello1);//添加事件hello1addEventHandler(btn5,&quot;click&quot;,hello2);//添加事件hello2removeEventHandler(btn5,&quot;click&quot;,hello1);//移除事件hello1 事件委托 事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果 12345678910&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn6&quot;&gt;var btn6 = document.getElementById(&quot;btn6&quot;);document.onclick = function(event)&#123; event = event || window.event; var target = event.target || event.srcElement; if(target == btn6)&#123; alert(btn5.value); &#125;&#125; 事件委托优点 提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用 传统写法 123456789101112131415161718192021&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);item1.onclick = function()&#123; alert(&quot;hello item1&quot;);&#125;item2.onclick = function()&#123; alert(&quot;hello item2&quot;);&#125;item3.onclick = function()&#123; alert(&quot;hello item3&quot;);&#125;&lt;/script&gt; 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var item1 = document.getElementById(&quot;item1&quot;);var item2 = document.getElementById(&quot;item2&quot;);var item3 = document.getElementById(&quot;item3&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target == item1)&#123; alert(&quot;hello item1&quot;); &#125;else if(target == item2)&#123; alert(&quot;hello item2&quot;); &#125;else if(target == item3)&#123; alert(&quot;hello item3&quot;); &#125;&#125;)&lt;/script&gt; 动态的添加DOM元素，不需要因为元素的改动而修改事件绑定 传统写法 123456789101112131415161718192021222324&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);var item = list.getElementsByTagName(&quot;li&quot;);for(var i=0;i&lt;item.length;i++)&#123; (function(i)&#123; item[i].onclick = function()&#123; alert(item[i].innerHTML); &#125; &#125;)(i)&#125;var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 点击item1到item3都有事件响应，但是点击item4时，没有事件响应。说明传统的事件绑定无法对动态添加的元素而动态的添加事件。 事件委托 12345678910111213141516171819202122&lt;ul id=&quot;list&quot;&gt; &lt;li id=&quot;item1&quot; &gt;item1&lt;/li&gt; &lt;li id=&quot;item2&quot; &gt;item2&lt;/li&gt; &lt;li id=&quot;item3&quot; &gt;item3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var list = document.getElementById(&quot;list&quot;);document.addEventListener(&quot;click&quot;,function(event)&#123; var target = event.target; if(target.nodeName == &quot;LI&quot;)&#123; alert(target.innerHTML); &#125;&#125;)var node=document.createElement(&quot;li&quot;);var textnode=document.createTextNode(&quot;item4&quot;);node.appendChild(textnode);list.appendChild(node);&lt;/script&gt; 当点击item4时，item4有事件响应。说明事件委托可以为新添加的DOM元素动态的添加事件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"事件","slug":"事件","permalink":"http://yoursite.com/tags/事件/"}]},{"title":"JS继承的几种方法总结","slug":"js-inherit","date":"2015-12-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-inherit/","link":"","permalink":"http://yoursite.com/2015/12/13/js-inherit/","excerpt":"由于js不像java那样是真正面向对象的语言，js是基于对象的，它没有类的概念 所以，要想实现继承，可以用js的原型prototype机制或者用apply和call方法去实现。在面向对象的语言中，我们使用类来创建一个自定义对象。然而js中所有事物都是对象，那么用什么办法来创建自定义对象呢？ 这就需要用到js的原型：我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的Proto指针，指向原型对象）。","text":"由于js不像java那样是真正面向对象的语言，js是基于对象的，它没有类的概念 所以，要想实现继承，可以用js的原型prototype机制或者用apply和call方法去实现。在面向对象的语言中，我们使用类来创建一个自定义对象。然而js中所有事物都是对象，那么用什么办法来创建自定义对象呢？ 这就需要用到js的原型：我们可以简单的把prototype看做是一个模版，新创建的自定义对象都是这个模版（prototype）的一个拷贝 （实际上不是拷贝而是链接，只不过这种链接是不可见，新实例化的对象内部有一个看不见的Proto指针，指向原型对象）。 1、继承第一种方式：对象冒充 123456789101112131415161718192021222324252627282930blogfunction Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log('hello ' + this.username); &#125; &#125;Parent.prototype.sayMorning = function()&#123; console.log('good morning ' + this.username);&#125; function Child(username,password)&#123; //通过以下3行实现将Parent的属性和方法追加到Child中，从而实现继承 //第一步：this.method是作为一个临时的属性，并且指向Parent所指向的对象， //第二步：执行this.method方法，即执行Parent所指向的对象函数 //第三步：销毁this.method属性，即此时Child就已经拥有了Parent的所有属性和方法 this.method = Parent; this.method(username);//最关键的一行 delete this.method; this.password = password; this.world = function()&#123; console.log(this.password); &#125; &#125; var parent = new Parent(\"zhangsan\"); var child = new Child(\"lisi\",\"123456\"); parent.hello(); parent.sayMorning(); child.hello(); child.world(); 2、继承第二种方式：call()方法方式 12345678910111213141516171819202122232425262728function Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log(this.username); &#125; &#125;Parent.prototype.sayMorning = function()&#123; console.log('good morning ' + this.username); &#125; function Child(username,password)&#123; Parent.call(this,username); this.password = password; this.world = function()&#123; console.log(this.password); &#125; &#125; var parent = new Parent(\"zhangsan\"); var child = new Child(\"lisi\",\"123456\"); parent.hello(); parent.sayMorning(); child.hello(); child.world();// child.sayMorning(); 通过prototype 添加的方法和属性，不能用来继承 3、继承的第三种方式：apply()方法方式 1234567891011121314151617181920212223242526function Parent(username)&#123; this.username = username; this.hello = function()&#123; console.log(this.username); &#125; &#125; Parent.prototype.sayMorning = function()&#123; console.log('good morning ' + this.username); &#125; function Child(username,password)&#123; Parent.apply(this,new Array(username)); this.password = password; this.world = function()&#123; console.log(this.password); &#125; &#125;var parent = new Parent(\"zhangsan\"); var child = new Child(\"lisi\",\"123456\"); parent.hello(); parent.sayMorning(); child.hello(); child.world();// child.sayMorning(); 通过prototype 添加的方法和属性，不能用来继承 4、继承的第四种方式：原型链方式，即子类通过prototype将所有在父类中通过prototype追加的属性和方法都追加到Child，从而实现了继承 12345678910111213141516171819function Person()&#123; &#125; Person.prototype.hello = \"hello\"; Person.prototype.sayHello = function()&#123; console.log(this.hello); &#125; function Child()&#123; &#125; Child.prototype = new Person();//这行的作用是：将Parent中将所有通过prototype追加的属性和方法都追加到Child，从而实现了继承 Child.prototype.world = \"world\"; Child.prototype.sayWorld = function()&#123; console.log(this.world); &#125; var c = new Child(); c.sayHello(); c.sayWorld();通过prototype 添加的方法和属性，不能用来继承 5、继承的第五种方式：混合方式, 混合了call或者apply方式、原型链方式 12345678910111213141516171819202122function Parent(hello)&#123; this.hello = hello; &#125; Parent.prototype.sayHello = function()&#123; console.log(this.hello); &#125; function Child(hello,world)&#123; Parent.call(this,hello);//将父类的属性继承过来 this.world = world;//新增一些属性 &#125; Child.prototype = new Parent();//将父类的方法继承过来 Child.prototype.sayWorld = function()&#123;//新增一些方法 console.log(this.world); &#125; var c = new Child(\"zhangsan\",\"lisi\"); c.sayHello(); c.sayWorld();可以继承通过prototype 添加的方法和属性","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}]},{"title":"Javascript数组详解","slug":"js-arr","date":"2015-12-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-arr/","link":"","permalink":"http://yoursite.com/2015/12/13/js-arr/","excerpt":"数组的定义 数组是按序号排列的一组值，每个值的位置都有编号（从0开始）。数组本质上是一种特殊的对象。它的键名是按（0，1，2...）排列的一组数字","text":"数组的定义 数组是按序号排列的一组值，每个值的位置都有编号（从0开始）。数组本质上是一种特殊的对象。它的键名是按（0，1，2...）排列的一组数字 创建数组： 12var arr = new Array(values);var arr = [vaules]; 判断比是否是个数组 Array.isArray(arr) arr instanceof Array 增加数组元素 push()方法 在数组的末尾增加一个或多个元素，并返回数组的新长度。 unshift()方法 在数组的开头增加一个或多个元素，并返回数组的新长度。 length 属性 1234567var arr = [1, 2, 3]arr.push(4)arr // 1, 2, 3, 4arr.unshift(6)arr // 6, 1, 2, 3, 4arr[arr.length] = 7 // 与push()方法类似arr // 6, 1, 2, 3, 4, 7 删除数组中的元素 delete 运算符，可以删除数组中的某个元素，但这不会改变length属性的值. pop() 方法 删除数组的最后一个元素，并返回这个元素 shift() 方法 删除数组的第一个元素，并返回这个元素 123456789var arr = [1,2,3];delete arr[0];arr // [undefined,2,3]arr.length // 3var last = arr.pop()var first = arr.shift()last // 3first // undefinedarr //2 类数组对象 在js中，有些对象被叫做“类数组对象”（array-like object），因为这些对象看起来很像数组，可以使用length属性，但是无法使用数组的方法。 典型的类数组对象是函数的arguments对象，以及大多数DOM元素集，还有字符串 1234567891011121314151617// arguments对象function args() &#123;return arguments; &#125;var arraylike = args('a','b')arrayLike[0] // 'a'arrayLike.length // 2arrayLike instanceof Array // falseArray.isArray(arrayLike) // false// DOM元素集var elts = document.getElementsByTagName('p');elts.length // 3eles instanceof Array // false//字符串'abc'[1] // 'b''abc'.length // 3'abc' instanceof Array // false 数组的遍历 for…in 循环 123456var a =[1, 2, 3];a.other = 'other';for (var i in arr)&#123; console.log( arr[i]);&#125;// 1, 2, 3, other 从上面的输出结果可以看出，利用for..in循环会将动态添加的非数字键的值遍历出来，因此需要使用的时候需要注意 for 循环和 while 循环 123456789101112131415161718var a = [1, 2, 3];// for循环for(var i = 0; i &lt; a.length; i++) &#123; console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123; console.log(a[i]); i++;&#125;var l = a.length;while (l--) &#123; console.log(a[l]);&#125; forEach()方法 123456789//array.forEach(callback[, thisArg])//callback 在数组的每一项上执行的函数，接受三个参数：item: 数组当前项的值，index: 当前项的索引，arr:数组本身。var arr = [1, 2, 3]arr.forEach(function(item, index, arr)&#123; console.log(item, index);&#125;);//1 0//2 1//3 2 数组常用的方法 join() 将数值转换为字符串 123var arr = [1, 2, 3];arr.join(); // \"1,2,3\"arr.join(\"_\"); // \"1_2_3\" reverse() 将数组逆序 1234// 原数组会被修改var arr = [1, 2, 3];arr.reverse(); // [3, 2, 1]arr; // [3, 2, 1] sort() 数组排序 默认情况下是升序排列的，底层是调用了每个数组项的 toString() 方法，然后比较得到字符串，即使每个数组项的数值是数字，比较的也是字符串 123456// 原数组会被修改var arr = [1, 12, 213, 1432, 'a'];arr.sort(); // [1, 12, 1432, 213, \"a\"]arr.sort(function(a, b)&#123; return b-a; //按倒序排列数组&#125;); slice() 返回部分数组 slice用于复制数组，复制完后旧数组不变，返回得到的新数组是旧数组的子集 第一个参数begin是开始复制的位置，需要注意的是，可以设负数。设负数表示从尾往前数几个位置开始复制 123456//原数组不会被修改var arr = [1, 2, 3, 4, 5];arr.slice(); //[1, 2, 3, 4, 5]arr.slice(1,3); // [2, 3]arr.slice(1, -1); // [2, 3, 4]arr; // [1, 2, 3, 4, 5] splice() 数组拼接 12345678910//原数组会被修改var arr = [1, 2, 3, 4, 5];//从第三个数组元素删除arr.splice(2); // returns [3, 4, 5] arr; // [1, 2]//从第三个数组元素删除，删除两个元素arr.splice(2, 2) // returns [3, 4]arr; // [1, 2, 5]//将'a','b'替换到数组的第二个元素arr.splice(1, 1, 'a', 'b') isArray() 判断是否是数组 1234var arr = [];var a = \"not array\";Array.isArray(arr); // trueArray.isArray(a); // false indexOf() lastIndexOf() 数组检索 两者都用于返回项目的索引值。区别是indexOf从头开始找，lastIndexOf从尾开始找。如果查找失败，无匹配，返回-1 1234567var arr = ['a', 'b', 'c', 'd', 'e'];arr.indexOf('c'); // 2 找到返回数组下标arr.indexOf('c', 3); // -1 指定从3号位开始查找arr.indexOf('f'); // -1 没找到该元素arr.lastIndexOf('c'); // 2arr.lastIndexOf('c',2); // 2arr.lastIndexOf('f'); // -1 没找到该元素","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"OOP之类与对象","slug":"js-oop-and-class","date":"2015-12-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-oop-and-class/","link":"","permalink":"http://yoursite.com/2015/12/13/js-oop-and-class/","excerpt":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成","text":"对象 对象的含义 所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成 对象的创建 使用new运算符创建Object 12var p = new Object();p.name = \"Tony\"; 使用对象字面量的形式 12345678910111213141516171819//对象字面量形式var p =&#123; name: \"tony\", work: function()&#123; console.log(\"working....\"); &#125;, _age: 18, get age()&#123; return this._age; &#125;, set age(val)&#123; if( val &lt;0 || val &gt; 150)&#123; throw new Error(\"invalid value\"); &#125;else&#123; this._age = val; &#125; &#125;&#125;console.log(p.name); 对象的基本操作 成员属性的添加 123456789101112// Object.defineProperty()方法Object.defineProperty(p, \"age\",&#123;value: 18, writable: false&#125;);//Object.defineProperties()方法 添加多个属性Object.defineProperties(p, &#123; salary:&#123; value: 1000, writable: false &#125;, gender:&#123; value: true &#125;&#125;); 成员的遍历 使用 for..in语句 Object.keys()方法 返回一个包含对象键名的字符串数组 1234567var o =&#123;&#125;;o.name = \"jack\";o.age = 20;for(var i in o)&#123; console.log(o[i]);&#125; // jack, 20Object.keys(o); // [\"name\", \"age\"] 检查对象是否有某个属性 in 操作符 Object.hasOwnProperty()方法 123var o = &#123;name: \"mariya\"&#125;\"name\" in o; // trueo.hasOwnProperty(\"name\"); // true 得到对象的属性特性描述 Object.getOwnPropertyDescriptor(obj,property) 1234Object.getOwnPropertyDescriptor(o, \"name\");//Object &#123;// value: \"mariya\", writable: true, enumerable: true, configurable: true&#125; 删除属性 delete运算符,但有些对象的属性是删除不了的 12delete o.name; //trueo.name; // undefined Constructor属性 constructor始终指向创建当前对象的构造函数 12345678var arr = [];console.log(arr.constructor === Array); // truevar Foo = function() &#123;&#125;;console.log(Foo.constructor === Function); // true// 由构造函数实例化一个obj对象var obj = new Foo();console.log(obj.constructor === Foo); // trueconsole.log(obj.constructor.constructor === Function); // true 每个函数都有一个默认的属性prototype，而这个prototype的constructor默认指向这个函数 类的创建 虽然js是门基于对象的语言，但是没有类这一概念的，虽然保留了class的关键字，但在ES6之前是无法使用的。所以，可以用构造函数模拟类的创建，也就是伪类。 所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上 每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承 12345678910//构造函数模式function Person(age, name)&#123; //Class this.age = age; this.name = name;&#125;//将公共的属性或方法放在prototype属性上Person.prototype.headCount = 1;//创建实例对象var p = new Person(19, 'johnsom');var p1 = new Person(20, 'allen'); this this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向 全局代码中的this1console.log(this === window); //true 全局范围内使用this指向window对象 普通的函数调用123function f()&#123;this.name = \"tony\"; // this在运行时指向window对象,在严格模式下则是undefined&#125; 在对象中使用123456var o = &#123; name: \"tony\", print: function()&#123; console.log(this.name); //this指向对象o，但是可以改变其指向 &#125;&#125;; 作为构造函数1new F(); // 函数内部的this指向新创建的对象。 多层嵌套的内部函数1234567891011var name = \"global\";var person = &#123; name : \"person\", hello : function(sth)&#123; var sayhello = function(sth) &#123; console.log(this.name + \" says \" + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(\"hello world\");//global says hello world 在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是JavaScript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self： 123456789101112var name = \"global\";var person = &#123; name : \"person\", hello : function(sth)&#123; var that = this; var sayhello = function(sth) &#123; console.log(that.name + \" says \" + sth); &#125;; sayhello(sth); &#125;&#125;person.hello(\"hello world\");//person says hello world 事件中的this1234var ele = document.getElementById(\"id\");ele.addEventListener('click',function()&#123; console.log(this); //this指向dom元素&#125;); 使用apply和call改变this的指向 apply和call类似，只是后面的参数是通过一个数组传入，而不是分开传入。两者都是将某个函数绑定到某个具体对象上使用，自然此时的this会被显式的设置为第一个参数。两者的方法定义： 12call( thisArg [，arg1，arg2，… ] ); // 参数列表，arg1，arg2，...apply(thisArg [，argArray] ); // 参数数组，argArray 1234567891011var name = 'global';var o = &#123; name: 'job', getName: function()&#123; console.log(this.name); &#125;&#125;;o.getName(); // job//用call或apply改变函数中this的指向o.getName.call(this); // global 简单的总结： 当函数作为对象的方法调用时，this指向该对象。 构造函数中的this指向新创建的对象 嵌套函数中的this不会继承上层函数的this，如果需要，可以用一个变量保存上层函数的this bind（） 该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数. 12$(\"#ele\").click(person.hello.bind(person));//相应元素被点击时，输出person says hello world","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}]},{"title":"OOP之原型与原型链","slug":"js-prototype","date":"2015-12-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-prototype/","link":"","permalink":"http://yoursite.com/2015/12/13/js-prototype/","excerpt":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子：","text":"prototype原型对象 每个函数都有一个默认的prototype属性，其实际上还是一个对象，如果被用在继承中，姑且叫做原型对象 在构造函数中的prototype中定义的属性和方法，会被创建的对象所继承下来。举个栗子： 123456function F()&#123;&#125;F.prototype.work = function()&#123; console.log('F is working..');&#125;;var f = new F();f.work(); // F is working.. 当你创建函数时，JS会为这个函数自动添加 prototype 属性，值是空对象。而一旦你把这个函数当作构造函数（ constructor ）调用（即通过 new关键字调用），那么JS就会帮你创建该构造函数的实例，实例继承构造函数 prototype 的所有属性和方法（实例通过设置自己的__proto__ 指向构造函数的 prototype 来实现这种继承） 神秘的proto JS的对象中都包含了一个__proto__属性，其指向的是创建该对象时的构造函数的原型对象prototype 从上面的输出结果看出，f.__proto__指向了其构造函数F的prototype，而F.prototype本身也是一个对象，其内部也有__proto__属性，其指向的是Object.prototype,直到最后Object.prototype指向null，这条原型链才结束 因此，__proto__这个神秘的属性才是原型链形成的真正原因 原型链 由于原型对象本身也是对象，根据上边的定义，它也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链，JavaScritp引擎在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找 从上图看出： Object.prototype是顶级对象，所有对象都继承自它。 Function继承 Function本身， Function.prototype 继承 Object.prototype Function.prototype 和 Function.__proto__ 都指向 Function.prototype Object.prototype.__proto__ === null ，说明原型链到 Object.prototype终止","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"原型链","slug":"原型链","permalink":"http://yoursite.com/tags/原型链/"}]},{"title":"OOP之面向对象","slug":"js-oop","date":"2015-12-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-oop/","link":"","permalink":"http://yoursite.com/2015/12/13/js-oop/","excerpt":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝","text":"一般面向对象包含：继承，封装，多态，抽象 对象形式的继承 浅拷贝 12345678910111213141516171819202122232425var Person = &#123; name: 'allin', age: 18, address: &#123; home: 'home', office: 'office', &#125; sclools: ['x','z'],&#125;;var programer = &#123; language: 'js',&#125;;function extend(p, c)&#123; var c = c || &#123;&#125;; for( var prop in p)&#123; c[prop] = p[prop]; &#125;&#125;extend(Person, programer);programer.name; // allinprogramer.address.home; // homeprogramer.address.home = 'house'; //housePerson.address.home; // house 从上面的结果看出，浅拷贝的缺陷在于修改了子对象中引用类型的值，会影响到父对象中的值，因为在浅拷贝中对引用类型的拷贝只是拷贝了地址，指向了内存中同一个副本 深拷贝 1234567891011function extendDeeply(p, c)&#123; var c = c || &#123;&#125;; for (var prop in p)&#123; if(typeof p[prop] === \"object\")&#123; c[prop] = (p[prop].constructor === Array)?[]:&#123;&#125;; extendDeeply(p[prop], c[prop]); &#125;else&#123; c[prop] = p[prop]; &#125; &#125;&#125; 利用递归进行深拷贝，这样子对象的修改就不会影响到父对象 123extendDeeply(Person, programer);programer.address.home = 'allin';Person.address.home; // home 利用call和apply继承 12345678function Parent()&#123; this.name = \"abc\"; this.address = &#123;home: \"home\"&#125;;&#125;function Child()&#123; Parent.call(this); this.language = \"js\"; &#125; ES5中的Object.create()123var p = &#123; name : 'allin'&#125;;var obj = Object.create(o);obj.name; // allin Object.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法： 12345678910//模拟Object.create()方法function myCreate(o)&#123; function F()&#123;&#125;; F.prototype = o; o = new F(); return o;&#125;var p = &#123; name : 'allin'&#125;;var obj = myCreate(o);obj.name; // allin 目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署 1234567 if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 类的继承 Object.create() 123456789function Person(name, age)&#123;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log('eating...');&#125;function Programmer(name, age, title)&#123;&#125;Programmer.prototype = Object.create(Person.prototype); //建立继承关系Programmer.prototype.constructor = Programmer; // 修改constructor的指向 调用父类方法 12345678910111213141516171819202122function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.headCount = 1;Person.prototype.eat = function()&#123; console.log('eating...');&#125;function Programmer(name, age, title)&#123; Person.apply(this, arguments); // 调用父类的构造器&#125;Programmer.prototype = Object.create(Person.prototype);Programmer.prototype.constructor = Programmer;Programmer.prototype.language = \"js\";Programmer.prototype.work = function()&#123; console.log('i am working code in '+ this.language); Person.prototype.eat.apply(this, arguments); // 调用父类上的方法&#125; 封装 命名空间 js是没有命名空间的，因此可以用对象模拟 12345678910var app = &#123;&#125;; // 命名空间app//模块1app.module1 = &#123; name: 'allin', f: function()&#123; console.log('hi robot'); &#125;&#125;;app.module1.name; // \"allin\"app.module1.f(); // hi robot 静态成员 123456789function Person(name)&#123; var age = 100; this.name = name;&#125;//静态成员Person.walk = function()&#123; console.log('static');&#125;;Person.walk(); // static 私有与公有 1234567891011121314151617function Person(id)&#123; // 私有属性与方法 var name = 'allin'; var work = function()&#123; console.log(this.id); &#125;; //公有属性与方法 this.id = id; this.say = function()&#123; console.log('say hello'); work.call(this); &#125;;&#125;;var p1 = new Person(123);p1.name; // undefinedp1.id; // 123p1.say(); // say hello 123 模块化 1234567891011var moduleA;moduleA = function() &#123; var prop = 1; function func() &#123;&#125; return &#123; func: func, prop: prop &#125;;&#125;(); // 立即执行匿名函数 多态 模拟方法重载 arguments属性可以取得函数调用的实参个数，可以利用这一点模拟方法的重载 12345678function demo(a, b )&#123; console.log(demo.length); // 得到形参个数 console.log(arguments.length); //得到实参个数 console.log(arguments[0]); // 第一个实参 4 console.log(arguments[1]); // 第二个实参 5&#125;demo(4, 5, 6); 123456789101112131415161718192021222324252627282930313233343536373839//实现可变长度实参的相加function add()&#123; var total = 0; for( var i = arguments.length - 1; i &gt;= 0; i--)&#123; total += arguments[i]; &#125; return total;&#125;console.log(add(1)); // 1console.log(add(1, 2, 3)); // 7// 参数不同的情况function fontSize()&#123; var ele = document.getElementById('js'); if(arguments.length == 0)&#123; return ele.style.fontSize; &#125;else&#123; ele.style.fontSize = arguments[0]; &#125;&#125;fontSize(18);console.log(fontSize());// 类型不同的情况function setting()&#123; var ele = document.getElementById('js'); if(typeof arguments[0] === \"object\")&#123; for(var p in arguments[0])&#123; ele.style[p] = arguments[0][p]; &#125; &#125;else&#123; ele.style.fontSize = arguments[0]; ele.style.backgroundColor = arguments[1]; &#125;&#125;setting(18, 'red');setting(&#123;fontSize:20, backgroundColor: 'green'&#125;); 方法重写 1234567891011function F()&#123;&#125;var f = new F();F.prototype.run = function()&#123; console.log('F');&#125;f.run(); // Ff.run = function()&#123; console.log('fff');&#125;f.run(); // fff 抽象类 在构造器中 throw new Error(&#39;&#39;); 抛异常。这样防止这个类被直接调用 12345678910111213141516171819202122232425function DetectorBase() &#123; throw new Error('Abstract class can not be invoked directly!');&#125;DetectorBase.prototype.detect = function() &#123; console.log('Detection starting...');&#125;;DetectorBase.prototype.stop = function() &#123; console.log('Detection stopped.');&#125;;DetectorBase.prototype.init = function() &#123; throw new Error('Error');&#125;;// var d = new DetectorBase();// Uncaught Error: Abstract class can not be invoked directly!function LinkDetector() &#123;&#125;LinkDetector.prototype = Object.create(DetectorBase.prototype);LinkDetector.prototype.constructor = LinkDetector;var l = new LinkDetector();console.log(l); //LinkDetector &#123;&#125;__proto__: LinkDetectorl.detect(); //Detection starting...l.init(); //Uncaught Error: Error","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}]},{"title":"JS常用的内置函数整理","slug":"js-inner-func","date":"2015-12-13T06:50:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/12/13/js-inner-func/","link":"","permalink":"http://yoursite.com/2015/12/13/js-inner-func/","excerpt":"String字符串对象 length 属性 长度 concat(String) 连接两个或更多个字符 indexOf(string) 返回出现字符的位置 substr(num1,[num2])截取字符串 toLowerCase()转成小写 toUpperCase()转成大写 replace(str1,str2) 字符串替换","text":"String字符串对象 length 属性 长度 concat(String) 连接两个或更多个字符 indexOf(string) 返回出现字符的位置 substr(num1,[num2])截取字符串 toLowerCase()转成小写 toUpperCase()转成大写 replace(str1,str2) 字符串替换 Date日期 getYear()返回年份（2位或4为） getFullYear()返回年份(4位) getMonth()返回月份0-11 getDate()返回日期1-31 getDay()返回星期数0-6 getHours()返回小时数0-23 getMinutes()返回分钟数0-59 getSeconds()返回秒数0-59 getMilliseconds()返回毫秒数0-999` Math数学对象 cell(数值)大于或等于该数的最小整数 floor(数值)小于或等于该数的最大整数 min(数值1，数值2)返回最小值 max(数值1，数值2)返回最大值 pow(数值1，数值2)返回数值1的数值2的次方 random()返回随机数0--1 round(数值)四舍五入 sqrt(数值)开平方根 数组对象 concat()返回一个由两个数组合并组成的新数组 join()返回一个由数组中的所有元素连接在一起的String对象 pop()删除数组中的最后一个元素并返回该值 push()向数组中添加新元素 返回新长度 shift()删除数组中的第一个元素并返回该值 unshift返回一个数组，在该数组头部插入指定的元素 sort()返回一个元素被排序了的Array对象 reverse()返回一个元素反序的Array对象 splice(index.num,foo...)返回数组的一个片段 –剪切 slice(start,end)复制 [start,end) 负数的时候 lenght+start/end","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"内置对象","slug":"内置对象","permalink":"http://yoursite.com/tags/内置对象/"}]},{"title":"HTML5+CSS3整体回顾","slug":"HTML5+CSS3基础回顾 ","date":"2015-10-19T01:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/10/19/HTML5+CSS3基础回顾 /","link":"","permalink":"http://yoursite.com/2015/10/19/HTML5+CSS3基础回顾 /","excerpt":"转载请声明 原文链接 这篇文章主要总结H5的一些新增的功能以及一些基础归纳，这里只是一个提纲，并不是很详细，后面会一直完善补充新的内容，本文是一些笔记记录，放在这里供自己参考也供他人学习！","text":"转载请声明 原文链接 这篇文章主要总结H5的一些新增的功能以及一些基础归纳，这里只是一个提纲，并不是很详细，后面会一直完善补充新的内容，本文是一些笔记记录，放在这里供自己参考也供他人学习！ HTML5概览 第一课 HTML5结构 HTML5 是新一代的 HTML DTD声明改变 &lt;!DOCTYPE html&gt; 新的结构标签 常用的一些新的结构标签 结构标签 多媒体交互标签 特殊样式标签 兼容性不是很好的标签 补充说明 small 这个元素表示边栏评论，如附属细则 cite这个元素可用于显示作品标题（图书、电影、诗歌等） adress这个元素显示article或整个文档的合同信息，且位于footer这个元素之中 time显示人和机器可读的日期和时间，而且机器可读的时间戳是属性datetime的值第二个可选的是pubtime用于表示出版日期值 删除的HTML标签 纯表现的元素： basefont big center font s strike tt u 对可用性产生负面影响的元素： frame frameset noframes 产生混淆的元素： acronym applet isindex dir 重新定义的HTML标签 &lt;b&gt; 代表内联文本，通常是粗体，没有传递表示重要的意思 &lt;i&gt; 代表内联文本，通常是斜体，没有传递表示重要的意思 &lt;dd&gt; 可以同details与figure一同使用，定义包含文本，ialog也可用 &lt;dt&gt; 可以同details与figure一同使用，汇总细节，dialog也可用 &lt;hr&gt;表示主题结束，而不是水平线，虽然显示相同 &lt;menu&gt; 重新定义用户界面的菜单，配合commond或者menuitem使用 &lt;small&gt; 表示小字体，例如打印注释或者法律条款 &lt;strong&gt; 表示重要性而不是强调符号 崭新新的页面布局 传统的布局 HTML5标签布局 实例-from-dunitian 草图--from-dunitian 第二课 HTML5智能表单 HTML4.01 form表单复习 input表单type属性值 type=&quot;text&quot; 单行文本输入框 type=&quot;password&quot; 密码（maxlength=&quot;&quot;） type=&quot;radio&quot; 单项选择（checked=&quot;checked&quot;） type=&quot;checkbox&quot; 多项选择 type=&quot;button&quot; 按钮 type=&quot;submit&quot; 提交 type=&quot;file&quot; 上传文件 type=&quot;reset&quot; 重置 HTML5智能表单 input表单type属性值： type = &quot;email&quot; 限制用户输入必须为Email类型 type=&quot;url&quot; 限制用户输入必须为URL类型 type=&quot;date&quot; 限制用户输入必须为日期类型 type=&quot;datetime&quot; 显示完整日期 含时区 type=&quot;datetime-local&quot; 显示完整日期 不含时区 type=&quot;time&quot; 限制用户输入必须为时间类型 type=&quot;month&quot; 限制用户输入必须为月类型 type=&quot;week&quot; 限制用户输入必须为周类型 type=&quot;number&quot; 限制用户输入必须为数字类型 type=&quot;range&quot; 生成一个滑动条 type=&quot;search&quot; 具有搜索意义的表单results=&quot;n&quot;属性 type=&quot;color&quot; 生成一个颜色选择表单 type=&quot;tel&quot; 显示电话号码 Input 类型 - Date Pickers（日期选择器） **HTML5 拥有多个可供选取日期和时间的新输入类型： date 选取日、月、年 month 选取月、年 week 选取周和年 time 选取时间（小时和分钟） 以下两个没有作用 datetime 选取时间、日、月、年（UTC 时间） datetime-local 选取时间、日、月、年（本地时间） HTML5新增表单属性 required: required内容不能为空 placeholder: 表单提示信息 autofocus:自动聚焦 pattern: 正则表达式 输入的内容必须匹配到指定正则范围 autocomplete:是否保存用户输入值 默认为on，关闭提示选择off formaction: 在submit里定义提交地址 datalist: 输入框选择列表配合list使用 list值为datalist的id值 output: 计算或脚本输出 表单验证 validity对象，通过下面的valid可以查看验证是否通过，如果八种验证都返回true,一种验证失败返回false oText.addEventListener(&quot;invalid&quot;,fn1,false) ev.preventDefault(): 阻止默认事件 valueMissing: 当输入值为空的时候，返回true typeMismatch: 控件值与预期不吻合，返回true patternMismatch: 输入值不满足pattern正则，返回true cusomError setCustomValidity() 第三课 css3选择器 css3属性快速一览 css3属性快速一览 CSS3发展史简介 HTML的诞生 20世纪90年代初 1996年底， CSS第一版诞生 1998年5月 CSS2正式发布 2004年 CSS2.1发布 CSS3的发布 2002 2003 2004 2005 2007 2009 2010 模块化开发 CSS1 中定义了网页的基本属性： 字体、颜色、基本选择器等 CSS2中在CSS1的基础上添加了高级功能 浮动和定位、高级选择器等(子选择器、相邻选择器、通用选择器) CSS3遵循的是模块化开发。发布时间并不是一个时间点，而是一个时间段 CSS选择器复习 通用选择器：* 选择到所有的元素 选择子元素：&gt; 选择到元素的直接后代 相邻兄弟选择器：+选择到紧随目标元素后的第一个元素 普通兄弟选择器：~选择到紧随其后的所有兄弟元素 伪元素选择器： ::first-line 匹配文本块的首行 ::first-letter 选择文本块的首字母 伪类选择器： :before,:after在元素内容前面、后面添加内容(相当于行内元素) CSS3结构选择器 CSS3结构选择器 Css3 属性选择器 CSS3伪类选择器 UI伪类选择器： :enabled选择启用状态元素 :disabled 选择禁用状态元素 :checked选择被选中的input元素（单选按钮或复选框） :default 选择默认元素 :valid、invalid 根据输入验证选择有效或无效的input元素 :in-range、out-of-range选择指定范围之内或者之外受限的元素 :required、optional根据是否允许:required属性选择input元素 动态伪类选择器： :link选择链接元素 :visited 选择用户以访问的元素 :hover 鼠标悬停其上的元素 :active鼠标点击时触发的事件 :focus 当前获取焦点的元素 其他伪类选择器： :not(&lt;选择器&gt;)对括号内选择器的选择取反 :lang(&lt;目标语言&gt;) 基于lang全局属性的元素 :target url片段标识符指向的元素 :empty选择内容为空的元素 :selection鼠标光标选择元素内容 第四课 CSS3新增文本属性 CSS文本属性复习 white-space：对象内空格的处理方式 nowrap 控制文本不换行 pre 空白会被浏览器保留 pre-line 合并空白 保留换行符 pre-wrap 保留空白 正常换行 direction：文本流的方向 ltr 文本从左向右 rtl 文本从右往左 unicode-bidi：用于同一个页面里存在从不同方向读进的文本显示。与direction属性一起使用 CSS3新增文本属性 color:rgba(); text-overflow:是否使用一个省略标记（…）标示对象内文本的溢出 text-align:文本的对齐方式 text-transform:文字的大小写 text-decoration:文本的装饰线，复合属性 text-shadow:文本阴影 text-fill-color:文字填充颜色 text-stroke:复合属性。设置文字的描边 tab-size:制表符的长度 word-wrap:当前行超过指定容器的边界时是否断开转行 word-break:规定自动换行的处理方法 text-overflow:是否使用一个省略标记（...）标示对象内文本的溢出 clip： 默认值 无省略号 ellipsis：当对象内文本溢出时显示省略标记（...）。 注意：该属性需配合over-flow:hidden属性(超出处理)还有 white-space:nowrap(禁止换行)配合使用，否则无法看到效果 text-align:文本的对齐方式 css1 left:默认值 左对齐 right:右对齐 center:居中 justify： 内容两端对齐。 css3 start:开始边界对齐 end:结束边界对齐 text-transform:文字的大小写 css1 none： 默认值 无转换 capitalize： 将每个单词的第一个字母转换成大写 uppercase： 转换成大写 lowercase： 转换成小写 css3 full-width： 将左右字符设为全角形式。不支持 full-size-kana：将所有小假名字符转换为普通假名。不支持 例如：土耳其语 text-decoration:文本的装饰线，复合属性(只火狐支持) text-decoration-line： 指定文本装饰的种类。相当于CSS1时的text-decoration属性 text-decoration-style ： `指定文本装饰的样式。 text-decoration-color： `指定文本装饰的颜色。 blink： 指定文字的装饰是闪烁。 opera和firefox text-decoration : #F00 double overline CSS3实例 text-shadow:文本阴影 取值：x y blur color,…… x 横向偏移 y 纵向偏移 blur 模糊距离(灰度) color 阴影颜色 text-fill-color:文字填充颜色 text-stroke:复合属性。设置文字的描边 text-stroke-width:文字的描边厚度 text-stroke-color:文字的描边颜色 tab-size:制表符的长度 默认值为8(一个tab键的空格字节长度)，在 pre标签之内才会有显示 word-wrap:当前行超过指定容器的边界时是否断开转行 normal： 默认值 允许内容顶开或溢出指定的容器边界。 break-word： 内容将在边界内换行。如果需要，单词内部允许断行 第五课 CSS3盒模型 CSS盒模型复习 标准盒子模型 IE盒子模型 CSS3弹性盒模型 以下6个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-items align-content 属性详解 flex-direction: row | row-reverse | column | column-reverse; flex-wrap: nowrap | wrap | wrap-reverse; flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content属性定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around; align-items属性定义项目在交叉轴上如何对齐。 align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 align-content: flex-start | flex-end | center | space-between | space-around | stretch; 以下6个属性设置在项目上 order flex-grow flex-shrink flex-basis flex align-self 属性详解 order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretch; 拓展阅读 flex布局语法篇 flex布局实例篇 第六课 css3新增背景属性 CSS背景属性复习 background: background-color:背景颜色 background-image:背景图片 background-repeat:背景重复 background-position:背景定位 background-attachment:背景固定(scroll/fixed) CSS3新增背景属性 background-size 背景尺寸 background-size:x y 水平 垂直方向的尺寸，像素/百分比/auto/… background-size:100% 100% background-size:cover 比例放大 background-size:contain 包含（图片不溢出） 多背景 background-image:url(1.jpg),url(2.jpg); background-origin 背景区域定位 border-box： 从border区域开始显示背景。 padding-box： 从padding区域开始显示背景。 content-box： 从content内容区域开始显示背 background-clip 背景绘制区域 border-box： 从border区域向外裁剪背景。 padding-box： 从padding区域向外裁剪背景。 content-box： 从content区域向外裁剪背景。 text:背景填充文本 no-clip： 从border区域向外裁剪背景 颜色渐变 线性渐变：linear-gradient(起点/角度，颜色 位置，…,) 起点：left/top/right/bottom/left top......默认top 角度：逆时针方向 0-360度 颜色 位置：red 50%, blue 100%(红色从50%渐变到100%为蓝色) repeating-linear-gradient 线性渐变重复平铺 IE低版本渐变(滤镜)： filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#39;#ffffff&#39;,endColorstr=&#39;#ff0000&#39;,GradientType=&#39;1&#39;); 径向渐变：radial-gradient(起点(圆心位置), 形状/半径/大小，颜色1，颜色2) 起点：left/top/right/bottom或具体值/百分比 形状：ellipse(椭圆)、circle(正圆) 大小：具体数值或百分比，也可以是关键字（closest-side(最近端), closest-corner最近角), farthest-side(最远端), farthest-corner(最远角), contain(包含) ,cover(覆盖)）; 第七课 css3新增颜色属性 CSS颜色属性复习 color name 颜色英文名称命名 HEX方式 十六进制方式 rgb方式 三原色配色方式 CSS3新增颜色属性 rgba() 名称 颜色 颜色 取值 r red 红色 0-255 g green 绿色 0-255 b blue 蓝色 0-255 a alpha 透明 0-1 HSL模式 HSLA模式 H： Hue(色调)。 0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360 S：Saturation(饱和度)。取值为：0.0% - 100.0% L： Lightness(亮度)。取值为：0.0% - 100.0% A: alpha 透明度 0~1之间 语法:HSLA(H,S,L,A) HSL色轮 透明颜色：transparent 实例：border实现三角箭头、风车等 透明度： opacity 取值：0-1之间 注：低版本的IE浏览器不兼容,需用IE浏览器的滤镜实现相同效果，filter:alpha(opacity=50) 对于低版本的火狐浏览器需添加内核前缀，-moz-opacity 第八课 CSS3边框系列 圆角-阴影 边框圆角 在CSS2中添加圆角矩形需要技巧。我们必须为每个圆角使用不同的图片 在 CSS3中，创建圆角是非常容易的 在CSS3中，border-radius属性用于创建圆角 border-radius边框圆角写法 border-radius: 2em 1em 4em / 0.5em 3em; 等价于1234border-top-left-radius: 2em 0.5em;border-top-right-radius: 1em 3em;border-bottom-right-radius: 4em 0.5em;border-bottom-left-radius: 1em 3em; box-shadow方框添加阴影 语法：box-shadow:x-shadow y-shadow blur spread color inset; box-shadow的API x-shadow 必需。水平阴影的位置。允许负值。 y-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS颜色值 inset 可选。将外部阴影 (outset) 改为内部阴影 实例：box-shadow:10px 10px 5px 5px #888888; 边框系列-图片 border-image语法 属性 版本 简介 border-image CSS3 设置或检索对象的边框使用图像来填充 border-image-source CSS3 设置或检索对象的边框是否用图像定义样式或图像来源路径 border-image-slice CSS3 设置或检索对象的边框背景图的分割方式 border-image-width CSS3 设置或检索对象的边框厚度 border-image-outset CSS3 设置或检索对象的边框背景图的扩展 border-image-repeat CSS3 设置或检索对象的边框图像的平铺方式 border-image-slice 设置或检索对象的边框背景图的分割方式 border-image-repeat 用于指定边框背景图的重复方式 取值： stretch： 指定用拉伸方式来填充边框背景图。 *默认的 repeat： 指定用平铺方式来填充边框背景图。当图片碰到边界时，如果超过则被截断。 round： 指定用平铺方式来填充边框背景图。图片会根据边框的尺寸动态调整图片的大小 直至正好可以铺满整个边框。写本文档时仅Firefox能看到该效果 第九课 CSS3运动体系 过渡 过渡：给改变添加过程 什么是过渡 过渡效果由哪几部分组成 过渡可以干些什么 transition 过渡属性 transition: property duration timing-function delay; transition-property:过渡属性的名称 none 没有过渡属性 all 所有属性都过渡(默认值) property 具体属性名称(property1,property2…) transition-duration:过渡属性花费的时间 time 秒或毫秒 transition-timing-function:过渡效果速度曲线 time 秒或毫秒 transition-delay:过渡效果延迟时间 transition-timing-function:过渡效果速度曲线 linear:规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease:规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in:规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out :规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out :规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n):在 cubic-bezier 函数中定义自己的值。可能的值是 0至 1 之间的数值。 过渡完成事件 Webkit内核： 1obj.addEventListener('webkitTransitionEnd',function()&#123;&#125;) 标准: 1obj.addEventListener('transitionend',function()&#123;&#125;) 动画 什么是CSS3 动画？ 通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript 动画接口 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。 animation-timing-function 规定动画的速度曲线。 animation-delay 规定动画何时开始。 animation-iteration-count 规定动画被播放的次数。 animation-direction 规定动画是否在下一周期逆向地播放。 animation-play-state 规定动画是否正在运行或暂停。 animation-fill-mode 规定对象动画时间之外的状态。 animation-timing-function速度曲线 值 描述 linear 动画从头到尾的速度是相同的。 ease 默认。动画以低速开始，然后加快，在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动画以低速开始和结束。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。 在谷歌浏览器里面需要加上-webkit-IE6,7,8,9不支持css3运动 拓展阅读 CSS3动画简介 CSS3盒模型阴影 box-shadow:inset x y blur spread color inset：投影方式 inset：内投影 outset：外投影 默认(不能设置) x、y：阴影偏移 blur：模糊半径（灰度） spread：扩展阴影半径 先扩展原有形状，再开始画阴影 color CSS3盒模型倒影 box-reflect 倒影 方向 above|below|left|right; 距离 渐变（可选） CSS3其他盒模型 box-sizing 盒模型解析模式 content-box 标准盒模型(和css2一样的计算) width/height=border+padding+content border-box 怪异盒模型width/height与设置的值一样 ，content减小 扩展阅读 学会使用css3的box-sizing布局 第十课 transform 2D转换 Css3平面转换方法 translate() 移动 rotate() 旋转 scale() 缩放 skew() 翻转 matrix() 矩阵 transform: rotate() 旋转函数 (deg) deg 度数 skew(X,Y) 倾斜函数 (deg) skewX() skewY() scale(X,Y) 缩放函数 (正数、负数和小数) scaleX() scaleY() translate(X,Y) 位移函数(px) translateX() translateY() rotate() 旋转方法 用于旋转元素角度 例：rotate(30deg) 把元素顺时针旋转 30 度 translate()位置方法 用于移动元素位置 例：translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。 其实有些类似于我们的相对定位 scale()尺寸方法 方法用于改变元素尺寸 例：scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍 skew() 翻转方法 通过 skew()方法，元素翻转给定的角度 例：transform: skew(30deg,20deg); 把元素围绕 X轴把元素翻转30 度，围绕 Y 轴翻转 20度 第十一课 transform 3D转换 Css3立体转换 transform-style（preserve-3d） 建立3D空间（指定元素的子元素展示的场景是在3D场景还是平面(投影)场景） Perspective 视角（指定观察者与z=0平面的距离，从而让元素及子元素看起来有3D透视位置效果值：集体的带单位数值） Perspective- origin 视角基点 值：取值类似于变换基准 transform-origin：坐标轴基点（变换基准） 值：具体的坐标值/百分比/(left/right/center/top/bottom)默认 center center transform 新增函数 rotateX() rotateY() rotateZ() translateZ() scaleZ() 第十二课 视频音频 视频音频格式的简单介绍 常见的视频格式 视频的组成部分：画面、音频、编码格式 视频编码：H.264、Theora、VP8(google开源) 常见的音频格式 视频编码：ACC、MP3、Vorbis HTML5支持的格式 HTML5能在完全脱离插件的情况下播放音视频,但是不是所有格式都支持。 支持的视频格式： Ogg=带有Theora视频编码+Vorbis音频编码的Ogg文件 MEPG4=带有H.264视频编码+AAC音频编码的MPEG4文件 WebM=带有VP8视频编码+Vorbis音频编码的WebM格式 Video的使用 单独用法 &lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 带提示用法 123&lt; video src=\"文件地址\" controls=\"controls\"&gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; 兼容用法 12345&lt; video controls=\"controls\" width=\"300\"&gt; &lt;source src=\"move.ogg\" type=\"video/ogg\" &gt; &lt;source src=\"move.mp4\" type=\"video/mp4\" &gt; 您的浏览器暂不支持video标签。播放视频&lt;/ video &gt; Video的常见属性 属性 值 描述 Autoplay Autoplay 视频就绪自动播放 controls controls 向用户显示播放控件 Width Pixels(像素) 设置播放器宽度 Height Pixels(像素) 设置播放器高度 Loop Loop 播放完是否继续播放该视频，循环播放 Preload load{auto,meta,none} 规定是否预加载视频。 Src url 视频url地址 Poster Imgurl 加载等待的画面图片 Autobuffer Autobuffer 设置为浏览器缓冲方式，不设置autoply才有效 Video的API方法 方法 属性 事件 play() currentSrc play pause() currentTime pause load() videoWidth progress canPlayType() videoHeight error 第十三课 canvas 标签 &lt;canvas&gt; 不支持canvas 的浏览器可以看到的内容 默认宽度300px，默认高度150px 注意：canvas宽高需要设置在标签中 否则绘制的东西可能出错 &lt;canvas&gt; 绘制环境 getContext(&quot;2d&quot;);目前支持2d的场景 123&lt;canvas width=\"\" height=\"\" id=\"\"&gt; 您的浏览器不支持canvas，请更换浏览器！&lt;/canvas&gt; 绘制矩形 rect(L,T,W,H):创建一个矩形 fillRect(L,T,W,H):绘制填充的矩形 clearRect(x,y,w,h) 清除矩形选区 strokeRect(L,T,W,H)绘制空心矩形(无填充) 默认一像素黑色边框 设置绘图样式 fillStyle:填充颜色(绘制canvas是有顺序的) lineWidth:触笔宽度(线宽) strokeStyle:触笔颜色 绘制路径 beginPath() :开始路径 closePath():结束路径 moveTo(x,y):将触笔移动到x,y点 lineTo(x,y):绘制到x,y点 stroke(): 触笔方法 画线 默认为黑色 fill():填充方法 rect(x,y,w,h):矩形路径 save():保存路径 restore():恢复路径 绘制曲线 arcTo(x1,y1,x2,y2,r) x1,y1 坐标一 x2,y2坐标二 r圆弧半斤 quadraticCurveTo(dx,dy,x1,y1) 贝塞尔曲线:dx,dy控制点 x1,y1结束坐标 bezierCurveTo(dx1,dy1,dx2,dy2,x1,y1) 贝塞尔曲线:dx1,dy1 控制点一 dx2,dy2控制点二 x1,y1结束坐标 绘制圆形 arc(x,y,半径,起始弧度,结束弧度,旋转方向) x，y起始位置 弧度与角度：弧度=角度值*Math.PI/180 旋转方向：顺时针（默认：false），逆时针（true） 绘制文本 strokeText(文本,x,y); 绘制空心文本 fillText(文本,x,y); 绘制实心文本 font = &quot;font-size font-family&quot;注:尺寸 字体缺一不可 textAlign = &quot;&quot;;文本左右对齐方式 start center end left right textBaseline文本上下对齐方式 alphabetic默认。文本基线是普通的字母基线。 top 文本基线是 em 方框的顶端。。 hanging 文本基线是悬挂基线。 middle 文本基线是em 方框的正中。 ideographic 文本基线是表意基线。 bottom 文本基线是 em 方框的底端。 measureText(文本).width; 文本实际宽度(只有宽度值) 图形边界样式 lineJoin: 边界连接点样式 miter(默认值),round(圆角),bevel(斜角) lineCap: 端点样式 butt(默认值),round(圆角),square(高度多出线宽一半) 绘制图片 图片预加载，获取图片文件 onload中调用 drawImage(img,x,y,w,h);绘制图片(图片,坐标x,坐标y,宽度,高度) 设置背景 createPattern(img,平铺方式) 平铺方式:repeat,repeat-x,repeat-y,no-repeat canvas变换 translate(x,y) 坐标基准点偏移 : 从起始点为基准，移动到当前位置 rotate(弧度): 旋转 弧度公式 = 角度*PI/180 scale(wb,hb)缩放比例(缩放canvas绘制的图片) 颜色渐变 线性渐变:createLinearGradient(x1,y1,x2,y2) x1,y1起始坐标点 x2,y2结束坐标点 径向渐变:createRadialGradient(x1,y1,r1,x2,y2,r2) x1,y1,r1内圆坐标及半径 x2,y2,r2外圆坐标及半径 addColorStop(位置,颜色) 位置:渐变点 0-1之间 可多个 阴影 shadowOffsetX,shadowOffsetY x轴、y轴偏移 shadowBlur 阴影模糊度 shadowColor 阴影颜色 默认颜色:rgba(0,0,0,0) 像素 createImageData(sx,sy) 创建新的、空白的 ImageData 对象 getImageData(x1,y1,sx,sy) 返回ImageData对象，该对象为画布上指定的矩形复制像素数据putImageData(img,x2,y2) 把图像数据（从指定的 ImageData 对象）放回画布上 合成 globalAlpha 设置或返回绘图的当前alpha或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 source-over默认。在目标图像上显示源图像。 source-atop在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over在源图像上方显示目标图像。 destination-atop在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter显示源图像 + 目标图像。 copy显示源图像。忽略目标图像。 xor使用异或操作对源图像与目标图像进行组合。 扩展阅读 canvas学习之API整理笔记（一） HTML5 API大盘点 第十四课 SVG绘图 svg是什么 矢量图 与canvas的区别 svg的引入方式 方式一： 12345&lt;?xml version=\"1.1\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;/svg&gt; 方式二： 图片、背景、框架 方式三: html页面中添加svg circle:圆形 圆心坐标 cx,cy 半径 r fill stroke stroke-width stlye样式 fill = &quot;none/transparent&quot; ellipse:椭圆 cx属性定义的椭圆中心的x坐标 cy属性定义的椭圆中心的y坐标 rx属性定义的水平半径 ry属性定义的垂直半径 rect : 矩形 width height 宽高 坐标 x,y 圆角 rx,ry line:线条 x1,y1,x2,y2 stroke-opacity 透明 fill-opacity polyline:折线 points:点坐标（x1 y1 x2 y2...）或(x1,y1,x2,y2....) polygon:多边形 折线闭合 fill-rule:evenodd/nonzero; path: 路劲 d属性 M(起始坐标),L(结束坐标),H(水平线),V(垂直线),A(圆弧),Z(闭合路劲) C,S,Q,T 贝塞尔曲线 大写为绝对坐标(具体的坐标位置) 小写为相对坐标(相对起始坐标点的具体长度) A命令 x半径 y半径 角度 弧长(0 小弧 1大弧) 方向(0逆时针 1顺时针) 终点(x y) C命令：三次贝塞尔曲线 (x1,y1,x2,y2,x,y) x1,y1控制点一 x2,y2控制点二 x,y结束点 S命令：平滑贝塞尔曲线(自动对称一个控制点) (x2,y2,x,y) x2,y2控制点 x,y结束点 Q命令：二次贝塞尔曲线 (x1,y1,x,y) x1,y1控制点 x,y结束点 T命令：一次贝塞尔曲线 (x,y)结束点 g标签:组合元素 设置元素公共属性 共用属性 transform = &quot;translate(0,0)&quot; text标签 x, y, text-anchor(对齐start end middle) font-size image 标签 x, y, width height xlink:href(图片地址) 第十五课 地理信息与本地存储 地理位置 经度 : 南北极的连接线 纬度 : 东西连接的线 位置信息从何而来 IP地址 GPS全球定位系统 Wi-Fi无线网络 基站 avigator.geolocation 单次定位请求 ：getCurrentPosition(请求成功,请求失败,数据收集方式) 请求成功函数 经度 : coords.longitude 纬度 : coords.latitude 准确度 : coords.accuracy 海拔 : coords.altitude 海拔准确度 : coords.altitudeAcuracy 行进方向 : coords.heading 地面速度 : coords.speed 请求的时间: new Date(position.timestamp) 请求失败函数 失败编号 ：code 0 : 不包括其他错误编号中的错误 1 : 用户拒绝浏览器获取位置信息 2 : 尝试获取用户信息，但失败了 3 : 设置了timeout值，获取位置超时了 数据收集 : json的形式 enableHighAcuracy : 更精确的查找，默认false timeout : 获取位置允许最长时间，默认infinity maximumAge : 位置可以缓存的最大时间，默认0 多次定位请求* : watchPosition 移动设备有用，位置改变才会触发 配置参数：frequency 更新的频率 关闭更新请求 : clearWatch examp01 getCurrentPosition 12&lt;button id=\"btn\"&gt;请求位置信息&lt;/button&gt;&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567891011121314151617181920var btn = document.getElementById(\"btn\");var box = document.getElementById(\"box\"); btn.onclick = function()&#123; navigator.geolocation.getCurrentPosition(function(position)&#123; box.innerHTML +=\"经度：\"+position.coords.longitude + \"&lt;br&gt;\"; box.innerHTML +=\"纬度：\"+position.coords.latitude + \"&lt;br&gt;\"; box.innerHTML +=\"海拔：\"+position.coords.accuracy + \"&lt;br&gt;\"; box.innerHTML +=\"海拔的准确度：\"+position.coords.altitudeAccuracy + \"&lt;br&gt;\"; box.innerHTML +=\"地面速度\"+position.coords.speed + \"&lt;br&gt;\"; box.innerHTML +=\"行进方向\"+position.coords.heading + \"&lt;br&gt;\"; box.innerHTML +=\"请求时间\"+new Date(position.timestamp) + \"&lt;br&gt;\"; &#125;,function(err)&#123; alert(err.code); &#125;,&#123; enableHighAccuracy:false,//精确请求 timeout:5000,//设置超时 maximumAge:1000//缓存时间 &#125;); &#125; 在线演示 examp02 1234567891011121314151617181920var btn = document.getElementById(\"btn\");var box = document.getElementById(\"box\"); btn.onclick = function()&#123; navigator.geolocation.watchPosition(function(position)&#123; box.innerHTML +=\"经度：\"+position.coords.longitude + \"&lt;br&gt;\"; box.innerHTML +=\"纬度：\"+position.coords.latitude + \"&lt;br&gt;\"; box.innerHTML +=\"海拔：\"+position.coords.accuracy + \"&lt;br&gt;\"; box.innerHTML +=\"海拔的准确度：\"+position.coords.altitudeAccuracy + \"&lt;br&gt;\"; box.innerHTML +=\"地面速度\"+position.coords.speed + \"&lt;br&gt;\"; box.innerHTML +=\"行进方向\"+position.coords.heading + \"&lt;br&gt;\"; box.innerHTML +=\"请求时间\"+new Date(position.timestamp) + \"&lt;br&gt;\"; &#125;,function(err)&#123; alert(err.code); &#125;,&#123; enableHighAccuracy:false,//精确请求 timeout:5000,//设置超时 maximumAge:1000//缓存时间 &#125;); &#125; 在线演示 example03 高德地图应用 123456#container &#123; width:600px; height: 300px; margin:40px auto; border:1px solid red;&#125; 1234&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=278b7b8b4728ba302b7e566fc2a97b36\"&gt;&lt;/script&gt; 1var map = new AMap.Map('container'); 在线演示 examp04 搜索城市 1234567891011121314151617181920212223242526272829303132#container &#123;width:500px; height:500px; margin:100px auto;&#125; .menu&#123; width:100px; box-shadow: 0 0 5px #000; margin:auto; background:#fff;&#125;.menu ul li&#123; list-style:none; line-height:30px; text-align:center; cursor:pointer;&#125;#box&#123; width:400px; height:40px; position:absolute; top:150px; left:50%; margin-left:-200px; background:#fff; box-shadow:0 0 10px #000;&#125;input&#123; height:38px; width:300px; border:none; outline:none;&#125;#btn&#123; width:80px;&#125; 12345678&lt;div id=\"container\"&gt;&lt;/div&gt; &lt;div id=\"box\"&gt; &lt;input type=\"text\" id=\"city\" placeholder=\"请输入城市...\"&gt; &lt;input type=\"button\" value=\"搜索\" id=\"btn\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"http://webapi.amap.com/maps?v=1.3&amp;key=278b7b8b4728ba302b7e566fc2a97b36\"&gt;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var btn = document.getElementById(\"btn\");var city = document.getElementById(\"city\");var map = new AMap.Map('container');var toolBar,mouseTool,contextMenu;//在地图中添加操作toolBar插件、mouseTool插件map.plugin([\"AMap.ToolBar\",\"AMap.MouseTool\"],function()&#123; toolBar = new AMap.ToolBar(); map.addControl(toolBar); mouseTool = new AMap.MouseTool(map);&#125;);var menuContext = document.createElement(\"div\");menuContext.innerHTML = \"&lt;div class=menu&gt;&lt;ul&gt;&lt;li onclick='zoomMenu(0)'&gt;缩小&lt;/li&gt;&lt;li onclick='zoomMenu(1)'&gt;放大&lt;/li&gt;&lt;li onclick='distanceMeasureMenu()'&gt;距离量测&lt;/li&gt;&lt;li onclick = 'addMarkerMenu()'&gt;添加标记&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;\";//创建一个自定义的右键菜单contextMenu = new AMap.ContextMenu(&#123;isCustom:true,content:menuContext&#125;);//给地图绑鼠标右键功能弹出右键菜单AMap.event.addListener(map,\"rightclick\",function(e)&#123; contextMenu.open(map,e.lnglat);//e.lnglat鼠标点击的经纬度 contextMenuPosition = e.lnglat;&#125;)//右键菜单缩放地图function zoomMenu(n)&#123; if(n === 0)&#123;map.zoomOut();&#125; if(n === 1)&#123;map.zoomIn();&#125; contextMenu.close();&#125;contextMenu.close();//测量距离功能function distanceMeasureMenu()&#123; mouseTool.rule(); contextMenu.close();&#125;//添加标注功能function addMarkerMenu()&#123; mouseTool.close(); var marker = new AMap.Marker(&#123; map: map, position: contextMenuPosition, //基点位置 offset: &#123;x:-5,y:-10&#125; //相对于基点位置 &#125;); contextMenu.close();&#125;//搜索城市btn.onclick = function()&#123; var val = city.value; map.setCity(val);&#125; 在线演示 本地存储 Storage sessionStorage session临时回话，从页面打开到页面关闭的时间段 窗口的临时存储，页面关闭，本地存储消失 localStorage 永久存储（可以手动删除数据） Storage的特点 存储量限制 ( 5M ) 客户端完成，不会请求服务器处理 sessionStorage数据是不共享、 localStorage共享 Storage API setItem(): 设置数据，(key,value)类型，类型都是字符串 可以用获取属性的形式操作 getItem(): 获取数据，通过key来获取到相应的value removeItem(): 删除数据，通过key来删除相应的value clear(): 删除全部存储的值 存储事件: 当数据有修改或删除的情况下，就会触发storage事件 在对数据进行改变的窗口对象上是不会触发的` Key : 修改或删除的key值，如果调用clear(),key为null newValue : 新设置的值，如果调用removeStorage(),key为null oldValue : 调用改变前的value值 storageArea : 当前的storage对象 url : 触发该脚本变化的文档的url 注：session同窗口才可以,例子：iframe操作 第十六课 HTML5新增JS方法 新增选择器 document.querySelector() 选择单个元素 document.querySelectorAll() 选择所有的 document.getElementsByClassName() 通过类名选择 延迟加载JS JS的加载会影响后面的内容加载 很多浏览器都采用了并行加载JS，但还是会影响其他内容 Html5的defer和async defer=“defer ”: 延迟加载，会按顺序执行，在onload执行前被触发 async =“async”: 异步加载，加载完就触发，有顺序问题 浏览器兼容性：Labjs库 123456789101112131415161718192021222324252627282930/*** 动态加载script文件 （推荐方法） 只需请求一次 可加载多个JavaScript文件，减少请求次数以及页面的加载阻塞*/function loadScript(url,callback)&#123; var script = document.createElement(\"script\"); script.type = \"text/javascript\"; if(script.readyState)&#123;//IE script.onreadystatechange = function()&#123; if(script.readyState == \"loaded\" || script.readyState == \"complete\")&#123; onreadystatechange = null; callback(); &#125; &#125; &#125;else &#123; script.onload = function()&#123; callback(); &#125; &#125; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script);&#125;loadScript(\"js/defer.js\",function()&#123; console.log(\"加载成功\"); // 加载成功回调&#125;);loadScript(\"js/async.js\",function()&#123; console.log(\"加载成功\"); // 加载成功回调&#125;); 获取class列表属性 classList length : class的长度 add() : 添加class方法 remove() : 删除class方法 toggle() : 切换class方法 contains() : 判断类名是否存在返回bool值 JSON的新方法 parse() : 把字符串转成json 字符串中的属性要严格的加上引号 stringify() : 把json转化成字符串 会自动的把双引号加上 与eval的区别 eval()：对任何的字符串进行解析变成js parse()：字符串中的属性要严格的加上引号 其他浏览器兼容 去下载json2.js 历史管理 onhashchange ：改变hash值来管理 history ： 服务器下运行 pushState : 三个参数 ：数据 标题(都没实现) 地址(可选) onpopstate事件 : 读取数据 event.state 第十七课 HTML5拖拽事件 图片自带拖拽功能 其他元素可设置draggable属性 draggable ：true 拖拽元素(被拖拽元素对象)事件 : ondragstart : 拖拽前触发 ondrag :拖拽前、拖拽结束之间，连续触发 ondragend :拖拽结束触发 目标元素(拖拽元素被拖到的对象)事件 : ondragenter :进入目标元素触发 ondragover:进入目标、离开目标之间，连续触发 ondragleave :离开目标元素触发 ondrop :在目标元素上释放鼠标触发 需要在ondragover事件里面阻止默认事件 拖拽兼容问题 火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 dataTransfer对象 setData() : 设置数据 key和value(必须是字符串) getData() : 获取数据，根据key值，获取对应的value effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) setDragImage ：三个参数（指定的元素，坐标X，坐标Y） files： 获取外部拖拽的文件，返回一个filesList列表 filesList下有个type属性，返回文件的类型 读取文件信息 FileReader(读取文件信息) readAsDataURL 参数为要读取的文件对象 onload当读取文件成功完成的时候触发此事件 this. result 获取读取的文件数据 examp01 拖拽案例 12&lt;div id=\"drap\" draggable=\"true\"&gt;&lt;/div&gt;&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567891011#drap &#123; width: 100px; height: 100px; background: red;&#125;#box &#123; width: 500px; height: 500px; border: 2px solid blue; margin: 50px auto;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//被拖拽元素事件drap.ondragstart = function(ev)&#123; // 拖拽前 var ev = ev || window.event; //火狐浏览器下需设置dataTransfer对象才可以拖拽除图片外的其他标签 ev.dataTransfer.setData(\"key\",\"poetries\"); //effectAllowed : 设置光标样式(none, copy, copyLink, copyMove, link, linkMove,move, all 和uninitialized) ev.dataTransfer.effectAllowed = \"copy\"; //设置被拖拽的小元素 setDragImage ：三个参数（指定的元素，坐标X，坐标Y） ev.dataTransfer.setDragImage(pic,25,25); this.style.background = \"green\";&#125;drap.ondrag = function()&#123; // 拖拽过程中 this.innerText = \"被拖拽中...\";&#125;drap.ondragend = function()&#123; // 拖拽结束 this.style.background = \"red\"; this.innerHTML = \"\";&#125;//目标元素事件box.ondragenter = function()&#123; //进入目标元素触发 this.innerHTML = \"可将文件拖放到这里!\";&#125;box.ondragover = function(ev)&#123; //进入目标、离开目标之间，连续触发 var ev = ev || window.event; ev.preventDefault(); this.style.background = \"pink\";&#125;box.ondragleave = function()&#123; //离开目标元素触发 this.innerHTML = \"\"; this.style.background = \"none\";&#125;box.ondrop = function(ev)&#123;//在目标元素上释放鼠标触发 //alert(\"拖放结束\") this.innerHTML = ev.dataTransfer.getData(\"key\");&#125; 在线演示 example02 拖拽相册 123&lt;h1&gt;请拖拽图片到红框中&lt;/h1&gt;&lt;div id=\"box\"&gt;&lt;span&gt;可以将文件拖放到这里！！&lt;/span&gt;&lt;/div&gt;&lt;div id=\"dustbin\"&gt;垃圾回收站&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132#box&#123; position:relative; width:500px; height:500px; border:2px solid red; margin:100px auto 0px; &#125;#box span&#123; position:absolute; left:0; top:0; right:0; bottom:0; height:50px; width:192px; margin:auto; display:none;&#125;img&#123; width:100px;height:100px;&#125;#dustbin&#123; width:200px; height:100px; background:#000; color:#fff; font-size:40px; text-align:center; line-height:100px; margin:auto;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var box = document.getElementById(\"box\");var dusTbin = document.getElementById(\"dustbin\");var span = box.getElementsByTagName(\"span\")[0];//目标元素事件var img = '';box.ondragenter = function()&#123;//进入目标元素触发 span.style.display = \"block\";&#125;box.ondragover = function(ev)&#123;//在目标元素上连续触发 var ev = ev||window.event; ev.preventDefault();//阻止默认事件 span.style.display = \"block\";&#125;box.ondragleave = function()&#123;//离开目标元素 span.style.display = \"none\";&#125;box.ondrop = function(ev)&#123;//在目标元素上面释放鼠标触发 //alert(\"拖拽结束！！\"); var ev = ev||window.event; ev.preventDefault();//阻止默认事件 span.style.display = \"none\"; var file = ev.dataTransfer.files; //alert(file[0].type); for (var i=0; i&lt;file.length ;i++ ) &#123; if (file[i].type.indexOf(\"image\")!=-1) &#123; var read = new FileReader();//新建一个读取文件对象 read.readAsDataURL(file[i]);//读取文件 read.onload = function()&#123;//读取文件成功之后调用什么函数 var img = document.createElement(\"img\"); //alert(this.result); img.src = this.result; box.appendChild(img); //获取img节点 实现删除功能 var oImg = document.getElementsByTagName(\"img\"); if (oImg) &#123; for (var j=0;j&lt;oImg.length ;j++ ) &#123; oImg[j].ondragstart = function(ev)&#123; ev.dataTransfer.setData(\"data\",ev.target.innerHTML); img = ev.target; &#125; oImg[j].ondragend = function(ev)&#123; ev.dataTransfer.clearData(\"data\");//清楚数据 img = null; &#125; &#125; &#125; //实现删除功能(移除img节点) dusTbin.ondragover = function(ev)&#123; ev.preventDefault(); &#125; dusTbin.ondrop = function()&#123; if (img) &#123; img.parentNode.removeChild(img); &#125; &#125; &#125; &#125;else&#123; alert(\"请上传图片！\"); &#125; &#125; &#125; 在线演示 example03 拖拽排序 123456789101112&lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;ul id=\"box\"&gt; &lt;li style=\"background:#f3f\" draggable=\"true\"&gt;1&lt;/li&gt; &lt;li style=\"background:#ff6\" draggable=\"true\"&gt;2&lt;/li&gt; &lt;li style=\"background:#c60\" draggable=\"true\"&gt;3&lt;/li&gt; &lt;li style=\"background:#903\" draggable=\"true\"&gt;4&lt;/li&gt; &lt;li style=\"background:#0f6\" draggable=\"true\"&gt;5&lt;/li&gt; &lt;li style=\"background:#636\" draggable=\"true\"&gt;6&lt;/li&gt; &lt;li style=\"background:#36f\" draggable=\"true\"&gt;7&lt;/li&gt; &lt;li style=\"background:#033\" draggable=\"true\"&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415.wrap&#123; width:500px; height:500px; margin:50px auto;&#125;ul li&#123; list-style:none; width:500px; height:50px; color:#fff; text-align:center; line-height:50px; font-size:40px; font-weight:bold;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344var oUl = document.getElementById(\"box\");var oLi = oUl.getElementsByTagName(\"li\");var curr = 0;function sort()&#123; for (var i = 0;i &lt; oLi.length;i++) &#123; oLi[i].index = i; oLi[i].ondragstart = function(ev)&#123; var ev = ev || window.event; ev.dataTransfer.setData(\"data\",this.innerHTML); //this.innerHTML = \"被拖拽中...\"; curr = this.index; &#125; oLi[i].ondragenter = function()&#123; for(var i = 0;i &lt; oLi.length;i++)&#123; oLi[i].style.border = \"none\"; &#125; if(curr != this.index)&#123; this.style.border = \"2px solid #000\"; &#125; &#125; oLi[i].ondragover = function(e)&#123; var e = e || window.event; e.preventDefault(); &#125; oLi[i].ondrop = function(ev)&#123; //鼠标释放的时候 //oUl.insertBefore(oLi[curr],this);//insertBefore(新节点，目标节点) inserAfter(oLi[curr],this); this.style.border = \"none\"; //oLi[curr].innerHTML = ev.DataTransfer.getData(\"data\"); sort(); &#125; &#125;&#125;sort();function inserAfter(newItem,targerItem)&#123; var parentItem = targerItem.parentNode; if(parentItem.lastChild == targerItem)&#123; parentItem.appendChild(newItem); &#125;else &#123; parentItem.insertBefore(newItem,targerItem.nextSibling); &#125;&#125; 在线演示 第十八课 跨文档操作 跨文档请求 同域跨文档 iframe内页： 父页面操作子页面：contentWindow 子页面操作父页面：window.top(找到最顶级的父页面)/parent(第一父页面) 新窗口页： 父页面操作子页面：window.open 子页面操作父页面：window.opener 不同域跨文档 postMessage（“发送的数据”,”接收的域”） message事件监听 ev.origin发送数据来源的域 ev.data 发送的数据 通过判断发送的数据来执行相应的需求 ajax跨域 XMLHttpRequest 新增功能 跨域请求：修改服务端头信息 IE兼容：XDomaiRequest 进度事件： upload.onprogress(ev) 上传进度(实现文件上传进度条) ev.total 发送文件的总量 ev.loaded 已发送的量 FormData 构建提交二进制数据 拓展阅读 HTML5 API 大盘点 附录一 css3响应式布局 媒体类型 *all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 *print 手持设备 projection 打印预览 *screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty不适用像素的设备 tv 电视 关键字 and not not关键字是用来排除某种制定的媒体类型 only only用来定某种特定的媒体类型 媒体特性 (max-width:600px) (max-device-width: 480px) 设备输出宽度 (orientation:portrait) 竖屏 (orientation:landscape) 横屏 (-webkit-min-device-pixel-ratio: 2) 像素比 devicePixelRatio 设备像素比 window.devicePixelRatio = 物理像素 / dips 样式引入 1&lt;link rel=\"stylesheet\" href=\"css/index.css\" media=\"print\" /&gt; 12@import url(\"css/demo.css\") screen;@media screen&#123; &#125; 12&lt;link rel=”stylesheet” media=”all and (orientation:portrait)” href=”portrait.css”&gt; 12&lt;link rel=”stylesheet” media=”all and (orientation:landscape)”href=”landscape.css”&gt; 1@media screen and (min-width:360px) and (max-width:500px) &#123;&#125; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexA.css\" media=\"screen and (min-width: 800px)\"&gt; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexB.css\" media=\"screen and (min-width: 600px) and (max-width: 800px)\"&gt; 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"indexC.css\" media=\"screen and (max-width: 600px)\"&gt; 附录二 HTML5速查表 可以查阅支持H5+CSS3的属性 HTML5 标签含义之元素周期表 HTML5标签速查表 展示 flexbox 属性的作用–推荐 Flexbox 视觉指南–更好更容易地理解 Flexbox 某个属性的作用 本文md文件-仅供参考","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"CSS 组合选择符用法总结","slug":"CSS 组合选择符用法总结","date":"2015-09-04T08:50:32.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/09/04/CSS 组合选择符用法总结/","link":"","permalink":"http://yoursite.com/2015/09/04/CSS 组合选择符用法总结/","excerpt":"组合选择符基本介绍","text":"组合选择符基本介绍 组合选择符说明了两个选择器直接的关系 CSS组合选择符包括各种简单选择符的组合方式 在 CSS3 中包含了四种组合方式 后代选取器(以空格分隔) 子元素选择器(以大于号分隔） 相邻兄弟选择器（以加号分隔） 普通兄弟选择器（以破折号分隔） 后代选取器 后代选取器匹配所有值得元素的后代元素 实例： 12345&lt;div&gt; &lt;p&gt;我是通过后代选择器选择的元素&lt;/p&gt; &lt;h1&gt;002&lt;/h1&gt; &lt;p&gt;我是通过后代选择器选择的元素&lt;/p&gt;&lt;/div&gt; 123div p&#123; background:red;&#125; 效果： 子元素选择器 如果您不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，请使用子元素选择器 html代码的文档树结构如图 123456&lt;div class=\"mainDiv\"&gt; 我是主DIV &lt;div class=\"son\"&gt;儿子 &lt;div class=\"sunzi\"&gt;孙子&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011.mainDiv&#123; background:yellow; width:100px; height:100px;&#125;.sunzi&#123; background:red; width:40px; height:40px;&#125;.mainDiv &gt; div&#123;background:green;&#125; 然后我们去掉子代选择器，添加一个后代选择器 123.mainDiv div&#123; background-color: red; &#125; 效果 经过上面的结果展示，我们能得到结论:子代选择器~ 和后代选择（空格）的区别： 子代选择器：只对应用对象的直接相应子节点有效。如实例代码中的儿子div 后代选择器：对应用对象内的所有相应子节点都有效。如实例中的儿子div和孙子div 相邻兄弟选择器 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素 以下实例选取了所有位于 &lt;div&gt; 元素后的第一个 &lt;p&gt; 元素 123456&lt;div&gt; &lt;p&gt;001&lt;/p&gt; &lt;h1&gt;002&lt;/h1&gt; &lt;p&gt;003&lt;/p&gt;&lt;/div&gt; &lt;p&gt;我是通过相邻兄弟选择器选择的元素&lt;/p&gt; 1div + p&#123;background:red;&#125; 效果： 普通相邻兄弟选择器 普通兄弟选择器选取所有指定元素的相邻兄弟元素 12345678&lt;div&gt; &lt;p&gt;001&lt;/p&gt; &lt;h1&gt;002&lt;/h1&gt; &lt;p&gt;003&lt;/p&gt;&lt;/div&gt; &lt;p&gt;我是普通相邻兄弟选择器~选择的&lt;/p&gt;&lt;p&gt;我是普通相邻兄弟选择器~选择的&lt;/p&gt;&lt;p&gt;我是普通相邻兄弟选择器~选择的&lt;/p&gt; 1div ~ p&#123;background:red;&#125; 效果","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"实用的60个CSS代码片段","slug":"实用的60个CSS代码片段","date":"2015-08-13T04:25:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/08/13/实用的60个CSS代码片段/","link":"","permalink":"http://yoursite.com/2015/08/13/实用的60个CSS代码片段/","excerpt":"1、垂直对齐 如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑： 1234567.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性","text":"1、垂直对齐 如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑： 1234567.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性 2、伸展一个元素到窗口高度 在具体场景中，你可能想要将一个元素伸展到窗口高度，基本元素的调整只能调整容器的大小,因此要使一个元素伸展到窗口高度，我们需要伸展顶层元素：html和body: 1234html, body &#123; height: 100%;&#125; 然后将100%应用到任何元素的高 123div &#123; height: 100%;&#125; 3、基于文件格式使用不同的样式 为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片： 123456789101112131415a[href^=\"http://\"]&#123; padding-right: 20px; background: url(external.gif) no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"]&#123; padding-right: 20px; background: url(email.png) no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"]&#123; padding-right: 20px; background: url(pdf.png) no-repeat center right;&#125; 效果演示 4、创建跨浏览器的图像灰度 灰度有时看起来简约和优雅，能为网站呈现更深层次的色调。在示例中，我们将对一个SVG图像添加灰度过滤： 12345&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;filter id=&quot;grayscale&quot;&gt; &lt;feColorMatrix type=&quot;matrix&quot; values=&quot;0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0&quot;/&gt; &lt;/filter&gt;&lt;/svg&gt; 为了跨浏览器，会用到filter属性： 12345img &#123; filter: url(filters.svg#grayscale); /* Firefox 3.5+ */ filter: gray; /* IE6-9 */ -webkit-filter: grayscale(1); /* Google Chrome, Safari 6+ &amp; Opera 15+ */&#125; 5、背景渐变动画 CSS中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。 123456789button &#123; background-image: linear-gradient(#5187c4, #1c2f45); background-size: auto 200%; background-position: 0 100%; transition: background-position 0.5s;&#125; button:hover &#123; background-position: 0 0;&#125; 效果演示： 6、CSS：表格列宽自适用 对于表格，当谈到调整列宽时，是比较痛苦的。然后，这里有一个可以使用的技巧：给td元素添加white-space: nowrap;能让文本正确的换行 123td &#123; white-space: nowrap;&#125; 演示 7、只在一边或两边显示盒子阴影 如果你要一个盒阴影，试试这个技巧，能为任一边添加阴影。为了实现这个，首先定义一个有具体宽高的盒子，然后正确定位:after伪类。实现底边阴影的代码如下 123456789101112131415161718192021222324.box-shadow &#123; background-color: #FF8020; width: 160px; height: 90px; margin-top: -45px; margin-left: -80px; position: absolute; top: 50%; left: 50%;&#125;.box-shadow:after &#123; content: \"\"; width: 150px; height: 1px; margin-top: 88px; margin-left: -75px; display: block; position: absolute; left: 50%; z-index: -1; -webkit-box-shadow: 0px 0px 8px 2px #000000; -moz-box-shadow: 0px 0px 8px 2px #000000; box-shadow: 0px 0px 8px 2px #000000;&#125; 演示 8、包裹长文本 如果你碰到一个比自身容器长的文本，这个技巧对你很有用。在这个示例中，默认时，不管容器的宽度，文本都将水平填充。 简单的CSS代码就能在容器中调整文本： 1234pre &#123; white-space: pre-line; word-wrap: break-word;&#125; 效果看起来如下： 9、制造模糊文本 想要让文本模糊？可以使用color透明和text-shadow实现 1234.blurry-text &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; 演示 10、用CSS动画实现省略号动画 这个片段将帮助你制造一个ellipsis的动画，对于简单的加载状态是很有用的，而不用去使用gif图像。 123456789101112131415.loading:after &#123; overflow: hidden; display: inline-block; vertical-align: bottom; animation: ellipsis 2s infinite; content: \"\\2026\"; /* ascii code for the ellipsis character */&#125;@keyframes ellipsis &#123; from &#123; width: 2px; &#125; to &#123; width: 15px; &#125;&#125; 演示 11、样式重置 12345678910111213141516171819202122html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; outline: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;html &#123; height: 101%; &#125;body &#123; font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; &#125;article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125;ol, ul &#123; list-style: none; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125;strong &#123; font-weight: bold; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125;img &#123; border: 0; max-width: 100%; &#125;p &#123; font-size: 1.2em; line-height: 1.0em; color: #333; &#125; 12、典型的CSS清除浮动 1234.clearfix:after &#123; content: \".\"; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; &#125;.clearfix &#123; display: inline-block; &#125;html[xmlns] .clearfix &#123; display: block; &#125;* html .clearfix &#123; height: 1%; &#125; 13、新版清除浮动（2011） 1234.clearfix:before, .container:after &#123; content: \"\"; display: table; &#125;.clearfix:after &#123; clear: both; &#125;/* IE 6/7 */.clearfix &#123; zoom: 1; &#125; 14、跨浏览器的透明 123456.transparent &#123; filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */&#125; 15、CSS引用模板 123456789101112131415161718blockquote &#123; background: #f9f9f9; border-left: 10px solid #ccc; margin: 1.5em 10px; padding: .5em 10px; quotes: \"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";&#125;blockquote:before &#123; color: #ccc; content: open-quote; font-size: 4em; line-height: .1em; margin-right: .25em; vertical-align: -.4em;&#125;blockquote p &#123; display: inline;&#125; 16、个性圆角 1234567891011121314151617#container &#123; -webkit-border-radius: 4px 3px 6px 10px; -moz-border-radius: 4px 3px 6px 10px; -o-border-radius: 4px 3px 6px 10px; border-radius: 4px 3px 6px 10px;&#125;/* alternative syntax broken into each line */#container &#123; -webkit-border-top-left-radius: 4px; -webkit-border-top-right-radius: 3px; -webkit-border-bottom-right-radius: 6px; -webkit-border-bottom-left-radius: 10px; -moz-border-radius-topleft: 4px; -moz-border-radius-topright: 3px; -moz-border-radius-bottomright: 6px; -moz-border-radius-bottomleft: 10px;&#125; 17、通用媒体查询 12345678910111213141516171819202122232425262728293031323334353637/* Smartphones (portrait and landscape) ----------- */@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123; /* Styles */&#125;/* Smartphones (landscape) ----------- */@media only screen and (min-width : 321px) &#123; /* Styles */&#125;/* Smartphones (portrait) ----------- */@media only screen and (max-width : 320px) &#123; /* Styles */&#125;/* iPads (portrait and landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123; /* Styles */&#125;/* iPads (landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123; /* Styles */&#125;/* iPads (portrait) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123; /* Styles */&#125;/* Desktops and laptops ----------- */@media only screen and (min-width : 1224px) &#123; /* Styles */&#125;/* Large screens ----------- */@media only screen and (min-width : 1824px) &#123; /* Styles */&#125;/* iPhone 4 ----------- */@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) &#123; /* Styles */&#125; 18、现代字体栈 12345678910111213141516/* Times New Roman-based serif */font-family: Cambria, \"Hoefler Text\", Utopia, \"Liberation Serif\", \"Nimbus Roman No9 L Regular\", Times, \"Times New Roman\", serif;/* A modern Georgia-based serif */font-family: Constantia, \"Lucida Bright\", Lucidabright, \"Lucida Serif\", Lucida, \"DejaVu Serif,\" \"Bitstream Vera Serif\", \"Liberation Serif\", Georgia, serif;/*A more traditional Garamond-based serif */font-family: \"Palatino Linotype\", Palatino, Palladio, \"URW Palladio L\", \"Book Antiqua\", Baskerville, \"Bookman Old Style\", \"Bitstream Charter\", \"Nimbus Roman No9 L\", Garamond, \"Apple Garamond\", \"ITC Garamond Narrow\", \"New Century Schoolbook\", \"Century Schoolbook\", \"Century Schoolbook L\", Georgia, serif;/*The Helvetica/Arial-based sans serif */font-family: Frutiger, \"Frutiger Linotype\", Univers, Calibri, \"Gill Sans\", \"Gill Sans MT\", \"Myriad Pro\", Myriad, \"DejaVu Sans Condensed\", \"Liberation Sans\", \"Nimbus Sans L\", Tahoma, Geneva, \"Helvetica Neue\", Helvetica, Arial, sans-serif;/*The Verdana-based sans serif */font-family: Corbel, \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Liberation Sans\", Verdana, \"Verdana Ref\", sans-serif;/*The Trebuchet-based sans serif */font-family: \"Segoe UI\", Candara, \"Bitstream Vera Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Trebuchet MS\", Verdana, \"Verdana Ref\", sans-serif;/*The heavier \"Impact\" sans serif */font-family: Impact, Haettenschweiler, \"Franklin Gothic Bold\", Charcoal, \"Helvetica Inserat\", \"Bitstream Vera Sans Bold\", \"Arial Black\", sans-serif;/*The monospace */font-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace; 19、自定义文本选择 123::selection &#123; background: #e2eae2; &#125;::-moz-selection &#123; background: #e2eae2; &#125;::-webkit-selection &#123; background: #e2eae2; &#125; 20、为logo隐藏H1 1234567h1 &#123; text-indent: -9999px; margin: 0 auto; width: 320px; height: 85px; background: transparent url(\"images/logo.png\") no-repeat scroll;&#125; 21、图片边框偏光 12345678910img.polaroid &#123; background:#000; /*Change this to a background image or remove*/ border:solid #fff; border-width:6px 6px 20px 6px; box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */ -webkit-box-shadow:1px 1px 5px #333; -moz-box-shadow:1px 1px 5px #333; height:200px; /*Set to height of your image or desired div*/ width:200px; /*Set to width of your image or desired div*/&#125; 22、锚链接伪类 1234a:link &#123; color: blue; &#125;a:visited &#123; color: purple; &#125;a:hover &#123; color: red; &#125;a:active &#123; color: yellow; &#125; 23、奇特的CSS引用 1234567891011121314151617181920212223242526272829303132.has-pullquote:before &#123; /* Reset metrics. */ padding: 0; border: none; /* Content */ content: attr(data-pullquote); /* Pull out to the right, modular scale based margins. */ float: right; width: 320px; margin: 12px -140px 24px 36px; /* Baseline correction */ position: relative; top: 5px; /* Typography (30px line-height equals 25% incremental leading) */ font-size: 23px; line-height: 30px;&#125;.pullquote-adelle:before &#123; font-family: \"adelle-1\", \"adelle-2\"; font-weight: 100; top: 10px !important;&#125;.pullquote-helvetica:before &#123; font-family: \"Helvetica Neue\", Arial, sans-serif; font-weight: bold; top: 7px !important;&#125;.pullquote-facit:before &#123; font-family: \"facitweb-1\", \"facitweb-2\", Helvetica, Arial, sans-serif; font-weight: bold; top: 7px !important;&#125; 24、CSS3：全屏背景 1234567html &#123; background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover;&#125; 25、内容垂直居中 12345.container &#123; min-height: 6.5em; display: table-cell; vertical-align: middle;&#125; 26、强制出现垂直滚动条 1html &#123; height: 101% &#125; 27、CSS3渐变模板 123456789#colorbox &#123; background: #629721; background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721)); background-image: -webkit-linear-gradient(top, #83b842, #629721); background-image: -moz-linear-gradient(top, #83b842, #629721); background-image: -ms-linear-gradient(top, #83b842, #629721); background-image: -o-linear-gradient(top, #83b842, #629721); background-image: linear-gradient(top, #83b842, #629721);&#125; 28、@font-face模板 1234567891011@font-face &#123; font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125;body &#123; font-family: 'MyWebFont', Arial, sans-serif;&#125; 29、缝合CSS3元素 123456789101112131415161718192021222324252627282930313233p &#123; position:relative; z-index:1; padding: 10px; margin: 10px; font-size: 21px; line-height: 1.3em; color: #fff; background: #ff0030; -webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); -moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5); -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;&#125;p:before &#123; content: \"\"; position: absolute; z-index: -1; top: 3px; bottom: 3px; left :3px; right: 3px; border: 2px dashed #fff;&#125;p a &#123; color: #fff; text-decoration:none;&#125;p a:hover, p a:focus, p a:active &#123; text-decoration:underline;&#125; 30、CSS3 斑马线 123tbody tr:nth-child(odd) &#123; background-color: #ccc;&#125; 31、有趣的&amp; 12345.amp &#123; font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif; font-style: italic; font-weight: normal;&#125; 32、大字段落 12345678p:first-letter&#123; display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif;&#125; 33、内部CSS3 盒阴影 12345#mydiv &#123; -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000;&#125; 34、外部CSS3 盒阴影 12345#mydiv &#123; -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);&#125; 35、三角形列表项目符号 1234567891011121314151617ul &#123; margin: 0.75em 0; padding: 0 1em; list-style: none;&#125;li:before &#123; content: \"\"; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative;&#125; 36、固定宽度的居中布局 1234#page-wrap &#123; width: 800px; margin: 0 auto;&#125; 37、CSS3 列文本 123456789#columns-3 &#123; text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc;&#125; 38、CSS固定页脚 12345678910111213#footer &#123; position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444;&#125;/* IE 6 */* html #footer &#123; position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');&#125; 39、IE6的PNG透明修复 12345678910111213141516.bg &#123; width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png',sizingMethod='crop');&#125;/* 1px gif method */img, .png &#123; position: relative; behavior: expression((this.runtimeStyle.behavior=\"none\")&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == \"IMG\" &amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = \"none\", this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.src + \"', sizingMethod='image')\", this.src = \"images/transparent.gif\"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url(\"','').replace('\")',''), this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.origBg + \"', sizingMethod='crop')\", this.runtimeStyle.backgroundImage = \"none\")),this.pngSet=true));&#125; 40、跨浏览器设置最小高度 12345#container &#123; min-height: 550px; height: auto !important; height: 550px;&#125; 41、CSS3 鲜艳的输入 12345678910111213141516input[type=text], textarea &#123; -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd;&#125;input[type=text]:focus, textarea:focus &#123; box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1);&#125; 42、基于文件类型的链接样式 123456789101112131415/* external links */a[href^=\"http://\"] &#123; padding-right: 13px; background: url('external.gif') no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"] &#123; padding-right: 20px; background: url('email.png') no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"] &#123; padding-right: 18px; background: url('acrobat.png') no-repeat center right;&#125; 43、强制换行 1234567pre &#123; white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap; /* Mozilla, since 1999 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ word-wrap: break-word; /* Internet Explorer 5.5+ */&#125; 44、在可点击的项目上强制手型 123a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer &#123; cursor: pointer;&#125; 45、网页顶部盒阴影 123456789101112body:before &#123; content: \"\"; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;&#125; 46、CSS3对话气泡 123456789101112131415161718192021222324252627282930313233343536.chat-bubble &#123; background-color: #ededed; border: 2px solid #666; font-size: 35px; line-height: 1.3em; margin: 10px auto; padding: 10px; position: relative; text-align: center; width: 300px; -moz-border-radius: 20px; -webkit-border-radius: 20px; -moz-box-shadow: 0 0 5px #888; -webkit-box-shadow: 0 0 5px #888; font-family: 'Bangers', arial, serif; &#125;.chat-bubble-arrow-border &#123; border-color: #666 transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -42px; left: 30px;&#125;.chat-bubble-arrow &#123; border-color: #ededed transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -39px; left: 30px;&#125; 47、H1-H5默认样式 1234567891011121314151617181920212223h1,h2,h3,h4,h5&#123; color: #005a9c;&#125;h1&#123; font-size: 2.6em; line-height: 2.45em;&#125;h2&#123; font-size: 2.1em; line-height: 1.9em;&#125;h3&#123; font-size: 1.8em; line-height: 1.65em;&#125;h4&#123; font-size: 1.65em; line-height: 1.4em;&#125;h5&#123; font-size: 1.4em; line-height: 1.25em;&#125; 48、纯CSS背景噪音 1234body &#123; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==); background-color: #0094d0;&#125; 49、持久的列表排序 1234567891011121314151617181920ol.chapters &#123; list-style: none; margin-left: 0;&#125;ol.chapters &gt; li:before &#123; content: counter(chapter) \". \"; counter-increment: chapter; font-weight: bold; float: left; width: 40px;&#125;ol.chapters li &#123; clear: left;&#125;ol.start &#123; counter-reset: chapter;&#125;ol.continue &#123; counter-reset: chapter 11;&#125; 50、CSS悬浮提示文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061a &#123; border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none;&#125;a:hover,a:focus &#123; color:#36c;&#125;a:active &#123; top:1px; &#125;/* Tooltip styling */a[data-tooltip]:after &#123; border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: \"\"; display: none; height: 0; width: 0; left: 25%; position: absolute;&#125;a[data-tooltip]:before &#123; background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125;a[data-tooltip]:hover:after &#123; display: block; top: -9px;&#125;a[data-tooltip]:hover:before &#123; display: block; top: -41px;&#125;a[data-tooltip]:active:after &#123; top: -10px;&#125;a[data-tooltip]:active:before &#123; top: -42px;&#125; 51、深灰色的圆形按钮 12345678910111213141516171819202122232425262728293031.graybtn &#123; -moz-box-shadow:inset 0px 1px 0px 0px #ffffff; -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff; box-shadow:inset 0px 1px 0px 0px #ffffff; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) ); background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1'); background-color:#ffffff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #dcdcdc; display:inline-block; color:#777777; font-family:arial; font-size:15px; font-weight:bold; padding:6px 24px; text-decoration:none; text-shadow:1px 1px 0px #ffffff;&#125;.graybtn:hover &#123; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) ); background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff'); background-color:#d1d1d1;&#125;.graybtn:active &#123; position:relative; top:1px;&#125; 52、在可打印的网页中显示URLs 12345@media print &#123; a:after &#123; content: \" [\" attr(href) \"] \"; &#125; &#125; 53、禁用移动Webkit的选择高亮 12345678body &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 54、CSS3 圆点图案 12345body &#123; background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px; background-size: 100px 100px;&#125; 55、CSS3 方格图案 1234567body &#123; background-color: white; background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black); background-size: 100px 100px; background-position: 0 0, 50px 50px;&#125; 56、Github的fork色带 1234567891011121314151617181920212223242526.ribbon &#123; background-color: #a00; overflow: hidden; /* top left corner */ position: absolute; left: -3em; top: 2.5em; /* 45 deg ccw rotation */ -moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); /* shadow */ -moz-box-shadow: 0 0 1em #888; -webkit-box-shadow: 0 0 1em #888;&#125;.ribbon a &#123; border: 1px solid #faa; color: #fff; display: block; font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif; margin: 0.05em 0 0.075em 0; padding: 0.5em 3.5em; text-align: center; text-decoration: none; /* shadow */ text-shadow: 0 0 0.5em #444;&#125; 57、CSS font属性缩写 123p &#123; font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;&#125; 58、论文页面的卷曲效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ul.box &#123; position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0; &#125;ul.box li &#123; position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; &#125;ul.box li:before,ul.box li:after &#123; content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg); &#125;ul.box li:after &#123; left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg); &#125; 59、鲜艳的锚链接 123456789101112131415161718192021222324a &#123; color: #00e;&#125;a:visited &#123; color: #551a8b;&#125;a:hover &#123; color: #06e;&#125;a:focus &#123; outline: thin dotted;&#125;a:hover, a:active &#123; outline: 0;&#125;a, a:visited, a:active &#123; text-decoration: none; color: #fff; -webkit-transition: all .3s ease-in-out;&#125;a:hover, .glow &#123; color: #ff0; text-shadow: 0 0 10px #ff0;&#125; 60、带CSS3特色的横幅显示 12345678910111213141516171819202122232425262728.featureBanner &#123; position: relative; margin: 20px&#125;.featureBanner:before &#123; content: \"Featured\"; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1;&#125;.featureBanner:after &#123; content: \"\"; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Snippet","slug":"Snippet","permalink":"http://yoursite.com/tags/Snippet/"}]},{"title":"JavaScript中property和attribute的区别","slug":"JavaScript中property和attribute的区别","date":"2015-07-27T05:50:20.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript中property和attribute的区别/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript中property和attribute的区别/","excerpt":"1. 定义 property（元素属性）：DOM 节点是一个对象，因此，可以添加自定义的属性以及方法。property 的值可以是任何的数据类型，对大小写敏感。自定义的property不会出现在 html 中，只存在 JavaSctipt 中。 attribute（标签属性）：attribute 只能是字符串，大小写不敏感，出现在 innerHTML 中，通过类数组attributes可以罗列所有的 attribute。 2. 相同之处","text":"1. 定义 property（元素属性）：DOM 节点是一个对象，因此，可以添加自定义的属性以及方法。property 的值可以是任何的数据类型，对大小写敏感。自定义的property不会出现在 html 中，只存在 JavaSctipt 中。 attribute（标签属性）：attribute 只能是字符串，大小写不敏感，出现在 innerHTML 中，通过类数组attributes可以罗列所有的 attribute。 2. 相同之处 标准 DOM 的 properties（元素属性）与attributes（标签属性）是同步的。公认的 attributes（标签属性）会添加到DOM对象 property（元素属性）上，如 id、style、className、disabled、checked等。这时候直接操作 property (el. checked) 或者使用 el.getAttribute() / el.setAttribute()效果一致。但是参数不一定相同，如：el.className 与 el.getAttribute(&#39;class&#39;) 3. 不同之处 对于有些标准的特性的操作，el.getAttribute 与 el.property获取的值存在差异性。如: `href、src、value、style、onclic 等 Demo1：el.getAttribute 获取的是 href 的实际值，el.property 获取的是完整的 url 123alEl.href = '/';alert(alEl.getAttribute('href')); // '/'alert(alEl.href); // full URL Demo2：el.property 可以从 el.setAttribute 获得同步 12inputEl.setAttribute('value', 'hello');alert(inputEl.value ); // 'hello' -- property changed! Demo3： el.getAttribute 不能从 el.property 获得同步 12inputEl.value = 'bye';alert(inputEl.getAttribute('value')); // 'hello' – attribute not changed! Demo4：el.getAttribute 只能获取输入框的原始值，el.property 可以获取输入框修改后值 用户输入 ‘good’，inputEl.value 获得 ‘good’，inputEl.getAttribute(‘value’) 获得原始值 ‘hello’。可以利用 inputEl.value == inputEl.getAttribute(‘value’) 检验 input 是否变化 Demo5：checkbox 未选中时 – el.getAttribute 返回 null，el.property 返回 false checkbox 选中时 – el.getAttribute 仍返回 null，el.property 返回 ture12alert(checkboxEl.checked); // boolean truealert(checkboxEl.getAttribute('checked')); // object null Demo6：style – el.getAttribute 返回 string, el.property 返回 object 12alert(divEl.style); // 'width:200px;height:200px;'alert(divEl.getAttribute('style') ) // [object CSSStyleDeclaration] 4. 浏览器兼容性上的差别 1)IE&lt;9 浏览器中，el.property 和 el.getAttribute 可以相互访问自定义属性 2)IE&lt;8（包括IE8种的IE7兼容模式），el.property 和 el.getAttribute 相同 因为 attribute 对大小写不敏感，在这种情况下，用 el.getAttribute 访问特性时，浏览器会选择第一次出现的值。 1234document.body.abba = 1 // assign property (now can read it by getAttribute)document.body.ABBA = 5 // assign property with another case// must get a property named 'ABba' in case-insensitive way.alert( document.body.getAttribute('ABba') ) // 1 5. 优先选择 property 在实际应用中，98% 的 DOM 操作都是使用 properties。 总结：只有两种情形需要使用attributes ： 1) 自定义的 HTML attributes，因为它并不同步到DOM property 2) 访问内置的HTML attributes（设置的初始值），这些 attribute不能从property 同步过来。例如input标签的 value 值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript之事件的中断传播与行为阻止","slug":"JavaScript之事件的中断传播与行为阻止","date":"2015-07-27T03:50:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript之事件的中断传播与行为阻止/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript之事件的中断传播与行为阻止/","excerpt":"如何中断事件的传播？ stopPropagation() w3c取消冒泡 cancleBubble = true IE取消冒泡","text":"如何中断事件的传播？ stopPropagation() w3c取消冒泡 cancleBubble = true IE取消冒泡 取消事件默认效果： returnValue = false IE 取消事件效果 defaultPrevent() w3c取消事件效果 12345&lt;div id='aa'&gt; &lt;div id='bb'&gt; &lt;div id ='cc'&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415 #aa&#123; width: 600px; height: 600px; background: gray;&#125;#bb&#123; width: 400px; height: 400px; background: green;&#125;#cc&#123; width: 200px; height: 200px; background: red;&#125; 捕捉写法停止传播 从最顶层开始往下 123document.getElementById('aa').addEventListener('click',function (ev)&#123;alert('aa');ev.stopPropagation();&#125;,true);// 结果捕捉到aa 加true 由冒泡变为捕捉 从上到下 document.getElementById('bb').addEventListener('click',function ()&#123;alert('bb')&#125;,true); document.getElementById('cc').addEventListener('click',function ()&#123;alert('cc')&#125;,true); 冒泡写法停止传播 从下往上 123456789document.getElementById('aa').addEventListener('click',function ()&#123;alert('aa');&#125;);//加true 由冒泡变为捕捉 从上到下 document.getElementById('bb').addEventListener('click',function ()&#123;alert('bb')&#125;); document.getElementById('cc').addEventListener('click', function (ev)&#123; alert('cc'); ev.stopPropagation(); // ev.cancleBubble = true;//IE下 取消冒泡方法 &#125;); //结果是冒出cc 停止传播&#125; 取消事件效果 returnValue = false //IE 取消事件效果 preventDefault() //w3c取消事件效果 12345678document.getElementsByTagName('a')[0].onclick = function (ev)&#123; alert('点击'); //达到事件结束的效果 但是函数还是往下运行 // ev.preventDefault(); alert('已经拦截');&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript之面向对象中的封装","slug":"JavaScript之面向对象中的封装","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript之面向对象中的封装/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript之面向对象中的封装/","excerpt":"对象的属性外界是可读可写 如何来达到封装的额目的？ 答：可通过闭包+局部变量来完成","text":"对象的属性外界是可读可写 如何来达到封装的额目的？ 答：可通过闭包+局部变量来完成 在构造函数内部声明局部变量 和普通方法 因为作用域的关系 只有构造函数内的方法 才能访问局部变量 而方法对于外界是开放的 因此可以通过方法来访问 原本外界访问不到的局部变量 达到函数封装的目的 123456789101112131415161718192021222324252627282930313233function Girl(name,age)&#123; var love = '小明';//love 是局部变量 准确说不属于对象 属于这个函数的额激活对象 函数调用时必将产生一个激活对象 love在激活对象身上 激活对象有作用域的关系 有办法访问 加一个函数提供外界访问 this.name = name; this.age = age; this.say = function () &#123; return love; &#125;; this.movelove = function ()&#123; love = '小轩'; //35 &#125;&#125; var g = new Girl('yinghong',22);console.log(g);console.log(g.say());//小明console.log(g.movelove());//undefined 因为35行没有返回console.log(g.say());//小轩function fn()&#123; function t()&#123; //var age = 22;//声明age变量 在t的激活对象上 age = 22;//赋值操作 t的激活对象上找age属性 ，找不到 找fn的激活对象....再找到 最终找到window.age = 22; //不加var就是操作window全局属性 &#125; t();&#125;console.log(fn());//undefined","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript对象","slug":"JavaScript对象","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript对象/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript对象/","excerpt":"创建对象","text":"创建对象 对象的概念： 对象和数组的本质一样 都是组织一堆数据 只不过 对象的下表不为数字而且无序 每个编号–&gt;内容 属性–&gt;值 对象和数组的本质一样 都是组织一堆数据 只不过 对象的下表不为数字而且无序 创建对象：（不仅给值 还给属性） 创建对象和数组的[]不一样 和创建对象用{} 和创建数组直接放置的值不一样 创建对象时值前面还要加上属性 创建语法:{属性1:值1,属性2:值2} 对象单元值的引用：（两种方法） Obj.属性 Obj[&#39;属性&#39;] 12345678var stu = &#123;name:'小明',age:22,number:007,score:99&#125;;// alert(stu);//这种方法不推荐//alert(stu['name']);// name需要加上单引号 不然就和变量一样了//推荐用法alert(stu.score); 对象的遍历 遍历对象： 因为对象的属性和数组的下标不一样 数组的下表从0开始并且有规律的递增 因此可以用for循环遍历 对象的属性 没有规律的 for in结构来遍历123For(per in Obj)&#123; ......&#125; 注意：在for in结构中循环得到的属性取值时不能用Obj.属性的方式 只能用中括号 对象和数组本质一个键值对 1234567var stu = &#123;name:'小明',age:22,number:007,score:99&#125;;//注意：在for in 结构中循环得到的属性取值时不能用Obj.属性的方式 只能用obj[属性] for(var i in stu)&#123;//把stu里面的所有属性依次赋给i遍历输出 document.write(stu[i]+'&lt;br&gt;');//stu['i'] 不能这样写 stu['name'] 必须加上单引号 否则系统理解为name是变量 name是属性 是一个字符 &#125; 对象的单元删除 对象的单元删除:对象单元的删除delete obj.属性 1234567891011var stu = &#123;name:'小明',age:22,number:007,score:99&#125;; for(var i in stu)&#123; document.write(stu[i]+'&lt;br&gt;'); &#125; document.write('&lt;hr&gt;'); delete stu.score; for(var i in stu)&#123; document.write(stu[i]+'&lt;br&gt;'); &#125; 对象的方法 在js中 函数本身就是变量 而在数组和对象中存储的就是‘变量’ 对象的某个属性的值–没有可能是一个哈函数？也是可以的 对象的某个属性对象的值可以是函数，如果是函数时，这个属性叫做方法 如果对象的某个方法（属性），需要调用自身的某个属性值，可以在函数中用一个关键词this来代替自己这个对象 this–&gt;指向当前正在调用这个方法的对象（对象自身） 1234//写法1var stu = &#123;name:'张三',age:20,talk:function ()&#123;alert('哈哈哈');&#125;&#125;;// alert(stu.talk);stu.talk();//调用这个函数 1234567891011121314//写法2var zhang = &#123;name:'张三',age:20,talk:null&#125;;var lisi = &#123;name:'李四',age:22,talk:null&#125;;function t(pname)&#123; alert('你好'+pname);&#125;zhang.talk = t;zhang.talk(zhang.name);lisi.talk = t;lisi.talk(lisi.name); 123456789101112131415//写法3 推荐var zhang = &#123;name:'张三',age:20,talk:null&#125;;var lisi = &#123;name:'李四',age:22,talk:null&#125;;function t()&#123; alert('你好'+this.name);//this指向当前正在调用这个方法的对象&#125;zhang.talk = t;zhang.talk();lisi.talk = t;lisi.talk(); JavaScript内置对象: 在js中 所有的变量 都可以被js引擎包装秤对象来处理 比如：str=&#39;abd&#39;字符串本身没有length属性 但是你去调用str.length 在调用一瞬间js引擎会把它包装成一下 当做对象来处理 并且给这个赋了一些方法 对于字符串 布尔值 数值类型 数组 null这些变量 虽然没有属性 但是在调用的前一瞬间 js会为他们包装一些属性和方法 还有一些内置对象，是通过new得来的 比如：日期时间对象 先new 在调用方法和属性 Math对象 和字符串一样 不用new也能直接其方法 字符串对象的属性和方法： length属性： 长度 concat方法：连接两个或者更多个字符串 indexOf（String）返回出现字符串的位置 找不到就返回-1 substr(num1,[num2])//截取字符串 num2截取的宽度 toUpperCase()转换成大写 toLowerCase()转换成小写 replace(oldstr1,newstr2)//字符串替换 123456789101112var str = 'helloworld';//这是一个字符串变量 // alert(str.length); alert(str.concat('中国'));//concat方法：连接两个或者更多个字符串 alert(str.indexOf('o'));//4 alert(str.substr(str.indexOf('o')));//substr截取字符串 一般从开始位置截取 //如有特殊：需要指定截取位置 indexOf（String）返回出现字符串的位置 从当前位置开始截取 alert(str.toUpperCase()); alert(str.replace('hello','连英'));// replace(oldstr1,newstr2) 字符串替换 日期时间对象 日期时间对象 必须通过new 来得到 早数组可以new Array() 造日期时间对象 new Date(); getYear() 返回年份（2位或4位） getFullYear() 返回年份（4位） getMonth()返回月份（0-11） getDate() 返回日期 1-31 getDay() 返回星期数 0-6 getHours()返回小时数0-23 getMinutes()返回分钟数 0-59 getSeconds()返回秒数 0-59 getMilliseconds() 返回毫秒数0-999 12345678910var time = new Date();alert(time.getYear());//116alert(time.getFullYear());//2016alert(time.getMonth());//5alert(time.getDate());//5alert(time.getDay());// 星期天 0alert(time.getHours());//1alert(time.getSeconds());//17alert(time.getMinutes());//20alert(time.getMilliseconds()); 12345678910111213141516//页面上动态时钟function t()&#123; //把年月日 拼接起来 var time = new Date(); var year = time.getFullYear(); var month = time.getMonth(); var day = time.getDate(); var hour = time.getHours(); var minute = time.getMinutes(); var second = time.getSeconds(); document.getElementById('clock').value = (year+\" \"+month+\" \"+day+\" \"+hour+\":\"+minute+\":\"+second); &#125; // document.getElementById('clock').value = t(); //error var clock = setInterval('t()',1000); Math对象 Math对象 和字符串一样 不用new也能直接其方法 ceil(数值)大于或等于该数的最小整数 floor(数值) 小于或等于该数的最大整数 min(数值1,数值2) 返回最小值 max()返回最大值 pow(num1,num2)//返回num1的那么次方 random()返回随机数 0–1 round(数值)四舍五入 sqrt(数值)开平方根 123456for (var i = 0; i &lt; 20; i++) &#123;document.write(5+Math.random()*5+'&lt;br&gt;');//5-10之间的随机&#125;alert(Math.round(3.6658));//4alert(Math.sqrt(2));//1.4 1234567891011//输入任意两个数字 返回两个数之间的随机数的整数 function rd(big,small)&#123; return Math.ceil(Math.random()*(big-small))+small;&#125;for(var i = 0; i &lt; 30; i++) &#123; document.write(rd(big,small)+'&lt;br&gt;');&#125;//javascript中prompt方法可以让用户输入一个文本，从而作为返回值 prompt返回的是字符串类型//需要用到parseInt 转成数字型 比如：输入12 实际返回的是'12'//alert(typeof(window.prompt()));//string","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript之面向对象中的多态","slug":"JavaScript之面向对象中的多态","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript之面向对象中的多态/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript之面向对象中的多态/","excerpt":"多态:同一个父类继承出来的子类各有各的形态","text":"多态:同一个父类继承出来的子类各有各的形态 123456789101112131415161718192021222324252627282930function Cat()&#123; this.eat = '肉';&#125;function Tiger()&#123; this.color = '黑黄相间';&#125;function Cheetah()&#123; this.color = '报文';&#125;function Lion()&#123; this.color = '土黄色';&#125;Tiger.prototype = Cheetah.prototype = Lion.prototype = new Cat();//共享一个祖先 Catvar T = new Tiger();var C = new Cheetah();var L = new Lion();console.log(T.color);console.log(C.color);console.log(L.color);console.log(T.eat);console.log(C.eat);console.log(L.eat);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript与Unicode编码","slug":"JavaScript与Unicode编码","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript与Unicode编码/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript与Unicode编码/","excerpt":"字符集的概念： 字符集：就是–编码–&gt;字符的映射","text":"字符集的概念： 字符集：就是–编码–&gt;字符的映射 例如：65--&gt;A ASCII字符集:0-255 -128---127 在中国： [00000000] 汉字 最多也不过256个 常用的汉字3000多 全部3w+ [00000000][11111111] 0--65535之间 用两个字节表示一个汉字：gb2312(只存了7000左右的汉字 少)–&gt;GBK Unicode编码集： Unicode规定：国 为例 在 Unicode有一个独特的号 假设是2976 Unicode编码集给世界上大部分的语言每个字符都分配了一个号码 国[gbk]–&gt;unicode[2976]–&gt;日本–&gt;从Unicode得到 国 字 把字符转化成对应Unicode对应的编码 以适应不同的计算机平台 escape 把字符转化成各平台通用的Unicode编码 1234var str = '中国';var enc = escape(str);alert(enc);alert(unescape(enc));// unescape 对escape转化的Unicode编码 解密","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript之面向对象中的静态方法-静态属性","slug":"JavaScript之面向对象中的静态方法-静态属性","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript之面向对象中的静态方法-静态属性/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript之面向对象中的静态方法-静态属性/","excerpt":"面向对象中的静态方法-静态属性：没有new对象 也能引用静态方法属性","text":"面向对象中的静态方法-静态属性：没有new对象 也能引用静态方法属性 12345678910function Bird()&#123; this.wing = 2; this.fly = function()&#123; alert('飞'); &#125; &#125;// var maque = new Bird();//我们可以调用麻雀的属性和方法 思考：可不可以不创建麻雀对象 直接调用Bird的相关方法 函数是什么？是变量 是什么类型的变量？是一个对象类型的变量 js里面有几样东西不通过构造器构造出来 原生数据类型有几种：null undefined true false 字符型(‘hello’) 数值型(12) 这五种不用构造器 对象 函数 数组 都是通过构造器构造出来的（自然是对象） 既然是对象 就能给对象加静态属性 1234Bird.ke = 'niaoke';Bird.jiao = function()&#123;alert('叽叽喳喳')&#125;;Bird.jiao();//没有new对象 也能引用静态方法属性 从豆浆机–&gt;制造的流程看 豆浆机充当的是构造函数的角色，如果单独看豆浆机本身 豆浆机也是一部机器 一个对象 也有属性和方法 那么 豆浆机作为对象的属性和方法 就相当于类的静态属性、静态方法","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript-DOM事件","slug":"JavaScript-DOM事件","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript-DOM事件/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript-DOM事件/","excerpt":"DOM 事件就是指 当页面上发生某一件事的时候激发某一个函数 相当监听/触发设备","text":"DOM 事件就是指 当页面上发生某一件事的时候激发某一个函数 相当监听/触发设备 比如： 元素被单击时 onclick 元素失去焦点时 onblur 表单被提交时，用onsubmit DOM事件如何声明？ 直接在元素标签中声明 &lt;input type=&#39;button&#39; onclick=&quot;&quot;&gt; 以事件属性附上一个函数变量：例如inputobj.onclick = 一个函数; 主要的DOM事件：（可以归为3类） 页面上的变化引起的 比如 失去焦点 关闭页面 鼠标变化引起的 比如 鼠标单击 鼠标经过 键盘事件 其中onsubmit比较特殊 ： 在&lt;form onsubmit=&#39;return 函数名&#39;&gt;这样函数return false时 才能阻拦表单的提交行为 鼠标事件： - `onclick` 当单击时 - `onmouseOver` 当经过时 - `onMouseDown` 当鼠标按下时 - `onMouserUp` 当鼠标抬起时 - `onMouseMove` 当鼠标移动时 键盘事件： - `onchange `当内容被改变时[重要] - `onSelect` 当内容被选中时 - `onkeydown `当键盘按下时 - `onkeyup` 当键盘抬起时 - `onSubmit `当表单提交时[重要] - `onReset `当表单重置时 页面事件： - `onblur` 当失去焦点时 - `onfocus `当获得焦点时 - `onload` 当页面加载时 - `onunload` 当页面关闭时 onblur失去焦点 1234&lt;form action=\"\"&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\" value=\"\" onblur=\"t1();\"&gt;&lt;/p&gt; &lt;p&gt;姓名:&lt;input type=\"text\" name=\"username\" onfocus=\"t2();\"&gt;&lt;/p&gt;&lt;/form&gt; 12345678910111213//失去焦点function t1()&#123; var con = document.getElementsByName('email')[0].value; if(con == '')&#123; document.getElementsByName('email')[0].value = prompt('请输入邮件地址：'); &#125;&#125;//获得焦点function t2()&#123; var con = document.getElementsByName('username')[0]; con.style.border = '2px solid red';&#125; onload 1234567&lt;body onload=\"t1();\" onunload=\"t2();\"&gt;&lt;!-- onload写在页面的开始位置 --&gt; &lt;/body&gt;&lt;form action=\"\"&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\" value=\"\" &gt;&lt;/p&gt; &lt;p&gt;姓名:&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt;&lt;/form&gt; 12345678function t1()&#123; var con = document.getElementsByName('email')[0].value='请填写您的email';&#125;function t2()&#123; alert(\"您真的要关闭吗\");&#125; onmouserover 1234567891011121314151617181920&lt;a href=\"#\" onmouseover=\"t3();\" onmouseout=\"t4();\"&gt;百度&lt;/a&gt;&lt;p id=\"baidu\"&gt; 百度详细介绍 &lt;img src=\"./images/logo.png\"&gt;&lt;/p&gt;&lt;p&gt;&lt;select name=\"xueli\" onchange=\"t5();\"&gt; &lt;option value=\"\"&gt;请选择学历&lt;/option&gt; &lt;option value=\"大学\" &gt;大学&lt;/option&gt; &lt;option value=\"中学\"&gt;中学&lt;/option&gt; &lt;option value=\"初中\"&gt;初中&lt;/option&gt; &lt;option value=\"小学\"&gt;小学&lt;/option&gt; &lt;/select&gt;&lt;/p&gt;&lt;form action=\"\" onsubmit=\"return t6();\"&gt; &lt;!-- onsubmit 和return false结合才能阻止提交 地址栏没变化说明阻拦 --&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\" value=\"\" &gt;&lt;/p&gt; &lt;p&gt;姓名:&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交 \"&gt;&lt;/p&gt;&lt;/form&gt; 12345&lt;style type=\"text/css\"&gt; #img&#123; display: none; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233function t1()&#123; alert('来了'); &#125; function t2()&#123; alert('走了'); &#125; function t3()&#123; var bd = document.getElementById('baidu'); bd.style.display = 'block'; &#125; function t4()&#123; var bd = document.getElementById('baidu'); bd.style.display = 'none'; &#125; function t5()&#123; var sel = document.getElementsByTagName('select')[0]; // alert(sel.value); if(sel.value == '')&#123; alert('至少选择一个'); &#125; &#125; function t6()&#123; var con = document.getElementsByName('email')[0].value; if(con == '')&#123; document.getElementsByName('email')[0].value = prompt('请输入邮件地址：'); return false;//和67行结合才能阻拦提交 &#125; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript之函数表达式&arguments详解","slug":"JavaScript之函数表达式&arguments详解","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript之函数表达式&arguments详解/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript之函数表达式&arguments详解/","excerpt":"This与arguments","text":"This与arguments 当一个函数运行的时候 函数内部能引用的变量有这么几种 AO arguments this 对于arguments和this函数都有自己的arguments和this且不进行链式查找 arguments是什么？ 答：arguments是收到的实参的副本 在词法分析中 首先形参形成AO属性 值为undefined 当实参传来时 再修改AO的相应属性 并把收到的实参收集起来放到一个arguments对象里面 t(a,b,c){}为例：调用 时 t(1,2,3,4,5)个参数 此时AO属性只有a,b,c三个属性 但是arguments有1,2,3,4,5所有的值 对于超出形参个数的实参可以通过argument来获得 argument的索引从0 1 2..递增 与实参一一对应 argument.length属性代表实参个数 arguments一定不是数组，但是长得像数组的一个对象而已 虽然也有length属性 arguments每个函数都有 因此只会在内部找自身的argument 无法引用到外部的arguments 123456789101112131415161718function t(a,b,c)&#123;//参数实际来AO的属性 有几个形参 就形成几个AO属性 arguments就代表这个函数的额参数 console.log(a);//1 console.log(b);//2 console.log(c);//3 console.log(arguments[0]);//1 console.log(arguments[1]);//2 console.log(arguments[2]);//3 a = 90; console.log(a);//90 console.log(arguments[0]);//90 互为副本 arguments有一个好处 它接收的实际是你传过来的参数 arguments接收的是所有的实参 console.log(arguments[0]); console.log(arguments[3]);//4 console.log(arguments[4]);//5&#125;t(1,2,3,4,5); 12345678910111213141516//利用 argument的特点完成其他语言的函数重载//求圆形面积 矩形面积 三角形面积 function area()&#123; if(arguments.length ==1)&#123; alert(3.14*arguments[0]*arguments[0]); &#125;else if(arguments.length ==2)&#123; alert(arguments[0]*arguments[1]); &#125;else if(arguments.length ==3)&#123; alert(arguments[0]+arguments[1]+arguments[2]); &#125;else&#123; return null; &#125; &#125;area(10,20,30); 12345678910111213function t()&#123; var age = 22;//age在链的AO上 alert(arguments[0]);//1 alert(arguments[1]);//2 function d()&#123; alert(arguments[0]);//a alert(arguments[1]);//undefined 此时这个argument不会找到上面的arguments[1]去 只有Ao才会按照链来查找 argument不会按照链查找 &#125; d('a');&#125;t(1,2);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript之定时器","slug":"JavaScript之定时器","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript之定时器/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript之定时器/","excerpt":"window定时器 setIntval(表达式,毫秒) clearIntval(定时器对象) setTimeout(表达式,毫秒) clearTimeout(定时器对象)","text":"window定时器 setIntval(表达式,毫秒) clearIntval(定时器对象) setTimeout(表达式,毫秒) clearTimeout(定时器对象) setTimeout(表达式,毫秒)：是指经过指定时间后执行事件一次 清除定时器： 在创建定时器的时候 把创建的结果赋给一个定时器变量 比如：var clock = windows.setTimeout()再用cleraTimeout(clock); 12345678910//定一段时间后执行某一个函数 function t()&#123; window.location.href = 'http:///www.baidu.com'; &#125; window.setTimeout('t()',10*1000);//setTimeout只是执行一次 //用setTimeout来实现每隔5秒执行某一个一次 放到函数里面可以做到 setTimeout实现每隔几秒执行一下 123456789function t()&#123; // window.location.href = 'http:///www.baidu.com';window.setTimeout('t()',2*1000);&#125;t(); setIntval每隔指定时间执行一次事件 碰到每隔几秒执行一次事件的 推荐用setInterval 12345678910function t()&#123; alert('2秒到');&#125;var clock = window.setInterval('t()',2000);//clock命名为了后面消除定时器用到 这个变量是指向定时器function t1()&#123; clearInterval(clock);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中三种绑定事件的方式与去除绑定","slug":"JavaScript中三种绑定事件的方式与去除绑定","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript中三种绑定事件的方式与去除绑定/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript中三种绑定事件的方式与去除绑定/","excerpt":"绑定事件的第1种办法： 函数写在结构层里面 非常不好，使页面很混乱，行为与结构得不到分离","text":"绑定事件的第1种办法： 函数写在结构层里面 非常不好，使页面很混乱，行为与结构得不到分离 1&lt;input type=\"button\" onclick=\"func();\"&gt; 绑定事件的第2种办法 好处：行为与结构开始分离 缺点： 第二种绑定方式中 只能给一个时间绑定一个处理函数 即.onclick = fn1;.onclick = fn2 最终的效果是onclick = fn2 1234567891011121314&lt;select name=\"xueli\" &gt; &lt;option value=\"\"&gt;请选择学历&lt;/option&gt; &lt;option value=\"大学\" &gt;大学&lt;/option&gt; &lt;option value=\"中学\"&gt;中学&lt;/option&gt; &lt;option value=\"初中\"&gt;初中&lt;/option&gt; &lt;option value=\"小学\"&gt;小学&lt;/option&gt; &lt;/select&gt;&lt;form action=\"\"&gt; &lt;p&gt;Email:&lt;input type=\"text\" name=\"email\"&gt; 姓名：&lt;input type=\"text\" name=\"ming\" &gt; &lt;/p&gt;&lt;/form&gt; 12345678910document.getElementsByTagName('select')[0].onclick= function ()&#123; alert('嘻嘻'); &#125;document.getElementsByName('email')[0].onblur=function ()&#123; alert('哈哈哈');&#125; 123456789101112window.onload = function()&#123; var d = document.getElementById('school'); function fn1()&#123; alert('hello'); &#125; function fn2()&#123; alert('world'); &#125; d.onclick = fn1;//赋值操作 最终显示fn2 d.onclick = fn2;&#125; 绑定事件的第3种办法 1234567891011121314151617181920//错误写法1window.onload = function()&#123; var d = document.getElementById('school'); function fn1()&#123;//this此时指向window this.style.background = 'blue'; &#125; function fn2()&#123;//this此时指向window this.style.background = 'red'; &#125; //写一个匿名函数 //最终的出现错误 d.onclick = function ()&#123; fn1(); fn2(); //fn1 fn2是属性window的 实际上是这样 window.fn1() window.fn2() &#125;&#125; 下面这种写法没有问题 但是给DOM树额外增加了两个变量123456789101112131415161718window.onload = function()&#123; var d = document.getElementById('school'); d.fn1 = function ()&#123;//fn1是d的属性 最终this此时指向DOM对象 this.style.background = 'blue'; &#125; d.fn2 = function ()&#123;//this此时指向DOM对象 this.style.background = 'red'; &#125; //匿名函数 调用上面两个函数 d.onclick = function ()&#123; this.fn1(); this.fn2(); &#125;&#125; 不在使用onclick 12345678window.onload = function()&#123; var d = document.getElementById('school'); //达到了一次绑定两个函数 d.addEventListener('click',function () &#123;alert('blue');this.style.background ='blue'&#125;); d.addEventListener('click',function () &#123;alert('red');this.style.background ='red'&#125;); &#125; 去除绑定 不能用匿名函数 匿名函数 当时产生 当时消失 123456789101112131415161718var fn1 = function () &#123;alert('blue');this.style.background ='blue'&#125;;var fn2 = function () &#123;alert('red');this.style.background ='red'&#125;; function adde()&#123; var d = document.getElementById('school'); d.addEventListener('click',fn1); d.addEventListener('click',fn2); &#125;function reme()&#123; var d = document.getElementById('school'); //d.removeEventListener('click',fn1);//只剩fn1 d.removeEventListener('click',fn2);&#125; 在IE下第三种绑定事件的方法 12345&lt;div id=\"school\"&gt; &lt;/div&gt; &lt;input type=\"button\" value=\"加事件\" onclick=\"adde();\"&gt; &lt;input type=\"button\" value=\"减事件\" onclick=\"reme();\"&gt; 12345678910111213141516171819var fn1 = function () &#123;alert('blue');this.style.background ='blue'&#125;;var fn2 = function () &#123;alert('red');this.style.background ='red'&#125;; function adde()&#123; var d = document.getElementById('school'); // IE6,7是后绑定的事件先发生 d.attachEvent('onclick',fn1); d.attachEvent('onclick',fn2); //fn2先发生 &#125;function reme()&#123; var d = document.getElementById('school'); //d.deltachEvent('click',fn1);//只剩fn1 d.deltachEvent('click',fn2);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript之IE,火狐兼容事件对象","slug":"JavaScript之IE,火狐兼容事件对象","date":"2015-07-27T03:40:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript之IE,火狐兼容事件对象/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript之IE,火狐兼容事件对象/","excerpt":"1234567document.getElementById('par').addEventListener ('click',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+ev.screenY)&#125; ); document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;);","text":"1234567document.getElementById('par').addEventListener ('click',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+ev.screenY)&#125; ); document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;); 在js方法和属性没区别 方法和函数都是变量 1234567891011121314151617var par = document.getElementById('par'); if (par.attachEvent)&#123; par.attachEvent('onclick',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+'--'+ev.screenY)&#125; ); &#125;else&#123; par.addEventListener('click',function (ev)&#123; ev = ev||window.event;// 在IE下ev为null window.event为真 || &amp;&amp;在php和js中不同 在js中 第一个真 就返回 否则返回第二个 alert(ev.screenX+'--'+ev.screenY)&#125; ); 下面方法更加简洁 123456789101112131415//document.getElementById('son').addEventListener ('click',function ()&#123;alert('son')&#125;); var par = document.getElementById('par'); var prefix = ''; if (par.attachEvent)&#123;//如果是IE par.addEventListener = par.attachEvent; prefix = 'on'; //讨论IE 火狐的onclick click &#125; par.addEventListener('click',function (ev)&#123;//火狐下 ev = ev||window.event; alert(ev.screenX+'--'+ev.screenY)&#125; );","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript词法分析和作用域闭包","slug":"JavaScript词法分析和作用域闭包","date":"2015-07-26T16:50:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript词法分析和作用域闭包/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript词法分析和作用域闭包/","excerpt":"在函数运行时 会进词法分析（预编译） 预编译做了哪些工作 分析参数 分析变量声明(分析带var的变量声明) 分析函数声明","text":"在函数运行时 会进词法分析（预编译） 预编译做了哪些工作 分析参数 分析变量声明(分析带var的变量声明) 分析函数声明 如何分析变量声明？ 答：对于var声明的变量 以var str = ‘local’为例，分为 分析过程 和执行过程 先分析后执行先分析var str即仅仅声明了一个str变量 str变量此时没有赋值 值是undefined 然后在进行执行过程 1234567891011121314151617181920/*var age = 22;var num = 99; function t()&#123; var num = 88; var str = 'hello'; function a()&#123; var str = 'world'; alert(str);//world alert(num);//88 alert(age);//22 &#125; a(); &#125; t(); 1234567891011121314151617181920/*var str = 'global';function t()&#123; alert(str);//undefined var str = 'local';//local alert(str); //词法分析 var str; //执行语句 alert(str) str = 'local' alert(str)&#125;t(); 活动对象、激活对象 Active Object AO上有哪些属性： 对于函数的AO属性来自三个方面 参数 局部变量声明 函数声明 在函数调用瞬间 AO这样形成 首先分析参数 把分析的的参数形成AO属性 如果传来实参 则把实参赋给相应的属性 其次分析var声明 以var str= hello为例 把str声明为AO的属性 值为undefined 如果var声明的变量名与形参名称一致 不产生影响 因为AO的str已经存在 最后分析函数声明，function函数名(){}//有函数名 函数的变量有其作用域，引用某变量时，在某个范围内查询该变量，这个范围又在哪里？在AO上找 在函数调用的瞬间 会产生一个AO 这个AO对象的属性 即存储着该函数所能引用的到的变量 123456789var str = 'global';function t(age)&#123; alert(age);//99 var age = 12; alert(age);//12&#125;t(); 对上面的结果进行分析： AO：{age:undefined} //词法分析得到AO：{age:99} //实参赋值 AO.age属性AO:{age:12} //修改AO.age的值 1234567function f(age,hei)&#123; var age; alert(age); function age()&#123; alert('he'); &#125;&#125; 分析过程： AO:{} AO:{age:undefined,hei:undefined} AO:{age:32,hei,undefined} 分析完形参 紧接着分析var age 不产生影响 因为AO的age已经存在 AO:{age:function(){aler..},hei:undefined} 执行 alert(age)—》AO.age—》函数 函数就是变量 函数声明就是变量声明 函数声明：假设函数名fn 函数声明会把函数赋值为AO.fn属性的值 函数声明与函数表达式的区别 表达式必有一个返回值 （即 匿名函数赋给了一个变量 此时 就是普通的赋值过程） 函数表达式返回返回 并把函数作为值 赋给变量 函数声明的优先级高 例如function fn(){} 则会把AO.fn = function fn(){} 函数表达式 123456789101112131415161718192021222324function fn1()&#123; alert(age); var age = function()&#123; alert('hahh'); &#125; alert(age);&#125;fn1(32);//结果： 32 function//函数声明function fn1()&#123; alert(age); function age()&#123; alert('hahh'); &#125; alert(age);&#125;fn1(32);//结果： function function 闭包 a.程序永远是先定义后执行 b.执行永远从上到下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 闭包 作用域 记住：先定义var function 在从上往下执行 定义在自己的栈里面 执行在自己的堆里面 运行在运行的环境中 函数每调用前 只是一个地址 只要调用一次函数就会动态开辟一块内存 创建一个封闭的空间 在自己的封闭的空间的栈中定义var在执行 函数执行完 里面的东西全部销毁 12345678910111213//alert(x);//9:执行弹出x,结果x没定义,错误.alert(i);//9:执行弹出i,然而i之前已经定义,只不过没地址,因此是undefiendvar i = 10;//1:var i; 10:把常量池中10的地址赋给栈中的ivar j = \"你好\";//2:var j; 11:把常量池中 你好 的地址复给栈中的jvar k = z = null;//3:var k,z; 12:把堆中null的地址赋值给z和kvar m = function()&#123;//4:var m; 5:function匿名函数 13:把匿名函数在堆中的地址赋给栈中的m alert(2);&#125;var b = document.body;//6:var b; 14:把堆中document.body对象的地址赋给栈中的bvar f = true;//7:var f; 15:把常量池中true的地址赋给栈中的变量ffunction m()&#123;//8:function m; alert(1);&#125; 12345678910function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); //var c;&#125;var c = 150; // 函数m()还未执行到 还没被销毁 此时全局c的值c=50m();var c = 20;//到这里一步 m()已经执行完了 函数已经销毁了 这里的c还是20alert(c);//20 1234567891011121314function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); function inner()&#123; c = 30; alert('嘻嘻'); &#125; inner();//c在函数内部找不到定义 所以沿着作用域链找到了全局的c&#125;var c = 20;//到这里一步 m()还没执行 函数没被销毁 这里的c是30m();alert(c);//30","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript面向对象程序设计","slug":"JavaScript面向对象程序设计","date":"2015-07-26T16:36:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript面向对象程序设计/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript面向对象程序设计/","excerpt":"object对象","text":"object对象 new关键字代表的是新开辟一块内存空间 没有被引用的内存空间，会在适当的时候被销毁 两句代码含义等同 var person = new Object(); var person = {}; 访问对象的属性除了用 对象引用.属性 key以外，还可以使用对象引用[属性key] 面向对象的程序设计 function构造器 共同点: 动态创建一块内存空间，闭包 不同点: 函数调用是没有办法拿到空间的地址的，而且这块地址是一块临时地址，执行完函数之后，就会销毁 new开辟内存空间，把这块空间的地址返回，这块空间就有可能长期的被引用 prototype原型 通过原型使通过同样一个构造器所new（创建）出来的对象具有相同的属性和行为 prototype本质就是一个对象 foreach this 指代当前创建的这块内存 this.name=name 指代当前内存中的这个name属性 接收外界传过来的值 继承 本质就是从一个prototype对象中把它的功能都copy到另一个prototype对象 继承为什么要循环 封装(面向对象程序设计过程) 1：找对象 小头爸爸 大头儿子 饭 2：抽象（类，构造器） 3：创建对象并且建立关系（操作对象） prototype内存解析 prototype是原型，是一块所有对应构造器创建的对象都共享的内存空间 在面向对象设计程序的时候，属性应该是对应的空间的，而功能应该是prototype公共空间的 通过prototype扩展功能 所有的构造器都是继承于Object构造器的，因此只要Object的原型里有的功能，所有的对象都有 call、apply方法 func.call（obj）：调用func的时候，以obj这个对象的作用域去调用 改变函数在调用的时候里面闭包的作用域 call(obj,arg1,arg2,arg3);call第一个参数传对象，可以是null。参数以逗号分开进行传值，参数可以是任何类型。apply(obj,[arg1,arg2,arg3]);apply第一个参数传对象，参数可以是数组或者arguments对象","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之正则表达式(十)","slug":"JavaScript语言基础之正则表达式(十)","date":"2015-07-26T16:09:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript语言基础之正则表达式(十)/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript语言基础之正则表达式(十)/","excerpt":"","text":"Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5}，{c1,c2} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 g.+代表的是1-N个，*代表的是0-N个 h.?代表该字符要不没有要不就有一个 i..代表的是任意字符 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之Window属性(八)","slug":"JavaScript语言基础之Window属性(八)","date":"2015-07-26T16:05:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript语言基础之Window属性(八)/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript语言基础之Window属性(八)/","excerpt":"一些讨论","text":"一些讨论 window 是Window构造器造出来的一个对象 alert(window instanceof Window) document 是Document构造器造出来的一个对象 任何对象在我们的内存中他都是由某个构造器创建出来的 也就是说 有构造器一定有对应的原型prototype 例如：div是由HTMLDivElement 这个构造器创建的一个实例 div = new HTMLDivElement() span = new HTMLSpanElement() 查看某个对象对应的构造器：console.log(); 整个浏览器的实现就是一个面向对象的编程思想 一切皆是对象 BOM 浏览器对象模型 a.screen 指的不是浏览器的宽度，指的是整个电脑屏幕的分辨率 可以拿到屏幕可用分辨率 b.navigator 可以通过userAgent判断当前浏览器信息 c.location URL：统一资源定位符 Union Resource Location 可以通过href属性重定向（改变）页面的URL，进行页面跳转 d.history go方法能够让我们进行历史回退或者前进 e.frames 获得当前窗体的子页面（iframe） f.document DOM模型的核心对象 DOM 文档对象模型 document 功能 getElementById：通过传入的ID，返回标识了这个ID的唯一对象的内存地址 getElementsByTagName:通过传入的标签名字，返回所有该标签对象（HTMLCollection） getElementsByClassName:通过类的名字，返回所有该类的元素对象（HTMLCollection） createElement:想要创建出来的元素能够绘制在页面中，那么它必须在DOM树中 总结： document对象是DOM原型的核心对象，它是内存DOM树的根，所以它提供了很多功能让我们快速的找到DOM树中的某些DOM节点（对象） element 功能方法：（自定义属性非常灵活好用） setAttribute/getAttribute //getAttribute获取标签的属性 –用来操作标签的属性 setAttribute设置标签的属性 appendChild:添加子元素 属性： id className，style name,value(只有表单元素有 其他是没有的) href,src…(对应的元素) innerHTML/innerText innerText返回文本信息 children://子元素集合 parentNode//父元素 总结：元素的功能属性直接可以通过元素对象点出来，除此意外的自定义属性，请通过get/setAtribute去操作 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之DOM操作(九)","slug":"JavaScript语言基础之DOM操作(九)","date":"2015-07-26T16:05:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript语言基础之DOM操作(九)/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript语言基础之DOM操作(九)/","excerpt":"DOM 操作","text":"DOM 操作 图片切换的相册效果 tab切换效果 表单验证 特效就是DOM操作的具体应用 DOM操作就是用js来写HTML代码 节点/元素/标签： 三种常用的节点类型： 元素节点 属性节点 文本节点 操作DOM对象： 修改：–找到这个节点 删除：–找到这个节点 添加：–先造出一个节点 然后插入 插入到哪里？找节点来定位 这些都离不开节点的查找 节点的查找：（最重要） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i]` 注意：早期浏览器都认为name只出现在表单中 因此document.getElemenstByName只对表单中的元素发挥作用 后来部分浏览器把Name属性扩展到一般的元素 如：div 但是IE浏览器还是只能对表单使用byName因此处于兼容性 我们只能对表单使用byName DOM中查找节点的思路：（由大到小 个别情况 由子到父） 由大到小：（通过下面的来定位） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i] 如果还没有查到自己想要的节点，还可以继续根据上面已经找到的节点再次定位来查找 怎么继续定位？ 答案：childNodes/child 继续查找： 1、查找子元素 children[index]/childNodes 2、查找父元素 node.parentNode –&gt;获取父元素 3、查找兄弟元素 nextSibling previousSibling 4、nextSibling previousSibling firstChild lastChild这四个属性容易受到空白文本的影响 建议不用 12345678910111213141516//============给Object原型加一个方法 消除文本节点对DOM操作的影响 例如：nextSibling` `previousSibling` `firstChild` `lastChild （受到换行 和文本节点影响）Object.prototype.next = function()&#123; //NodeType == 3 text的代号 //NodeType == 1 tag的代号 if(this.nextSibling)&#123;//判断下一个兄弟节点是否存在 switch(this.nextSibling.nodeType)&#123; case 1: return this.nextSibling; case 3: return this.nextSibling.nextSibling; &#125;&#125;else&#123; return null;&#125;console.log(div1.next().next().innerText); 5、对于查到的某个元素里面的子元素非常多 这时候还可利用getElementsByTagname进一步筛选 注意：对于元素对象和document对象相比 元素对象只能利用getElementsByTagName函数 其他两个不能用 节点查找也是通过由大到小来定位：找到大的元素进一步细化 完全可以找到页面上任意一个元素控制他 子元素 不好找 就找他的父元素 要过滤空白文本节点，用children取他的文本节点 DOM与节点的关系： node: childNodes[] parentNode firstChild getElementsByTagName(&#39;元素标签&#39;) lastchild nextSibling previousSibling children[index] children 不是w3c标准 但是各大浏览器兼容性很好 通过给原型添加方法在元素后面创建标签 启示：在项目中，很多很多地方都需要一个方法但是系统没提供，这时可以通过原型扩展 123456789101112//var p = document.createElement('p');//p.innerHTML = \"this is a p\";//var child = document.getElementsByTagName('div');//给Div的HTMLDivElement构造器原型加一个创建元素的方法 要所有的元素都有这个方法 改成 ObjectHTMLDivElement.prototype.createElement = function(tagName)&#123; var child = document.createElement(tagName); this.appendChild(child); return child;&#125;var child = document.getElementsByTagName('div')[2].createElement(\"p\");child.innerHTML = 'pppppp'; 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之数组(七)","slug":"JavaScript语言基础之数组(七)","date":"2015-07-26T16:05:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/27/JavaScript语言基础之数组(七)/","link":"","permalink":"http://yoursite.com/2015/07/27/JavaScript语言基础之数组(七)/","excerpt":"","text":"附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之流程控制(五)","slug":"JavaScript语言基础之流程控制(五)","date":"2015-07-26T15:50:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/26/JavaScript语言基础之流程控制(五)/","link":"","permalink":"http://yoursite.com/2015/07/26/JavaScript语言基础之流程控制(五)/","excerpt":"条件结构 if if...else if...else if...else","text":"条件结构 if if...else if...else if...else 当通过判断返回某个值的时候，优先使用三元表达式 当通过判断执行N段逻辑代码的时候，只能用条件结构 switch switch case break default 条件 判断 退出 默认 a.只要匹配上一个case，那么它下面的所有的case都会执行包括default b.break的意思跳出当前结构 for 循环有三个要素 a.循环变量 b.判断（循环体） c.改变循环变量 d.continue的意思结束本次循环进入下次循环 continue 结束本次循环，继续下一次循环 当前这次循环不做 直接做下面的 break 结束后面的循环不做了 while/do...while没有谁好谁坏 只有适应场景不同 比如：先吃饭 在买单 do..while 用户体验高 有风险 扫雷游戏也是先体验 在问是否退出 提高体验 比如：先买单 在吃饭 while 用户体验不高 一般情况下面，如果条件判断是数字的比较==&lt;&gt;，for循环优先. 如果是非数值相关的比较循环，while优先 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之字符串方法(四)","slug":"JavaScript语言基础之字符串方法(四)","date":"2015-07-26T15:46:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/26/JavaScript语言基础之字符串方法(四)/","link":"","permalink":"http://yoursite.com/2015/07/26/JavaScript语言基础之字符串方法(四)/","excerpt":"","text":"附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之运算符(三)","slug":"JavaScript语言基础之运算符(三)","date":"2015-07-26T14:46:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/26/JavaScript语言基础之运算符(三)/","link":"","permalink":"http://yoursite.com/2015/07/26/JavaScript语言基础之运算符(三)/","excerpt":"算术运算符(+,-,*,/,%,++,--`) 如果引用所指的地方是null的话，那么在运算中就会自动变成0 %运算符 如：4%5取模 模是4 7%5取模 模是7-5=2","text":"算术运算符(+,-,*,/,%,++,--`) 如果引用所指的地方是null的话，那么在运算中就会自动变成0 %运算符 如：4%5取模 模是4 7%5取模 模是7-5=2 字符串和数字相加的情况： 左右都是数字：数字相加 左右有一个字符串：字符串拼接 左右边有一个null:null看做0 左右边有一个undefined：结果是NAN（not is number） 赋值运算符(=,-=,+=,*=,/=,%=`) 比较运算符(==,===,!=,&gt;,&lt;,&gt;=,&lt;=`) 先执行表达式计算再赋值 ==和!=在比较之前首先让双方的值做隐士类型转换，===不转换 逻辑运算符(||,&amp;&amp;,!) || 在js中和PHP中是不一样的 js中返回逻辑或的左边或右边的一个结果 PHP返回||或出来以后的结果即：true false 特殊性（注意）—一定要记住（这个特性和其他编程语言不一样）：在js里返回不是布尔值 || 短路运算 第一个条件为真 后面不执行 ‘&amp;&amp;’把表达式最后一个值返回（注意这里） 例子：var age = prompt(“温馨提示：”,”请输入您的年龄”)||0 当点击取消的时候，如果出现undefined null fasle 0 表示非的逻辑 那么||就会过滤，取右边的值0 条件运算符(表达式1?表达式2:表达式3)三元运算符 表达式1?表达式2:表达式3 表达式1为真 返回表达式2 否则返回表达式3 三元运算符 可以多层次嵌套使用 在js中 有四种被认为是非： undefined null false 0 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之数据类型(二)","slug":"JavaScript语言基础之数据类型(二)","date":"2015-07-26T13:46:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/26/JavaScript语言基础之数据类型(二)/","link":"","permalink":"http://yoursite.com/2015/07/26/JavaScript语言基础之数据类型(二)/","excerpt":"一、JavaScript中基本的数据类型查看数据类型用：typeof 变量名","text":"一、JavaScript中基本的数据类型查看数据类型用：typeof 变量名Javascript的数据类型有六种（ES6新增了第七种Symbol） JS中的值有两种类型：原始类型(Primitive)、对象类型(Object)。 原始类型包括：Undefined、Null、Boolean、Number和String等五种。 Undefined类型和Null类型的都只有一个值，即undefined和null；Boolean类型有两个值：true和false；Number类型的值有很多很多；String类型的值理论上有无数个。 所有对象都有valueOf()和toString()方法，它们继承自Object，当然也可能被子类重写 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示 未定义 或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 通常，我们将数值、字符串、布尔值称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值 二、数据类型的转换 转换函数 toString() 转换为字符串，在JavaScript中所有数据类型都可以转换为string类型 12345678910var n1 = 12;var n2 = true;var a = [1, 2, 3];var o = &#123;&#125;;function f()&#123;&#125;n1.toString(); //\"12\"n2.toString(); //\"true\"a.toString(); //\"1,2,3\"o.toString(); //\"[object Object]\"f.toString(); //\"function f()&#123;&#125;\" parseInt()解析出一个string或者number类型的整数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"12\";var n2 = \"23hello\";var n3 = \"hello\";parseInt(n1); //12parseInt(n2); //23parseInt(n3); //NaN parseFloat()解析出一个string的浮点数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"1.2.3\";var n2 = \"1.2hello\"var n3 = \"hello\"parseFloat(n1); //1.2parseFloat(n2); //1.2parseFloat(n3); //NaN 强制类型转换 Boolean(value)- 把给定的值转换成Boolean型 123456Boolean(123); //trueBoolean(\"\"); //falseBoolean([]); //trueBoolean(&#123;&#125;); //trueBoolean(null); //falseBoolean(undefined); //false Number(value)-把给定的值转换成数字（可以是整数或浮点数） 12345678Number(\"123\"); //123Number(\"123h\"); //NaNNumber(true); //1Number(false); //0Number(undefined); //NaNNumber(null); //0Number([]); //0Number(&#123;&#125;); //NaN String(value)- 把给定的值转换成字符串 12345String(123); //\"123\"String([1,2]); //\"1,2\"String(undefined) //\"undefined\"String(null) //\"null\"String(&#123;&#125;) //\"[object Object]\" 隐式转换 数字＋字符串：数字转换为字符串 console.log(12+&quot;12&quot;); //1212 数字＋布尔值：true转换为1，false转换为0 console.log(12+true); //13 字符串＋布尔值：布尔值转换为true或false console.log(&quot;hello&quot;+true); //hellotrue 布尔值＋布尔值 console.log(true+true); //2 null和undefined undefined 表示一种未知状态，声明了但没有初始化的变量，变量的值时一个未知状态。访问不存在的属性或对象window.xxx）方法没有明确返回值时，返回值是一个undefined.当对未声明的变量应用typeof运算符时，显示为undefined。 null表示尚未存在的对象,null是一个有特殊意义的值。可以为变量赋值为null，此时变量的值为“已知状态”(不是undefined)，即null。（用来初始化变量，清除变量内容，释放内存） `undefined==null` //结果为true,但含义不同。 `undefined===null` //false,两者类型不一致，前者为“undefined”，后者为“object” 总结一下==运算的规则：(隐式转换) undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。 String == Boolean，需要两个操作数同时转为Number。 String/Boolean == Number，需要String/Boolean转为Number。 Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法) 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之函数基础(六)","slug":"JavaScript语言基础之函数基础(六)","date":"2015-07-26T13:46:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/26/JavaScript语言基础之函数基础(六)/","link":"","permalink":"http://yoursite.com/2015/07/26/JavaScript语言基础之函数基础(六)/","excerpt":"代码内存解析","text":"代码内存解析 闭包 a.程序永远是先定义后执行 b.执行永远从上到下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 闭包 作用域 记住：先定义var function 在从上往下执行 定义定义在自己的栈里面 执行在自己的堆里面 运行在运行的环境中 函数每调用前 只是一个地址 只要调用一次函数就会动态开辟一块内存 创建一个封闭的空间 在自己的封闭的空间的栈中定义var在执行 函数执行完 里面的东西全部销毁 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript语言基础之变量(一)","slug":"JavaScript语言基础之变量(一)","date":"2015-07-26T12:46:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/07/26/JavaScript语言基础之变量(一)/","link":"","permalink":"http://yoursite.com/2015/07/26/JavaScript语言基础之变量(一)/","excerpt":"关于变量的一些讨论 变量是内存中的一段存储空间，变量的值就是一段地址 存储的是值（变量名本质是地址的一个别名） 变量本质是一个空盒子，里面记录了一个内存地址，使能找到内存中的对象，保存了指向具体的实在的东西的地址 在js语言中 不必像php那样神明引用赋值， 不用加&amp;取地址 在js中三种默认是引用赋值的：数组 对象 函数 变量存在栈中，对象存在堆中 变量的意义：方便我们去操作对象 var b = document.body 含义：把body这个对象在内存中的地址放到b变量里面，变量b（b是内存地址的别名）本身也存在内存中，以后的操作是针对body这个地址","text":"关于变量的一些讨论 变量是内存中的一段存储空间，变量的值就是一段地址 存储的是值（变量名本质是地址的一个别名） 变量本质是一个空盒子，里面记录了一个内存地址，使能找到内存中的对象，保存了指向具体的实在的东西的地址 在js语言中 不必像php那样神明引用赋值， 不用加&amp;取地址 在js中三种默认是引用赋值的：数组 对象 函数 变量存在栈中，对象存在堆中 变量的意义：方便我们去操作对象 var b = document.body 含义：把body这个对象在内存中的地址放到b变量里面，变量b（b是内存地址的别名）本身也存在内存中，以后的操作是针对body这个地址 变量命名规范 由字母(a-zA-Z)数字(0-9)下划线(_)以及美元符号($) 不能由数字开头 命名尽量用英文并且具有一定的含义 如果有多个英文单词,后面单词的首字母大写 不能使用关键字 首字母不要大写，大写是有特殊含义的 附录：思维导图总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"计算机基础","slug":"计算机基础","date":"2015-07-12T14:24:08.000Z","updated":"2018-03-29T15:06:20.447Z","comments":true,"path":"2015/07/12/计算机基础/","link":"","permalink":"http://yoursite.com/2015/07/12/计算机基础/","excerpt":"","text":"数据结构与算法 算法 整理自《算法 第四版》 Leetcode 题解 对题目做了一个分类，并对每种题型的解题思想做了总结。 已经整理了 300+ 的题目，基本涵盖所有经典题目，持续整理中。 剑指 offer 题解 目录按《剑指 Offer 第二版》编排，在牛客网的在线编程中出现的题目都已经 AC。 很多题目都在 Leetcode 中出现过，所以一些解题思路就不在这里重复写了。想要看解题思路的话，可以看《剑指 Offer》原书，或者先看 Leetcode 题解，看完 Leetcode 题解再看剑指 Offer 会觉得很容易。 网络 计算机网络 整理自《计算机网络 第七版》，重点内容会在标题之后加 *。 HTTP 整理自《图解 HTTP》 操作系统 计算机操作系统 整理自《现代操作系统》 Linux 整理自《鸟哥的 Linux 私房菜》 面向对象 设计模式 整理自《Head First 设计模式》，这本书内容废话太多，笔记内容提取了重点部分。 面向对象思想 一些面向对象思想和原则 数据库 SQL 语法 整理自《SQL 必知必会》，原书内容不多，笔记内容会更简洁。 MySQL 整理自《高性能 MySQL》，重点整理。 Java JVM 整理自《深入理解 Java 虚拟机》，包括内存模型、垃圾回收和类加载机制。 Java 容器 容器的一些总结，包含容器源码的分析。 Java IO File、InputStream 和 OutputStream、Reader 和 Writer、Serializable、Socket 以及 NIO 编码实践 重构 重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 编写可读代码的艺术 编程有很大一部分时间是在阅读代码，可读性良好的代码能够大大提高编程效率。 资料下载 百度网盘 一些 PDF 书籍 后记原文发表在 牛客网：计算机基础知识整理 :star: :star: :star: 牛客网上有很多优质面经，面经往往会给出一些面试需要准备的知识列表，但是这些知识列表都很零散，不适合系统地进行学习。为此，楼主选取了一些计算机经典书籍和材料，对面试相关的计算机基础知识做了比较系统整理，希望对大家有所帮助。 整理的笔记开源在 Github 上，包括数据结构与算法、网络、操作系统、面向对象。 Github 仓库提供相关 PDF 书籍的下载，基本都是高清版本。 如有笔误，直接在 Github 上进行编辑修改就行，楼主会及时 Merge。 想要支持楼主的话，在 Github 仓库点个 Star 即可。 笔记基本是楼主一个字一个字打上去的，笔记内容可供个人随意使用，转载请注明出处，毕竟写了这么久没那么轻松~ 楼主作为一个轻度强迫症患者，笔记内容会尽量保证排版美观，可读性好。有时候找不到好看的图，会选择自己画一个，可见楼主的强迫症多严重。为了让笔记内容更整洁，前前后后做了很多次修改，也写了一个为中英混排文档进行排版的脚本，来提高笔记的可读性。 为了上传笔记到 Github 上，也花了不少时间。楼主使用的笔记软件是为知笔记，怎么把笔记内容提取成文本文档，并且提取笔记中的图片就是一个问题。Github 使用的是 GFM 来渲染 md 文档，和普通的 Markdown 不太一样，例如 GFM 不支持 MathJax 公式，也不支持 TOC 标记，为此需要替换 MathJax 公式为 Codecogs 的云服务和重新生成 TOC 目录。楼主实现了脚本解决了上述的问题，并且整个过程可以一键进行，包括 Git 同步到仓库中。有需要该工具的话可以在我的 Github 中找到。 :star: :star: :star:","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/tags/计算机/"}]},{"title":"ES6编码风格","slug":"es6-coding-style","date":"2015-04-14T06:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/04/14/es6-coding-style/","link":"","permalink":"http://yoursite.com/2015/04/14/es6-coding-style/","excerpt":"","text":"一、块级作用域 1.1 let取代var ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用 var命令存在变量提升效用，let命令没有这个问题 建议不再使用var命令，而是使用let命令取代 12345\"use strict\";if(true) &#123;console.log(x); // ReferenceErrorlet x = 'hello';&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则 1.2 全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。 12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误 所有的函数都应该设置为常量 let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全 1.3 严格模式 V8引擎只在严格模式之下，支持let和const。结合前两点，这实际上意味着，将来所有的编程都是针对严格模式的。 二、字符串 静态字符串一律使用单引号，不使用双引号。动态字符串使用反引号 123456789// badconst a = \"foobar\";const b = 'foo' + a + 'bar';// goodconst a = 'foobar';const b = `foo$&#123;a&#125;bar`;const c = 'foobar'; 三、解构赋值 使用数组成员对变量赋值，优先使用解构赋值 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值 1234567891011121314// badfunction getFullName(user) &#123;const firstName = user.firstName;const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123;const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序 12345678910// badfunction processInput(input) &#123;return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123;return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 四、对象 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾 12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123;k1: v1,k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123;k1: v1,k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法 1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义 12345678910111213// badconst obj = &#123;id: 5,name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;'// goodconst obj = &#123;id: 5,name: 'San Francisco',[getKey('enabled')]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 123456789101112131415161718ar ref = 'some value';// badconst atom = &#123;ref: ref,value: 1,addValue: function (value) &#123;return atom.value + value;&#125;,&#125;;// goodconst atom = &#123;ref,value: 1,addValue(value) &#123;return atom.value + value;&#125;,&#125;; 五、数组 使用扩展运算符（...）拷贝数组 12345678910// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123;itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组 12const foo = document.querySelectorAll('.foo');const nodes = Array.from(foo); 六、函数 立即执行函数可以写成箭头函数的形式 123(() =&gt; &#123;console.log('Welcome to the Internet.');&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this 123456789// bad[1, 2, 3].map(function (x) &#123;return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123;return x * x;&#125;); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this 1234567891011// badconst self = this;const boundMethod = function(...params) &#123;return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用arguments变量，使用rest运算符（...）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组 12345678910// badfunction concatenateAll() &#123;const args = Array.prototype.slice.call(arguments);return args.join('');&#125;// goodfunction concatenateAll(...args) &#123;return args.join('');&#125; 使用默认值语法设置函数参数的默认值 123456789// badfunction handleThings(opts) &#123;opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123;// ...&#125; 七、Map结构 注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key:value的数据结构，使用Map。因为Map有内建的遍历机制 12345678910let map = new Map(arr);for (let key of map.keys()) &#123;console.log(key);&#125;for (let value of map.values()) &#123;console.log(value);&#125;for (let item of map.entries()) &#123;console.log(item[0], item[1]);&#125; 八、Class 总是用class，取代需要prototype操作。因为class的写法更简洁，更易于理解 123456789101112131415161718192021// badfunction Queue(contents = []) &#123;this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;// goodclass Queue &#123;constructor(contents = []) &#123;this._queue = [...contents];&#125;pop() &#123;const value = this._queue[0];this._queue.splice(0, 1);return value;&#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险 12345678910111213141516// badconst inherits = require('inherits');function PeekableQueue(contents) &#123;Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123;return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123;peek() &#123;return this._queue[0];&#125;&#125; 九、模块 Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require 1234567// badconst moduleA = require('moduleA');const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from 'moduleA'; 使用export取代module.exports 1234567891011121314151617// commonJS的写法var React = require('react');var Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from 'react';const Breadcrumbs = React.createClass(&#123;render() &#123;return &lt;nav /&gt;;&#125;&#125;);export default Breadcrumbs 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default） 12345// badimport * as myObject './importModule';// goodimport myObject from './importModule'; 如果模块默认输出一个函数，函数名的首字母应该小写 123function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写 12345const StyleGuide = &#123;es6: &#123;&#125;&#125;;export default StyleGuide;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Emmet：HTML/CSS代码快速编写神器","slug":"Emmet：HTML-CSS代码快速编写神器","date":"2015-03-14T06:33:00.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/03/14/Emmet：HTML-CSS代码快速编写神器/","link":"","permalink":"http://yoursite.com/2015/03/14/Emmet：HTML-CSS代码快速编写神器/","excerpt":"前端开发必备！Emmet使用手册","text":"前端开发必备！Emmet使用手册 Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，比如下面的演示： 该插件已经改名为Emmet。但Emmet不只改名，还带来了一些新特性。 快速编写HTML代码 初始化 HTML文档需要包含一些固定的标签，比如&lt;html&gt;、&lt;head&gt;、&lt;body&gt;等，现在你只需要1秒钟就可以输入这些标签。比如输入“!”或“html:5”，然后按Tab键： html:5 或!：用于HTML5文档类型 html:xt：用于XHTML过渡文档类型 html:4s：用于HTML4严格文档类型 连续输入元素名称和ID，Emmet会自动为你补全，比如输入p#foo： 连续输入类和id，比如p.bar#foo，会自动生成：Html代码 &lt;p class=&quot;bar&quot; id=&quot;foo&quot;&gt;&lt;/p&gt; 下面来看看如何定义HTML元素的内容和属性。你可以通过输入h1{foo}和a[href=#]，就可以自动生成如下代码： &lt;h1&gt;foo&lt;/h1&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 嵌套 现在你只需要1行代码就可以实现标签的嵌套。 &gt;：子元素符号，表示嵌套的元素 +：同级标签符号 ^：可以使该符号前的标签提升一行 分组 你可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo&gt;h1)+(.bar&gt;h2)，会自动生成如下代码： 123456&lt;div class=\"foo\"&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"bar\"&gt; &lt;h2&gt;&lt;/h2&gt; &lt;/div&gt; 隐式标签 声明一个带类的标签，只需输入div.item，就会生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt; 在过去版本中，可以省略掉div，即输入.item即可生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在&lt;ul&gt;中输入.item，就会生成&lt;li class=&quot;item&quot;&gt;&lt;/li&gt;。 下面是所有的隐式标签名称： li：用于ul和ol中 tr：用于table、tbody、thead和tfoot中 td：用于tr中 option：用于select和optgroup中 定义多个元素 要定义多个元素，可以使用*符号。比如，ul&gt;li*3可以生成如下代码： 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 定义多个带属性的元素 如果输入 ul&gt;li.item$*3，将会生成如下代码： 12345&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;/ul&gt; CSS缩写 值 比如要定义元素的宽度，只需输入w100，即可生成 width: 100px; 除了px，也可以生成其他单位，比如输入h10p+m5e，结果如下： height: 10%; margin: 5em; 单位别名列表： p 表示% e 表示 em x 表示 ex 附加属性 可能你之前已经了解了一些缩写，比如 @f，可以生成： 1234@font-face &#123; font-family:; src:url(); &#125; 一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成： 123456789@font-face &#123; font-family: 'FontName'; src: url('FileName.eot'); src: url('FileName.eot?#iefix') format('embedded-opentype'), url('FileName.woff') format('woff'), url('FileName.ttf') format('truetype'), url('FileName.svg#FontName') format('svg'); font-style: normal; font-weight: normal; &#125; 模糊匹配 如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：overflow: hidden; 供应商前缀 如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成： 12345-webkit-transform: ; -moz-transform: ; -ms-transform: ; -o-transform: ; transform: ; 你也可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo： 12345-webkit-super-foo: ; -moz-super-foo: ; -ms-super-foo: ; -o-super-foo: ; super-foo: ; 如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀： 123-webkit-transform: ; -moz-transform: ; transform: ; 前缀缩写如下： w 表示 -webkit- m表示 -moz- s 表示 -ms- o 表示 -o- 渐变 输入lg(left, #fff 50%, #000)，会生成如下代码： 12345background-image: -webkit-gradient(linear, 0 0, 100% 0, color-stop(0.5, #fff), to(#000));background-image: -webkit-linear-gradient(left, #fff 50%, #000);background-image: -moz-linear-gradient(left, #fff 50%, #000);background-image: -o-linear-gradient(left, #fff 50%, #000);background-image: linear-gradient(left, #fff 50%, #000); 附加功能 生成Lorem ipsum文本 引用 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Libero delectus. 定制 你还可以定制Emmet插件： 添加新缩写或更新现有缩写，可修改[snippets.json][16]文件 更改Emmet过滤器和操作的行为，可修改[preferences.json][17]文件 定义如何生成HTML或XML代码，可修改[syntaxProfiles.json][18]文件 针对不同编辑器的插件* Emmet支持的编辑器如下（链接为针对该编辑器的Emmet插件）： Sublime Text 2 TextMate 1.x Eclipse/Aptana Coda 1.6 and 2.x Espresso Chocolat （通过“Install Mixin”对话框添加) Komodo Edit/IDE （通过Tools → Add-ons菜单添加) Notepad++ PSPad textarea CodeMirror2/3 Brackets Emmet官网文档： emmet插件下载中心 GitHub主页 emmet快捷键表 emmet文档","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"Emmet","slug":"Emmet","permalink":"http://yoursite.com/tags/Emmet/"}]},{"title":"DIV企业命名参考","slug":"企业DIV使用频率高的命名方法","date":"2015-03-14T06:09:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/03/14/企业DIV使用频率高的命名方法/","link":"","permalink":"http://yoursite.com/2015/03/14/企业DIV使用频率高的命名方法/","excerpt":"网页内容类","text":"网页内容类 标题: title 摘要: summary 箭头： arrow 商标： label 网站标志： logo 转角/圆角： corner 横幅广告： banner 子菜单： subMenu 搜索： search 搜索框： searchBox 登录： login 登录条：loginbar 工具条： toolbar 下拉： drop 标签页： tab 当前的： current 列表： list 滚动： scroll 服务： service 提示信息： msg 热点：hot 新闻： news 小技巧： tips 下载： download 栏目标题： title 热点： hot 加入： joinus 注册： regsiter 指南： guide 友情链接： friendlink 状态： status 版权： copyright 按钮： btn 合作伙伴： partner 投票： vote 左右中：left right center 注释的写法:/ Footer /内容区/ End Footer / id的命名: 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名: 颜色:使用颜色的名称或者16进制代码,如 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; } .font9px {font-size: 9pt; } 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } .bottom { float:bottom; } 标题栏样式,使用”类别+功能”的方式命名,如 .barnews { } .barproduct { } 注意事项:: 一律小写; 尽量用英文; 不加中杠和下划线; 尽量不缩写，除非一看就明白的单词. 【推荐的 CSS 书写顺序】： 显示属性 display list-style position float clear 自身属性 width height margin padding border background 文本属性 color font text-decoration text-align vertical-align white-space other text content","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://yoursite.com/tags/规范/"}]},{"title":"前端题目","slug":"前端题目","date":"2015-03-14T06:09:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/03/14/前端题目/","link":"","permalink":"http://yoursite.com/2015/03/14/前端题目/","excerpt":"","text":"本文旨在加深对前端知识点的理解，资料来源于网络，由本人(博客：http://segmentfault.com/u/trigkit4) 收集整理。 一些开放性题目1.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。 2.项目介绍 3.如何看待前端开发？ 4.平时是如何学习前端开发的？ 5.未来三到五年的规划是怎样的？ position的值， relative和absolute分别是相对于谁进行定位的？ absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出 如何解决跨域问题 JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 12345678910111213141516171819&lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript); &#125; createJs('jsonp.js'); box(&#123; 'name': 'test' &#125;); function box(json)&#123; alert(json.name); &#125;&lt;/script&gt; CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 XML和JSON的区别？123456789101112131415(1).数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。(2).数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。(3).数据描述方面。JSON对数据的描述性比XML较差。(4).传输速度方面。JSON的速度要远远快于XML。 谈谈你对webpack的看法WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 webpack的两大特色： 1.code splitting（可以自动完成） 2.loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack具有requireJs和browserify的功能，但仍有很多自己的新特性： 1234567891011121314151. 对 CommonJS 、 AMD 、ES6的语法做了兼容2. 对js、css、图片等资源文件都支持打包3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持4. 有独立的配置文件webpack.config.js5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间6. 支持 SourceUrls 和 SourceMaps，易于调试7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 说说TCP传输的三次握手四次挥手策略 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开一个TCP连接则需要“四次握手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 创建ajax过程1234567891011(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.(3)设置响应HTTP请求状态变化的函数.(4)发送HTTP请求.(5)获取异步调用返回的数据.(6)使用JavaScript和DOM实现局部刷新. 渐进增强和优雅降级渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 123456781.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等。2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 要完成一次CSRF攻击，受害者必须依次完成两个步骤： 123登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B。 CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法 Web Worker 和webSocket worker主线程: 12345671.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。2.通过worker.postMessage( data ) 方法来向worker发送数据。3.绑定worker.onmessage方法来接收worker发送过来的数据。4.可以使用 worker.terminate() 来终止一个worker的执行。 WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个HTML5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。 HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 为什么HTTPS安全因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 对前端模块化的认识 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 CMD模块方式 12345define(function(require, exports, module) &#123; // 模块代码&#125;); Javascript垃圾回收方法 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 你觉得前端工程的价值体现在哪为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 谈谈性能优化问题代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 代码层面的优化 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 移动端性能优化 尽量使用css3动画，开启硬件加速。 适当使用touch事件代替click事件。 避免使用css3渐变阴影效果。 可以用transform: translateZ(0)来开启硬件加速。 不滥用Float。Float在渲染时计算量比较大，尽量减少使用 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。 合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加 PC端的在移动端同样适用 相关阅读：如何做到一秒渲染一个移动页面 什么是Etag？当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。 情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。 情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同① ① 只有get请求会被缓存，post请求不会 Expires和Cache-ControlExpires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 123456789Cache-Control: no-cache, private, max-age=0ETag: abcdeExpires: Thu, 15 Apr 2014 20:00:00 GMTPragma: privateLast-Modified: $now // RFC1123 format ETag应用:Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下： ====第一次请求=== 1.客户端发起 HTTP GET 请求一个文件； 2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200 ====第二次请求=== 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办 答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后， 服务器才能返回304.(不要陷入到底使用谁的问题怪圈) 为什么使用Etag请求头? Etag 主要为了解决 Last-Modified 无法解决的一些问题。 栈和队列的区别?栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 快速 排序的思想并实现一个快排？“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较 &#125; alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87”&lt;/script&gt; 你觉得jQuery或zepto源码有哪些写的好的地方(答案仅供参考) jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。 12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery;&#125;)( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。 ES6的了解新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念 js继承方式及其优缺点 原型链继承的缺点 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 具体请看：JavaScript继承方式详解 关于Http 2.0 你知道多少？HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 defer和async defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 谈谈浮动和清除浮动浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 如何评价AngularJS和BackboneJSbackbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto) 就比一个AngularJS 多出了2 次HTTP请求. Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新。 AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。 用过哪些设计模式？ 工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。 function createObject(name,age,profession){//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () { return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession; }; return obj; } var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例 构造函数模式 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 1.构造函数方法没有显示的创建对象 (new Object()); 2.直接将属性和方法赋值给 this 对象; 3.没有 renturn 语句。 说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收 具体请看：详解js闭包 请你谈谈Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。 第一：每个特定的域名下最多生成20个cookie 1.IE6或更低版本最多20个cookie 2.IE7和之后的版本最后可以有50个cookie。 3.Firefox最多50个cookie 4.chrome和Safari没有做硬性限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。 cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。 IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。 优点：极高的扩展性和可用性 1.通过良好的编程，控制保存在cookie中的session对象的大小。 2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。 3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。 4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 缺点： 1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉. 2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 浏览器本地存储在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。 html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 display:none和visibility:hidden的区别？ display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 CSS中link 和@import的区别是？ (1) link属于HTML标签，而@import是CSS提供的; (2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载; (3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; (4) link方式的样式的权重 高于@import的权重. position:absolute和float属性的异同 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。 介绍一下box-sizing属性？ box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content 标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ 12345678910111213141516171.id选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[rel = \"external\"]）9.伪类选择器（a: hover, li:nth-child） 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 CSS3新增伪类举例： 12345678910111213p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 CSS3有哪些新特性？ CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询，多栏布局 border-image CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认）布局所占宽度Width： 1Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height: 1Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box布局所占宽度Width： 1Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height: 1Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box布局所占宽度Width： 1Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: 1Height = height(包含padding-top + padding-bottom + border-top + border-bottom) 对BFC规范的理解？ BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。 （W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。 说说你对语义化的理解？1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构 2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。 2）、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种Doctype文档类型？ 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML与XHTML——二者有什么区别区别： 1.所有的标记都必须要有一个相应的结束标记 2.所有标签的元素和属性的名字都必须使用小写 3.所有的XML标记都必须合理嵌套 4.所有的属性必须用引号&quot;&quot;括起来 5.把所有&lt;和&amp;特殊符号用编码表示 6.给所有属性赋一个值 7.不要在注释内容中使“--” 8.图片必须有说明文字 常见兼容性问题？png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 _display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb{ background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ } 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发 怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在 可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;` 上下margin重合问题 ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。 解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 解释下浮动和它的工作原理？清除浮动的技巧浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 1.使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 2.使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 3.使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； 浮动元素引起的问题和解决办法？浮动元素引起的问题： （1）父元素的高度无法被撑开，影响与父元素同级的元素 （2）与浮动元素同级的非浮动元素（内联元素）会跟随其后 （3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式： 123.clearfix:after&#123;content: \".\";display: block;height: 0;clear: both;visibility: hidden;&#125;.clearfix&#123;display: inline-block;&#125; /* for IE/Mac */ 清除浮动的几种方法： 123456789101112131415161718192021221，额外标签法，&lt;div style=\"clear:both;\"&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）2，使用after伪类#parent:after&#123; content:\".\"; height:0; visibility:hidden; display:block; clear:both; &#125;3,浮动外部元素4,设置overflow为hidden或者auto DOM操作——怎样添加、移除、移动、复制、创建和查找节点。 1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //并没有insertAfter() 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强， 会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 拖拽释放(Drag and drop) API 语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： 1234567891011121314IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt;如何区分： DOCTYPE声明\\新增的结构元素\\功能元素 如何实现浏览器内多个标签页之间的通信?1调用localstorge、cookies等本地存储方式 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？1234567 FOUC - Flash Of Unstyled Content 文档样式闪烁 &lt;style type=\"text/css\" media=\"all\"&gt;@import \"../fouc.css\";&lt;/style&gt;而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。 null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 new操作符具体干了什么呢? 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); js延迟加载的方式有哪些？defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js call() 和 apply() 的区别和作用？作用：动态改变某个类的某个方法的运行环境（执行上下文）。 区别参见：JavaScript学习总结（四）function函数部分 哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 详见：详解js变量、作用域及内存 列举IE 与其他浏览器不一样的特性？ IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num 事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none CSS圆角：ie7以下不支持圆角 WEB应用从服务器主动推送Data到客户端有那些方式？Javascript数据推送 Commet：基于HTTP长连接的服务器推送技术 基于WebSocket的推送方案 SSE（Server-Send Event）：服务器推送数据新方式 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 分为4个步骤： （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。 （2）， 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 （3），一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。 （4），此时，`Web`服务器提供资源服务，客户端开始下载资源。 请求返回后，便进入了我们关注的前端模块 简单来说，浏览器会解析`HTML`生成`DOM Tree`，其次会根据CSS生成CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM` 详情：从输入 URL 到浏览器接收的过程中发生了什么事情？ javascript对象的几种创建方式1，工厂模式 2，构造函数模式 3，原型模式 4，混合构造函数和原型模式 5，动态原型模式 6，寄生构造函数模式 7，稳妥构造函数模式 javascript继承的6种方法1，原型链继承 2，借用构造函数继承 3，组合继承(原型+借用构造) 4，原型式继承 5，寄生式继承 6，寄生组合式继承 详情：JavaScript继承方式详解 创建ajax的过程1234567891011121314151617181920212223242526(1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象.(2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息.(3)设置响应`HTTP`请求状态变化的函数.(4)发送`HTTP`请求.(5)获取异步调用返回的数据.(6)使用JavaScript和DOM实现局部刷新.var xmlHttp = new XMLHttpRequest();xmlHttp.open('GET','demo.php','true');xmlHttp.send()xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200)&#123; &#125;&#125; 详情：JavaScript学习总结（七）Ajax和Http状态字 异步加载和延迟加载1.异步加载的方案： 动态插入script标签 2.通过ajax去获取js代码，然后通过eval执行 3.script标签上添加defer或者async属性 4.创建并插入iframe，让它异步执行js 5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。 ie各版本和chrome可以并行下载多少个资源IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个 Firefox，chrome也是6个 ####Flash、Ajax各自的优缺点，在使用中如何取舍？ Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。 -Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM 请解释一下 JavaScript 的同源策略。概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么要有同源限制？ 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点： 现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 GET和POST的区别，何时使用POST？ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值， 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。； 3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`; ajax的缺点和在IE下的问题？详情请见：JavaScript学习总结（七）Ajax和Http状态字 ajax的缺点 1、ajax不支持浏览器back按钮。 2、安全问题 AJAX暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 5、不容易调试。 IE缓存问题 在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(&#39;t&#39;= + new Date().getTime()) 或者： 1open(&apos;GET&apos;,&apos;demo.php?rand=+Math.random()&apos;,true);// Ajax请求的页面历史记录状态问题 可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时页面状态的变化。 还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变 谈谈你对重构的理解网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 HTTP状态码1234567891011121314151617181920212223242526272829100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 说说你对Promise的理解依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125;&#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。 说说你对前端架构师的理解负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护；带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制123456789101112Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === \"object\" ? this[e].clone() : this[e]; &#125; return o;&#125; 说说严格模式的限制严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 注：经过测试IE6,7,8,9均不支持严格模式。 如何删除一个cookie 1.将时间设为当前时间往前一点。 123var date = new Date();date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天。 2.expires的设置 1document.cookie = 'user='+ encodeURIComponent('name') + ';expires = ' + new Date(0) &lt;strong&gt;，&lt;em&gt;和&lt;b&gt;，&lt;i&gt;标签1234567&lt;strong&gt; 标签和 &lt;em&gt; 标签一样，用于强调文本，但它强调的程度更强一些。em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 &lt;i&gt;...&lt;/i&gt;;&lt; b &gt; &lt; i &gt;是视觉要素，分别表示无意义的加粗，无意义的斜体。em 和 strong 是表达要素(phrase elements)。 说说你对AMD和Commonjs的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 详情：也谈webpack及其开发模式 document.write()的用法document.write()方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。 document.write只能重绘整个页面。innerHTML可以重绘页面的一部分 编写一个方法 求一个字符串的字节长度假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1234567891011121314151617 function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(\"你好,as\")); git fetch和git pull的区别123git pull：相当于是从远程获取最新版本并merge到本地git fetch：相当于是从远程获取最新版本到本地，不会自动merge 说说你对MVC和MVVM的理解 MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 组成部分Model、View、ViewModel View：UI界面 ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model； Model：数据访问层 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 attribute和property的区别是什么？attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的， 说说网络分层里七层模型是哪七层 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 12345678物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 各种协议 ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 说说mongoDB和MySQL的区别MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：①弱一致性（最终一致），更能保证用户的访问速度：②文档结构的存储方式，能够更便捷的获取数据。 讲讲304缓存的原理服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。 什么样的前端代码是好的高复用低耦合，这样文件小，好维护，而且好扩展。 代码题 css代码题 js代码题","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"题目","slug":"题目","permalink":"http://yoursite.com/tags/题目/"}]},{"title":"前端面试题整理","slug":"ms","date":"2015-03-12T14:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/03/12/ms/","link":"","permalink":"http://yoursite.com/2015/03/12/ms/","excerpt":"","text":"目录$HTML， HTTP，web综合问题 1、前端需要注意哪些SEO 2、&lt;img&gt;的title和alt有什么区别 3、HTTP的几种请求方法用途 4、从浏览器地址栏输入url到显示页面的步骤 5、如何进行网站性能优化 6、HTTP状态码及其含义 7、语义化的理解 8、介绍一下你对浏览器内核的理解 9、html5有哪些新特性、移除了那些元素？ 10、HTML5的离线储存怎么使用，工作原理能不能解释一下？ 11、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 12、请描述一下 cookies，sessionStorage 和 localStorage 的区别 13、iframe有那些缺点？ 14、WEB标准以及W3C标准是什么? 15、xhtml和html有什么区别? 16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？ 18、HTML全局属性(global attribute)有哪些 19、Canvas和SVG有什么区别？ 20、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ 21、如何在页面上实现一个圆形的可点击区域？ 22、网页验证码是干嘛的，是为了解决什么安全问题 $CSS部分 1、css sprite是什么,有什么优缺点 2、display: none;与visibility: hidden;的区别 3、link与@import的区别 4、什么是FOUC?如何避免 5、如何创建块级格式化上下文(block formatting context),BFC有什么用 7、清除浮动的几种方式，各自的优缺点 8、为什么要初始化CSS样式? 9、css3有哪些新特性 10、display有哪些值？说明他们的作用 11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 12、CSS优先级算法如何计算？ 13、对BFC规范的理解？ 14、谈谈浮动和清除浮动 15、position的值， relative和absolute`定位原点是 16、display:inline-block 什么时候不会显示间隙？(携程) 17、PNG,GIF,JPG的区别及如何选 18、行内元素float:left后是否变为块级元素？ 19、在网页中的应该使用奇数还是偶数的字体？为什么呢？ 20、::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用 21、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 22、CSS合并方法 23、CSS不同选择器的权重(CSS层叠的规则) 24、列出你所知道可以改变页面布局的属性 25、CSS在性能优化方面的实践 26、CSS3动画（简单动画的实现，如旋转等） 27、base64的原理及优缺点 $JavaScript 1、闭包 2、说说你对作用域链的理解 3、JavaScript原型，原型链 ? 有什么特点？ 4、请解释什么是事件代理 5、Javascript如何实现继承？ 6、谈谈This对象的理解 7、事件模型 8、new操作符具体干了什么呢? 9、Ajax原理 11、模块化开发怎么做？ 12、异步加载JS的方式有哪些？ 13、那些操作会造成内存泄漏？ 14、XML和JSON的区别？ 15、谈谈你对webpack的看法 17、常见web安全及防护原理 18、用过哪些设计模式？ 19、为什么要有同源限制？ 20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 21、javascript有哪些方法定义对象 22、常见兼容性问题？ 22、说说你对promise的了解 23、你觉得jQuery源码有哪些写的好的地方 25、Node的应用场景 26、谈谈你对AMD、CMD的理解 27、那些操作会造成内存泄漏？ 28、web开发中会话跟踪的方法有哪些 29、介绍js的基本数据类型 30、介绍js有哪些内置对象？ 31、说几条写JavaScript的基本规范？ 32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 33、javascript创建对象的几种方式？ 34、eval是做什么的？ 35、null，undefined 的区别？ 36、[“1”, “2”, “3”].map(parseInt) 答案是多少？ 37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 38、JSON的了解？ 39、js延迟加载的方式有哪些？ 40、同步和异步的区别? 41、渐进增强和优雅降级 42、defer和async 43、说说严格模式的限制 44、attribute和property的区别是什么？ 45、谈谈你对ES6的理解 46、ECMAScript6 怎么写class么，为什么会出现class这种东西? 47、什么是面向对象编程及面向过程编程，它们的异同和优缺点 48、从你自己的理解来看，你是如何理解面向对象编程的，它解决了什么问题，有什么作用 49、对web标准、可用性、可访问性的理解 $编程题 1、写一个通用的事件侦听器函数 2、如何判断一个对象是否为数组 3、冒泡排序 4、快速排序 5、编写一个方法 求一个字符串的字节长度 $其他 1、谈谈你对重构的理解 2、什么样的前端代码是好的 3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 4、你觉得前端工程的价值体现在哪 5、平时如何管理你的项目？ 人事面 面试完你还有什么问题要问的吗 你有什么爱好? 你最大的优点和缺点是什么? 你为什么会选择这个行业，职位? 你觉得你适合从事这个岗位吗? 你有什么职业规划? 你对工资有什么要求? 如何看待前端开发？ 未来三到五年的规划是怎样的？ 常问 自我介绍 你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？ 你认为哪个项目做得最好？ 最近在看哪些前端方面的书？ 平时是如何学习前端开发的？ 你最有成就感的一件事 你是怎么学习前端的 $HTML， HTTP，web综合问题1、前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 2、&lt;img&gt;的title和alt有什么区别 通常当鼠标滑动到元素上的时候显示 alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 3、HTTP的几种请求方法用途 1、GET方法 发送一个请求来取得服务器上的某一资源 2、POST方法 向URL指定的资源提交数据或附加新的数据 3、PUT方法 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有 4、HEAD方法 只请求页面的首部 5、DELETE方法 删除服务器上的某资源 6、OPTIONS方法 它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息 7、TRACE方法 TRACE方法被用于激发一个远程的，应用层的请求消息回路 8、CONNECT方法 把请求连接转换到透明的TCP/IP通道 4、从浏览器地址栏输入url到显示页面的步骤 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 5、如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名 减少DOM元素数量 Server方面 使用CDN 配置ETag 对组件使用Gzip压缩 Cookie方面 减小cookie大小 css方面 将样式表放到页面顶部 不使用CSS表达式 使用&lt;link&gt;不使用@import Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 6、HTTP状态码及其含义 1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 7、语义化的理解 用正确的标签做正确的事情！ html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 8、介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 9、html5有哪些新特性、移除了那些元素？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u` 对可用性产生负面影响的元素：frame，frameset，noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 10、HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 11、浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 12、请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 13、iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 14、WEB标准以及W3C标准是什么? 标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离 15、xhtml和html有什么区别? 一个是功能上的差别 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确地编译网页 另外是书写习惯的差别 XHTML 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素 16、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载import只在IE5以上才能识别，而link是XHTML标签，无兼容问题link方式的样式的权重 高于@import的权重 &lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现 17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？ 行内元素有：a b span img input select strong 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 空元素：&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 行内元素不可以设置宽高，不独占一行 块级元素可以设置宽高，独占一行 18、HTML全局属性(global attribute)有哪些 class:为元素设置类标识 data-*: 为元素增加自定义属性 draggable: 设置元素是否可拖拽 id: 元素id，文档内唯一 lang: 元素内容的的语言 style: 行内css样式 title: 元素相关的建议信息 19、Canvas和SVG有什么区别？ svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布 svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿 20、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 21、如何在页面上实现一个圆形的可点击区域？ svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 22、网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 $CSS部分1、css sprite是什么,有什么优缺点 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。 优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现 缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式 2、display: none;与visibility: hidden;的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容 3、link与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC link可以通过rel=&quot;alternate stylesheet&quot;指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import 4、什么是FOUC?如何避免 Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。 解决方法：把样式表放到文档的head 5、如何创建块级格式化上下文(block formatting context),BFC有什么用 创建规则： 根元素 浮动元素（float不是none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素 overflow不是visible的元素 作用： 可以包含浮动元素 不被浮动元素覆盖 阻止父子元素的margin折叠 6、display,float,position的关系 如果display为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整display 7、清除浮动的几种方式，各自的优缺点 父级div定义height 结尾处加空div标签clear:both 父级div定义伪类:after和zoom 父级div定义overflow:hidden 父级div也浮动，需要定义宽度 结尾处加br标签clear:both 比较好的是第3种方式，好多网站都这么用 8、为什么要初始化CSS样式? 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 9、css3有哪些新特性 新增各种css选择器 圆角 border-radius 多列布局 阴影和反射 文字特效text-shadow 线性渐变 旋转transform CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个&lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt;元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中 10、display有哪些值？说明他们的作用 block 象块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 11、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种， IE盒子模型、W3C盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; 12、CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高 13、对BFC规范的理解？ 它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用 14、谈谈浮动和清除浮动 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 15、position的值， relative和absolute定位原点是 absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位 relative：生成相对定位的元素，相对于其正常位置进行定位 static 默认值。没有定位，元素出现在正常的流中 inherit 规定从父元素继承 position 属性的值 16、display:inline-block 什么时候不会显示间隙？(携程) 移除空格 使用margin负值 使用font-size:0 letter-spacing word-spacing 17、PNG,GIF,JPG的区别及如何选 GIF 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画 JPEG 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片 PNG 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮 18、行内元素float:left后是否变为块级元素？ 浮动后，行内元素不会成为块状元素，但是可以设置宽高。行内元素要想变成块状元素，占一行，直接设置display:block;。但如果元素设置了浮动后再设置display:block;那就不会占一行。 19、在网页中的应该使用奇数还是偶数的字体？为什么呢？ 偶数字号相对更容易和 web 设计的其他部分构成比例关系 20、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素 用于区分伪类和伪元素 21、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 22、CSS合并方法 避免使用@import引入多个css文件，可以使用CSS工具将CSS合并为一个CSS文件，例如使用Sass\\Compass等 23、CSS不同选择器的权重(CSS层叠的规则) ！important规则最重要，大于其它规则 行内样式规则，加1000 对于选择器中给定的各个ID属性值，加100 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10 对于选择其中给定的各个元素标签选择器，加1 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则 24、列出你所知道可以改变页面布局的属性 position、display、float、width、height、margin、padding、top、left、right、` 25、CSS在性能优化方面的实践 css压缩与合并、Gzip压缩 css文件放在head里、不要用@import 尽量用缩写、避免用滤镜、合理使用选择器 26、CSS3动画（简单动画的实现，如旋转等） 依靠CSS3中提出的三个属性：transition、transform、animation transition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、transition-timing-function、transition-delay。 transform：定义元素的变化结果，包含rotate、scale、skew、translate。 animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction 27、base64的原理及优缺点 优点可以加密，减少了http请求 缺点是需要消耗CPU进行编解码 $JavaScript1、闭包 闭包就是能够读取其他函数内部变量的函数 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中 闭包的另一个用处，是封装对象的私有属性和私有方法 好处：能够实现封装和缓存等； 坏处：就是消耗内存、不正当使用会造成内存溢出的问题 使用闭包的注意点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 解决方法是，在退出函数之前，将不使用的局部变量全部删除 2、说说你对作用域链的理解 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期 3、JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象 4、请解释什么是事件代理 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 可以实现当新增子对象时无需再次对其绑定 5、Javascript如何实现继承？ 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213function Parent()&#123; this.name = 'wang'; &#125; function Child()&#123; this.age = 28; &#125; Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 &#125; 6、谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window 7、事件模型 W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling） 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件 阻止冒泡：在W3c中，使用stopPropagation（）方法；在IE下设置cancelBubble = true 阻止捕获：阻止事件的默认行为，例如click - &lt;a&gt;后的跳转。在W3c中，使用preventDefault（）方法，在IE下设置window.event.returnValue = false 8、new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 9、Ajax原理 Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据 Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制 1234567891011121314151617// 1. 创建连接 var xhr = null; xhr = new XMLHttpRequest() // 2. 连接服务器 xhr.open('get', url, true) // 3. 发送请求 xhr.send(null); // 4. 接受请求 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success(xhr.responseText); &#125; else &#123; // fail fail &amp;&amp; fail(xhr.status); &#125; &#125; &#125; ajax 有那些优缺点? 优点： 通过异步模式，提升了用户体验. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax可以实现动态不刷新（局部刷新） 缺点： 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 不容易调试。 10、如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 11、模块化开发怎么做？ 立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 12、异步加载JS的方式有哪些？ defer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack 13、那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包使用不当 14、XML和JSON的区别？ 数据体积方面 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 数据交互方面 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互 数据描述方面 JSON对数据的描述性比XML较差 传输速度方面 JSON的速度要远远快于XML 15、谈谈你对webpack的看法 WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 16、说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 17、常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 总的来说有以下几点 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤 登录受信任网站A，并在本地生成Cookie 在不登出A的情况下，访问危险网站B CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数 通过验证码的方法 18、用过哪些设计模式？ 工厂模式： 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字 构造函数模式 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 直接将属性和方法赋值给 this对象; 19、为什么要有同源限制？ 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 20、offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别 offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同 clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条 scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 21、javascript有哪些方法定义对象 对象字面量： var obj = {}; 构造函数： var obj = new Object(); Object.create(): var obj = Object.create(Object.prototype); 22、常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一,，但是全局效率很低，一般是如下这样解决： 1234body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p&#123;margin:0;padding:0;&#125; IE下,event对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. 22、说说你对promise的了解 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled与 rejected一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应resolve, onRejected对应 reject 23、你觉得jQuery源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 24、vue、react、angular Vue.js一个用于创建 web 交互界面的库，是一个精简的 MVVM。它通过双向数据绑定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了Directives 和 Filters AngularJS是一个比较完善的前端MVVM框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 Angular指令 reactReact 仅仅是 VIEW 层是facebook公司。推出的一个用于构建UI的一个库，能够实现服务器端的渲染。用了virtual dom，所以性能很好。 25、Node的应用场景 特点： 1、它是一个Javascript运行环境 2、依赖于Chrome V8引擎进行代码解释 3、事件驱动 4、非阻塞I/O 5、单进程，单线程 优点： 高并发（最重要的优点） 缺点： 1、只支持单核CPU，不能充分利用CPU 2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃 26、谈谈你对AMD、CMD的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 27、那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 28、web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 29、介绍js的基本数据类型 Undefined、Null、Boolean、Number、String 30、介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 31、说几条写JavaScript的基本规范？ 不要在同一行声明多个变量 请使用===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 32、JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 33、javascript创建对象的几种方式？ javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 对象字面量的方式 1person=&#123;firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"&#125;; 用function来模拟无参的构造函数 12345678 function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class person.name=\"Mark\"; person.age=\"25\"; person.work=function()&#123; alert(person.name+\" hello...\"); &#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); &#125; &#125; var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） 1234567var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function()&#123; alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); &#125; wcDog.work(); 用原型方式来创建 123456789function Dog()&#123; &#125; Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function()&#123; alert(this.name+&quot;是个吃货&quot;); &#125; var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建 123456789function Car(name,price)&#123; this.name=name; this.price=price; &#125; Car.prototype.sell=function()&#123; alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); &#125; var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell(); 34、eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;) 35、null，undefined 的区别？ undefined 表示不存在这个值。 undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined 例如变量被声明了，但没有赋值时，就等于undefined null 表示一个对象被定义了，值为“空值” null : 是一个对象(空对象, 没有任何属性和方法) 例如作为函数的参数，表示该函数的参数不是对象； 在验证null时，一定要使用 === ，因为 ==无法分别null 和 undefined 36、[“1”, “2”, “3”].map(parseInt) 答案是多少？ [1, NaN, NaN]因为 parseInt 需要两个参数 (val, radix)，其中radix 表示解析时用的基数。 map传了 3个(element, index, array)，对应的 radix 不合法导致解析失败。 37、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 38、JSON 的了解？** JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 JSON字符串转换为JSON对象: 123var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);var obj = str.parseJSON();var obj = JSON.parse(str); JSON对象转换为JSON字符串： 12var last=obj.toJSONString();var last=JSON.stringify(obj); 39、js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js 40、同步和异步的区别? 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 41、渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 42、defer和async defer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 43、说说严格模式的限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 禁止this指向全局对象 44、attribute和property的区别是什么？ attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 对于html的标准属性来说，attribute和property是同步的，是会自动更新的 但是对于自定义的属性来说，他们是不同步的 45、谈谈你对ES6的理解 新增模板字符串（为JavaScript提供了简单的字符串插值功能） 箭头函数 for-of（用来遍历数据—例如数组中的值。） arguments对象可被不定参数和默认参数完美代替。 ES6将promise对象纳入规范，提供了原生的Promise对象。 增加了let和const命令，用来声明变量。 增加了块级作用域。 let命令实际上就增加了块级作用域。 还有就是引入module模块的概念 46、ECMAScript6 怎么写class么，为什么会出现class这种东西? 这个语法糖可以让有OOP基础的人更快上手js，至少是一个官方的实现了 但对熟悉js的人来说，这个东西没啥大影响；一个Object.creat()搞定继承，比class简洁清晰的多 47、什么是面向对象编程及面向过程编程，它们的异同和优缺点 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为 面向对象是以功能来划分问题，而不是步骤 48、面向对象编程思想 基本思想是使用对象，类，继承，封装等基本概念来进行程序设计 优点 易维护 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的 易扩展 开发工作的重用性、继承性高，降低重复工作量。 缩短了开发周期 49、对web标准、可用性、可访问性的理解 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 $编程题1、写一个通用的事件侦听器函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125; 2、如何判断一个对象是否为数组123456function isArray(arg) &#123; if (typeof arg === 'object') &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125; return false;&#125; 3、冒泡排序 每次比较相邻的两个数，如果后一个比前一个小，换位置 1234567891011121314151617var arr = [3, 1, 4, 6, 5, 7, 2];function bubbleSort(arr) &#123;for (var i = 0; i &lt; arr.length - 1; i++) &#123; for(var j = 0; j &lt; arr.length - 1; j++) &#123; if(arr[j + 1] &lt; arr[j]) &#123; var temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;return arr;&#125;console.log(bubbleSort(arr)); 4、快速排序 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边 123456789101112131415161718192021222324var arr = [3, 1, 4, 6, 5, 7, 2];function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; return quickSort(l).concat(c, quickSort(r));&#125;console.log(quickSort(arr)); 5、编写一个方法 求一个字符串的字节长度 假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1234567891011121314151617function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(\"你好,as\")); 6、bind的用法，以及如何实现bind的函数和需要注意的点 bind的作用与call和apply相同，区别是call和apply是立即调用函数，而bind是返回了一个函数，需要调用的时候再执行。一个简单的bind函数实现如下 123456Function.prototype.bind = function(ctx) &#123; var fn = this; return function() &#123; fn.apply(ctx, arguments); &#125;;&#125;; $其他1、谈谈你对重构的理解 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 2、什么样的前端代码是好的 高复用低耦合，这样文件小，好维护，而且好扩展。 3、对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近 实现界面交互 提升用户体验 有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 4、你觉得前端工程的价值体现在哪 为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 5、平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理 人事面 面试完你还有什么问题要问的吗 你有什么爱好? 你最大的优点和缺点是什么? 你为什么会选择这个行业，职位? 你觉得你适合从事这个岗位吗? 你有什么职业规划? 你对工资有什么要求? 如何看待前端开发？ 未来三到五年的规划是怎样的？ 常问 自我介绍 你的项目中技术难点是什么？遇到了什么问题？你是怎么解决的？ 你认为哪个项目做得最好？ 最近在看哪些前端方面的书？ 平时是如何学习前端开发的？ 你最有成就感的一件事 你是怎么学习前端的","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"ES6新特性","slug":"es6-new-property","date":"2015-02-04T10:20:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2015/02/04/es6-new-property/","link":"","permalink":"http://yoursite.com/2015/02/04/es6-new-property/","excerpt":"","text":"一、作用域 块级作用域 块级变量let 块级常量 const 二、箭头函数 sum = (a,b)=&gt; a + b nums.forEach(v=&gt; {console.log(v)}) 词法 this 三、参数处理 默认参数值 剩余参数 展开运算符 四、模板字面量 多行字符串 字符串插值 带标签的模板字面量 原始字符串 五、原有字面量加强 更安全的二进制字面量(0b1111101) 更安全的八进制字面量(0o767) 字符串支持Unicode String.fromCodePoint String.prototype.codePointAt 正则表达式字面量添加 Unicode 正则表达式添加y标记，支持粘滞匹配 对象属性加强 属性定义支持短语法obj = {x,y} 属性名支持表达式 obj = {[&quot;baz&quot;+quux()]:42} 添加__proto__属性，但不建议使用 六、解构赋值 匹配 [b,a] = [a,b] 对象匹配 let {a,b,c} = objABC 参数匹配 function g({name:n,val:v}){} 七、模块 导入(import) 导出(export) 默认导出(export default) 八、类 使用extends继承 重写构造器 super关键字 九、迭代 迭代器 for of 十、生成器 十一、promise 十二、元编程 代理(proxy) 反射(Reflex) 十三、新增数据类型 Symbol类型 Set类型 Map类型 WeakSet类型 WeakMap类型 TypedArray类型 十四、原有内置对象API增强 Object.assign Array.from Array.of Array.prototype.fill Array.prototype.find Array.prototype.findIndex Array.prototype.copyWithin Array.prototype.entries Array.prototype.keys Array.prototype.values String.prototype.includes String.prototype.repeat String.prototype.startsWidth String.prototype.endsWidth() Number.EPSILON Number.isInteger Number.isSafeInteger Number.isFinite Number.isNaN(&quot;NaN&quot;) Math.acosh Math.hypot Math.imul Math.sign Math.trunc","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"javascript代码片段","slug":"javascript常用代码片段","date":"2014-12-24T02:33:00.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/12/24/javascript常用代码片段/","link":"","permalink":"http://yoursite.com/2014/12/24/javascript常用代码片段/","excerpt":"转义特殊字符为html实体 123HtmlEncode: function(str)&#123; return str.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;').replace(/'/g, ''');&#125;, 验证是否为有效的手机电话号码 1234IsMobile: function(str)&#123; var rp = /^1[3|4|5|7|8][0-9]\\d&#123;4,8&#125;$/; return rp.test(str);&#125;, 验证是否为有效的座机电话号码","text":"转义特殊字符为html实体 123HtmlEncode: function(str)&#123; return str.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;').replace(/'/g, ''');&#125;, 验证是否为有效的手机电话号码 1234IsMobile: function(str)&#123; var rp = /^1[3|4|5|7|8][0-9]\\d&#123;4,8&#125;$/; return rp.test(str);&#125;, 验证是否为有效的座机电话号码 1234IsTel: function(str)&#123; var rp = /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/; return rp.test(str);&#125;, 判断是那种类型的浏览器 123456789101112131415161718192021222324252627282930313233343536373839404142434445WhichBrowser: function()&#123; var userAgent = navigator.userAgent; var isOpera = userAgent.indexOf(\"Opera\") &gt; -1; var isIE = userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; userAgent.indexOf(\"MSIE\") &gt; -1 &amp;&amp; !isOpera; var isFF = userAgent.indexOf(\"Firefox\") &gt; -1; var isCH = userAgent.indexOf(\"Chrome\") &gt; -1; var isSafari = userAgent.indexOf(\"Safari\") &gt; -1; if (isIE)&#123; var IE5 = IE55 = IE6 = IE7 = IE8 = false; var reIE = new RegExp(\"MSIE (\\\\d+\\\\.\\\\d+);\"); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[\"$1\"]); IE55 = fIEVersion == 5.5; IE6 = fIEVersion == 6.0; IE7 = fIEVersion == 7.0; IE8 = fIEVersion == 8.0; if (IE55) &#123; return \"IE55\"; &#125; if (IE6) &#123; return \"IE6\"; &#125; if (IE7) &#123; return \"IE7\"; &#125; if (IE8) &#123; return \"IE8\"; &#125; &#125; if (isFF) &#123; return \"Firefox\"; &#125; if (isCH) &#123; return \"Chrome\"; &#125; if (isOpera) &#123; return \"Opera\"; &#125; if (isSafari) &#123; return \"Safari\"; &#125;&#125;, 获取客户端浏览器cookie 123456789101112GetCookie: function(c_name)&#123; if(document.cookie.length&gt;0)&#123; c_start = document.cookie.indexOf(c_name + '='); if(c_start != -1)&#123; c_start = c_start + c_name.length + 1; c_end = document.cookie.indexOf(';',c_start); if (c_end==-1) c_end = document.cookie.length; return unescape(document.cookie.substring(c_start,c_end)); &#125; &#125; return '';&#125;, 设置客户端浏览器cookie 123456SetCookie: function(c_name, value, expiredays)&#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie = c_name + \"=\" + escape(value) + ((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString());&#125;,&#125;; 字符串长度截取 1234567891011121314151617181920function cutstr(str, len) &#123; var temp, icount = 0, patrn = /[^\\x00-\\xff]/， strre = \"\"; for (var i = 0; i &lt; str.length; i++) &#123; if (icount &lt; len - 1) &#123; temp = str.substr(i, 1); if (patrn.exec(temp) == null) &#123; icount = icount + 1 &#125; else &#123; icount = icount + 2 &#125; strre += temp &#125; else &#123; break; &#125; &#125; return strre + \"...\"&#125; 替换全部 123String.prototype.replaceAll = function(s1, s2) &#123; return this.replace(new RegExp(s1, \"gm\"), s2)&#125; 清除空格 1234String.prototype.trim = function() &#123; var reExtraSpace = /^\\s*(.*?)\\s+$/; return this.replace(reExtraSpace, \"$1\")&#125; 清除左空格/右空格 12function ltrim(s)&#123; return s.replace( /^(\\s*| *)/, \"\"); &#125; function rtrim(s)&#123; return s.replace( /(\\s*| *)$/, \"\"); &#125; 判断是否以某个字符串开头 123String.prototype.startWith = function (s) &#123; return this.indexOf(s) == 0&#125; 判断是否以某个字符串结束 1234String.prototype.endWith = function (s) &#123; var d = this.length - s.length; return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)&#125; 转义html标签 123function HtmlEncode(text) &#123; return text.replace(/&amp;/g, '&amp;').replace(/\\\"/g, '\"').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;')&#125; 时间日期格式转换 123456789101112131415161718Date.prototype.Format = function(formatStr) &#123; var str = formatStr; var Week = ['日', '一', '二', '三', '四', '五', '六']; str = str.replace(/yyyy|YYYY/, this.getFullYear()); str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : '0' + (this.getYear() % 100)); str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : '0' + (this.getMonth() + 1)); str = str.replace(/M/g, (this.getMonth() + 1)); str = str.replace(/w|W/g, Week[this.getDay()]); str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : '0' + this.getDate()); str = str.replace(/d|D/g, this.getDate()); str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : '0' + this.getHours()); str = str.replace(/h|H/g, this.getHours()); str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : '0' + this.getMinutes()); str = str.replace(/m/g, this.getMinutes()); str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : '0' + this.getSeconds()); str = str.replace(/s|S/g, this.getSeconds()); return str&#125; 判断是否为数字类型 12345678function isDigit(value) &#123; var patrn = /^[0-9]*$/; if (patrn.exec(value) == null || value == \"\") &#123; return false &#125; else &#123; return true &#125;&#125; 设置cookie值 123456789function setCookie(name, value, Hours) &#123; var d = new Date(); var offset = 8; var utc = d.getTime() + (d.getTimezoneOffset() * 60000); var nd = utc + (3600000 * offset); var exp = new Date(nd); exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + exp.toGMTString() + \";domain=360doc.com;\"&#125; 获取cookie值 12345function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\")); if (arr != null) return unescape(arr[2]); return null&#125; 加入收藏夹 1234567891011function AddFavorite(sURL, sTitle) &#123; try &#123; window.external.addFavorite(sURL, sTitle) &#125; catch(e) &#123; try &#123; window.sidebar.addPanel(sTitle, sURL, \"\") &#125; catch(e) &#123; alert(\"加入收藏失败，请使用Ctrl+D进行添加\") &#125; &#125;&#125; 设为首页 12345678910111213141516function setHomepage() &#123; if (document.all) &#123; document.body.style.behavior = 'url(#default#homepage)'; document.body.setHomePage('http://w3cboy.com') &#125; else if (window.sidebar) &#123; if (window.netscape) &#123; try &#123; netscape.security.PrivilegeManager.enablePrivilege(\"UniversalXPConnect\") &#125; catch(e) &#123; alert(\"该操作被浏览器拒绝，如果想启用该功能，请在地址栏内输入 about:config,然后将项 signed.applets.codebase_principal_support 值该为true\") &#125; &#125; var prefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefBranch); prefs.setCharPref('browser.startup.homepage', 'http://w3cboy.com') &#125;&#125; 加载样式文件 123456789101112function LoadStyle(url) &#123; try &#123; document.createStyleSheet(url) &#125; catch(e) &#123; var cssLink = document.createElement('link'); cssLink.rel = 'stylesheet'; cssLink.type = 'text/css'; cssLink.href = url; var head = document.getElementsByTagName('head')[0]; head.appendChild(cssLink) &#125;&#125; 返回脚本内容 123456789101112131415161718function evalscript(s) &#123; if(s.indexOf('&lt;script') == -1) return s; var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig; var arr = []; while(arr = p.exec(s)) &#123; var p1 = /&lt;script[^\\&gt;]*?src=\\\"([^\\&gt;]*?)\\\"[^\\&gt;]*?(reload=\\\"1\\\")?(?:charset=\\\"([\\w\\-]+?)\\\")?&gt;&lt;\\/script&gt;/i; var arr1 = []; arr1 = p1.exec(arr[0]); if(arr1) &#123; appendscript(arr1[1], '', arr1[2], arr1[3]); &#125; else &#123; p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i; arr1 = p1.exec(arr[0]); appendscript('', arr1[2], arr1[1].indexOf('reload=') != -1); &#125; &#125; return s;&#125; 清除脚本内容 123function stripscript(s) &#123; return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, '');&#125; 动态加载脚本文件 1234567891011121314151617181920212223242526272829303132function appendscript(src, text, reload, charset) &#123; var id = hash(src + text); if(!reload &amp;&amp; in_array(id, evalscripts)) return; if(reload &amp;&amp; $(id)) &#123; $(id).parentNode.removeChild($(id)); &#125; evalscripts.push(id); var scriptNode = document.createElement(\"script\"); scriptNode.type = \"text/javascript\"; scriptNode.id = id; scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset); try &#123; if(src) &#123; scriptNode.src = src; scriptNode.onloadDone = false; scriptNode.onload = function () &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125;; scriptNode.onreadystatechange = function () &#123; if((scriptNode.readyState == 'loaded' || scriptNode.readyState == 'complete') &amp;&amp; !scriptNode.onloadDone) &#123; scriptNode.onloadDone = true; JSLOADED[src] = 1; &#125; &#125;; &#125; else if(text)&#123; scriptNode.text = text; &#125; document.getElementsByTagName('head')[0].appendChild(scriptNode); &#125; catch(e) &#123;&#125;&#125; 返回按ID检索的元素对象 123function $(id) &#123; return !id ? null : document.getElementById(id);&#125; 跨浏览器绑定事件 12345678910function addEventSamp(obj,evt,fn)&#123; if(!oTarget)&#123;return;&#125; if (obj.addEventListener) &#123; obj.addEventListener(evt, fn, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+evt,fn); &#125;else&#123; oTarget[\"on\" + sEvtType] = fn; &#125; &#125; 跨浏览器删除事件 12345678910function delEvt(obj,evt,fn)&#123; if(!obj)&#123;return;&#125; if(obj.addEventListener)&#123; obj.addEventListener(evt,fn,false); &#125;else if(oTarget.attachEvent)&#123; obj.attachEvent(\"on\" + evt,fn); &#125;else&#123; obj[\"on\" + evt] = fn; &#125;&#125; 为元素添加on方法 12345678Element.prototype.on = Element.prototype.addEventListener; NodeList.prototype.on = function (event, fn) &#123;、 []['forEach'].call(this, function (el) &#123; el.on(event, fn); &#125;); return this;&#125;; 为元素添加trigger方法 12345678910111213141516Element.prototype.trigger = function (type, data) &#123; var event = document.createEvent('HTMLEvents'); event.initEvent(type, true, true); event.data = data || &#123;&#125;; event.eventName = type; event.target = this; this.dispatchEvent(event); return this;&#125;; NodeList.prototype.trigger = function (event) &#123; []['forEach'].call(this, function (el) &#123; el['trigger'](event); &#125;); return this;&#125;; 检验URL链接是否有效 12345678910111213141516171819function getUrlState(URL)&#123; var xmlhttp = new ActiveXObject(\"microsoft.xmlhttp\"); xmlhttp.Open(\"GET\",URL, false); try&#123; xmlhttp.Send(); &#125;catch(e)&#123; &#125;finally&#123; var result = xmlhttp.responseText; if(result)&#123; if(xmlhttp.Status==200)&#123; return(true); &#125;else&#123; return(false); &#125; &#125;else&#123; return(false); &#125; &#125;&#125; 格式化CSS样式代码 123456789function formatCss(s)&#123;//格式化代码 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.replace(/\\,[\\s\\.\\#\\d]*&#123;/g, \"&#123;\"); s = s.replace(/([^\\s])\\&#123;([^\\s])/g, \"$1 &#123;\\n\\t$2\"); s = s.replace(/([^\\s])\\&#125;([^\\n]*)/g, \"$1\\n&#125;\\n$2\"); s = s.replace(/([^\\s]);([^\\s\\&#125;])/g, \"$1;\\n\\t$2\"); return s;&#125; 压缩CSS样式代码 12345678function compressCss (s) &#123;//压缩代码 s = s.replace(/\\/\\*(.|\\n)*?\\*\\//g, \"\"); //删除注释 s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, \"$1\"); s = s.replace(/\\,[\\s\\.\\#\\d]*\\&#123;/g, \"&#123;\"); //容错处理 s = s.replace(/;\\s*;/g, \";\"); //清除连续分号 s = s.match(/^\\s*(\\S+(\\s+\\S+)*)\\s*$/); //去掉首尾空白 return (s == null) ? \"\" : s[1];&#125; 获取当前路径 123456var currentPageUrl = \"\";if (typeof this.href === \"undefined\") &#123; currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123; currentPageUrl = this.href.toString().toLowerCase();&#125; 判断是否移动设备 1234567891011121314151617function isMobile()&#123; if (typeof this._isMobile === 'boolean')&#123; return this._isMobile; &#125; var screenWidth = this.getScreenWidth(); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport ||rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(!fixViewPortsExperiment)&#123; if(!this.isAppleMobileDevice())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; &#125; var isMobileScreenSize = screenWidth &lt; 600; var isMobileUserAgent = false; this._isMobile = isMobileScreenSize &amp;&amp; this.isTouchScreen(); return this._isMobile;&#125; 判断是否移动设备访问 123function isMobileUserAgent()&#123; return (/iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase()));&#125; 判断是否苹果移动设备访问 123function isAppleMobileDevice()&#123; return (/iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否安卓移动设备访问 123function isAndroidMobileDevice()&#123; return (/android/i.test(navigator.userAgent.toLowerCase()));&#125; 判断是否Touch屏幕 123function isTouchScreen()&#123; return (('ontouchstart' in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch);&#125; 判断是否打开视窗 123function isViewportOpen() &#123; return !!document.getElementById('wixMobileViewport');&#125; 获取移动设备初始化大小 12345678910function getInitZoom()&#123; if(!this._initZoom)&#123; var screenWidth = Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; this._initZoom = screenWidth /document.body.offsetWidth; &#125; return this._initZoom;&#125; 获取移动设备最大化大小 12345678910111213function getZoom()&#123; var screenWidth = (Math.abs(window.orientation) === 90) ? Math.max(screen.height, screen.width) : Math.min(screen.height, screen.width); if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; screenWidth = screenWidth/window.devicePixelRatio; &#125; var FixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var FixViewPortsExperimentRunning = FixViewPortsExperiment &amp;&amp; (FixViewPortsExperiment === \"New\" || FixViewPortsExperiment === \"new\"); if(FixViewPortsExperimentRunning)&#123; return screenWidth / window.innerWidth; &#125;else&#123; return screenWidth / document.body.offsetWidth; &#125;&#125; 获取移动设备屏幕宽度 1234567891011function getScreenWidth()&#123; var smallerSide = Math.min(screen.width, screen.height); var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport; var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === \"new\"); if(fixViewPortsExperiment)&#123; if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123; smallerSide = smallerSide/window.devicePixelRatio; &#125; &#125; return smallerSide;&#125; 完美判断是否为网址 12345678function IsURL(strUrl) &#123; var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i if (regular.test(strUrl)) &#123; return true; &#125;else &#123; return false; &#125;&#125; 获取页面高度 123456function getPageHeight()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125; 获取页面scrollLeft 1234function getPageScrollLeft()&#123; var a = document; return a.documentElement.scrollLeft || a.body.scrollLeft;&#125; 获取页面可视宽度 123456function getPageViewWidth()&#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientWidth;&#125; 获取页面宽度 123456function getPageWidth()&#123; var g = document, a = g.body, f = g.documentElement, d = g.compatMode == \"BackCompat\" ? a : g.documentElement; return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125; 获取页面scrollTop 1234function getPageScrollTop()&#123; var a = document; return a.documentElement.scrollTop || a.body.scrollTop;&#125; 获取页面可视高度 123456function getPageViewHeight() &#123; var d = document, a = d.compatMode == \"BackCompat\" ? d.body : d.documentElement; return a.clientHeight;&#125; 去掉url前缀 1234567function removeUrlPrefix(a)&#123; a=a.replace(/：/g,\":\").replace(/．/g,\".\").replace(/／/g,\"/\"); while(trim(a).toLowerCase().indexOf(\"http://\")==0)&#123; a=trim(a.replace(/http:\\/\\//i,\"\")); &#125; return a;&#125; 随机数时间戳 1234function uniqueId()&#123; var a=Math.random,b=parseInt; return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());&#125; 全角半角转换 1234567891011121314151617181920212223242526272829//iCase: 0全到半，1半到全，其他不转化function chgCase(sStr,iCase)&#123; if(typeof sStr != \"string\" || sStr.length &lt;= 0 || !(iCase === 0 || iCase == 1))&#123; return sStr; &#125; var i,oRs=[],iCode; if(iCase)&#123;/*半-&gt;全*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 32)&#123; iCode = 12288; &#125;else if(iCode &lt; 127)&#123; iCode += 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125;else&#123;/*全-&gt;半*/ for(i=0; i&lt;sStr.length;i+=1)&#123; iCode = sStr.charCodeAt(i); if(iCode == 12288)&#123; iCode = 32; &#125;else if(iCode &gt; 65280 &amp;&amp; iCode &lt; 65375)&#123; iCode -= 65248; &#125; oRs.push(String.fromCharCode(iCode)); &#125; &#125; return oRs.join(\"\"); &#125; 确认是否键盘有效输入值 12345678910function checkKey(iKey)&#123; if(iKey == 32 || iKey == 229)&#123;return true;&#125;/*空格和异常*/ if(iKey&gt;47 &amp;&amp; iKey &lt; 58)&#123;return true;&#125;/*数字*/ if(iKey&gt;64 &amp;&amp; iKey &lt; 91)&#123;return true;&#125;/*字母*/ if(iKey&gt;95 &amp;&amp; iKey &lt; 108)&#123;return true;&#125;/*数字键盘1*/ if(iKey&gt;108 &amp;&amp; iKey &lt; 112)&#123;return true;&#125;/*数字键盘2*/ if(iKey&gt;185 &amp;&amp; iKey &lt; 193)&#123;return true;&#125;/*符号1*/ if(iKey&gt;218 &amp;&amp; iKey &lt; 223)&#123;return true;&#125;/*符号2*/ return false;&#125; 日期格式化函数+调用方法 12345678910111213141516171819Date.prototype.format = function(format)&#123; var o = &#123; \"M+\" : this.getMonth()+1, //month \"d+\" : this.getDate(), //day \"h+\" : this.getHours(), //hour \"m+\" : this.getMinutes(), //minute \"s+\" : this.getSeconds(), //second \"q+\" : Math.floor((this.getMonth()+3)/3), //quarter \"S\" : this.getMilliseconds() //millisecond &#125;; if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(format)) format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] :(\"00\"+ o[k]).substr((\"\"+ o[k]).length)); &#125; return format;&#125;alert(new Date().format(\"yyyy-MM-dd hh:mm:ss\")); 常用的正则表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//正整数/^[0-9]*[1-9][0-9]*$/;//负整数/^-[0-9]*[1-9][0-9]*$/;//正浮点数/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/; //负浮点数/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/; //浮点数/^(-?\\d+)(\\.\\d+)?$/;//email地址/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;//url地址/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&apos;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$ //年/月/日（年-月-日、年.月.日）/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;//匹配中文字符/[\\u4e00-\\u9fa5]/;//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;//匹配空白行的正则表达式/\\n\\s*\\r/;//匹配中国邮政编码/[1-9]\\d&#123;5&#125;(?!\\d)/;//匹配身份证/\\d&#123;15&#125;|\\d&#123;18&#125;/;//匹配国内电话号码/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;//匹配IP地址/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;//匹配首尾空白字符的正则表达式/^\\s*|\\s*$/;//匹配HTML标记的正则表达式&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;//sql 语句^(select|drop|delete|create|update|insert).*$//提取信息中的网络链接(h|H)(r|R)(e|E)(f|F) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)? //提取信息中的邮件地址\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* //提取信息中的图片链接(s|S)(r|R)(c|C) *= *(&apos;|&quot;)?(\\w|\\\\|\\/|\\.)+(&apos;|&quot;| *|&gt;)? //提取信息中的 IP 地址(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)//取信息中的中国手机号码(86)*0*13\\d&#123;9&#125; //提取信息中的中国邮政编码[1-9]&#123;1&#125;(\\d+)&#123;5&#125; //提取信息中的浮点数（即小数）(-?\\d*)\\.?\\d+ //提取信息中的任何数字(-?\\d*)(\\.\\d+)?//电话区号^0\\d&#123;2,3&#125;$//腾讯 QQ 号^[1-9]*[1-9][0-9]*$ //帐号（字母开头，允许 5-16 字节，允许字母数字下划线）^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ //中文、英文、数字及下划线^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$ 返回顶部的通用方法 1234567891011121314151617181920function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = \"none\"; btn.onclick = function() &#123; btn.style.display = \"none\"; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': \"none\" &#125;&#125;;backTop('goTop'); 获得URL中GET参数值 1234567891011121314// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[\"t1\"], GET[\"t2\"], GET[\"t3\"]function get_get()&#123; querystr = window.location.href.split(\"?\") if(querystr[1])&#123; GETs = querystr[1].split(\"&amp;\"); GET = []; for(i=0;i&lt;GETs.length;i++)&#123; tmp_arr = GETs.split(\"=\") key=tmp_arr[0] GET[key] = tmp_arr[1] &#125; &#125; return querystr[1];&#125; 打开一个窗体通用方法 1234567891011121314151617181920function openWindow(url,windowName,width,height)&#123; var x = parseInt(screen.width / 2.0) - (width / 2.0); var y = parseInt(screen.height / 2.0) - (height / 2.0); var isMSIE= (navigator.appName == \"Microsoft Internet Explorer\"); if (isMSIE) &#123; var p = \"resizable=1,location=no,scrollbars=no,width=\"; p = p+width; p = p+\",height=\"; p = p+height; p = p+\",left=\"; p = p+x; p = p+\",top=\"; p = p+y; retval = window.open(url, windowName, p); &#125; else &#123; var win = window.open(url, \"ZyiisPopup\", \"top=\" + y + \",left=\" + x + \",scrollbars=\" + scrollbars + \",dialog=yes,modal=yes,width=\" + width + \",height=\" + height + \",resizable=no\" ); eval(\"try &#123; win.resizeTo(width, height); &#125; catch(e) &#123; &#125;\"); win.focus(); &#125;&#125; 提取页面代码中所有网址 12var aa = document.documentElement.outerHTML.match(/(url\\(|src=|href=)[\\\"\\']*([^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)[\\\"\\'\\)]*|(http:\\/\\/[\\w\\-\\.]+[^\\\"\\'\\(\\)\\&lt;\\&gt;\\[\\] ]+)/ig).join(\"\\r\\n\").replace(/^(src=|href=|url\\()[\\\"\\']*|[\\\"\\'\\&gt;\\) ]*$/igm,\"\");alert(aa); 清除相同的数组 12345678910String.prototype.unique=function()&#123; var x=this.split(/[\\r\\n]+/); var y=''; for(var i=0;i&lt;x.length;i++)&#123; if(!new RegExp(\"^\"+x.replace(/([^\\w])/ig,\"\\\\$1\")+\"$\",\"igm\").test(y))&#123; y+=x+\"\\r\\n\" &#125; &#125; return y&#125;; 按字母排序，对每行进行数组排序 12345function SetSort()&#123; var text=K1.value.split(/[\\r\\n]/).sort().join(\"\\r\\n\");//顺序 var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(\"\\r\\n\");//反序 K1.value=K1.value!=text?text:test;&#125; 清除html代码中的脚本 123456789101112function clear_script()&#123; K1.value=K1.value.replace(/&lt;script.*?&gt;[\\s\\S]*?&lt;\\/script&gt;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?\"[\\s\\S]*?\"|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?'[\\s\\S]*?'|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=[^ &gt;]+/ig,\"\");&#125;动态执行JavaScript脚本 function javascript()&#123; try&#123; eval(K1.value); &#125;catch(e)&#123; alert(e.message); &#125;&#125; 金额大写转换函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function transform(tranvalue) &#123; try &#123; var i = 1; var dw2 = new Array(\"\", \"万\", \"亿\"); //大单位 var dw1 = new Array(\"拾\", \"佰\", \"仟\"); //小单位 var dw = new Array(\"零\", \"壹\", \"贰\", \"叁\", \"肆\", \"伍\", \"陆\", \"柒\", \"捌\", \"玖\"); //整数部分用 //以下是小写转换成大写显示在合计大写的文本框中 //分离整数与小数 var source = splits(tranvalue); var num = source[0]; var dig = source[1]; //转换整数部分 var k1 = 0; //计小单位 var k2 = 0; //计大单位 var sum = 0; var str = \"\"; var len = source[0].length; //整数的长度 for (i = 1; i &lt;= len; i++) &#123; var n = source[0].charAt(len - i); //取得某个位数上的数字 var bn = 0; if (len - i - 1 &gt;= 0) &#123; bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字 &#125; sum = sum + Number(n); if (sum != 0) &#123; str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面 if (n == '0') sum = 0; &#125; if (len - i - 1 &gt;= 0) &#123; //在数字范围内 if (k1 != 3) &#123; //加小单位 if (bn != 0) &#123; str = dw1[k1].concat(str); &#125; k1++; &#125; else &#123; //不加小单位，加大单位 k1 = 0; var temp = str.charAt(0); if (temp == \"万\" || temp == \"亿\") //若大单位前没有数字则舍去大单位 str = str.substr(1, str.length - 1); str = dw2[k2].concat(str); sum = 0; &#125; &#125; if (k1 == 3)&#123; //小单位到千则大单位进一 k2++; &#125; &#125; //转换小数部分 var strdig = \"\"; if (dig != \"\") &#123; var n = dig.charAt(0); if (n != 0) &#123; strdig += dw[Number(n)] + \"角\"; //加数字 &#125; var n = dig.charAt(1); if (n != 0) &#123; strdig += dw[Number(n)] + \"分\"; //加数字 &#125; &#125; str += \"元\" + strdig; &#125; catch(e) &#123; return \"0元\"; &#125; return str;&#125;//拆分整数与小数function splits(tranvalue) &#123; var value = new Array('', ''); temp = tranvalue.split(\".\"); for (var i = 0; i &lt; temp.length; i++) &#123; value = temp; &#125; return value;&#125; 获取窗体可见范围的宽与高 1234567function getViewSize()&#123; var de=document.documentElement; var db=document.body; var viewW=de.clientWidth==0 ? db.clientWidth : de.clientWidth; var viewH=de.clientHeight==0 ? db.clientHeight : de.clientHeight; return Array(viewW ,viewH);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS 中的 call、apply、bind 方法","slug":"call-apply-bind","date":"2014-12-13T06:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/12/13/call-apply-bind/","link":"","permalink":"http://yoursite.com/2014/12/13/call-apply-bind/","excerpt":"call()、apply()、bind()都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用 一、方法定义 call方法 语法 1fun.call(thisArg[, arg1[, arg2[, ...]]]) thisArg：fun函数运行时指定的this值，可能的值为： 不传，或者传null，undefined， this指向window对象 传递另一个函数的函数名fun2，this指向函数fun2的引用值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean 传递一个对象，函数中的this指向这个对象","text":"call()、apply()、bind()都是函数对象的一个方法，它们的作用都是改变函数的调用对象。它的使用极大的简化了代码的调用 一、方法定义 call方法 语法 1fun.call(thisArg[, arg1[, arg2[, ...]]]) thisArg：fun函数运行时指定的this值，可能的值为： 不传，或者传null，undefined， this指向window对象 传递另一个函数的函数名fun2，this指向函数fun2的引用值为原始值(数字，字符串，布尔值),this会指向该原始值的自动包装对象，如 String、Number、Boolean 传递一个对象，函数中的this指向这个对象 apply方法 语法：apply([thisObj[,argArray]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明：apply的第一个参数thisObj和call方法的一样，第二个参数argArray为一个传参数组thisObj如果未传，那么 Global对象被用作 thisObj bind方法 在ECMAScript5中扩展了叫bind的方法（IE6,7,8不支持） 语法：bind([thisObj[,arg1[, arg2[, [,.argN]]]]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明：bind的thisObj参数也和call方法一样，thisObj如果未传，那么 Global对象被用作 thisObj。arg1 … argN可传可不传。如果不传，可以在调用的时候再传。如果传了，调用的时候则可以不传，调用的时候如果你还是传了，则不生效 12345678910111213var person = &#123; name:&quot;tsrot&quot;, age:24, sayHello:function(age)&#123; console.log(this.name); console.log(age); &#125; &#125;;var son = &#123; name:&quot;xieliqun&quot; &#125;;var boundFunc = person.sayHello.bind(son);boundFunc(25); 12var boundFunc = person.sayHello.bind(son,25);boundFunc(); 12var boundFunc = person.sayHello.bind(son,25);boundFunc(30); 二、call、apply、bind的区别 call的arg传参需一个一个传，apply则直接传一个数组 123456function hello(name,age)&#123; console.log(name); console.log(age); &#125;hello.call(this,&quot;tsrot&quot;,24);hello.apply(this,[&quot;tsrot&quot;,24]); call和apply直接执行函数，而bind需要再一次调用 1234567891011var obj = &#123; x: 81, &#125;;var foo = &#123; getX: function() &#123; return this.x; &#125; &#125;console.log(foo.getX.bind(obj)()); console.log(foo.getX.call(obj)); console.log(foo.getX.apply(obj)); 三、运用场景 实现继承 1234567891011function Animal(name) &#123; this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;function Cat(name) &#123; Animal.call(this, name); &#125;var cat = new Cat(&apos;Black Cat&apos;);cat.showName(); 数组追加 1234var array1 = [1 , 2 , 3, 5];var array2 = [&quot;xie&quot; , &quot;li&quot; , &quot;qun&quot; , &quot;tsrot&quot;];Array.prototype.push.apply(array1, array2);console.log(array1); 获取数组中的最大值和最小值 12345var num = [1,3,5,7,2,-10,11];var maxNum = Math.max.apply(Math, num);var minNum = Math.min.apply(Math, num);console.log(maxNum); console.log(minNum); 将伪数组转化为数组 1234567var fakeArr = &#123;0:&apos;a&apos;,1:&apos;b&apos;,length:2&#125;;var arr1 = Array.prototype.slice.call(fakeArr);console.log(arr1[0]); var arr2 = [].slice.call(fakeArr);console.log(arr2[0]); arr1.push(&quot;c&quot;);console.log(arr1); 保存this变量 1234567891011121314151617var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this ; $(&apos;.someClass&apos;).on(&apos;click&apos;,function(event) &#123; console.log(_this.bar); &#125;); &#125; &#125;var foo = &#123; bar : 1, eventBind: function()&#123; $(&apos;.someClass&apos;).on(&apos;click&apos;,function(event) &#123; console.log(this.bar); &#125;.bind(this)); &#125; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Ajax总结篇","slug":"Ajax-summary","date":"2014-11-26T06:35:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/11/26/Ajax-summary/","link":"","permalink":"http://yoursite.com/2014/11/26/Ajax-summary/","excerpt":"","text":"原文出处 http://blog.poetries.top/2016/11/26/Ajax-summary 本文主要总结整理Ajax的一些常用的基础知识，适合初学者。 一、Ajax简介、优劣势、应用场景以及技术 Ajax简介 : Asynchronous Javascript And XML （异步的JavaScript和XML） 它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体 AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 优点： 页面无刷新，用户体验好。 异步通信，更加快的响应能力。 减少冗余请求，减轻了服务器负担 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序 缺点： ajax干掉了back按钮，即对浏览器后退机制的破坏。 存在一定的安全问题。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。 无法用URL直接访问 ajax应用场景 场景 1. 数据验证 场景 2. 按需取数据 场景 3. 自动更新页面 AJAX 包含以下五个部分：ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 使用CSS和XHTML来表示。 使用DOM模型来交互和动态显示。 数据互换和操作技术，使用XML与XSLT 使用XMLHttpRequest来和服务器进行异步通信。 使用javascript来绑定和调用。 在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它 第一张图尤其说明了传统Web 应用程序的结构与采用了 AJAX 技术的 Web应用程序的结构上的差别 主要的差别，其实不是 JavaScript，不是 HTML/XHTML和 CSS，而是采用了 XMLHttpRequest 来向服务器异步的请求 XML 数据 再来看第二张图，传统的 Web 应用模式，用户的体验是割裂的，点击-&gt;等待-&gt;看到新的页面-&gt;再点击-&gt;再等待。而采用了AJAX技术之后，大部分的计算工作，都是在用户不察觉的情况下，交由服务器去完成了 XMLHttpRequest对象的属性 XMLHttpRequest对象的方法 二、创建ajax的步骤 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。原生创建ajax可分为以下四步 1、创建XMLHttpRequest对象 Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 创建 XMLHttpRequest对象的语法： 1var xhr = new XMLHttpRequest(); 老版本的 Internet Explorer（IE5 和 IE6）使用ActiveX 对象： 1var xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest对象。如果支持，则创建XMLHttpRequest对象。如果不支持，则创建ActiveXObject： 兼容各个浏览器的创建Ajax的工具函数 12345678910111213141516function createRequest ()&#123; try &#123; xhr = new XMLHttpRequest(); &#125;catch (tryMS)&#123; try &#123; xhr = new ActiveXObject(\"Msxm12.XMLHTTP\"); &#125; catch (otherMS) &#123; try &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;catch (failed) &#123; xhr = null; &#125; &#125; &#125; return xhr;&#125; 2、准备请求 初始化该XMLHttpRequest对象，接受三个参数： 1xhr.open(method,url,async); 第一个参数表示请求类型的字符串，其值可以是GET或者POST。 GET请求： 1xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true); POST请求： 1xhr.open(\"POST\",demo.php,true); 第二个参数是要作为请求发送目标的URL。 第三个参数是true或false，表示请求是以异步还是同步的模式发出。（默认为true，一般不建议为false） false：同步模式发出的请求会暂停所有javascript代码的执行，知道服务器获得响应为止，如果浏览器在连接网络时或者在下载文件时出了故障，页面就会一直挂起。 true：异步模式发出的请求，请求对象收发数据的同时，浏览器可以继续加载页面，执行其他javascript代码 3、发送请求 1xhr.send(); 一般情况下，使用Ajax提交的参数多是些简单的字符串，可以直接使用GET方法将要提交的参数写到open方法的url参数中，此时send方法的参数为null或为空。 GET请求： 12xhr.open(\"GET\",demo.php?name=tsrot&amp;age=24,true);xhr.send(null); POST请求：如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader()来添加 HTTP 头。然后在send()方法中规定您希望发送的数据： 123xhr.open(\"POST\",demo.php,true);xhr.setRequestHeder(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");xhr.sen 4、处理响应 12345xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125;&#125; onreadystatechange ：当处理过程发生变化的时候执行下面的函数 readyState ：ajax处理过程 0：请求未初始化（还没有调用 open()）。 1：请求已经建立，但是还没有发送（还没有调用 send()）。 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4：响应已完成；您可以获取并使用服务器的响应了。 status属性： 200:”OK” 404: 未找到页面 responseText：获得字符串形式的响应数据 responseXML：获得 XML形式的响应数据 对象转换为JSON格式使用JSON.stringify json转换为对象格式用JSON.parse() 返回值一般为json字符串，可以用JSON.parse(xhr.responseText)转化为JSON对象 从服务器传回的数据是json格式，这里做一个例子说明，如何利用 1、首先需要从XMLHttpRequest对象取回数据这是一个JSON串，把它转换为真正的JavaScript对象。使用JSON.parse(xhr.responseText)转化为JSON对象 2、遍历得到的数组，向DOM中添加新元素 123456789101112function example(responseText)&#123;var saleDiv= document.getElementById(\"sales\");var sales = JSON.parse(responseText); for(var i=0;i&lt;sales.length;i++)&#123; var sale = sales[i]; var div = document.createElement(\"div\"); div.setAttribute(\"class\",\"salseItem\"); div.innerHTML = sale.name + sale.sales; salseDiv.appendChild(div); &#125;&#125; HTTP状态码 5、封装例子 将AJAX请求封装成ajax()方法，它接受一个配置对象params 1234567891011121314151617181920function ajax(params) &#123; params = params || &#123;&#125;; params.data = params.data || &#123;&#125;; // 判断是ajax请求还是jsonp请求 var json = params.jsonp ? jsonp(params) : json(params); // ajax请求 function json(params) &#123; // 请求方式，默认是GET params.type = (params.type || 'GET').toUpperCase(); // 避免有特殊字符，必须格式化传输数据 params.data = formatParams(params.data); var xhr = null; // 实例化XMLHttpRequest对象 if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // IE6及其以下版本 xhr = new ActiveXObjcet('Microsoft.XMLHTTP'); &#125;; 使用实例： 123456789ajax(&#123; url: 'test.php', // 请求地址 type: 'POST', // 请求类型，默认\"GET\"，还可以是\"POST\" data: &#123;'b': '异步请求'&#125;, // 传输数据 success: function(res)&#123; // 请求成功的回调函数 console.log(JSON.parse(res)); &#125;, error: function(error) &#123;&#125; // 请求失败的回调函数&#125;); 这个过程是一定要记在脑子里的 12345678910111213141516171819function ajax(url, success, fail)&#123; // 1. 创建连接 var xhr = null; xhr = new XMLHttpRequest() // 2. 连接服务器 xhr.open('get', url, true) // 3. 发送请求 xhr.send(null); // 4. 接受请求 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success(xhr.responseText); &#125; else &#123; // fail fail &amp;&amp; fail(xhr.status); &#125; &#125; &#125;&#125; XMLHttpRequest 在异步请求远程数据时的工作流程 谈谈JSONP 要访问web服务器的数据除了XMLHttpRequest外还有一种方法是JSONP 如果HTML和JavaScript与数据同时在同一个机器上，就可以使用XMLHttpRequest 什么是JSONP？ JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式） JSONP有什么用？ 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求 如何使用JSONP？ 在客户端声明回调函数之后，客户端通过script标签向服务器跨域请求数据，然后服务端返回相应的数据并动态执行回调函数 用XMLHttpRequest时，我们得到一个字符串；要用JSON.parse把字符串转化成对象，使用jsonp时，script标志会解析并执行返回的代码，等我们处理数据时，已经是一个JavaScript对象了 简单实例 12345678910111213&lt;meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\" /&gt; &lt;script type=\"text/javascript\"&gt; function jsonpCallback(result) &#123; alert(result.a); alert(result.b); alert(result.c); for(var i in result) &#123; alert(i+\":\"+result[i]);//循环输出a:1,b:2,etc. &#125; &#125; &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"http://crossdomain.com/services.php?callback=jsonpCallback\"&gt;&lt;/script&gt; &lt;!--callback参数指示生成JavaScript代码时要使用的函数jsonpcallback--&gt; 注意浏览器的缓存问题 在末尾增加一个随机数可避免频繁请求同一个链接出现的缓存问题 ` 原生JavaScript实现完整的Ajax、JSONP例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function ajax(params) &#123; params = params || &#123;&#125;; params.data = params.data || &#123;&#125;; var json = params.jsonp ? jsonp(params) : json(params); // ajax请求 function json(params) &#123; params.type = (params.type || 'GET').toUpperCase(); params.data = formatParams(params.data); var xhr = null; // 实例化XMLHttpRequest对象 if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // IE6及其以下版本 xhr = new ActiveXObjcet('Microsoft.XMLHTTP'); &#125;; // 监听事件 xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4) &#123; var status = xhr.status; if(status &gt;= 200 &amp;&amp; status &lt; 300) &#123; var response = ''; var type = xhr.getResponseHeader('Content-type'); if(type.indexOf('xml') !== -1 &amp;&amp; xhr.responseXML) &#123; response = xhr.responseXML; //Document对象响应 &#125; else if(type === 'application/json') &#123; response = JSON.parse(xhr.responseText); //JSON响应 &#125; else &#123; response = xhr.responseText; //字符串响应 &#125;; params.success &amp;&amp; params.success(response); &#125; else &#123; params.error &amp;&amp; params.error(status); &#125; &#125; &#125;; // 连接和传输数据 if(params.type == 'GET') &#123; xhr.open(params.type, params.url + '?' + params.data, true); xhr.send(null); &#125; else &#123; xhr.open(params.type, params.url, true); //设置提交时的内容类型 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8'); xhr.send(params.data); &#125; &#125; // jsonp请求 function jsonp(params) &#123; //创建script标签并加入到页面中 var callbackName = params.jsonp; var head = document.getElementsByTagName('head')[0]; // 设置传递给后台的回调参数名 params.data['callback'] = callbackName; var data = formatParams(params.data); var script = document.createElement('script'); head.appendChild(script); //创建jsonp回调函数 window[callbackName] = function(json) &#123; head.removeChild(script); clearTimeout(script.timer); window[callbackName] = null; params.success &amp;&amp; params.success(json); &#125;; //发送请求 script.src = params.url + '?' + data; //超时处理 if(params.time) &#123; script.timer = setTimeout(function() &#123; window[callbackName] = null; head.removeChild(script); params.error &amp;&amp; params.error(&#123; message: '超时' &#125;); &#125;, time); &#125; &#125;; //格式化参数 function formatParams(data) &#123; var arr = []; for(var name in data) &#123; arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name])); &#125;; // 添加一个随机数，防止缓存 arr.push('v=' + random()); return arr.join('&amp;'); &#125; // 获取随机数 function random() &#123; return Math.floor(Math.random() * 10000 + 500); &#125;&#125; 使用 12345678910111213141516171819202122232425262728ajax(&#123; url: 'get.php', type: 'GET', data: &#123;'intro': 'get请求'&#125;, success:function(res)&#123; res = JSON.parse(res); document.getElementById('a').innerHTML = res.intro; console.log(res); &#125; &#125;); ajax(&#123; url: 'post.php', type: 'POST', data: &#123;'intro': 'post请求'&#125;, success:function(res)&#123; res = JSON.parse(res); document.getElementById('b').innerHTML = res.intro; console.log(res); &#125; &#125;); ajax(&#123; url: 'http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js', jsonp: 'jsonpCallback', data: &#123;'callback': 'jsonpCallback'&#125;, success:function(res)&#123; JsonCallback(json); &#125; &#125;); 下面我们就根据以上 封装的例子跨域获取qq音乐的数据 在线演示–跨域获取qq音乐的数据 下面的方法也可以实现 使用jQuery实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script src=\"jquery-3.1.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $.ajax(&#123; type: \"get\", async: false, url: \"http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js\", dataType: \"jsonp\", jsonp: \"callback\", jsonpCallback: \"JsonCallback\", scriptCharset: 'GBK',//设置编码，否则会乱码 success: function(data) &#123; //var result = JSON.stringify(data); JsonCallback(data); &#125;, error: function() &#123; alert('fail'); &#125; &#125;); function JsonCallback(json)&#123; var data = json.songlist; var html = ''; for (var i=0;i&lt;data.length;i++) &#123; document.write(data[i].url+\"&lt;br&gt;\"); &#125; &#125; &lt;/script&gt;``` - 原生js简洁实现```javascriptvar script = document.createElement(\"script\"); script.src = 'http://music.qq.com/musicbox/shop/v3/data/hit/hit_all.js?callback=JsonCallback'; document.body.appendChild(script); function JsonCallback(json)&#123; var data = json.songlist; var html = ''; for (var i=0;i&lt;data.length;i++) &#123; console.log(data[i]); &#125; &#125; 三、 jQuery中的Ajax jQuery中的ajax封装案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//ajax请求后台数据var btn = document.getElementsByTagName(\"input\")[0];btn.onclick = function()&#123; ajax(&#123;//json格式 type:\"post\", url:\"post.php\", data:\"username=poetries&amp;pwd=123456\", asyn:true, success:function(data)&#123; document.write(data); &#125; &#125;);&#125;//封装ajaxfunction ajax(aJson)&#123; var ajx = null; var type = aJson.type || \"get\"; var asyn = aJson.asyn || true; var url = aJson.url; // url 接收 传输位置 var success = aJson.success;// success 接收 传输完成后的回调函数 var data = aJson.data || '';// data 接收需要附带传输的数据 if(window.XMLHttpRequest)&#123;//兼容处理 ajx = new XMLHttpRequest();//一般浏览器 &#125;else &#123; ajx = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE6+ &#125; if (type == \"get\" &amp;&amp; data) &#123; url +=\"/?\"+data+\"&amp;\"+Math.random(); &#125; //初始化ajax请求 ajx.open( type , url , asyn ); //规定传输数据的格式 ajx.setRequestHeader('content-type','application/x-www-form-urlencoded'); //发送ajax请求（包括post数据的传输） type == \"get\" ?ajx.send():ajx.send(aJson.data); //处理请求 ajx.onreadystatechange = function(aJson)&#123; if(ajx.readState == 4)&#123; if (ajx.status == 200 &amp;&amp; ajx.status&lt;300)//200是HTTP 请求成功的状态码 &#123; //请求成功处理数据 success &amp;&amp; success(ajx.responseText); &#125;else&#123; alert(\"请求出错\"+ajx.status); &#125; &#125; &#125; jQuery中的Ajax的一些方法 jquery对Ajax操作进行了封装，在jquery中的$.ajax()方法属于最底层的方法，第2层是load()、$.get()、$.post();第3层是$.getScript()、$.getJSON()，第2层使用频率很高 load()方法 load()方法是jquery中最简单和常用的ajax方法，能载入远程HTML代码并插入DOM中 结构为：load(url,[data],[callback]) 使用url参数指定选择符可以加载页面内的某些元素 load方法中url语法：url selector 注意：url和选择器之间有一个空格 传递方式 load()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，采用POST 回调参数 必须在加载完成后才执行的操作，该函数有三个参数 分别代表请求返回的内容、请求状态、XMLHttpRequest对象 只要请求完成，回调函数就会被触发 12345$(\"#testTest\").load(\"test.html\",function(responseText,textStatus,XMLHttpRequest)&#123; //respnoseText 请求返回的内容 //textStatus 请求状态 ：sucess、error、notmodified、timeout //XMLHttpRequest &#125;) load方法参数 参数名称 类型 说明 url String 请求HTML页面的URL地址 data(可选) Object 发送至服务器的key / value数据 callback(可选) Function 请求完成时的回调函数，无论是请求成功还是失败 $.get()和$.post()方法 load()方法通常用来从web服务器上获取静态的数据文件。在项目中需要传递一些参数给服务器中的页面，那么可以使用$.get()和$.post()或$.ajax()方法 注意：$.get()和$.post()方法是jquery中的全局函数 $.get()方法 $.get()方法使用GET方式来进行异步请求 结构为：$.get(url,[data],callback,type) 如果服务器返回的内容格式是xml文档，需要在服务器端设置Content-Type类型 代码如下：header(&quot;Content-Type:text/xml:charset=utf-8&quot;) //php $.get()方法参数解析 参数 类型 说明 url String 请求HTML页的地址 data(可选) Object 发送至服务器的key/ value 数据会作为QueryString附加到请求URL中 callback(可选) Function 载入成功的回调函数（只有当Response的返回状态是success才调用该方法） type(可选) String 服务器返回内容的格式，包括xml、html、script、json、text和_default $.post()方法 它与$.get()方法的结构和使用方式相同，有如下区别 GET请求会将参数跟张乃URL后进行传递，而POST请求则是作为Http消息的实体内容发送给web服务器，在ajax请求中，这种区别对用户不可见 GET方式对传输数据有大小限制（通常不能大于2KB），而使用POST方式传递的数据量要比GET方式大得多（理论不受限制） GET方式请求的数据会被浏览器缓存起来，因此其他人可以从浏览器的历史纪录中读取这些数据，如：账号、密码。在某种情况下，GET方式会带来严重的安全问题，而POST相对来说可以避免这些问题 GET和POST方式传递的数据在服务端的获取也不相同。在PHP中，GET方式用$_GET[]获取；POST方式用$_POST[]获取;两种方式都可用$_REQUEST[]来获取 总结 使用load()、$.get()和$.post()方法完成了一些常规的Ajax程序，如果还需要复杂的Ajax程序，就需要用到$.ajax()方式 $.ajax()方法 $.ajax()方法是jquery最底层的Ajax实现，它的结构为$.ajax(options) 该方法只有一个参数，但在这个对象里包含了$.ajax()方式所需要的请求设置以及回调函等信息，参数以key / value存在，所有参数都是可选的 $.ajax()方式常用参数解析 参数 类型 说明 url String (默认为当前页地址)发送请求的地址 type String 请求方式（POST或GET）默认为GET timeout Number 设置请求超时时间（毫秒） dataType String 预期服务器返回的类型。可用的类型如下 xml:返回XML文档，可用jquery处理html:返回纯文本的HTML信息，包含的script标签也会在插入DOM时执行script：返回纯文本的javascript代码。不会自动缓存结果，除非设置cache参数。注意：在远程请求时，所有的POST请求都将转为GET请求json:返回JSON数据jsonp:JSONP格式，使用jsonp形式调用函数时，例如：myurl?call back=?,jquery将自动替换后一个？为正确的函数名，以执行回调函数text:返回纯文本字符串 beforeSend Function 发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次Ajax请求。XMLHttpRequest对象是唯一的参数 function(XMLHttpRequest){ this;//调用本次Ajax请求时传递的options参数} complete Function 请求完成后的回调函数（请求成功或失败时都调用） 参数：XMLHttpRequest对象和一个描述成功请求类型的字符串function(XMLHttpRequest,textStatus){ this;//调用本次Ajax请求时传递的options参数} success Function 请求成功后调用的回调函数，有两个参数(1)由服务器返回，并根据dataTyppe参数进行处理后的数据(2)描述状态的字符串function(data,textStatus){ //data可能是xmlDoc、`jsonObj、html、text等&lt;br&gt;this;//调用本次Ajax请求时传递的options`参数} error Function 请求失败时被调用的函数 global Boolean 默认为true。表示是否触发全局Ajax事件，设置为false将不会触发。AjaxStart或AjaxStop可用于控制各种Ajax事件 参考 锋利的jQuery","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"居中解决方案荟萃","slug":"CSS-center-methods","date":"2014-11-12T09:55:24.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/11/12/CSS-center-methods/","link":"","permalink":"http://yoursite.com/2014/11/12/CSS-center-methods/","excerpt":"水平居中方案 方案一：text-align + inline-block 123&lt;div id=\"parent1\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 12345678910#parent1&#123; text-align: center; background:#ddd; margin-bottom:20px;&#125;#parent1 .child&#123; display: inline-block; background:#666; color:#fff;&#125;","text":"水平居中方案 方案一：text-align + inline-block 123&lt;div id=\"parent1\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 12345678910#parent1&#123; text-align: center; background:#ddd; margin-bottom:20px;&#125;#parent1 .child&#123; display: inline-block; background:#666; color:#fff;&#125; 方案二：margin：0 auto 123&lt;div id=\"parent2\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 1234567891011#parent2&#123; text-align: center; background:#ddd; margin-bottom:20px;&#125;#parent2 .child&#123; display: table; margin: 0 auto; background:#666; color:#fff;&#125; 方案三：absolute+transform) 123&lt;div id=\"parent3\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 123456789101112#parent3&#123; position: relative; background:#ddd; margin-bottom:20px;&#125;#parent3 .child&#123; position: absolute; left: 50%; transform: translateX(-50%); background:#666; color:#fff;&#125; 方案四：justify-content 123&lt;div id=\"parent4\"&gt; &lt;div class=\"child\"&gt;水平居中&lt;/div&gt;&lt;/div&gt; 1234567891011#parent4&#123; display: flex; justify-content: center; background:#ddd; margin-bottom:20px;&#125;#parent4 .child&#123; margin:0 auto; background:#666; color:#fff;&#125; 垂直居中方案 方案一： 利用 line-height 实现垂直居中 这种方法适用于单行文本垂直居中,如果文本内容太长，出现了换行，换行后的内容会溢出 123&lt;div id=\"example1\"&gt; 单行文字垂直居中&lt;/div&gt; 1234567#example1 &#123; height: 100px; line-height: 100px; background: #161616; color: #fff; width: 200px;&#125; 方案二 利用 display: table 实现垂直居中 123&lt;div id=\"example2\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415#example2 &#123; height: 100px; background: #161616; color: #fff; width: 400px; overflow: hidden; display: table; margin-bottom:20px;&#125;#example2 .inner&#123; display: table-cell; vertical-align: middle; height: 50px; background:#999;&#125; 方案三 margin 填充 这种方法需要知道内外容器的大小 123&lt;div id=\"example3\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415#example3 &#123; height: 100px; background: #161616; color: #fff; width: 400px; overflow: hidden; margin-bottom:20px;&#125;#example3 .inner&#123; margin-left: auto; margin-right: auto; margin-top: calc((100px - 50px)/2); height: 50px; background:#999;&#125; 方案四：经典 absolute 布局上下文垂直居中 123&lt;div id=\"example4\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718#example4 &#123; width: 400px; height: 100px; background: #161616; color: #fff; position: relative; margin-bottom:20px;&#125;#example4 .inner&#123; height: 50px; width: 200px; position: absolute; left: 50%; top: 50%; margin-top: -25px; margin-left: -100px; background:#999;&#125; 方案五：absolute+transform 123&lt;div id=\"example5\"&gt; &lt;div class=\"inner\"&gt;块区域垂直居中&lt;/div&gt;&lt;/div&gt; 123456789101112131415#example5 &#123; width: 400px; height: 100px; background: #161616; color: #fff; position: relative; margin-bottom:20px;&#125;#example5 .inner&#123; position: absolute; left: 50%; top: 50%; background: #999; transform: translateX(-50%) translateY(-50%);&#125; 方案六 利用margin：auto 居中 123&lt;div id=\"expample6\"&gt; &lt;div class=\"inner\"&gt;Content here&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920#expample6 &#123; width: 400px; height: 100px; background: #eee; position: relative; margin-bottom:20px;&#125;#expample6 .inner &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; height: 50px; width: 70%; background: #aaa; color:#222;&#125; 方案七 利用 Flex布局 居中 123&lt;div id=\"expample7\"&gt; &lt;div class=\"inner\"&gt;Content here&lt;/div&gt;&lt;/div&gt; 123456789101112131415#expample7 &#123; width: 400px; height: 100px; background: #eee; display: flex; justify-content: center; align-items: center;&#125;#expample7 .inner &#123; height: 50px; width: 70%; background: #aaa; color:#222;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"http://yoursite.com/tags/居中/"}]},{"title":"javascript笔记总结篇","slug":"javascript笔记基础总结篇","date":"2014-09-24T02:33:00.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/09/24/javascript笔记基础总结篇/","link":"","permalink":"http://yoursite.com/2014/09/24/javascript笔记基础总结篇/","excerpt":"转载请声明出处 博客原文 随手翻阅以前的学习笔记，顺便整理一下放在这里，方便自己复习，也希望你有也有帮助吧 第一课时 入门基础 知识点： 操作系统就是个应用程序 只要是应用程序都要占用物理内存 浏览器本身也是一个应用程序 浏览器本身只懂得解析HTML 调用浏览器这个应用程序的一个功能绘制","text":"转载请声明出处 博客原文 随手翻阅以前的学习笔记，顺便整理一下放在这里，方便自己复习，也希望你有也有帮助吧 第一课时 入门基础 知识点： 操作系统就是个应用程序 只要是应用程序都要占用物理内存 浏览器本身也是一个应用程序 浏览器本身只懂得解析HTML 调用浏览器这个应用程序的一个功能绘制 1、javascript介绍 JavaScript操作DOM的本质是=获取+触发+改变 目的：就是用来操作内存中的DOM节点 修改DOM节点的属性 过javascript语法组织逻辑代码操作DOM BOM(window)它包含了DOM DOM(document) script脚本推荐放在最下边好处：防止因网络问题，页面加载时间长，出现空白；即便网络问题，浏览器也把DOM加载渲染完成，等待从服务端下载完js脚本，出现效果 css不放在最下面原因通俗地讲：好比先穿好衣服在出去，浏览器先把css样式准备好，在加载结构层，使得页面有样子；如果放在下面，因为页面是从上往下加载，没有css，就剩下裸露的标签，很难看，使得用户体验不好 2、基于对象的内存管理 javascript就是来操作这些对象 通过逻辑组织对象之间的关系和行为 如何操作这些对象？通过变量引用 3、变量 变量本质是一个空盒子，里面记录了一个内存地址，使能找到内存中的对象，保存了指向具体的实在的东西的地址 变量存在栈中，对象存在堆中 变量的意义：方便我们去操作对象 变量的几种引用方式 指针（C语言中叫法） 引用（Java） 变量 例如： var b = document.body 含义：把body这个对象在内存中的地址放到b变量里面，变量b（b是内存地址的别名）本身也存在内存中，以后的操作是针对body这个地址 变量命名规范 由字母(a-zA-Z)数字(0-9)下划线(_)以及美元符号($) 不能由数字开头 命名尽量用英文并且具有一定的含义 如果有多个英文单词,后面单词的首字母大写 不能使用关键字 首字母不要大写，大写是有特殊含义的 DOM在内存中的一些图示 DOM Tree DOM内存图 DOM内存图 DOM内存图 第二课时 回顾上节： 1、javascript介绍 2、基于对象的内存管理 javascript就是来操作这些对象 通过逻辑组织对象之间的关系和行为 如何操作这些对象？通过变量引用 3、变量 知识点： 1、window作用域 只要在script标签中定义的变量，默认就在window的作用域之下 默认就是window这个对象里面写代码 2、数据类型 如何判断js中的数据类型： typeof、instanceof、 constructor、 prototype方法比较 如何判断js中的类型呢，先举几个例子： 123456var a = \"iamstring.\";var b = 222;var c= [1,2,3];var d = new Date();var e = function()&#123;alert(111);&#125;;var f = function()&#123;this.name=\"22\";&#125;; 最常见的判断方法：typeof 123456alert(typeof a) ------------&gt; stringalert(typeof b) ------------&gt; numberalert(typeof c) ------------&gt; objectalert(typeof d) ------------&gt; objectalert(typeof e) ------------&gt; functionalert(typeof f) ------------&gt; function 其中typeof返回的类型都是字符串形式，需注意，例如： 12alert(typeof a == \"string\") -------------&gt; truealert(typeof a == String) ---------------&gt; false 另外typeof可以判断function的类型；在判断除Object类型的对象时比较方便。 判断已知对象类型的方法：instanceof 1234alert(c instanceof Array) ---------------&gt; truealert(d instanceof Date) alert(f instanceof Function) ------------&gt; truealert(f instanceof function) ------------&gt; false 注意：instanceof后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。 根据对象的constructor判断：constructor 123alert(c.constructor === Array) ----------&gt; truealert(d.constructor === Date) -----------&gt; truealert(e.constructor === Function) -------&gt; true 注意： constructor 在类继承时会出错 例子： 123456function A()&#123;&#125;;function B()&#123;&#125;;A.prototype = new B(); //A继承自Bvar aObj = new A();alert(aobj.constructor === B) -----------&gt; true;alert(aobj.constructor === A) -----------&gt; false; 而instanceof方法不会出现该问题，对象直接继承和间接继承的都会报true： 12alert(aobj instanceof B) ----------------&gt; true;alert(aobj instanceof B) ----------------&gt; true; 言归正传，解决construtor的问题通常是让对象的constructor手动指向自己： 123aobj.constructor = A; //将自己的类赋值给对象的constructor属性alert(aobj.constructor === A) -----------&gt; true;alert(aobj.constructor === B) -----------&gt; false; //基类不会报true了; 通用但很繁琐的方法： prototype 123456alert(Object.prototype.toString.call(a) === ‘[object String]’) -------&gt; true;alert(Object.prototype.toString.call(b) === ‘[object Number]’) -------&gt; true;alert(Object.prototype.toString.call(c) === ‘[object Array]’) -------&gt; true;alert(Object.prototype.toString.call(d) === ‘[object Date]’) -------&gt; true;alert(Object.prototype.toString.call(e) === ‘[object Function]’) -------&gt; true;alert(Object.prototype.toString.call(f) === ‘[object Function]’) -------&gt; true; 大小写不能写错，比较麻烦，但胜在通用。 通常情况下用typeof判断就可以了，遇到预知Object类型的情况可以选用instanceof或constructor方法 Javascript的数据类型有六种（ES6新增了第七种Symbol） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示 未定义 或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合 通常，我们将数值、字符串、布尔值称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值 内存中一共分为几种对象： 变量 DOM对象 常量 自定义对象 数据类型转换 转换函数 toString() 转换为字符串，在JavaScript中所有数据类型都可以转换为string类型 12345678910var n1 = 12;var n2 = true;var a = [1, 2, 3];var o = &#123;&#125;;function f()&#123;&#125;n1.toString(); //\"12\"n2.toString(); //\"true\"a.toString(); //\"1,2,3\"o.toString(); //\"[object Object]\"f.toString(); //\"function f()&#123;&#125;\" parseInt()解析出一个string或者number类型的整数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"12\";var n2 = \"23hello\";var n3 = \"hello\";parseInt(n1); //12parseInt(n2); //23parseInt(n3); //NaN parseFloat()解析出一个string的浮点数部分，如果没有可以转换的部分，则返回NaN（not a number） 123456var n1 = \"1.2.3\";var n2 = \"1.2hello\"var n3 = \"hello\"parseFloat(n1); //1.2parseFloat(n2); //1.2parseFloat(n3); //NaN 强制类型转换 Boolean(value)- 把给定的值转换成Boolean型 123456Boolean(123); //trueBoolean(\"\"); //falseBoolean([]); //trueBoolean(&#123;&#125;); //trueBoolean(null); //falseBoolean(undefined); //false Number(value)-把给定的值转换成数字（可以是整数或浮点数） 12345678Number(\"123\"); //123Number(\"123h\"); //NaNNumber(true); //1Number(false); //0Number(undefined); //NaNNumber(null); //0Number([]); //0Number(&#123;&#125;); //NaN String(value)- 把给定的值转换成字符串 12345String(123); //\"123\"String([1,2]); //\"1,2\"String(undefined) //\"undefined\"String(null) //\"null\"String(&#123;&#125;) //\"[object Object]\" 隐式转换 数字＋字符串：数字转换为字符串 console.log(12+&quot;12&quot;); //1212 数字＋布尔值：true转换为1，false转换为0 console.log(12+true); //13 字符串＋布尔值：布尔值转换为true或false console.log(&quot;hello&quot;+true); //hellotrue 布尔值＋布尔值 console.log(true+true); //2 null和undefined undefined 表示一种未知状态，声明了但没有初始化的变量，变量的值时一个未知状态。访问不存在的属性或对象window.xxx）方法没有明确返回值时，返回值是一个undefined.当对未声明的变量应用typeof运算符时，显示为undefined。 null表示尚未存在的对象,null是一个有特殊意义的值。可以为变量赋值为null，此时变量的值为“已知状态”(不是undefined)，即null。（用来初始化变量，清除变量内容，释放内存） 12undefined==null //结果为true,但含义不同。undefined===null //false,两者类型不一致，前者为“undefined”，后者为“object” 3、javascript脚本执行顺序 第一步定义： 分为var定义 和函数定义function 第二步执行： 其他所有 先从上往下定义完所有的后，再从上往下执行 除了var function定义外的 其他都是执行 如：赋值 函数调用 在栈里面找到的，就不去堆里面找，因为栈空间小，就近原则【总之：先在栈里面找，找不到再去堆里面找】在栈里面开辟，就能找到堆里面的地址 如：var b = function(){} 总结一下==运算的规则：(隐式转换) JS中的值有两种类型：原始类型(Primitive)、对象类型(Object)。 原始类型包括：Undefined、Null、Boolean、Number和String等五种。 Undefined类型和Null类型的都只有一个值，即undefined和null；Boolean类型有两个值：true和false；Number类型的值有很多很多；String类型的值理论上有无数个。 所有对象都有valueOf()和toString()方法，它们继承自Object，当然也可能被子类重写 undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。 String == Boolean，需要两个操作数同时转为Number。 String/Boolean == Number，需要String/Boolean转为Number。 Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法) 第三课时 上节回顾： 1、window作用域 只要在script标签中定义的变量，默认就在window的作用域之下 默认就是window这个对象里面写代码 2、数据类型 number:数字 string:字符类型，必须用引号引起来 boolean:布尔类型 true false null:变量引用了一块堆中一个空的空间 object:引用对象类型（存在于堆里面） array:数组类型 function:函数数据类型 对象数据类型： object,array,function 3、javascript脚本执行顺序 定义 var function 执行 其他所有 知识点： 1、运算符 算术运算符(+,-,*,/,%,++,--) 如果引用所指的地方是null的话，那么在运算中就会自动变成0 %运算符 如：4%5取模 模是4 7%5取模 模是7-5=2 字符串和数字相加的情况： 左右都是数字：数字相加 左右有一个字符串：字符串拼接 左右边有一个null:null看做0 左右边有一个undefined：结果是NAN（not is number） 赋值运算符(=,-=,+=,*=,/=,%=) 比较运算符(==,===,!=,&gt;,&lt;,&gt;=,&lt;=) 先执行表达式计算再赋值 ==和!=在比较之前首先让双方的值做隐士类型转换，===不转换 逻辑运算符(||,&amp;&amp;,!) || 在js中和PHP中是不一样的 js中返回逻辑或的左边或右边的一个结果 PHP返回||或出来以后的结果即：true false 特殊性（注意）—一定要记住（这个特性和其他编程语言不一样）：在js里返回不是布尔值 || 短路运算 第一个条件为真 后面不执行 &amp;&amp;把表达式最后一个值返回（注意这里） 条件运符(表达式1?表达式2:表达式3)三元运算符 表达式1?表达式2:表达式3 表达式1为真 返回表达式2 否则返回表达式3 三元运算符 可以多层次嵌套使用 2、在js中 有四种被认为是非： undefined null false 0 例子：var age = prompt(&quot;温馨提示：&quot;,&quot;请输入您的年龄&quot;)||0 当点击取消的时候，如果出现undefined null fasle 0 表示非的逻辑 那么||就会过滤，取右边的值0 第四课时 上节回顾： 1、运算符 算术运算符(+,-,*,/,%,++,--) 如果+号左边和右边有一边是字符串类型的数据的话，这个时候就变成字符串拼接 var str = &quot;你好&quot;+123;//你好123 var count = 2; var str1 = &quot;你叫了我第&quot;-count+&quot;次&quot;;//你叫了我第2次 如果引用所指的地方是null的话，那么在运算中就会自动变成0 2、赋值运算符*(=,-=,+=,`=,/=,%=`) 3、 比较运算符(==,===,!=,&gt;,&lt;,&gt;=,&lt;=) 先执行表达式计算再赋值 ==和!=在比较之前首先让双方的值做隐士类型转换，===不转换 4、逻辑运算符(||,&amp;&amp;,!) 5、条件运算符(1&gt;2?3:4) 知识点： 1、console.log调试程序 开发中大量使用这个 而不用alert 2、条件结构 if javascript中if语句优化写法 使用常见的三元操作符 123if (foo) bar(); else baz(); ==&gt; foo?bar():baz();if (!foo) bar(); else baz(); ==&gt; foo?baz():bar();if (foo) return bar(); else return baz(); ==&gt; return foo?bar():baz(); 使用and(&amp;&amp;)和or(||)运算符 12if (foo) bar(); ==&gt; foo&amp;&amp;bar();if (!foo) bar(); ==&gt; foo||bar(); if...else if...else if...else 当通过判断返回某个值的时候，优先使用三元表达式 当通过判断执行N段逻辑代码的时候，只能用条件结构 第五课时 上节回顾： 1、console.log调试程序 2、条件结构 if if...else if...else if...else 当通过判断返回某个值的时候，优先使用三元表达式 当通过判断执行N段逻辑代码的时候，只能用条件结构 知识点： 1、switch switch case break default 条件 判断 退出 默认 a.只要匹配上一个case，那么它下面的所有的case都会执行包括default b.break的意思跳出当前结构 2、for 循环有三个要素 a.循环变量 b.判断（循环体） c.改变循环变量 d.continue的意思结束本次循环进入下次循环 continue 结束本次循环，继续下一次循环 当前这次循环不做 直接做下面的 break 结束后面的循环不做了 第六课时 上节回顾： 1、switch switch case break default 条件 判断 退出 默认 a.只要匹配上一个case，那么它下面的所有的case都会执行包括default b.break的意思跳出当前结构 2、for 循环有三个要素 a.循环变量 b.判断条件（循环体） c.改变循环变量 d.continue的意思结束本次循环进入下次循环 知识点： 1、while/do...while 没有谁好谁坏 只有适应场景不同 比如：先吃饭 在买单 do..while 用户体验高 有风险 扫雷游戏也是先体验 在问是否退出 提高体验 比如：先买单 在吃饭 while 用户体验不高 一般情况下面，如果条件判断是数字的比较==&lt;&gt;，for循环优先. 如果是非数值相关的比较循环，while优先 2、代码内存解析 闭包 a.程序永远是先定义后执行 b.执行永远从上到下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 闭包 作用域 记住：先定义var function 在从上往下执行 定义定义在自己的栈里面 执行在自己的堆里面 运行在运行的环境中 函数每调用前 只是一个地址 只要调用一次函数就会动态开辟一块内存 创建一个封闭的空间 在自己的封闭的空间的栈中定义var在执行 函数执行完 里面的东西全部销毁 12345678910111213//alert(x);//9:执行弹出x,结果x没定义,错误.alert(i);//9:执行弹出i,然而i之前已经定义,只不过没地址,因此是undefiendvar i = 10;//1:var i; 10:把常量池中10的地址赋给栈中的ivar j = \"你好\";//2:var j; 11:把常量池中 你好 的地址复给栈中的jvar k = z = null;//3:var k,z; 12:把堆中null的地址赋值给z和kvar m = function()&#123;//4:var m; 5:function匿名函数 13:把匿名函数在堆中的地址赋给栈中的m alert(2);&#125;var b = document.body;//6:var b; 14:把堆中document.body对象的地址赋给栈中的bvar f = true;//7:var f; 15:把常量池中true的地址赋给栈中的变量ffunction m()&#123;//8:function m; alert(1);&#125; 12345678910function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); //var c;&#125;var c = 150; // 函数m()还未执行到 还没被销毁 此时全局c的值c=50m();var c = 20;//到这里一步 m()已经执行完了 函数已经销毁了 这里的c还是20alert(c);//20 1234567891011121314function m()&#123; c = 50;//在局部变量中找不到定义的c 沿着作用域链找到了全局变量的c alert('哈哈哈'); function inner()&#123; c = 30; alert('嘻嘻'); &#125; inner();//c在函数内部找不到定义 所以沿着作用域链找到了全局的c&#125;var c = 20;//到这里一步 m()还没执行 函数没被销毁 这里的c是30m();alert(c);//30 4、object对象 5、面向对象的程序设计 a.function构造器 b.prototype原型 c.foreach c.作用域 d.继承 一些内存图示 闭包示例1 闭包示例2 闭包1 闭包2 闭包3 原型链的几张图解 原型链图解 js原型链演示00-new Object js原型链演示01-函数Foo声明 js原型链演示-对象继承模式-01-浅拷贝 js原型链演示02-new Foo() js原型链演示02-1-new 原理 js原型链演示03-Foo.prototype js原型链演示-对象继承模式-03-基于对象的原型继承 js原型链演示05-继承函数示例 js原型链演示06-继承prototype模式 js原型链演示07-继承prototype模式改进 js原型链演示08-继承prototype直接继承 js原型链演示08-继承prototype空对象中介 js原型链演示09-继承prototype空对象中介封装expend js原型链演示10-构造器拷贝继承 扩展阅读 Javascript的原型链图详解 第七课时 上节回顾： 1.switch 2.while/do...while 一般情况下面，如果条件判断是数字的比较==&lt;&gt;，for循环优先. 如果是非数值相关的比较循环，while优先 3.function函数 4.代码内存解析 闭包 a.程序永远是先定义后执行 b.执行永远从上之下 c.函数定义的话在堆（只是一个地址而已） d.函数调用的时候，就会有自己的堆和栈（闭包） 知识点： 1、object对象 new关键字代表的是新开辟一块内存空间 没有被引用的内存空间，会在适当的时候被销毁 两句代码含义等同 var person = new Object(); var person = {}; 访问对象的属性除了用 对象引用.属性 key以外，还可以使用对象引用[属性key] new 原理详细解析 无论什么时候，只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针（就是指向新创建的函数）。 通过这个构造函数（原型对象的构造函数），可以继续为原型对象添加其他属性和方法。 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版管这个指针叫 [[Prototype]]。脚本中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__；而在其他实现中，这个属性对脚本是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例和构造函数的原型对象之间，而不是存在于实例和构造函数之间 new创建对象的步骤 创建一个新的对象 将构造函数的作用域赋给新对象 执行构造函数的代码，为这个新对象添加属性 返回新对象 12345678910111213141516171819202122232425function Person(name, age) &#123; this.name = name; this.age = age; this.say = function () &#123; console.log(this.name); &#125;;&#125;function createPerson(P) &#123; // 创建一个新对象 var o = new Object(); // 获取传递给Person函数的参数 var args = Array.prototype.slice.call(arguments, 1); // 新对象的__proto__属性指向Person的原型对象 o.__proto__ = P.prototype; // Person的原型对象的constructor指向Person P.prototype.constructor = P; // 把Person构造函数的作用域赋给新对象 // 给这个新对象添加属性（name,age,say） P.apply(o, args); // 返回这个新对象 return o;&#125;var p = createPerson(Person, 'wang', 35); 2、面向对象的程序设计 function构造器 共同点: 动态创建一块内存空间，闭包 不同点: 函数调用是没有办法拿到空间的地址的，而且这块地址是一块临时地址，执行完函数之后，就会销毁 new开辟内存空间，把这块空间的地址返回，这块空间就有可能长期的被引用 prototype原型 通过原型使通过同样一个构造器所new（创建）出来的对象具有相同的属性和行为 prototype本质就是一个对象 foreach this 指代当前创建的这块内存 this.name=name 指代当前内存中的这个name属性 接收外界传过来的值 继承 多种构造函数 传统的创建对象 12345678910111213141516var person = new Object();person.name = “lancer”;person.age = 24;person.job = “UI”;person.sayName = function()&#123;alert(this.name);&#125;person.sayName(); 工厂模式 123456789101112131415161718192021222324function createPerson(name,age,job)&#123;var o = new Object();o.name = name;o.age = age;o.job = job;o.sayName = function()&#123;alert(o.name);&#125;return o;&#125;var person1 = createPerson(“lancer”,24,”UI”);person1.sayName(); 构造函数 1234567891011121314151617181920function Person(name,age,job)&#123;this.name = name;this.age = age;this.job =job;this.sayName = function()&#123;alert(this.name)&#125;&#125;var person1 = createPerson(“lancer”,24,”UI”);person1.sayName(); 原型模式 1234567891011121314151617181920212223242526function Person()&#123;&#125;Person.prototype.name =”lancer”;Person.prototype.age =24;Person.prototype.job = “UI”;Person.prototype.sayName = function()&#123;alert(this.name)&#125;var person1 = new Person();person1.sayName();var person2 = new Person();person2.name =”lara”person2.sayName(); 简单原型模式 123456789101112131415161718192021222324function Person()&#123;&#125;Person.prototype = &#123;name : “lancer”,age : 24,job : “UI”,sayName : function()&#123;alert(this.name)&#125;&#125;;var person1 = new Person();person1.sayName(); 构造函数和原型模式 1234567891011121314151617181920212223242526function Person(name,age,job)&#123;this.name = name;this.age = age;this.job =job;&#125;Person.prototype = &#123;constructor :Person,sayName : function()&#123;alert(this.name)&#125;&#125;;var person1 = new Person(“lancer”,”24″,”UI”);person1.sayName(); 动态原型模式 123456789101112131415161718192021222324252627282930function Person(name,age,job)&#123;this.name = name;this.age = age;this.job =job;&#125;if(typeof this.sayName !=”function”)&#123;Person.prototype = &#123;constructor :Person,sayName : function()&#123;alert(this.name)&#125;&#125;;&#125;var person1 = new Person(“lancer”,”24″,”UI”);person1.sayName(); 稳妥构造函数 123456789101112131415161718var Person = function(name,age,job)&#123;var O = new Object();O.sayName = function()&#123;alert(name);&#125;;return O&#125;var person1 = Person(“lancer”,24,”UI”);person1.sayName(); 其他： 函数调用后一定有返回值，没有返回值就是undefined 一些内存图示 第八课时 上节回顾： 1.object对象 new关键字代表的是新开辟一块内存空间 没有被引用的内存空间，会在适当的时候被销毁 两句代码含义等同 var person = new Object(); var person = {}; 访问对象的属性除了用 对象引用属性key以外，还可以使用对象引用[属性key] 2.面向对象的程序设计 a.function构造器 共同点: 动态创建一块内存空间，闭包 不同点： 函数调用是没有办法拿到空间的地址的，而且这块地址是一块临时地址，执行完函数之后，就会销毁 new开辟内存空间，把这块空间的地址返回，这块空间就有可能长期的被引用 b.prototype原型 通过原型使通过同样一个构造器所new（创建）出来的对象具有相同的属性和行为 prototype本质就是一个对象 c.foreach c.this d.继承 知识点： 1.prototype内存解析 prototype是原型，是一块所有对应构造器创建的对象都共享的内存空间 在面向对象设计程序的时候，属性应该是对应的空间的，而功能应该是prototype公共空间的 2.通过prototype扩展功能 所有的构造器都是继承于Object构造器的，因此只要Object的原型里有的功能，所有的对象都有 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//多个对象的构造 以及 多个对象之间如何建立联系function Student(name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125;function Bingqilin(name)&#123; this.name = name;&#125;function Game(name)&#123; this.name = name;&#125;function Hour(time)&#123; this.time = time;&#125;Student.prototype = &#123; eat:function(b)&#123; alert(this.name+\"喜欢吃\"+b.name); &#125;, mess:function()&#123; alert(this.name+\"的信息：\"+this.age+','+this.sex); &#125;, sleep:function(h)&#123; alert(this.name+\"每天睡,\"+h.time+'小时'); &#125;, work:function(h)&#123; alert(this.name+\"每天工作,\"+h.time+'小时'); &#125;, like:function(g)&#123; alert(this.name+\"喜欢打,\"+g.name); &#125;&#125;var s = new Student(\"小明\",22,\"男\");var b = new Bingqilin(\"黑色的冰淇淋\");s.eat(b);//小明喜欢吃黑色的冰淇淋var g = new Game(\"英雄联盟\");s.like(g);//把对象的地址发送给like的参数即可访问构造函数Game的name属性var h = new Hour(10);s.sleep(h);s.work(h); 一些内存图示 第九课时 回顾： 1、prototype内存解析 prototype是原型，是一块所有对应构造器创建的对象都共享的内存空间 在面向对象设计程序的时候，属性应该是对应的空间的，而功能应该是prototype公共空间的 2、通过prototype扩展功能 所有的构造器都是继承于Object构造器的，因此只要Object的原型里有的功能，所有的对象都有 构造器在定义的时候 就默认创建了一个空的原型 3、封装 1：找对象 小头爸爸 大头儿子 饭 2：抽象（类，构造器） 3：创建对象并且建立关系（操作对象） 面向对象例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237//小头爸爸牵着大头儿子的手去吃饭，吃完饭之后，//小头爸爸背着大头儿子回家，回家后儿子学习，老爸工作，工作学习完后//儿子看动画片//围裙妈妈带儿子睡觉//张三和张四//分析对象 小头爸爸 大头儿子 饭 以及功能//设计构造器（类）//创建对象以及他们之间的关联 function Person(name,age)&#123; this.name = name; this.age = age; &#125;function Rice(name)&#123; this.name = name;&#125;//Person.prototype.getHand = function()&#123;//这样子写也可以 但还是用默认生成的那块空的内存对象 往里面添加属性 方法 //不浪费内存//&#125;//在prototype中定义的每个对象都有这些功能Person.prototype = &#123;//这样子写 抛弃了默认生成的那块空的内存对象 重新创建了一块新的内存对象 记住：原型的本质是对象 //多个功能写在一起 getHand:function(person)&#123;//牵手 alert(this.name+\"在牵着\"+person.name+\"的手....\"); &#125;, eat:function(rice)&#123; alert(this.name+\"在吃\"+rice.name); &#125;, //需求 18岁以上才能背人 /* //写法一 不推荐 这个满足18岁的功能是自己强加的 不是客户需求的 carry:function(person)&#123;//这里设计不合理 让老爸有这个功能 儿子没有这个功能 if(this.age&gt;=18)&#123; alert(this.name+'背着'+person.name); &#125;else&#123; alert(this.name+\",还未满18岁，背不起\"); &#125; &#125;,*/ backhome:function()&#123; alert(this.name+\"回家\"); &#125;, study:function()&#123; alert(this.name+\"正在学习\"); &#125;, watchTV:function(jm)&#123; alert(this.name+\"正在看\"+jm+'...'); &#125;&#125;;var p1 = new Person(\"老爸\",20);var p2 = new Person(\"儿子\",15);//p1.getHand(p2);//p1.eat(new Rice(\"蛋炒饭\"));//p2.eat(new Rice(\"猪脚饭\"));//p1.carry(p2);//老爸背儿子//p2.carry(p1);//让儿子背老爸 输出结果：儿子,还未满18岁，背不起//p1.backhome();//写法二 不推荐 100对关系 代码写很多遍/*//让老爸单独有背的这个功能 儿子没有这个功能p1.carry = function(person)&#123; alert(this.name+'背着'+person.name);&#125;p1.carry(p2);*///-------通过继承解决这个 让老爸单独有背的这个功能 儿子没有这个功能 可以应对多功能 多需求//功能函数Object.prototype.extends = function(func,actions)&#123;//让所有的子孙 构造器都有这个功能 for(var prop in func.prototype)&#123;//传进一个func构造器 迭代构造器中的功能 把构造器中的功能全都映射过来 复制一份 this.prototype[prop] = func.prototype[prop];//迭代原型中的所有的功能到 当前里面去 &#125; for(var prop in actions)&#123; this.prototype[prop] = actions[prop]; &#125;&#125;;function Father(name)&#123; this.name = name;&#125;Father.extends(Person,&#123; carry:function(person)&#123; alert(this.name+'背着'+person.name); &#125;, work:function()&#123; alert(this.name+\"正在工作\"); &#125;&#125;);//扩展//设计程序有个原则：不修改只增加function Children(name)&#123; this.name = name;&#125;Children.extends(Person);function Mother(name)&#123; this.name = name;&#125;Mother.extends(Person,&#123; scoop:function(person)&#123; //判断必须是children的对象才能执行这个功能 //if()&#123; alert(this.name+\"唱着摇篮曲哄\"+person.name+\"睡觉\"); //&#125; &#125;&#125;);/*Father.prototype.carry= function(person)&#123;//创建这个原型的想法是：原来Person有的功能 我都需要有 并在这些基础上加一个功能 carry //如何建立Father基础Person的功能？写一个继承的小工具来操作 alert(this.name+'背着'+person.name);&#125;;Father.prototype.work = function()&#123; alert(this.name+\"正在工作\");&#125;*/var p1 = new Father(\"老爸\");var p2 = new Children(\"儿子\");p1.carry(p2);//只有老爸有carry这个功能//p2.carry(p1);//error 儿子没有carry这个功能p2.study();//儿子在学习p1.work();//老爸在工作p1.watchTV('看足球');p2.watchTV('蜡笔小新');var p3 = new Mother('围裙妈妈');p3.scoop(p2); 知识点： 1.继承 2.面向对象程序设计案例（猜拳） 一些内存图示 第十课时 上节回顾： 1.继承 本质就是从一个prototype对象中把它的功能都copy到另一个prototype对象 继承为什么要循环 2.call apply方法的使用 func.call（obj）：调用func的时候，以obj这个对象的作用域去调用 改变函数在调用的时候里面闭包的作用域 call(obj,arg1,arg2,arg3);call第一个参数传对象，可以是null。参数以逗号分开进行传值，参数可以是任何类型。apply(obj,[arg1,arg2,arg3]);apply第一个参数传对象，参数可以是数组或者arguments对象 知识点： API application program interface 第一：遇到问题 第二：查资料或者学习 -&gt; 解决问题 第三：记住有这个功能 第四：查资料（百度） 常用API 1.String 2.Array 3.Math Math.random(); 4.Date 日期型函数Date 声明 1234567891011var myDate = new Date(); //系统当前时间var myDate = new Date(yyyy, mm, dd, hh, mm, ss);var myDate = new Date(yyyy, mm, dd);var myDate = new Date(“monthName dd, yyyy hh:mm:ss”);var myDate = new Date(“monthName dd, yyyy”);var myDate = new Date(epochMilliseconds); 获取时间的某部份 123456789101112131415161718192021222324252627var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) 时间戳！！myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 计算之前或未来的时间 123var myDate = new Date();myDate.setDate(myDate.getDate() + 10); //当前时间加10天//类似的方法都基本相同,以set开头,具体参考第2点 计算两个日期的偏移量 123var i = daysBetween(beginDate,endDate); //返回天数var i = beginDate.getTimezoneOffset(endDate); //返回分钟数 检查有效日期 123456//checkDate() 只允许”mm-dd-yyyy”或”mm/dd/yyyy”两种格式的日期if( checkDate(“2006-01-01”) )&#123; &#125;//正则表达式(自己写的检查 yyyy-mm-dd, yy-mm-dd, yyyy/mm/dd, yy/mm/dd 四种)var r = /^(\\d&#123;2&#125;|\\d&#123;4&#125;)[\\/-]\\d&#123;1,2&#125;[\\/-]\\d&#123;1,2&#125;$/;if( r.test( myString ) )&#123; &#125; 字符串String型函数API 声明 123var myString = new String(“Every good boy does fine.”);var myString = “Every good boy does fine.”; 字符串连接 123var myString = “Every ” + “good boy ” + “does fine.”;var myString = “Every “; myString += “good boy does fine.”; 截取字符串 1234567891011121314151617181920212223//截取第 6 位开始的字符var myString = “Every good boy does fine.”;var section = myString.substring(6); //结果: “good boy does fine.”//截取第 0 位开始至第 10 位为止的字符var myString = “Every good boy does fine.”;var section = myString.substring(0,10); //结果: “Every good”//截取从第 11 位到倒数第 6 位为止的字符var myString = “Every good boy does fine.”;var section = myString.slice(11,-6); //结果: “boy does”//从第 6 位开始截取长度为 4 的字符var myString = “Every good boy does fine.”;var section = myString.substr(6,4); //结果: “good” 转换大小写 12345var myString = “Hello”;var lcString = myString.toLowerCase(); //结果: “hello”var ucString = myString.toUpperCase(); //结果: “HELLO” 字符串比较 123456789var aString = “Hello!”;var bString = new String(“Hello!”);if( aString == “Hello!” )&#123; &#125; //结果: trueif( aString == bString )&#123; &#125; //结果: trueif( aString === bString )&#123; &#125; //结果: false (两个对象不同,尽管它们的值相同) 检索字符串 12345var myString = “hello everybody.”;// 如果检索不到会返回-1,检索到的话返回在该串中的起始位置if( myString.indexOf(“every”) &gt; -1 )&#123; &#125; //结果: true 查找替换字符串 123var myString = “I is your father.”;var result = myString.replace(“is”,”am”); //结果: “I am your father.” 特殊字符 \\b : 后退符 \\t : 水平制表符 \\n : 换行符 \\v : 垂直制表符 \\f : 分页符 \\r : 回车符 \\” : 双引号 \\’ : 单引号 \\\\ 反斜杆 将字符转换成Unicode编码 12345var myString = “hello”;var code = myString.charCodeAt(3); //返回”l”的Unicode编码(整型)var char = String.fromCharCode(66); //返回Unicode为66的字符 将字符串转换成URL编码 1234567var myString = “hello all”;var code = encodeURI(myString); //结果: “hello%20all”var str = decodeURI(code); //结果: “hello all”//相应的还有: encodeURIComponent() decodeURIComponent() 扩展阅读 JavaScript下常用的字符串 Math对象型 Math.abs(num) : 返回num的绝对值 Math.acos(num) : 返回num的反余弦值 Math.asin(num) : 返回num的反正弦值 Math.atan(num) : 返回num的反正切值 Math.atan2(y,x) : 返回y除以x的商的反正切值 Math.ceil(num) : 返回大于num的最小整数 Math.cos(num) : 返回num的余弦值 Math.exp(x) : 返回以自然数为底,x次幂的数 Math.floor(num) : 返回小于num的最大整数 Math.log(num) : 返回num的自然对数 Math.max(num1,num2) : 返回num1和num2中较大的一个 Math.min(num1,num2) : 返回num1和num2中较小的一个 Math.pow(x,y) : 返回x的y次方的值 Math.random() : 返回0到1之间的一个随机数 Math.round(num) : 返回num四舍五入后的值 Math.sin(num) : 返回num的正弦值 Math.sqrt(num) : 返回num的平方根 Math.tan(num) : 返回num的正切值 Math.E : 自然数(2.718281828459045) Math.LN2 : 2的自然对数(0.6931471805599453) Math.LN10 : 10的自然对数(2.302585092994046) Math.LOG2E : log 2 为底的自然数(1.4426950408889634) Math.LOG10E : log 10 为底的自然数(0.4342944819032518) Math.PI : π(3.141592653589793) Math.SQRT1_2 : 1/2的平方根(0.7071067811865476) Math.SQRT2 : 2的平方根(1.4142135623730951) Number型 常用的数字函数 声明 123var i = 1;var i = new Number(1); 字符串与数字间的转换 1234567891011var i = 1;var str = i.toString(); //结果: “1”var str = new String(i); //结果: “1”i = parseInt(str); //结果: 1i = parseFloat(str); //结果: 1.0//注意: parseInt,parseFloat会把一个类似于”32G”的字符串,强制转换成32 判断是否为有效的数字 1234567891011var i = 123; var str = “string”;if( typeof i == “number” )&#123; &#125; //true//某些方法(如:parseInt,parseFloat)会返回一个特殊的值NaN(Not a Number)//请注意第2点中的[注意],此方法不完全适合判断一个字符串是否是数字型!!i = parseInt(str);if( isNaN(i) )&#123; &#125; 数字型比较 1234567891011//此知识与[字符串比较]相同- **小数转整数**var f = 1.5;var i = Math.round(f); //结果:2 (四舍五入)var i = Math.ceil(f); //结果:2 (返回大于f的最小整数)var i = Math.floor(f); //结果:1 (返回小于f的最大整数) 格式化显示数字 123456789var i = 3.14159;//格式化为两位小数的浮点数var str = i.toFixed(2); //结果: “3.14”//格式化为五位数字的浮点数(从左到右五位数字,不够补零)var str = i.toPrecision(5); //结果: “3.1415” X进制数字的转换 123456var i = parseInt(“0x1f”,16);var i = parseInt(i,10);var i = parseInt(“11010011”,2); 随机数 1234567//返回0-1之间的任意小数var rnd = Math.random();//返回0-n之间的任意整数(不包括n)var rnd = Math.floor(Math.random() * n) 5.Regex 1234567891011121314151617181920212223242526272829//在这个最大的对象的原型上加一个extends方法 使得下面所有的原型 都有这个方法 //这个原型的作用是通过迭代 复制传进来的构造器的所有的原型的方法 Object.prototype.extends = function(parent)&#123; //console.log(parent.prototype); for(var prop in parent.prototype)&#123; //console.log(prop);//eat extends this.prototype[prop] = parent.prototype[prop];//复制传进来的构造器的所有的原型的方法给当前正在调用这个方法的对象 &#125; &#125; function Person(name)&#123; this.name = name; &#125; Person.prototype = &#123; eat:function()&#123; alert(this.name+\"在吃饭\"); &#125; &#125;; function Father(name)&#123; this.name = name; &#125; Father.extends(Person);//extends方法是最大的对象Object加的方法 所有的子孙 构造器都有这个方法 var f = new Father(\"小头爸爸\"); f.eat(); 一些图示 正则表达式扩展阅读 正则表达式30分钟入门教程 梳理常用的正则表达式 第十一课时 上节回顾： 1.String 2.Math Math.random() 知识点： 1.Date 日期类 2.Array 3.Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 简单封装一个对象案例 123456789101112131415String.prototype.isEmail = function()&#123; email = this; if (email.indexOf(\"@\")!=-1&amp;&amp;email.indexOf(\".\")!=-1) &#123; if(email.indexOf(\"@\")&lt;email.lastIndexOf(\"@\"))&#123; alert(\"邮箱不合法\"); &#125;else&#123; alert(\"邮箱合法\"); &#125; &#125;&#125;var email = \"jingguanliuye@gmail.com\";email.isEmail(); 12345678910111213141516171819202122232425262728//===============================日历练习(方法简洁 高效)======================================//var year = parseInt(prompt(\"请输入日历年份：\"));//var month = parseInt(prompt(\"请输入日历月份：\"))-1;Date.prototype.printCalendar = function()&#123;var year = this.getFullYear(),month = this.getMonth();var date = new Date(year,month,1);//alert(date.toLocaleString());document.write(\"&lt;div class='date'&gt;\"+year+\"年\"+(month+1)+\"月&lt;/div&gt;\");document.write(\"日 一 二 三 四 五 六&lt;br /&gt;\");var day = date.getDay();for(var i=0;i&lt;day;i++)&#123; document.write(' ');&#125;var count = new Date(year,month+1,0).getDate();//这里的0返回一个月的最后一天for(var i=1;i&lt;=count;i++)&#123; document.write(i+' '); if((i+day)%7==0)&#123; document.write('&lt;br/&gt;'); &#125;&#125;&#125;new Date(2012,2).printCalendar(); 第十二课时 上节回顾： 1.Date 期类 2.Array 3.Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5}，{c1,c2} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 新知识点： 1.Regex g.+代表的是1-N个，*代表的是0-N个 h.?代表该字符要不没有要不就有一个 i..代表的是任意字符 j. \\转义符 2.BOM 第十三课时 上节回顾： 1.Regex a.[]一个字符的范围 b.有顺序要求的 c.\\w==[a-zA-Z0-9_] \\d==[0-9] d.{count}设置匹配数量比如\\w{5}，{c1,c2} e.//的正则表达式匹配局部，/^$/的正则表达式是匹配全部 f.()的作用就是为了分组匹配 g.+代表的是1-N个，*代表的是0-N个 h.?代表该字符要不没有要不就有一个 i..代表的是任意字符 j.\\转义符 新知识： window 是Window构造器造出来的一个对象 alert(window instanceof Window) document 是Document构造器造出来的一个对象 任何对象在我们的内存中他都是由某个构造器创建出来的 也就是说 有构造器一定有对应的原型prototype 例如：div是由HTMLDivElement 这个构造器创建的一个实例 div = new HTMLDivElement() span = new HTMLSpanElement() 查看某个对象对应的构造器：console.log(); 整个浏览器的实现就是一个面向对象的编程思想 一切皆是对象 1.BOM 浏览器对象模型 BOM a.screen 指的不是浏览器的宽度，指的是整个电脑屏幕的分辨率 可以拿到屏幕可用分辨率 b.navigator 可以通过userAgent判断当前浏览器信息 c.location URL：统一资源定位符 Union Resource Location 可以通过href属性重定向（改变）页面的URL，进行页面跳转 d.history go方法能够让我们进行历史回退或者前进 e.frames 获得当前窗体的子页面（iframe） f.document DOM模型的核心对象 2.DOM 文档对象模型 document 功能 getElementById $(&#39;#aaa&#39;) getElementByTagName $(&#39;div&#39;) getElementsByClassName $(&#39;.aaa&#39;) getElementsByName 只用在表单元素中 document object 属性： className，style id name,value(表单元素) href,src…(对应的元素) innerHTML children parentNode 功能方法： setAttribute/getAttribute appendChild 第十四课时 上节回顾： 1.BOM 浏览器对象模型 a.screen 指的不是浏览器的宽度，指的是整个电脑屏幕的分辨率 可以拿到屏幕可用分辨率 b.navigator 可以通过userAgent判断当前浏览器信息 c.location URL：统一资源定位符 Union Resource Location 可以通过href属性重定向（改变）页面的URL，进行页面跳转 d.history go方法能够让我们进行历史回退或者前进 e.frames获得当前窗体的子页面（`iframe`） f.document DOM模型的核心对象 所有的DOM对象都是在堆内存创建的 都是有一个构造器生成的 查看对象的构造器器方法： step1：查看标签的对象以及构造器var body = document.body;console.log(body.toString()) step2：查看对象是否是这个构造器创建出来的 console.log(body instanceof HTMLBodyElement) 新知识点： 1.DOM 文档对象模型 document 功能 getElementById：通过传入的ID，返回标识了这个ID的唯一对象的内存地址 getElementsByTagName:通过传入的标签名字，返回所有该标签对象（HTMLCollection） getElementsByClassName:通过类的名字，返回所有该类的元素对象（HTMLCollection） createElement:想要创建出来的元素能够绘制在页面中，那么它必须在DOM树中 总结 document对象是DOM原型的核心对象，它是内存DOM树的根，所以它提供了很多功能让我们快速的找到DOM树中的某些DOM节点（对象） element 功能方法：（自定义属性非常灵活好用） setAttribute/getAttribute //getAttribute获取标签的属性 –用来操作标签的属性 setAttribute设置标签的属性 appendChild:添加子元素 属性： id className，style name,value(只有表单元素有 其他是没有的) href,src…(对应的元素) innerHTML/innerText innerText返回文本信息 children://子元素集合 parentNode//父元素 总结：元素的功能属性直接可以通过元素对象点出来，除此意外的自定义属性，请通过get/setAtribute去操作 DOM 操作： 图片切换的相册效果 tab切换效果 表单验证 特效就是DOM操作的具体应用 DOM操作就是用js来写HTML代码 节点/元素/标签： 三种常用的节点类型： 元素节点 属性节点 文本节点 操作DOM对象： 修改：–找到这个节点 删除：–找到这个节点 添加：–先造出一个节点 然后插入 插入到哪里？找节点来定位 这些都离不开节点的查找 节点的查找：（最重要） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i] 注意：早期浏览器都认为name只出现在表单中 因此document.getElemenstByName只对表单中的元素发挥作用 后来部分浏览器把Name属性扩展到一般的元素 如：div 但是IE浏览器还是只能对表单使用byName因此处于兼容性 我们只能对表单使用byName DOM中查找节点的思路：（由大到小 个别情况 由子到父） 由大到小：（通过下面的来定位） 1、document.getElementById—根据id查找节点 [返回的是节点本身] 2、document.getElementsByTagName–根据标签名字来查找[返回的是数组]document.getElementsByTagName[i] 3、document.getElemenstByName–根据name属性来查找节点（一般用在表单中）[返回的是数组]document.getElemenstByName[i] 如果还没有查到自己想要的节点，还可以继续根据上面已经找到的节点再次定位来查找 怎么继续定位？ 答：childNodes/child 继续查找： 1、查找子元素 children[index]/childNodes 2、查找父元素 node.parentNode –&gt;获取父元素 3、查找兄弟元素 nextSibling previousSibling 4、nextSibling previousSibling firstChild lastChild这四个属性容易受到空白文本的影响 建议不用 12345678910111213141516//============给Object原型加一个方法 消除文本节点对DOM操作的影响 例如：nextSibling` `previousSibling` `firstChild` `lastChild （受到换行 和文本节点影响）Object.prototype.next = function()&#123; //NodeType == 3 text的代号 //NodeType == 1 tag的代号 if(this.nextSibling)&#123;//判断下一个兄弟节点是否存在 switch(this.nextSibling.nodeType)&#123; case 1: return this.nextSibling; case 3: return this.nextSibling.nextSibling; &#125;&#125;else&#123; return null;&#125;console.log(div1.next().next().innerText); 5、对于查到的某个元素里面的子元素非常多 这时候还可利用getElementsByTagname进一步筛选 注意 对于元素对象和document对象相比 元素对象只能利用getElementsByTagName函数 其他两个不能用 节点查找也是通过由大到小来定位：找到大的元素进一步细化 完全可以找到页面上任意一个元素控制他 子元素 不好找 就找他的父元素 要过滤空白文本节点，用children取他的文本节点 DOM与节点的关系： node: childNodes[] parentNode firstChild getElementsByTagName(&#39;元素标签&#39;) lastchild nextSibling previousSibling children[index] children 不是w3c标准 但是各大浏览器兼容性很好 通过给原型添加方法在元素后面创建标签 启示：在项目中，很多很多地方都需要一个方法但是系统没提供，这时可以通过原型扩展 123456789101112//var p = document.createElement('p');//p.innerHTML = \"this is a p\";//var child = document.getElementsByTagName('div');//给Div的HTMLDivElement构造器原型加一个创建元素的方法 要所有的元素都有这个方法 改成 ObjectHTMLDivElement.prototype.createElement = function(tagName)&#123; var child = document.createElement(tagName); this.appendChild(child); return child;&#125;var child = document.getElementsByTagName('div')[2].createElement(\"p\");child.innerHTML = 'pppppp'; DOM属性小结 Attributes 存储节点的属性列表(只读) childNodes 存储节点的子节点列表(只读) dataType 返回此节点的数据类型 Definition 以DTD或XML模式给出的节点的定义(只读) Doctype 指定文档类型节点(只读) documentElement 返回文档的根元素(可读写) firstChild 返回当前节点的第一个子节点(只读) Implementation 返回XMLDOMImplementation对象 lastChild 返回当前节点最后一个子节点(只读) nextSibling 返回当前节点的下一个兄弟节点(只读) nodeName 返回节点的名字(只读) nodeType 返回节点的类型(只读) nodeTypedValue存储节点值(可读写) nodeValue 返回节点的文本(可读写) ownerDocument 返回包含此节点的根文档(只读) parentNode返回父节点(只读) Parsed 返回此节点及其子节点是否已经被解析(只读) Prefix 返回名称空间前缀(只读) preserveWhiteSpace 指定是否保留空白(可读写) previousSibling 返回此节点的前一个兄弟节点(只读) Text 返回此节点及其后代的文本内容(可读写) url返回最近载入的XML文档的URL(只读) Xml 返回节点及其后代的XML表示(只读) DOM方法小结 cloneNode 返回当前节点的拷贝 createAttribute 创建新的属性 节点操作DOMDocument属性和方法 createCDATASection 创建包括给定数据的CDATA段 createComment 创建一个注释节点 createDocumentFragment 创建DocumentFragment对象 createElement_x_x 创建一个元素节点 createEntityReference 创建EntityReference对象 createNode 创建给定类型,名字和命名空间的节点 createPorcessingInstruction 创建操作指令节点 createTextNode 创建包括给定数据的文本节点 getElementsByTagName返回指定名字的元素集合 hasChildNodes 返回当前节点是否有子节点 insertBefore在指定节点前插入子节点 Load导入指定位置的XML文档 loadXML 导入指定字符串的XML文档 removeChild 从子结点列表中删除指定的子节点 replaceChild从子节点列表中替换指定的子节点 Save 把XML`文件存到指定节点 selectNodes 对节点进行指定的匹配,并返回匹配节点列表 selectSingleNode 对节点进行指定的匹配,并返回第一个匹配节点 transformNode 使用指定的样式表对节点及其后代进行转换 transformNodeToObject 使用指定的样式表将节点及其后代转换为对象 document.documentElement返回文档的根节点 document.activeElement 返回当前文档中被击活的标签节点 event.fromElement 返回鼠标移出的源节点 event.toElement返回鼠标移入的源节点 event.srcElement 返回激活事件的源节点 node.parentNode,node.parentElement 返回父节点 node.childNodes 返回子节点集合（包含文本节点及标签节点） node.children 返回子标签节点集合 node.textNodes 返回子文本节点集合 node.firstChild返回第一个子节点 node.lastChild 返回最后一个子节点 node.nextSibling返回同属下一个节点 node.previousSibling 返回同属上一个节点 node.a(oNode) 追加子节点： node.applyElment(oNode,sWhere) sWhere有两个值：outside / inside 应用标签节点 node.insertBefore() node.insertAdjacentElement() node.replaceAdjacentText() 插入节点 node.remove() node.removeChild() node.removeNode() 删除节点 node.replaceChild() node.replaceNode() node.swapNode() 替换节点 node.cloneNode(bAll)返回复制复制节点引用 node.contains() 是否有子节点 node.hasChildNodes()是否有子节点 扩展阅读 DOM编程之API总结篇 第十五课时 上节回顾： 1.DOM 文档对象模型 document 功能 getElementById：通过传入的ID，返回标识了这个ID的唯一对象的内存地址 getElementsByTagName:通过传入的标签名字，返回所有该标签对象（HTMLCollection） getElementsByClassName:通过类的名字，返回所有该类的元素对象（HTMLCollection） createElement:想要创建出来的元素能够绘制在页面中，那么它必须在DOM树中 总结： document对象是DOM原型的核心对象，它是内存DOM树的根，所以它提供了很多功能让我们快速的找到DOM树中的某些DOM节点（对象） element 功能方法：（自定义属性非常灵活好用） setAttribute/getAttribute //getAttribute获取标签的属性 –用来操作标签的属性 setAttribute设置标签的属性 appendChild:添加子元素 属性： id className，style name,value(只有表单元素有 其他是没有的) href,src…(对应的元素) innerHTML/innerText innerText返回文本信息 children://子元素集合 parentNode//父元素 总结：元素的功能属性直接可以通过元素对象点出来，除此意外的自定义属性，请通过get/setAtribute去操作 新知识点： 1.事件（事故）基础 白话含义：就是当一个事物遇到某个事情的时候，要做的事情 （事件源） （事件监听名称） （事件处理程序） 2.常用事件 onclick:当事件源被点击的时候调用处理程序 onmouseover:鼠标进入事件 onmouseout:鼠标移出事件 onmousedown:鼠标按下去的时候 onmouseup:鼠标抬起来的时候 onscroll:当事件源滚动条滚动的时候 onkeydown:当键盘按下的时候 onkeypress:当键盘按下去的时候 onkeyup:当键盘弹上来的时候 onfocus:当事件源获得光标 onblur:当事件源失去光标 onchange:当事件源blur的时候内容改变了的话 浏览器事件注意事项： 1.以后我们不要把事件写在标签上,而使用js方式操作 2.js方式操作的话： 非IE浏览器第一个对象就会传入event事件源对象 IE浏览器第一个对象就不会传入event事件源对象（event = event||window.event;） 非IE浏览器的事件源属性是target属性（event.target = event.target||event.srcElement;） IE浏6览器的事件源属性是srcElement属性 3.事件冒泡机制 总结 以上是一些很基础的理论，笔记经验终究是别人的，看完了还是会忘记的，要转化成自己的东西，还要靠你不断实践。 JavaScript读书路线 JavaScript读书路线--from phodal js一些资料推荐 视频 Javascript第一季初级视频教程【李炎恢老师】 JavaScript视频教程 | 智能社 了解web开发知识体系 Growth - 陪你成为顶尖开发者 GitHub上收集整理的前端资源 常用组件 js常用组件整理 扩展阅读 廖雪峰JavaScript基础教程 JavaScript 闯关记 深入理解JavaScript系列 - 汤姆大叔 JavaScript秘密花园 附录一份大神总结的关于js的导图 DOM基本操作 javascript函数基础 JavaScript数据类型 window对象 javascript变量 JavaScript字符串函数 JavaScript正则表达式 JavaScript流程控制 JavaScript运算符 JavaScript数组 本文mardown原文件–欢迎转载","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"DOM编程之API学习总结篇","slug":"DOM编程之API学习总结篇","date":"2014-09-22T09:10:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/09/22/DOM编程之API学习总结篇/","link":"","permalink":"http://yoursite.com/2014/09/22/DOM编程之API学习总结篇/","excerpt":"原文 链接 一、基本类型介绍 1.1 Node类型 DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法 Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型","text":"原文 链接 一、基本类型介绍 1.1 Node类型 DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法 Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型 假设我们要判断一个Node是不是元素，我们可以这样判断 123if(someNode.nodeType == 1)&#123;console.log(\"Node is a element\");&#125; 这些Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型 1.2 Element类型 Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。 Element有下面几条特性： nodeType为1 nodeName为元素标签名，tagName也是返回标签名 nodeValue为null parentNode可能是Document或Element 子节点可能是 Element，Text，Comment，Processing_Instruction，CDATASection 或 EntityReference 1.3 Text类型 Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性： nodeType为3 nodeName为#text nodeValue为文本内容 parentNode是一个Element 没有子节点 1.4 Attr类型 Attr类型表示元素的特性，相当于元素的attributes属性中的节点，它有下面的特性： nodeType值为2 nodeName是特性的名称 nodeValue是特性的值 parentNode为null 1.5 Comment类型 Comment表示HTML文档中的注释，它有下面的几种特征： nodeType为8 nodeName为#comment nodeValue为注释的内容 parentNode可能是Document或Element 没有子节点 1.6 Document Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性： nodeType为9 nodeName为#document nodeValue为 null parentNode为 null 子节点可能是一个DocumentType或Element 1.7 DocumentFragment类型 DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性： nodeType为11 nodeName为#document-fragment nodeValue为null parentNode为null 我们简单地介绍了几种常见的Node类型，要记住，HTML中的节点并不只是包括元素节点，它还包括文本节点，注释节点等等。在这里我们只是简单地说明了几种常见的节点. 二、 DOM提供的几个属性 2.1 childNodes属性 在一棵节点树上，childNodes属性可以用来获取任何一个元素的所有子节点，它是一个包含这个元素全部子元素的数组 1element.childNodes 2.2 nodeType属性 节点之间的关系构成了节点层次，html 页面的可以画出一个以html标签为根节点的树形结构DOM 会把文档看作是一棵树，同时定义了很多方法来操作这棵数中的每一个元素（节点） 12345678&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;hello world!!!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 每一个节点都有nodeType属性 1node.nodeType nodeType属性总共有12中可能取值，但其中仅有3种有实用价值 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 1description.firstChild.nodeValue = text; 2.3 nodeValue属性 nodeValue属性 如果想改变一个文本节点的值，那就使用DOM提供的nodeValue,它用来得到一个节点的值 node.nodeValue 需要注意：nodeValue属性获取对象的值时，得到的并不是包含在这个段落里的文本 nodeValue属性不仅可以用来检测节点的值，还可以设置节点的值 2.4 firstChild和lastChild属性 数组元素childNodes[0]有个更直观的同义词。无论如何，只要访问childNodes数组的第一个元素，都可以把它写成firstChild 1node.firstChild 与下面等价 1node.childNodes[0] DOM还提供了一个与之对应的lastChild属性 1node.lastChild 三、节点创建型API 在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的 3.1 createElement createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签 12var div = document.createElement(\"div\"); 使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中 3.2 createTextNode createTextNode用来创建一个文本节点，用法如下 12var textNode = document.createTextNode(\"一个TextNode\"); createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中 3.3 cloneNode cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下： 123var parent = document.getElementById(\"parentElement\"); var parent2 = parent.cloneNode(true);// 传入trueparent2.id = \"parent2\"; 这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点 123456789101112131415&lt;div id=\"parent\"&gt; 我是父元素的文本 &lt;br/&gt; &lt;span&gt; 我是子元素 &lt;/span&gt;&lt;/div&gt;&lt;button id=\"btnCopy\"&gt;复制&lt;/button&gt;var parent = document.getElementById(\"parent\");document.getElementById(\"btnCopy\").onclick = function()&#123; var parent2 = parent.cloneNode(true); parent2.id = \"parent2\"; document.body.appendChild(parent2);&#125; 这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中 这里有几点要注意： 和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中 如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id 调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同 除此之外，我们还有一个需要注意的点： 如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论： 如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件 如果是内联方式绑定比如 12&lt;div onclick=\"showParent()\"&gt;&lt;/div&gt; 这样的话，副本节点同样会触发事件 3.4 createDocumentFragment createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中 createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中 1234567891011&lt;ul id=\"list\"&gt;&lt;/ul&gt;&lt;input type=\"button\" value=\"添加多项\" id=\"btnAdd\" /&gt;document.getElementById(\"btnAdd\").onclick = function()&#123; var list = document.getElementById(\"list\"); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(\"li\"); li.textContent = i; list.appendChild(li); &#125;&#125; 这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了 DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下 123456789101112document.getElementById(\"btnAdd\").onclick = function()&#123; var list = document.getElementById(\"list\"); var fragment = document.createDocumentFragment(); for(var i = 0;i &lt; 100; i++)&#123; var li = document.createElement(\"li\"); li.textContent = i; fragment.appendChild(li); &#125; list.appendChild(fragment);&#125; 优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list 3.5 创建型API总结 创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点： 它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中 cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题 使用createDocumentFragment来解决添加大量节点时的性能问题 四、页面修改型API 前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild 4.1 appendChild appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下： 1parent.appendChild(child); child节点将会作为parent节点的最后一个子节点 appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方 123456789101112131415&lt;div id=\"child\"&gt; 要被添加的节点&lt;/div&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;div id=\"parent\"&gt; 要移动的位置&lt;/div&gt; &lt;input id=\"btnMove\" type=\"button\" value=\"移动节点\" /&gt;document.getElementById(\"btnMove\").onclick = function()&#123; var child = document.getElementById(\"child\"); document.getElementById(\"parent\").appendChild(child);&#125; 这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件 4.2 insertBefore insertBefore用来添加一个节点到一个参照节点之前，用法如下 12parentNode.insertBefore(newNode,refNode); parentNode表示新节点被添加后的父节点 newNode表示要添加的节点 refNode表示参照节点，新节点会添加到这个节点之前 123456789101112131415&lt;div id=\"parent\"&gt; 父节点 &lt;div id=\"child\"&gt; 子元素 &lt;/div&gt;&lt;/div&gt;&lt;input type=\"button\" id=\"insertNode\" value=\"插入节点\" /&gt;var parent = document.getElementById(\"parent\");var child = document.getElementById(\"child\");document.getElementById(\"insertNode\").onclick = function()&#123; var newNode = document.createElement(\"div\"); newNode.textContent = \"新节点\" parent.insertBefore(newNode,child);&#125; 这段代码创建了一个新节点，然后添加到child节点之前 和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。 关于第二个参数参照节点还有几个注意的地方： refNode是必传的，如果不传该参数会报错 如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾 4.3 removeChild removeChild顾名思义，就是删除指定的子节点并返回，用法如下 12var deletedChild = parent.removeChild(node); deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。 注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除： 123if(node.parentNode)&#123; node.parentNode.removeChild(node);&#125; 通过节点自己获取节点的父节点，然后将自身删除 4.4 replaceChild replaceChild用于使用一个节点替换另一个节点，用法如下 12parent.replaceChild(newChild,oldChild); newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置 oldChild是被替换的节点 4.5 页面修改型API总结 页面修改型api主要是这四个接口，要注意几个特点： 不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置 节点本身绑定的事件会不会消失，会一直保留着 五、节点查询型API 节点查询型API也是非常常用的 5.1 document.getElementById 这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null 使用这个接口有几点要注意： 元素的Id是大小写敏感的，一定要写对元素的id HTML文档中可能存在多个id相同的元素，则返回第一个元素 只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的 5.2 document.getElementsByTagName 这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？ 12345678910111213141516&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt; &lt;input type=\"button\" value=\"显示数量\" id=\"btnShowCount\"/&gt;&lt;input type=\"button\" value=\"新增div\" id=\"btnAddDiv\"/&gt; var divList = document.getElementsByTagName(\"div\");document.getElementById(\"btnAddDiv\").onclick = function()&#123; var div = document.createElement(\"div\"); div.textContent =\"div\" + (divList.length+1); document.body.appendChild(div);&#125; document.getElementById(\"btnShowCount\").onclick = function()&#123; alert(divList.length);&#125; 这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div 使用document.getElementsByTagName这个方法有几点要注意： 如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率 如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection “*”表示所有标签 5.3 document.getElementsByName getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。一般用于获取表单元素的·name·属性 使用这个接口主要要注意几点： 返回对象是一个即时的NodeList，它是随时变化的 在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name`属性，它也是可以被查找到的 在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name 5.4 document.getElementsByClassName 这个API是根据元素的class返回一个即时的HTMLCollection，用法如下 1var elements = document.getElementsByClassName(names); 这个接口有下面几点要注意： 返回结果是一个即时的HTMLCollection，会随时根据文档结构变化 IE9以下浏览器不支持 如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如 12var elements = document.getElementsByClassName(\"test1 test2\"); 5.5 document.querySelector和document.querySelectorAll 这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则 首先来介绍一下document.querySelector document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。 注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素 1234567891011121314&lt;div&gt; &lt;div&gt; &lt;span class=\"test\"&gt;第三级的span&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"test\"&gt; 同级的第二个div&lt;/div&gt;&lt;input type=\"button\" id=\"btnGet\" value=\"获取test元素\" /&gt;document.getElementById(\"btnGet\").addEventListener(\"click\",function()&#123; var element = document.querySelector(\".test\"); alert(element.textContent);&#125;) 这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素 document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符 1234567891011121314&lt;div class=\"test\"&gt; class为test&lt;/div&gt;&lt;div id=\"test\"&gt; id为test&lt;/div&gt;&lt;input id=\"btnShow\" type=\"button\" value=\"显示内容\" /&gt;document.getElementById(\"btnShow\").addEventListener(\"click\",function()&#123; var elements = document.querySelectorAll(\"#test,.test\"); for(var i = 0,length = elements.length;i&lt;length;i++)&#123; alert(elements[i].textContent); &#125; &#125;) 这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点： querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关 返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化 兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持 小结： document.getElementById返回一个对象 document.getElementsByName和document.getElementsByClasName返回一个对象数组 六、节点关系型API 在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等 6.1 父关系型API parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null 6.2 兄弟关系型API previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下 previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持 nextSibling previousSibling 存在兼容性问题 nextElementSibling previousElementSibling 推荐使用 12345678910&lt;script&gt; var oUl = document.getElementById('ul1'); var firstEle = oUl.firstElementChild; var lastEle = oUl.lastElementChild; firstEle.nextElementSibling.style.background = 'red'; lastEle.previousElementSibling.style.background = 'green';&lt;/script&gt; nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下 nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持 6.3 子关系型API childNodes： 返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。childNodes子节点列表集合（只读属性 有兼容性问题 ） 12345678910&lt;ul id=\"ul1\"&gt; &lt;li&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;44444&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var oUl = document.getElementById('ul1'); console.log(oUl.childNodes);&lt;/script&gt; 从截图中可以看出 这段代码中ul的子节点有9个，这说明使用childNodes获取的节点包括了文本节点和元素节点 childNodes 在低版本的ie 浏览器下获取的节点只包括元素节点，这就导致了兼容性问题 如何解决兼容性？？ 根据子节点的nodeType属性值判断 1234567for (var i=0; i&lt;oUl.childNodes.length; i++) &#123; if ( oUl.childNodes[i].nodeType == 1 ) &#123; oUl.childNodes[i].style.background = 'red'; &#125; &#125; children： 一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。children子节点列表集合（只读属性 推荐使用 ） children 获取的子节点只包含元素节点 123for (var i = 0; i&lt;oUl.children.length; i++)&#123; oUl.children[i].style.background = 'red';&#125; firstNode：第一个子节点 lastNode：最后一个子节点 firstChild （firstElementChild） lastChild(lastElementChild) 第一个子节点 最后一个子节点 firstChild 、lastChild 和childNodes同样的存在兼容性问题，在低版本ie浏览器中只能获取到元素节点 firstElementChild、 lastElementChild 获取第一个元素子节点，最后一个元素子节点 推荐使用 1234567var oUl = document.getElementById('ul1');// oUl.firstChild.style.background = 'red';//标准浏览器 报错// oUl.lastChild.style.background = 'red';//标准浏览器 报错oUl.firstElementChild.style.background = 'red';oUl.lastElementChild.style.background = 'red'; hasChildNodes方法：可以用来判断是否包含子节点 七、元素属性型 7.1 setAttribute setAttribute：它允许我们对元素属性值做出修改与getAttribute一样setAttribute也能用于元素节点 通过setAttribute对文档做出修改后，在通过浏览器的查看源码选项看到的任然是改变之前的属性值，也就是说setAttribue做出的修改，不会反应到文档本身的源码里 setAttribute优势在于可以修改文档中的任何一个属性 12element.setAttribute(name, value); 其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。 如果元素本身包含指定的特性名为属性，则可以访问属性进行赋值，比如下面两条代码是等价 1234element.setAttribute(\"id\",\"test\");element.id = \"test\"; 非DOM的解决方案 其实不用setAttribute也可以改变元素的属性 setAttribute方法是第一级DOM的组成部分，它可以设计任何元素节点的任意属性。在第1级DOM出现之前，你可以通过另外一种办法设置大部分元素的属性 1element.value = \"the new value\"; 与下面语句等价 1element.setAttribute(\"value\",\"the new value\"); 7.2 getAttribute getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。 getAttribute不属性doucment对象，不能通过document对象调用，只能通过元素节点对象调用 例如可以与getElementsByTagName方法合用，获取每个p的title属性 1234var paras = document.getElementsByTagName(\"p\");for(var i=0;i&lt;para.lenght;i++)&#123; alert(paras.getAttrtitube(\"title\"));&#125; 八、表格操作 九、样式操作 十、大小和偏移 十一、网上的一张思维导图总结 参考 JavaScript DOM编程艺术 常用DOM操作 本文mardown原文件","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"Emmet常用快捷键","slug":"Emmet常用快捷键","date":"2014-09-09T13:00:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/09/09/Emmet常用快捷键/","link":"","permalink":"http://yoursite.com/2014/09/09/Emmet常用快捷键/","excerpt":"基本语法 div+div&gt;p&gt;span+em^bq","text":"基本语法 div+div&gt;p&gt;span+em^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt; div+div&gt;p&gt;span+em^^bq 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;/blockquote&gt; div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 1234567891011&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; (div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 12345678910111213&lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; ul&gt;li.item$*5 1234567&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt;&lt;/ul&gt; h$[title=item$]{Header $}*3 123&lt;h1 title=\"item1\"&gt;Header 1&lt;/h1&gt;&lt;h2 title=\"item2\"&gt;Header 2&lt;/h2&gt;&lt;h3 title=\"item3\"&gt;Header 3&lt;/h3&gt; ul&gt;li.item$$$*5 1234567&lt;ul&gt; &lt;li class=\"item001\"&gt;&lt;/li&gt; &lt;li class=\"item002\"&gt;&lt;/li&gt; &lt;li class=\"item003\"&gt;&lt;/li&gt; &lt;li class=\"item004\"&gt;&lt;/li&gt; &lt;li class=\"item005\"&gt;&lt;/li&gt;&lt;/ul&gt; ul&gt;li.item$@-*5 1234567&lt;ul&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt;&lt;/ul&gt; ul&gt;li.item$@3*5 1234567&lt;ul&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt;&lt;/ul&gt; form#search.wide 1&lt;form id=\"search\" class=\"wide\"&gt;&lt;/form&gt; p.class1.class2.class3 1&lt;p class=\"class1 class2 class3\"&gt;&lt;/p&gt; td[rowspan=2 colspan=3 title] 1&lt;td rowspan=\"2\" colspan=\"3\" title=\"\"&gt;&lt;/td&gt; HTML ! 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; a:link 1&lt;a href=\"http://\"&gt;&lt;/a&gt; a:mail 1&lt;a href=\"mailto:\"&gt;&lt;/a&gt; link:css 1&lt;link rel=\"stylesheet\" href=\"style.css\" /&gt; link:favicon 1&lt;link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"favicon.ico\" /&gt; link:rss 1&lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"rss.xml\" /&gt; meta:utf 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\" /&gt; script:src 1&lt;script src=\"\"&gt;&lt;/script&gt; form:get 1&lt;form action=\"\" method=\"get\"&gt;&lt;/form&gt; input:hidden,input:h 1&lt;input type=\"hidden\" name=\"\" /&gt; input:text, input:t input:password, input:p input:checkbox, input:c input:radio,input:r input:file, input:f input:submit, input:s input:image,input:i input:button, input:b option, opt 1&lt;option value=\"\"&gt;&lt;/option&gt; button:disabled,button:d, btn:d 1&lt;button disabled=\"disabled\"&gt;&lt;/button&gt; ifr 1&lt;iframe src=\"\" frameborder=\"0\"&gt;&lt;/iframe&gt; btn 1&lt;button&gt;&lt;/button&gt; ul+ 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; dl+ 12345&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;` table+ 12345&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; tr+ 123&lt;tr&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt; select+ 123&lt;select name=\"\" id=\"\"&gt; &lt;option value=\"\"&gt;&lt;/option&gt;&lt;/select&gt; c 1&lt;!-- --&gt; cc:ie6 123&lt;!--[if lte IE 6]&gt; $&#123;child&#125;&lt;![endif]--&gt; CSSvisual formating pos:s 1position:static; pos:a 1position:absolute; pos:r 1position:relative; pos:f 1position:fixed; t 1top:; b:a 1bottom:auto; l 1left:; l:a 1left:auto; z 1z-index:; z:a 1z-index:auto; fl 1float:left; fl:n 1float:none; fl:l 1float:left; fl:r 1float:right; cl 1clear:both; cl:n 1clear:none; cl:l 1clear:left; cl:r 1clear:right; cl:b 1clear:both; d 1display:block; d:n 1display:none; d:b 1display:block; d:i 1display:inline; d:ib 1display:inline-block; d:itb 1display:inline-table; d:tbc 1display:table-cell; v 1visibility:hidden; v:v 1visibility:visible; v:h 1visibility:hidden; ov 1overflow:hidden; ov:v 1overflow:visible; ov:h 1overflow:hidden; ov:s 1overflow:scroll; zoo, zm 1zoom:1; cur:d 1cursor:default; cur:ha 1cursor:hand; cur:p 1cursor:pointer; Margin &amp; Padding m:a 1margin:auto; mt 1margin-top:; mt:a 1margin-top:auto; mr 1margin-right:; mr:a 1margin-right:auto; mb 1margin-bottom:; mb:a 1margin-bottom:auto; ml 1margin-left:; ml:a 1margin-left:auto; pt 1padding-top:; pr 1padding-right:; pb 1padding-bottom:; pl 1padding-left:; Font fw 1font-weight:; fw:n 1font-weight:normal; fw:b 1font-weight:bold; fw:br 1font-weight:bolder; fw:lr 1font-weight:lighter; fs 1font-style:$&#123;italic&#125;; fs:n 1font-style:normal; fz 1font-size:; ff 1font-family:; ff:s 1font-family:serif; ff:ss 1font-family:sans-serif; ff:m 1font-family:monospace; ff:a 1font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif; ff:t 1font-family: \"Times New Roman\", Times, Baskerville, Georgia, serif; ff:v 1font-family: Verdana, Geneva, sans-serif; Background bg 1background:#000; bg+ 1background:#fff url() 0 0 no-repeat; bg:n 1background:none; bgc 1background-color:#fff; bgc:t 1background-color:transparent; bgi 1background-image:url(); bgi:n 1background-image:none; bgr 1background-repeat:; bgr:n 1background-repeat:no-repeat; bgr:x 1background-repeat:repeat-x; bgr:y 1background-repeat:repeat-y; bgr:sp 1background-repeat:space; bgr:rd 1background-repeat:round; bga 1background-attachment:; bga:f 1background-attachment:fixed; bga:s 1background-attachment:scroll; bgp 1background-position:0 0; bgpx 1background-position-x:; bgpy 1background-position-y:; bgbk 1background-break:; bgbk:bb 1background-break:bounding-box; bgbk:eb 1background-break:each-box; bgbk:c 1background-break:continuous; bgcp 1background-clip:padding-box; bgcp:bb 1background-clip:border-box; bgcp:pb 1background-clip:padding-box; bgcp:cb 1background-clip:content-box; bgcp:nc 1background-clip:no-clip; bgo 1background-origin:; bgo:pb 1background-origin:padding-box; bgo:bb 1background-origin:border-box; bgo:cb 1background-origin:content-box; bgsz 1background-size:; bgsz:a 1background-size:auto; bgsz:ct 1background-size:contain; bgsz:cv 1background-size:cover; Color c 1color:#000; c:r 1color:rgb(0, 0, 0); c:ra 1color:rgba(0, 0, 0, .5); op 1opacity:; 其他 ·@m·, @media· 123@media screen &#123; &#125; @i, @import 1@import url(); @kf 1234@keyframes identifier &#123; from &#123; &#125; to &#123; &#125;&#125; @f+ 12345678910@font-face &#123; font-family: 'FontName'; src: url('FileName.eot'); src: url('FileName.eot?#iefix') format('embedded-opentype'), url('FileName.woff') format('woff'), url('FileName.ttf') format('truetype'), url('FileName.svg#FontName') format('svg'); font-style: normal; font-weight: normal;&#125; @f 1234font-face &#123; font-family:; src:url(|);&#125; ! 1!important","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"Emmet","slug":"Emmet","permalink":"http://yoursite.com/tags/Emmet/"}]},{"title":"CSS中的BFC","slug":"CSS中的BFC","date":"2014-09-07T10:20:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/09/07/CSS中的BFC/","link":"","permalink":"http://yoursite.com/2014/09/07/CSS中的BFC/","excerpt":"BFC 是什么？ BFC (Block Formatting Contexts) 即块级格式化上下文，从样式上看，它与普通的容器没有什么区别，但是从功能上，BFC 可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性，例如可以包含浮动元素，使到它可以包含浮动元素，从而防止出现高度塌陷的问题","text":"BFC 是什么？ BFC (Block Formatting Contexts) 即块级格式化上下文，从样式上看，它与普通的容器没有什么区别，但是从功能上，BFC 可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性，例如可以包含浮动元素，使到它可以包含浮动元素，从而防止出现高度塌陷的问题 如何触发 BFC 触发 BFC 的条件 浮动元素，float 除 none 以外的值 绝对定位元素，position（absolute，fixed） display 为以下其中之一的值 inline-blocks，table-cells，table-captions overflow 除了 visible 以外的值（hidden，auto，scroll） 在 CSS3 中，BFC 叫做Flow Root，并增加了一些触发条件： display 的 table-caption 值 position 的 fixed 值，其实 fixed 是 absolute 的一个子类，因此在 CSS2.1 中使用这个值也会触发 BFC ，只是在CSS3 中更加明确了这一点 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如 此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 BFC的作用及原理 自适应两栏布局 1234567891011121314body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125; 1234 &lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第3条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触 根据BFC布局规则第四条： BFC的区域不会与float box重叠 我们可以通过通过触发main生成BFC， 来实现自适应两栏布局 123.main &#123; overflow: hidden;&#125; 当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下： 清除内部浮动 1234567891011.par &#123; border: 5px solid #fcc; width: 300px; &#125;.child &#123; border: 5px solid #f66; width: 100px; height: 100px; float: left;&#125; 123456&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 根据BFC布局规则第六条： 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算 123.par &#123; overflow: hidden;&#125; 防止垂直 margin 重叠 12345678p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 12&lt;p&gt;Haha&lt;/p&gt;&lt;p&gt;Hehe&lt;/p&gt; 两个p之间的距离为100px，发送了margin重叠 根据BFC布局规则第二条： Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了 1234567891011.wrap &#123; overflow: hidden;&#125;p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align: center; margin: 100px;&#125; 1234&lt;p&gt;Haha&lt;/p&gt;&lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/div&gt; 总结 其实以上的几个例子都体现了BFC布局规则第五条 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"DIV+CSS系统学习笔记回顾","slug":"DIV+CSS系统学习笔记回顾","date":"2014-09-06T10:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/09/06/DIV+CSS系统学习笔记回顾/","link":"","permalink":"http://yoursite.com/2014/09/06/DIV+CSS系统学习笔记回顾/","excerpt":"第一部分 HTML 第一章 职业规划和前景 职业方向规划定位： web前端开发工程师 web网站架构师 自己创业 转岗管理或其他","text":"第一部分 HTML 第一章 职业规划和前景 职业方向规划定位： web前端开发工程师 web网站架构师 自己创业 转岗管理或其他 web前端开发的前景展望： 未来IT行业企业需求最多的人才 结合最新的html5抢占移动端的市场 自己创业做老板 随着互联网的普及web开发成为企业的宠儿和核心 web职业发展目标： 第一、梳理知识架构 负责内容的HTML 负责外观的css（层叠样式表） 负责行为的js ps切图 第二、分解目标（起步阶段、提升阶段、成型阶段） 起步阶段： 基本知识的掌握 常用工具的掌握 沟通技巧的掌握（围绕客户的需求） 良好的开发习惯（加注释、对齐方式） 提升阶段： 熟悉掌握HTML基本标签和属性 熟练掌握css的基本语法和使用 浏览器兼容和w3c标准的掌握 结合html+css+js开始系统项目的开发 成型阶段： 精通DIV+CCS布局 精通css样式表控制html标签 熟悉运用js制作动态网站的效果 能独立开发完成网站 第二章 html基本结构 认识HTML： html不是一种编程语言，是一种标志语言 标记语言是由一套标识标签组成的 html使用标签来描述网页 html结构： 1234&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 不成对出现的标签&lt;br&gt; &lt;hr&gt; &lt;meta&gt; &lt;img&gt; &lt;input..&gt; &lt;option..&gt; &lt;link&gt; HTML 基本标签的讲解： &lt;html&gt; &lt;head&gt; &lt;body&gt;标签 &lt;h1&gt;—-&lt;h6&gt;仅仅用于标题文本，不要为了产生粗体文本使用它们 &lt;p&gt;标签 段落标签 &lt;strong&gt;&lt;b&gt;标签 都会让文字产生加粗效果 &lt;strong&gt;用于强调文本，强度更深，表示重要文本—&gt;用于SEO优化 &lt;b&gt;只是视觉加粗效果—&gt;单纯为了产生加粗 &lt;em&gt; &lt;i&gt;标签 em用于强调文本 i只是视觉斜体效果 &lt;strong&gt;比&lt;em&gt;强调更强 特殊符号： &amp;nbsp; —-&gt;空格 &amp;gt; —&gt;大于号 &amp;lt；—&gt;小于号 &amp;quot；—&gt;引号 &amp;copy;–&gt;版权号 第三章 html基本标签 HTMl基本标签： span标签 对被用来组合文档中的行内元素 注意：span没有固定的格式表现，当对它应用样式时，才会产生视觉上的变化 &lt;pre&gt;标签 文字的格式按源码的排版来显示，我们称之为预处理格式 &lt;a&gt;标签—&gt;他有一个必不可少的属性 href target属性： _self(在原来页面打开) _blank（新窗口打开） _top（打开时忽略所有的框架） _parent（在父窗口中打开） 创建锚点和锚链接 锚点也是一种超链接，是页面内进行跳转的超链接 第一步：创建锚点 &lt;a name=&quot;锚点名称&quot;&gt;&lt;/a&gt; 第二步：使用创建好的锚点名称 &lt;a href=&quot;#锚点名称&quot;&gt;内容&lt;/a&gt; marquee标签 可以创建一个内容滚动效果 1&lt;marquee direction=&quot;down&quot; loop=&quot;4&quot; onmouseover=this.stop() onmouseout=this.start()&gt;&lt;/marquee&gt; direction 表示滚动方向，取值有（left,right,up,down,默认left） loop表示滚动循环的次数，默认为无限循环 1onmouseover=this.stop() onmouseover=this.start() scrollamout=&quot;1&quot;(滚动速度) 表示当鼠标移上区域的时候停止滚动，鼠标移开继续滚动 第四章 img图片标签与路径 图片标签与路径： 常见图片格式 jpg png gif Gif （只支持全透明） Jpeg /jpg Png 半/全透明都支持 图片标签写法 ： &lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt; 图片四要素： src=&quot;&quot; 图片路径 alt=&quot;&quot; 图片含义 width=&quot;&quot; 图片宽度 和图片大小保持一致 height=&quot;&quot; 图片高度 和图片大小保持一致 title=&quot;&quot; 路径知识： 相对路径、绝对路径： 相对路径：(Relative Path) 相对于该文件的路径； 绝对路径：(Absolute Path) 从磁盘出发的路径； &lt;img src=&quot;&quot; …… align=&quot;&quot; /&gt; align属性–设置图片与后面文字的位置关系值–top、bottom、middle、absmiddle、left、right 在静态页面中： /开头表示根目录； ./表示当前目录；（斜画线前面一个点） ../上级目录；（斜画线前面两个点） 直接用文件名不带/也表示同一目录 这些都是相对于当前文件的位置来说的，如果用绝对路径的话就是写全了。 第五章 三种列表的讲解 三种列表的知识讲解： &lt;ul&gt;无序列表 无序列表是一个没有顺序项目的列表，此列表项默认粗体圆点进行标识 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表 有序列表也是一列项目，只是列表项目使用的是数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt;标签。 12345&lt;ol&gt; &lt;li&gt;内容一&lt;/li&gt; &lt;li&gt;内容二&lt;/li&gt; &lt;li&gt;内容三&lt;/li&gt;&lt;/ol&gt; 列表符号 无序列表-列表符号: type=&quot;circle&quot; 空心圆 type=“disc” 实心圆 默认值 type=&quot;square&quot; 方块符 有序列表-列表符号 type=&quot;A&quot; A B C D type=&quot;a&quot; a b c d type=&quot;1&quot; 1 2 3 4 默认值type=”I” I II III type=”i” i ii iii 列表嵌套 无序列表-嵌套 123456789&lt;ul&gt; &lt;li&gt;柚子 &lt;ul&gt; &lt;li&gt;沙田柚&lt;/li&gt; &lt;li&gt;蜜柚&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;荔枝&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt;&lt;/ul&gt; 有序列表-嵌套 123456789&lt;ol&gt; &lt;li&gt;茶 &lt;ul&gt; &lt;li&gt;红茶&lt;/li&gt; &lt;li&gt;绿茶&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;果汁&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt;&lt;/ol&gt; 定义列表 定义列表不仅仅是一列项目，而是项目及其注释的组合。定义列表以 &lt;dl&gt; 标签开始。每个定义列表项以 &lt;dt&gt;开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。 123456&lt;dl&gt; &lt;dt&gt;pc网页制作&lt;/dt&gt; &lt;dd&gt;学习DIV+CSS JS JQ 项目实战&lt;/dd&gt; &lt;dt&gt;手机网页制作&lt;/dt&gt; &lt;dd&gt;手机网页制作实战&lt;/dd&gt;&lt;/dl&gt; dd是对dt的解释 &lt; dl&gt;&lt; /dl&gt;用来创建一个普通的列表, &lt; dt&gt;&lt; /dt&gt;用来创建列表中的上层项目， &lt; dd&gt;&lt; /dd&gt;用来创建列表中最下层项目， &lt; dt&gt;&lt; /dt&gt;和&lt; dd&gt;&lt; /dd&gt;都必须放在&lt; dl&gt;&lt; /dl&gt;标志对之间。 12345678910&lt;dl&gt; &lt;dt&gt;中国城市&lt;/dt&gt; &lt;dd&gt;北京 &lt;/dd&gt; &lt;dd&gt;上海 &lt;/dd&gt; &lt;dd&gt;广州 &lt;/dd&gt; &lt;dt&gt;美国城市&lt;/dt&gt; &lt;dd&gt;华盛顿 &lt;/dd&gt; &lt;dd&gt;芝加哥 &lt;/dd&gt; &lt;dd&gt;纽约 &lt;/dd&gt;&lt;/dl&gt; dl是definition list的缩写 dt是definition title的缩写 dd是definition description的缩写 list-style属性具有三个属性分量： list-style-position ：设置列表项图标的位置，位于文本内或者文本外 list-style-type： 设置列表项图标的类型 list-style-image：使用图像设置列表项图标 第六章 表单元素(上) 表单标签: &lt;form&gt;表单标签 &lt;form&gt;表单是一个包含表单元素的区域，包括起来的都是表单的内容123&lt;form&gt; &lt;input type=&quot;text&quot;/&gt;&lt;/form&gt; HTML标签 - Action和确认按钮： 当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 1234&lt;form action=&quot;html.do&quot; method=&quot;get&quot;&gt; username: &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提 交&quot; /&gt;&lt;/form&gt; HTML标签 - 隐藏域隐藏标签： 隐藏域在页面中对于用户是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器 123&lt;form&gt; &lt;input type=&quot;hidden&quot; name=&quot;hid&quot; value=&quot;value&quot;&gt;&lt;/form&gt; &lt;input&gt;标签的掌握 常用type类型： &lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; /&gt; type=&quot;text&quot; 单行文本输入框 type=&quot;password&quot; 密码（maxlength=&quot;&quot;） type=&quot;radio&quot; 单项选择（checked=&quot;checked&quot;） type=&quot;checkbox&quot; 多项选择 type=&quot;button&quot; 按钮 type=&quot;submit&quot; 提交 type=&quot;image&quot;图片提交 type=&quot;file&quot; 上传文件 type=&quot;reset&quot;重置 type=&quot;hidden&quot; 隐藏 关于表单中的设置默认值： 123&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;今天心情不错&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;&quot; checked=&quot;checked&quot;&gt; 1234&lt;select name=&quot;&quot; &gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;&quot; selected=&quot;selected&quot;&gt;&lt;/option&gt;&lt;select&gt; textarea没有默认值 &lt;label&gt;标签的使用 &lt;label&gt;&lt;/label&gt; label 元素不会向用户呈现任何特殊效果。 不过，它为鼠标用户改进了可用性。 如果您在 label 元素内点击文本，就会触发此控件。 就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 &lt;label&gt; 标签的for 属性应当与相关元素的 id属性相同。 例子：（重要—注册表单–用户体验–必做） 123&lt;p&gt;单向选择&lt;/p&gt;&lt;label for=&quot;male&quot;&gt;男：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;/&gt;&lt;label for=&quot;nv&quot;&gt;女：&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;checked=&quot;check&quot;/&gt; 第七章 表单和表格(下) 表单和表格标签： &lt;textarea&gt;文本域标签 &lt;textarea&gt;标签： &lt;textarea&gt;&lt;/textarea&gt;是文本域标签，可以在其中插入一段文字内容，它有两个常用属性rows和cols 注意： rows表示这个文本域有多少行 cols表示这个文本域有多少列 除了这两个属性它还有readonly（只读，文本域的内容无法改变，相当于协议）和title（鼠标放上提示） &lt;select&gt;标签的掌握 注：当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将 &lt;select&gt; 表单数据提交给服务器时包括 name属性123456&lt;form&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;1月&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2月&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 常用到的属性：disabled=“disabled” name=&quot;sel&quot; size=&quot;2&quot; &lt;table&gt;表格标签 &lt;table&gt;表格标签：&lt;table&gt;是表格标签，可以用它定义一个表格。 123456&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 注意：&lt;table&gt;的border属性不能少 &lt;tr&gt; &lt;td&gt;标签的使用 &lt;tr&gt;行标签： &lt;tr&gt;可以定义表格中的一行，一个&lt;tr&gt;&lt;/tr&gt;表示一行。 1234567891011&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;td&gt;单元格标签: &lt;td&gt;可以定义表格中的一个单元格，&lt;td&gt;&lt;/td&gt;表示一个单元格。1234567&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td &gt;姓名&lt;/td&gt;&lt;td&gt;性别&lt;/td&gt;&lt;td&gt;爱好&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; border-collapse 属性设置是否将表格边框折叠为单一边框： border-collapse:collapse; colspan左右合并 rowspan上下合并 第一部分总结： 非可视化标签：head meta style scrpit... 可视化标签：img div span a ul li… 只有可视化标签，才能用css改变它 单标签：meta link base img input br hr 双标签：html head body div a p span ..ul li ol dl …. 常用可视化标签 div 一般用它来布局 a 超链接标签 href*属性：设置跳转的网页地址 target属性：设置跳转的目标 结论：凡事页面可以点击跳转或者表单提交的文字，都用a标签 img src*属性用来设置图片的url数据 alt提供给搜索引擎搜索的 width height 结论 ：显示图片 ul li 列表 结论：只要将来设计页面中有固定样式的列表，就用ul和li table caption tr td (th) 慢慢已经被淘汰了 被ul li代替 如果是合并竖排的就是合并行（rowspan） 如果是合并横排的就是合并列（colspan） HTML部分导图总结 HTML5标签集合 第二部分 CSS 第八章 css基础知识 css基础知识： css样式表的定义 css：（Cascading Style Sheets）层叠样式表； 分类及位置：内部样式-head区域style标签里面 外部样式-link调用 内联样式-标签元素里面 css内的注释：/*注释内容*/ css样式表的语法 CSS规则由两个主要的部分构成：要添加样式的盒子名或者标签名、和要添加的样式。 盒子名或者标签名{属性:值;} CSS中几种颜色的表示方法 用颜色名表示 有17个预先确定的颜色，它们是 aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, orange, purple, red, silver, teal, white, and yellow 用十六进制的颜色值表示(红、绿、蓝) #FF0000或者#F00 用rgb(r,g,b)函数表示 如：rgb(255,255,0) 用hsl(Hue,Saturation,Lightness)函数表示（色调、饱和度、亮度) 如：hsl(120,100%,100%),色调0代表红色，120代表绿色，240代表蓝色 用rgba(r,g,b,a)函数表示 其中a表示的是改颜色的透明度，取值范围是0~1，其中0代表完全透明 用hsla(Hue,Saturation,Lightness,alpha)函数表示 色调、饱和度、亮度、透明度 例子 123456789 &lt;div style=\"position:absolute;top:0px\"&gt; &lt;div style=\"background-color:gray;\"&gt;background-color:gray&lt;/div&gt; &lt;div style=\"background-color:#F00;\"&gt;background-color:#F00&lt;/div&gt; &lt;div style=\"background-color:#ffff00;\"&gt;background-color:#ffff00&lt;/div&gt; &lt;div style=\"background-color:rgb(255,0,255);\"&gt;background-color:rgb(255,0,255)&lt;/div&gt; &lt;div style=\"background-color:hsl(120,80%,50%);\"&gt;background-color:hsl(120,80%,50%)&lt;/div&gt; &lt;div style=\"background-color:rgba(255,0,255,0.5);\"&gt;background-color:rgba(255,0,255,0.5)&lt;/div&gt; &lt;div style=\"background-color:hsla(120,80%,50%,0.5);\"&gt;background-color:hsla(120,80%,50%,0.5)&lt;/div&gt;&lt;/div&gt; 内部样式表 当单个页面需要设置样式时，就应该使用内部样式表。 使用 &lt;style&gt;&lt;/style&gt;标签在文档&lt;head&gt;&lt;/head&gt;里面定义内部样式表 12345&lt;head&gt; &lt;style type=&quot;text/css&quot; &gt; p&#123;color:red;&#125; &lt;/style&gt;&lt;/head&gt; 从外部引入到样式分为两种：（注意写在head标签里面） 当样式需要应用于很多页面时，就需要用到外部样式表，首先需要创建一个css文件，然后引用到我们的页面中。 Link样式表式： &lt;link rel=”stylesheet” type=”text/css” href=”my.css”(href表示路径)&gt; Html式： &lt;style type=&quot;text/css&quot;&gt;@import url(&quot;css.css&quot;);&gt;&lt;/style&gt; 内联样式表（优先级高） 写在标签里面的样式 如：&lt;p style=&quot;color:red;&quot;&gt;&lt;/p&gt; 表示给p标签里面的文字颜色设置为红色 区别：外链样式与导入样式 link标签是属于xhtml范畴，而@import则是css2.1中特有的。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。 加载的顺序的区别，link加载的css时，是一种并行(没有尝试是否是这样)加载CSS方式，而@impor则在整个页面加载完成后才加载。 兼容性的区别，因@import`CSS2.1才特有的，所以对于不兼容CSS2.1`的浏览器来说，无效。 在样式控制上(比如动态改变网页的布局时,使用javascript操作DOM)的区别，此时@import就无能为力了。 样式的优先级补充 相同权值情况下，CSS样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）： 内联样式表（标签内部） &gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中） 权值不同时，浏览器是根据权值来判断使用哪种css样式的，哪种样式权值高就使用哪种样式 层叠优先级是: 浏览器缺省&lt; 外部样式表 &lt; 内部样式表 &lt; 内联样式 其中样式表又有:类选择器 &lt; 类派生选择器&lt;ID选择器 &lt; ID派生选择器 派生选择器以前叫上下文选择器，所以完整的层叠优先级是: 浏览器缺省 &lt;外部样式表 &lt; 外部样式表类选择器 &lt; 外部样式表类派生选择器&lt; 外部样式表ID选择器 &lt; 外部样式表ID派生选择器&lt; 内部样式表 &lt; 内部样式表类选择器 &lt; 内部样式表类派生选择器 &lt; 内部样式表ID选择器 &lt; 内部样式表ID派生选择器 &lt; 内联样式…共12个优先级 另外，如果同一个元素在没有其他样式的作用影响下，其Class定义了多个并以空格分开，其优先级顺序为： 一个元素同时应用多个class，后定义的优先（即近者优先），加上!important者最优先！ 第九章 css选择器(上) css选择器： class类选择器可以重复利用 id选择器唯一 标签选择器 什么是选择器：css选择器就是要改变样式的对象 选择器{属性:值;属性:值;} 标签选择器：页面中所有的标签都是一个选择器 p{color:red;} ID选择器 选择id命名的元素 以 # 开头 #p1{color:#0f0;} 类选择器 class选择器，选择clas命名的元素 以.开头 .first{color:#00f;} css代码写完后上线前要经过压缩处理 本地和服务器分两个css版本（备份） 压缩后注释都清除，空间体积减少 群组选择器 选择多个元素,以逗号隔开 #main,.first,span,a,h1{color:red;} 包含选择器 选择某元素的后代元素，也称后代选择器，父类与子类间以空格隔开p span{color:red;} 属性选择器 选择包含某一属性的元素 a[title]{color:red;} 选择包含title的a标签 a[title][href]{color:red;} 选择包含title和href的a标签 &gt; + 选择器子类选择器：只选择子元素（只选择儿子）（相当于包含元素） p &gt; span{color:red;} 相邻兄弟选择器：只选择后面的相邻兄弟元素 p + span{color:red;} 第十章 css选择器(下) &lt;a&gt;伪类选择器 a:link {color:#FF0000;} / 未访问的链接 / （只用于a标签） a:visited {color:#00FF00;} / 已访问的链接 / （只用于a标签） a:hover {color:#FF00FF;}/* 鼠标移动到链接上 */（可和其他标签结合一起用） a:active {color:#0000FF;} / 选定的链接 / 注意 伪类选择器的排序很重要，a:link a:visited a:hover a:active，记作lvha 输入伪类选择器（针对表单） input:focus{color:red;} / 键盘输入焦点 / 其他伪类选择器 p:first-child{color:red;} /* 第一个p */ :before 在元素之前添加内容。 :after 在元素之后添加内容。 css优先规则 内联样式表-&gt; ID 选择器—&gt; Class 类选择器-&gt;标签选择器 第十一章 背景属性 背景属性： 背景的添加 ： 背景颜色的添加: background:red; backgronnd-color:red; 背景图片的添加： background:url(“images/1.jpg”); backgronnd-image:url(“images/1.jpg”); 背景的平铺 什么是平铺？平铺就是图片是否重复出现 不平铺：background-repeat:no-repeat; 水平方向平铺：background-repeat:repeat-x; 垂直方向平铺：background-repeat:repeat-y; 完全平铺：默认为完全平铺 背景图片的定位 背景图片的定位就是可以设置显示背景图片的位置，通过属性background-position来实现 background-position的取值可为英文单词或者数值和百分值。 background-positon的英文单词取值 top left top center top right center left center center center right bottom left bottom center ottom right background-positon的数值取值 background-position:x y; positon的百分值取值 background-position:x% y%; 背景图片的大小 背景图片的大小可以通过属性background-size来设置background-size的取值可为数值和百分值。 background-size的数值取值 background-size:x y; background-size的数值取值 background-size:x% y%; 背景图片的滚动 背景图片是否随着内容的滚动而滚动由background-attachment设置 background-attachment:fixed; 固定，不随内容的滚动而滚动 background-attachment:scroll; 滚动，随内容的滚动而滚动 第十二章 文字文本属性 css文字文本属性： 文字属性 color:red; 文字颜色 font-size:12px; 文字大小 font-weight:“bold” 文字粗细(bold/normal) font-family:“宋体” 文字字体 font-variant:small-caps小写字母以大写字母显示 文本属性 text-align:center; 文本对齐(right/left/center) line-height:10px; 行间距(可通过它实现文本的垂直居中) text-indent:20px; 首行缩进 text-decoration:none; 文本线(none/underline/overline/line-through) letter-spacing: 字间距 第十三章 盒子模型 盒子模型 盒子模型就是一个有高度和宽度的矩形区域 所有html标签都是盒子模型 div标签自定义盒子模型 所有的标签都是盒子模型 class和id的主要差别是：class用于元素组（类似的元素，或者可以理解为某一类元素），而id用于标识单独的唯一的元素。 盒子模型的组成 盒子模型组成部分： 自身内容：width、height 宽高 内边距： padding 盒子边框： border 边框线 与其他盒子距离： margin外边距 内容+内边距+边框+外边距=面积 border 边框 常见写法 border:1px solid #f00; 单独属性： border-width: border-style: dotted 点状虚线 dashed（虚线） solid（实线） double（双实线） border-color (颜色) padding 内边距 值：像素/厘米等长度单位、百分比 padding:10px; 上下左右 padding:10px 10px; 上下 左右 padding:10px 10px 10px; 上 左右 下 padding:10px 10px 10px 10px; 上 右 下 左（设置4个点–&gt;顺时针方向） 单独属性： padding-top: padding-right: padding-bottom: padding-left: 当设置内边距的时候会把盒子撑大，为了保持盒子原来的大小，应该高度和宽度进行减小，根据width和height减小 margin 外边距 值：与padding相同 单独属性：与padding相同 外边距合并：两个盒子同时设置了外边距，会进行一个外边距合并 补充盒子模型内容 标准盒子模型 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同，先来看看我们熟知的标准盒子模型 从上图可以看到标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content部分不包含其他部分 IE盒子模型 从上图可以看到 ie盒子模型的范围也包括 margin、border、padding、content 和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border和 padding IE盒子模型width = padding+border+内容 标准盒子模型 = 内容的宽度（不包含border+padding） 例： 一个盒子的 margin为 20px，border 为 1px，padding为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 20*2+1*2+10*2+200=262px、高 20*2+1*2*10*2+50=112px，盒子的实际大小为：宽 1*2+10*2+200=222px、高 1*2+10*2+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 20*2+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px 那应该选择哪中盒子模型呢？当然是“标准 w3c 盒子模型”了。怎么样才算是选择了“标准 w3c盒子模型”呢？很简单，就是在网页的顶部加上 doctype 声明。 假如不加doctype 声明，那么各个浏览器会根据自己的行为去理解网页，即 ie浏览器会采用 ie 盒子模型去解释你的盒子，而 ff会采用标准w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。 反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 w3c盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。 用 jquery 做的例子来证实一下 123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是？&lt;/title&gt;&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script language=&quot;javascript&quot;&gt;var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码没有加上 doctype 声明，在 ie 浏览器中显示 ie盒子模型，在 ff 浏览器中显示“标准w3c 盒子模型”。 12345678910111213&lt;!doctype html public &quot;-//w3c//dtd xhtml 1.0 transitional//en&quot; &quot;http://www.w3.org/tr/xhtml1/dtd/xhtml1-transitional.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;你用的盒子模型是标准w3c盒子模型&lt;/title&gt;&lt;script language=&quot;javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script language=&quot;javascript&quot;&gt;var sbox = $.boxmodel ? &quot;标准w3c&quot;:&quot;ie&quot;;document.write(&quot;您的页面目前支持：&quot;+sbox+&quot;盒子模型&quot;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 代码2 与代码1 唯一的不同的就是顶部加了 doctype声明。在所有浏览器中都显示“标准 w3c盒子模型” 所以为了让网页能兼容各个浏览器，让我们用标准 w3c 盒子模型 扩展 学会使用box-sizing布局 第十四章 块元素、行元素与溢出 基本概念 块级元素：默认情况下独占一行的元素，可控制宽高、上下边距； 行内元素：默认情况下一行可以摆放多个的元素，不可控制宽高和上下边距 行块转换 display:none; 不显示 display:block; 变成块级元素 display:inline; 变成行级元素 display:inline-block; 以块级元素样式展示，以行级元素样式排列 溢出 overflow:hidden; 溢出隐藏 overflow:scroll; 内容会被修剪，浏览器会显示滚动条 overflow:auto; 如果内容被修剪，则产生滚动条 文本不换行：white-space:nowrap; 长单词换行：word-wrap:break-word; 行内元素和快级元素小结 一、块级元素：block element 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素； 块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。 DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 二、行内元素：inline element 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN元素，IFRAME元素和元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。 三、block（块）元素的特点: ①、总是在新行上开始； ②、高度，行高以及外边距和内边距都可控制； ③、宽度缺省是它的容器的100%，除非设定一个宽度。 ④、它可以容纳内联元素和其他块元素 四、inline元素的特点 ①、和其他元素都在一行上； ②、高，行高及外边距和内边距不可改变； ③、宽度就是它的文字或图片的宽度，不可改变 ④、内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下: 设置宽度width 无效。 设置高度height无效，可以通过line-height来设置。 设置margin 只有左右margin有效，上下无效。 设置padding只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 五、常见的块状元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是CSS layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript – 可选脚本内容（对于不支持script的浏览器显示此内容） ol – 有序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 无序列表 六、常见的内联元素 a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) bdo – bidi override big – 大字体 br – 换行 cite – 引用 code – 计算机代码(在引用源码的时候需要) dfn – 定义字段 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 kbd – 定义键盘文本 label – 表格标签 q – 短引用 s – 中划线(不推荐) samp – 定义范例计算机代码 select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 七，可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del- 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 八、行内元素与块级元素有什么不同 区别一： 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。 区别二： 块级：块级元素可以设置宽高 行内：行内元素不可以设置宽高 区别三： 块级：块级元素可以设置margin，padding 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。 区别四： 块级：display:block; 行内：display:inline; 替换元素有如下：（和img一样的设置方法） &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt; &lt;object&gt;都是替换元素，这些元素都没有实际的内容 可以通过修改display属性来切换块级元素和行内元素 第十五章 定位 static静态定位（不对它的位置进行改变，在哪里就在那里） 默认值。没有定位，元素出现在正常的流中（忽略 top,bottom, left, right 或者 z-index 声明）。 fixed固定定位（参照物–浏览器窗口）—做 弹窗广告用到 生成固定定位的元素，相对于浏览器窗口进行定位。 元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot;以及 &quot;bottom&quot;属性进行规定。 relative（相对定位 ）（参照物以他本身） 生成相对定位的元素，相对于其正常位置进行定位。 absolute（绝对定位）(除了static都可以，找到参照物–&gt;与它最近的已经有定位的父元素进行定位) 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 元素的位置通过 “left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定 z-index z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 定位的基本思想: 它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。 一切皆为框 块级元素: div、h1或p元素 即：显示为一块内容称之为 “块框“ ; 行内元素: span,strong,a等元素 即：内容显示在行中称 “行内框”; 使用display属性改变成框的类型 即：display:block; 让行内元素设置为块级元素，display:none; 没有框 相对定位： 如果对一个元素进行相对定位，它将出现在它所在的位置上。 通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动 .adv_relative { position: relative; left: 30px; top: 20px; } 绝对定位： 元素的位置相对于最近的已定位祖先元素，如果元素没有已定位 的祖先元素，它的位置相对于最初的包含块。 .adv_absolute { position: absolute; left: 30px; top: 20px; } 第十六章 框架 frameset框架： &lt;frameset&gt; —- 用来定义一个框架；双标签不能和 &lt;body&gt; 一起使用 rows、cols属性 rows 定义行表示框架有多少行（取值 px/%/ * ） cols 定义列表示框架有多少列（取值px/ %/ * ） frame子框架 &lt;frame&gt; —- 表示框架中的某一个部分；单标签，要跟结束标志 src 显示的网页的路径 name 框架名 frameborder 边框线（取值 0 / 1） &lt;noframes&gt;属性 &lt;noframes&gt; 提供不支持框架的浏览器显示body的内容；双标签 12345678&lt;frameset&gt; &lt;frame src=“” /&gt; &lt;frame src=“” /&gt; &lt;frame src=“” /&gt; &lt;noframes&gt; &lt;body&gt;内容&lt;/body&gt; &lt;/noframes&gt;&lt;/frameset&gt; &lt;iframe&gt;内联框架 iframe元素会创建包含另外一个文档的内联框架（即行内框架） 允许和 body 一起使用 width 宽（取值 px / %） height 高（取值 px / %） name 框架名 frameborder 边框线（取值 0 / 1） src 显示的网页的路径 第十七章 css高级属性 opacity透明属性 opacity 对于IE6/7/，使用filter:alpha(opacity:值;) 值为0-100 对于Webkit，Opera，Firefox，IE9+，使用opacity:值; 值为0-1 对于早期火狐，使用-moz-opacity:值; 值为0-1 所以写透明属性时，一般写法是 12345 &#123; opacity:0.5; filter:alpha(opacity：50);/*0-100*/ -moz-opacity:0.5; /*取值0-1*/--&gt;针对早起版本的火狐兼容问题的解决&#125; border-radius圆角边框属性 向 div 元素添加圆角边框 border-radius:10px; box-shadow阴影属性 box-shadow属性向框添加阴影效果,后面跟4个参数。 box-shadow:0px 0px 10px #000; &lt;embed&gt;属性 是HTML5中新增的标签,媒体嵌入插件标签，可以通过&lt;embed&gt;插入音频或视频 &lt;embed src=“media/music.mp3” /&gt; 格式.mid .wav .mp3等 CSS部分导图总结 原文件下载地址 访问密码 342a css常见简写 css简写速查 第三部分 附录 附录一 DIV命名规范 企业DIV使用频率高的命名方法 网页内容类 标题: title 摘要: summary 箭头： arrow 商标： label 网站标志： logo 转角/圆角：corner 横幅广告： banner 子菜单： subMenu 搜索： search 搜索框： searchBox 登录： login 登录条：loginbar 工具条： toolbar 下拉： drop 标签页： tab 当前的： current 列表： list 滚动： scroll 服务： service 提示信息： msg 热点：hot 新闻： news 小技巧： tips 下载： download 栏目标题： title 热点： hot 加入：joinus 注册： regsiter 指南： guide 友情链接： friendlink 状态： status 版权： copyright 按钮： btn 合作伙伴： partner 投票： vote 左右中：left right center 注释的写法: /* Footer */ 内容区/* End Footer */ id的命名: 页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的:current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名: 颜色:使用颜色的名称或者16进制代码,如 .red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } 字体大小,直接使用”font+字体大小”作为名称,如 .font12px { font-size: 12px; } .font9px {font-size: 9pt; } 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } .bottom { float:bottom; } 标题栏样式,使用”类别+功能”的方式命名,如 .barnews { } .barproduct { } 注意事项:: 一律小写; 尽量用英文; 不加中杠和下划线; 尽量不缩写，除非一看就明白的单词. 推荐的 CSS 书写顺序： 显示属性 display list-style position float clear 自身属性 width height margin padding border background 文本属性 color font text-decoration text-align vertical-align white-space other text content 附录二 CSS精灵 CSS精灵原理以及应用 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。 该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非&lt;img&gt;标签。 一个简单的例子： 一张图片作出一个按钮的三个状态 一个链接用CSS做成按钮的样式，我们可以使用同一张图片，完成按钮的三个状态，a:link，a:hover，a:active &lt;a class=&quot;button&quot; href=&quot;#&quot;&gt;链接&lt;/a&gt; 加入右侧的图片为：200px 65px的三个按钮图拼合而成的图片button.png，从上到下一次为按钮的普通、鼠标滑过、鼠标点击的状态。则可以使用CSS进行定义。 12345678910111213141516171819a &#123; display:block; width:200px; height:65px; line-height:65px; /*定义状态*/ text-indent:-2015px; /*隐藏文字*/ background-image:url(button.png); /*定义背景图片*/ background-position:0 0; /*定义链接的普通状态，此时图像显示的是顶上的部分*/&#125;a:hover &#123; background-position:0 -66px; /*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/&#125;a:active &#123; background-position:0 -132px; /*定 义链接的普通状态，此时显示的是底部的部分，向下取负值*/&#125; 更多的CSS雪碧，图片更复杂，背景定位更精确。可能会用到大量的数值 如：background:url(nav.png) -180px 24pxno-repeat; 来达到更精确的定位 优点： 减少加载网页图片时对服务器的请求次数 可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。 提高页面的加载速度 sprite技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)。由所需图片拼成的一张 GIF图片的尺寸会明显小于所有图片拼合前的大小。单张的 GIF只有相关的一个色表，而单独分割的每一张 GIF 都有自己的一个色表，这就增加了总体的大小。因此，单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。 减少鼠标滑过的一些bug IE6不会主动预加载鼠标滑过即a:hover中的背景图片，所以，如果使用多张图片，鼠标滑过会出现闪白的现象。使用CSS雪碧，由于一张图片即可，所以不会出现这种现象。 不足： CSS雪碧的最大问题是内存使用 影响浏览器的缩放功能 拼图维护比较麻烦 使CSS的编写变得困难 CSS 雪碧调用的图片不能被打印 错误得使用 Sprites 影响可访问性 附录三 一些tips解决方案 页面优化实践 从下面的几个方面可以进行页面的优化： 减少请求数 图片合并 CSS文件合并 减少内联样式 避免在 CSS中使用 import 减少文件大小 选择适合的图片格式 图片压缩 CSS 值缩写（Shorthand Property) 文件压缩 页面性能 调整文件加载顺序 减少标签数量 调整选择器长度 尽量使用CSS 制作显示表现 增强代码可读性与可维护性 规范化 语义化 模块化 写DIV+CSS 的一些常识 不要使用过小的图片做背景平铺 这就是为何很多人都不用 1px 的原因，这才知晓。宽高 1px 的图片平铺出一个宽高 200px 的区域，需要 200200=40, 000 次，占用资源 无边框 推荐的写法是 border:none;，哈哈，我一直在用这个。 border:0; 只是定义边框宽度为零，但边框样式、颜色还是会被浏览器解析，占用资源 慎用 通配符 所谓通配符，就是将CSS 中的所有标签均初始化，不管用的不用的，过时的先进的，一视同仁，这样，大大的占用资源。要有选择的初始化标签。 CSS的十六进制颜色代码缩写 习惯了缩写及小写，这才知道，原来不是推荐的写法，为的是减少解析所占用的资源。但同时会增加文件体积。孰优孰劣，有待仔细考证。 样式放头上，脚本放脚下。不内嵌，只外链 坚决不用 CSS表达式 使用 引用样式表，而不是通过@import 导入。 一般来说，PNG比 GIF 要小，小得多。再者，GIF 中有多少颜色是被浪费的，很值得优化。 千万不要在 HTML中缩放图片，一者不好看，二者占资源。 正文字体最好用偶数 12px、14px、16px，效果非常好。特例，15px。 block、ul、ol等上下留出至少一倍行距，左侧至少两倍行距，右侧随意。 段落之间，至少要有一倍行距 强行指定某些元素的 line-height，正文 1.6倍于文字大小，标题1.3倍。 中文标点用全角 英文夹杂在中文中，左右空格，半角。 中文字体的粗体和斜体，远离较好 常用代码片段 雅虎工程师提供的CSS初始化示例代码【仅供参考】 可以在html头文件中直接引用，从而避免浏览器的不兼容带来的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px;&#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption,cite, code, dfn, em, strong,th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none;&#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123; overflow-y: scroll;&#125; .clearfix:after &#123; content: \".\"; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; mobile meta标签 1&lt;meta name=”viewport” content=”width=320,target-densitydpi=dpi_value,initial-scale=1, user-scalable=no”/&gt; 表格不被撑开 1table-layout: fixed; word-break: break-all;;border-collapse: collapse 不设宽高居中 12345&lt;div id=”abc” style=”display:table;text-align:center;width:100%;height:100%;”&gt; &lt;span style=”background:#f00; display:table-cell; vertical-align:middle;”&gt; &lt;input type=”button” value=”item1″ /&gt; &lt;/span&gt;&lt;/div&gt; 透明度的兼容代码 1234filter:alpha(opacity=50); /*1-100*/-moz-opacity:0.5; /*0-1.0*/-khtml-opacity:0.5; /*0-1.0*/opacity:0.5; /*0-1.0*/ 文字溢出点点省略 123white-space:nowrap;text-overflow:ellipsis;overflow:hidden; 清除浮动的几种方法 方法一：投机取巧法 – 不推荐 直接一个放到当作最后一个子标签放到父标签那儿，此方法屡试不爽，兼容性强 方法二：overflow + zoom方法 –不推荐 .fix{overflow:hidden; zoom:1;} 此方法优点在于代码简洁，涵盖所有浏览器 方法三：after + zoom方法 -推荐–此方法可以说是综合起来最好的方法了 clearfix只应用在包含浮动子元素的父级元素上 12345678.fix&#123;zoom:1;&#125;.fix:after&#123; display:block; content:'clear'; clear:both; line-height:0; visibility:hidden;&#125; 更多代码片段详情 实用的60个CSS代码片段 一些总结 自动继承属性： color font text-align list-style… 非继承属性： background border position… 具有破坏性的元素： float display:none; position:absoblute/fixed/sticky; 具有包裹性的元素： display:inline-block/table-cell position:absolute/fixed/sticky overflow:hidden/scroll 消除图片底部间隙的方法 图片块状化-无基线对齐img{display:block;} 图片底线对齐img{vertical-align:bottom;} 行高足够小 - 基线位置上移.box{line-height:0;} 一些概念 BFC BFC全称”Block Formatting Context” 中文为“块级格式化上下文” 记住这么一句话：BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 扩展阅读 CSS中的BFC 优雅降级(graceful degradation) 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 渐进增强 progressive enhancement： 是在浏览器开启JavaScript功能后，如果浏览器版本不支持某些 JavaScript 能力，我们解决这种问题的方式 平稳退化 是在浏览器没有JavaScript功能，或没有开启JavaScript功能情况下，我们解决这种问题的方式； 方案荟萃扩展阅读 关于布局 垂直居中 css完全居中 居中之美 网页中的底部foot定位 页面高度100% textarea高度自适应 多行溢出省略 Retina屏1px线 Flexbugs 其他 IF IE ENDIF条件判断之IE10 Chrome 翻译插件 网页retina优化 常用meta 树状菜单 em vs rem css vs js css解决方案（w3cplus） Textures生成纹理 CSSgram Csscss（检查重复声明等） 附录四 部分工具资源 学会使用Emmet插件快速编码 Emmet常用快捷键 Sublime专题 Sublime常用插件总结 Front-End -Develop -Tools ToolsBox-自己整理的一份工具列表 附录五 编码规范 编码规范 前端规范 web develop standard Web 前端开发规范文档 前端开发规范手册 附录六 进阶学习 DOM编程之API学习 JavaScript基础学习 附录七 其他资源 Github上前端学习资源汇总 WEB 前端开发学习笔记 前端开发工具箱 148个资源让你成为CSS专家 学习CSS布局-经典必看 附录八 常见问题 前端指路 写给前端面试者（w3cplus） 如何成为一名卓越的前端工程师（勾三股四博客） 什么是全栈工程师 如何跟上前端开发的最新前沿 浏览器的工作原理 移动前端开发和 Web 前端开发的区别 大型网站CSS编写与维护 CSS核心技术关键字 性能/规范/实践 如何阅读W3c规范(王晓轩) 如何阅读W3c规范(高博) 雅虎web性能优化军规 权威前端性能指南 高性能css 一些问答社区 quora stackoverflow 知乎 前端乱炖问答区 segmentfault问答区 其他 本文Mardown原文件-欢迎转载","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"XHTML","slug":"XHTML","permalink":"http://yoursite.com/tags/XHTML/"}]},{"title":"PS基本切图及应用","slug":"PS基本切图及应用","date":"2014-08-08T07:30:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/08/08/PS基本切图及应用/","link":"","permalink":"http://yoursite.com/2014/08/08/PS基本切图及应用/","excerpt":"之前一直用别人切好的页面，心中很是惭愧，为不在麻烦于他人，还是重新打开很久没用过得PS，学习了一下如何切页面，顺便整理一下近期学到的PS切图的基本方法。 美工一般只提供设计稿，那么问题来了，我们如何把设计稿切成自己想要的图片呢，今天我们来简单学习一下如何切图：","text":"之前一直用别人切好的页面，心中很是惭愧，为不在麻烦于他人，还是重新打开很久没用过得PS，学习了一下如何切页面，顺便整理一下近期学到的PS切图的基本方法。 美工一般只提供设计稿，那么问题来了，我们如何把设计稿切成自己想要的图片呢，今天我们来简单学习一下如何切图：切图我们一般只切两种类型的图片，JPG图片和icon图表。重点还是在icon上。 PS环境配置 ps中用到的快捷键： 放大：z 缩小：Ctrl+alt+空格+鼠标点击 切片：c 移动：v 拖动：空格+鼠标拖动‘ 撤销：Ctrl+z ctrl+alt+z 保存：Ctrl+shift+Alt+s 配置工作环境： 基本图片的切法 icon图标切法 图片在网页中的定位12345678910111213141516171819*&#123; margin:0; padding:0;&#125;html,body&#123; width:100%; height:100%;&#125;.tb&#123;background-image:url(\"icon.png\");background-repeat:no-repeat;display:block;&#125;.icon&#123; width:28px; height:28px; background-position:-28px 0px;&#125;.icon1&#123; width:38px; height:38px; background-position:-39px -27px;&#125; 12 &lt;span class=\"icon tb\"&gt;&lt;/span&gt; &lt;span class=\"icon1 tb\"&gt;&lt;/span&gt; 这里介两种图片的定位方法 方法一：通过浏览器的插件定位图片的具体位置 方法二：在ps原稿中测量图片的位置 （完）","categories":[{"name":"Front-End","slug":"Front-End","permalink":"http://yoursite.com/categories/Front-End/"}],"tags":[{"name":"PS","slug":"PS","permalink":"http://yoursite.com/tags/PS/"}]},{"title":"javascript 下常用的字符串操作","slug":"javascript 下常用的字符串操作","date":"2014-08-02T09:35:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/08/02/javascript 下常用的字符串操作/","link":"","permalink":"http://yoursite.com/2014/08/02/javascript 下常用的字符串操作/","excerpt":"charAt() 返回在指定位置的字符。","text":"charAt() 返回在指定位置的字符。 12var str = \"abac_dfra_wa\";console.log(str.charAt(3)); //输出 c charCodeAt() 返回在指定的位置的字符的 Unicode 编码。12var str = \"abac_dfra_wa\";console.log(str.charCodeAt(3)); //输出99 fromCharCode() 从字符编码创建一个字符串1console.log(String.fromCharCode(72,69,76,76,79)); //输出HELLO concat() 连接字符串12var str = \"abac_dfra_wa\";console.log(str.concat('_000')); //输出abac_dfra_wa_000 indexOf() 检索字符串12var str = \"abac_dfra_wa\"; console.log(str.indexOf('ac')); //输出2 lastIndexOf() 从后向前搜索字符串。12var str = \"abac_dfra_wa\";console.log(str.lastIndexOf('ac')); //输出2 match() 找到一个或多个正则表达式的匹配1234var str=\"1 plus 2 equal 3\"console.log(str.match('plus')); // plusconsole.log(str.match('st')); // nullconsole.log(str.match(/\\d+/g)) // [ '1', '2', '3' ] replace() 替换与正则表达式匹配的子串123456789101112var str=\"Hello WoRlD!\"console.log(str.replace(/WoRlD/, \"World\")); // Hello World!var str=\"Hello WoRlD! \"str += str;console.log(str.replace(/WoRlD/g, \"World\")); //替换所有, 输出：Hello World! Hello World! var str = \"javascript Tutorial \";console.log(str.replace(/javascript/i, \"JavaScript\")); //确保匹配字符串大写字符的正确var name = \"Doe, John\";console.log(name.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\")); //将把 \"Doe, John\" 转换为 \"John Doe\" 的形式 search() 检索与正则表达式相匹配的值(大小写敏感)，未找到输出-1。12345var str=\"Hello World!\"console.log(str.search(/World/)); //输出6var str=\"Hello World!\"console.log(str.search(/world/i)); //忽略大小写的检索，输出6 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分123var str=\"Hello happy world!\"console.log(str.slice(6)); //输出happy world!console.log(str.slice(6, 11)); //输出happy split() 把字符串分割为字符串数组12345\"|a|b|c\".split(\"|\") ////将返回[\"\", \"a\", \"b\", \"c\"]\"How are you doing today?\".split(\" \",3) //返回 How,are,you\"hello\".split(\"\") //可返回 [\"h\", \"e\", \"l\", \"l\", \"o\"]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Snippet","slug":"Snippet","permalink":"http://yoursite.com/tags/Snippet/"}]},{"title":"梳理常用的正则表达式","slug":"梳理常用的正则表达式","date":"2014-07-09T17:04:51.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/07/10/梳理常用的正则表达式/","link":"","permalink":"http://yoursite.com/2014/07/10/梳理常用的正则表达式/","excerpt":"一、校验数字的表达式","text":"一、校验数字的表达式 1 数字：1^[0-9]*$ 2 n位的数字：1^\\d&#123;n&#125;$ 3 至少n位的数字：1^\\d&#123;n,&#125;$ 4 m-n位的数字：1^\\d&#123;m,n&#125;$ 5 零和非零开头的数字：1^(0|[1-9][0-9]*)$ 6 非零开头的最多带两位小数的数字：1^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 7 带1-2位小数的正数或负数：1^(-)?\\d+(.\\d&#123;1,2&#125;)?$ 8 正数、负数、和小数：1^(-|+)?\\d+(.\\d+)?$ 9 有两位小数的正实数：1^[0-9]+(.[0-9]&#123;2&#125;)?$ 10 有1~3位小数的正实数：1^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 11 非零的正整数：1^[1-9]\\d$ 或 ^([1-9][0-9])&#123;1,3&#125;$ 或 ^+?[1-9][0-9]*$ 12 非零的负整数：1^-[1-9][]0-9″$ 或 ^-[1-9]\\d$ 13 非负整数：1^\\d+$ 或 ^[1-9]\\d*|0$ 14 非正整数：1^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15 非负浮点数：1^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 16 非正浮点数：1^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 17 浮点数：1^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式 1 汉字：1^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 2 英文和数字：1^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 3 长度为3-20的所有字符：1^.&#123;3,20&#125;$ 4 由26个英文字母组成的字符串：1^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：1^[A-Z]+$ 6 由26个小写英文字母组成的字符串：1^[a-z]+$ 7 由数字和26个英文字母组成的字符串：1^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：1^\\w+$ 或 ^\\w&#123;3,20&#125;$ 9 中文、英文、数字包括下划线：1^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10 可以输入含有1^%&amp;’,;=?$\\”等字符：`[^%&amp;’,;=?$\\x22]+ 11 禁止输入含有~的字符：1[^~\\x22]+ 三、特殊需求表达式 1 Email地址：1^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 2 域名：1[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? 3 InternetURL：1[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 4 手机号码：1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 5 电话号码:1(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ 6 国内电话号码1(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; 7 身份证号(15位、18位数字)：1^\\d&#123;15&#125;|\\d&#123;18&#125;$ 8 短身份证号码(数字、字母x结尾)：1^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：1^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：1^[a-zA-Z]\\w&#123;5,17&#125;$ 11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：1^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 12 日期格式：1^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 13 一年的12个月(01～09和1～12)：1^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：1^((0?[1-9])|((1|2)[0-9])|30|31)$ 15 钱的输入格式： 16 1.有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：1^(0|[1-9][0-9]*)$ 18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：1^(0|-?[1-9][0-9]*)$ 19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：1^[0-9]+(.[0-9]+)?$ 20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：1^[0-9]+(.[0-9]&#123;2&#125;)?$ 21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：1^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：1^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：1^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 25 xml文件：1^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 26 中文字符的正则表达式：1[\\u4e00-\\u9fa5] 27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 29 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 30 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) 34 IP地址：1((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"梳理常见的CSS属性（二）","slug":"梳理常见的CSS属性（二）","date":"2014-06-25T15:56:31.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/06/25/梳理常见的CSS属性（二）/","link":"","permalink":"http://yoursite.com/2014/06/25/梳理常见的CSS属性（二）/","excerpt":"","text":"一、CSS 文字属性 语 言 功 能 color : #999999; 文字颜色 font-family:宋体,sans-serif; 文字字体 font-size:9pt; 文字大小 font-style:itelic; 文字斜体 font-variant:small-caps; 小字体 letter-spacing:1pt; 字间距离 line-height : 200%; 设置行高 font-weight:bold; 文字粗体 vertical-align:sub; 下标字 vertical-align:super; 上标字 text-decoration:line-through; 加删除线 text-decoration:overline; 加顶线 text-decoration:underline; 加下画线 text-decoration:none; 删除链接下画线 text-transform:capitalize; 首字大写 text-transform:uppercase; 英文大写 text-transform:lowercase; 英文小写 text-align:right; 文字右对齐 text-align:left; 文字左对齐 text-align:center; 文字居中对齐 text-align:justify; 文字两端对齐 vertical-align属性 vertical-align:top; 垂直向上对齐 vertical-align:bottom; 垂直向下对齐 vertical-align:middle; 垂直居中对齐 vertical-align:text-top; 文字垂直向上对齐 vertical-align:text-bottom; 文字垂直向下对齐 二、CSS 项目符号 list-style-type:none; 不编号 list-style-type:decimal; 阿拉伯数字 list-style-type:lower-roman; 小写罗马数字 list-style-type:upper-roman; 大写罗马数字 list-style-type:lower-alpha; 小写英文字母 list-style-type:upper-alpha; 大写英文字母 list-style-type:disc; 实心圆形符号 list-style-type:circle; 空心圆形符号 list-style-type:square; 实心方形符号 list-style-image:url(/dot.gif) 图片式符号 list-style-position:outside; 凸排 list-style-position:inside; 缩进 三、CSS 背景样式 background-color:#F5E2EC; 背景颜色 background:transparent; 透视背景 background-image:url(image/bg.gif); 背景图片 background-attachment:fixed; 浮水印固定背景 background-repeat:repeat; 重复排列-网页默认 background-repeat:no-repeat; 不重复排列 background-repeat:repeat-x; 在 X 轴重复排列 background-repeat:repeat-y; 在 Y 轴重复排列 background-position:90% 90%; 背景图片 X 与 Y 轴的位置 background-position:top; 向上对齐 background-position:buttom; 向下对齐 background-position:left; 向左对齐 background-position:right; 向右对齐 background-position:center; 居中对齐 四、CSS 链接属性 a 所有超链接 a:link 超链接文字格式 a:visited 浏览过的链接文字格式 a:active 按下链接的格式 a:hover 鼠标转到链接 cursor:crosshair 十字体 cursor:s-resize 箭头朝下 cursor:help 加一问号 cursor:w-resize 箭头朝左 cursor:n-resize 箭头朝上 cursor:ne-resize 箭头朝右上 cursor:nw-resize 箭头朝左上 cursor:text 文字 I 型 cursor:se-resize 箭头斜右下 cursor:sw-resize 箭头斜左下 cursor:wait 漏斗 五、CSS 边框属性 border-top:1px solid #6699cc; 上框线 border-bottom:1px solid #6699cc; 下框线 border-left:1px solid #6699cc; 左框线 border-right:1px solid #6699cc; 右框线 solid 实线框 2+6010 47dotted 虚线框 double 双线框 groove 立体内凸框 ridge 立体浮雕框 inset 凹框 outset 凸框 六、CSS 表单 &lt;input type=&quot;text&quot; name=&quot;T1&quot; size=&quot;15&quot;&gt; 文本域 &lt;input type=&quot;submit&quot; value=&quot;submit&quot; name =&quot;B1&quot;&gt; 按钮 &lt;input type=&quot;checkbox&quot; name=&quot;C1&quot;&gt; 复选框 &lt;input type=&quot;radio&quot; value=&quot;V1&quot; checked name=&quot;R1&quot;&gt; 单选按钮 &lt;select size=&quot;1&quot; name=&quot;D1&quot;&gt;&lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项 2&lt;/option&gt;&lt;/select&gt; 列表菜单 &lt;textarea rows=&quot;1&quot; name=&quot;1&quot; cols=&quot;15&quot;&gt; 多行文本域 七、CSS 边界样式 margin-top:10px; 上边界 margin-right:10px; 右边界值 margin-bottom:10px; 下边界值 margin-left:10px; 左边界值 八、CSS 边框空白 padding-top:10px; 上边框留空白 padding-right:10px; 右边框留空白 padding-bottom:10px; 下边框留空白 padding-left:10px; 左边框留空白 附录 css常用属性思维导图总结","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"css常用属性梳理（一）","slug":"css常用属性梳理（一）","date":"2014-06-25T15:24:17.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/06/25/css常用属性梳理（一）/","link":"","permalink":"http://yoursite.com/2014/06/25/css常用属性梳理（一）/","excerpt":"","text":"代码 说明 类型 font-family 字体 font-size 字体大小 font-style 字体样式 italic 斜体 oblique 扁斜体 line-height 行高 font-weight 字体粗细 font-variant 字体变形 small-caps 小型大写字母 text-transform 大小写 capitalize 首字母大写 uppercase 大写字母 lowercase 小写字母 text-decathlon 文本修饰 underline 下划线 overline 上划线 line-through 删除线 blink 闪烁 none 无 color 颜色 背景 background-color 背景颜色 background-image 背景图片 background-repeat 背景重复 background-attachment 附件 fixed 固定的 scroll 滚动 background-position（x） 背景水平位置 background-position（y） 背景垂直位置 right 右对齐 left 左对齐 center 居中对齐 区块 word-spacing 单词间距 letter-spacing 字母间距 vertical-align 垂直对齐 baseline 基线 sub 下标 super 上标 top 顶部 text-top 文本顶对齐 middle 中线对齐 bottom 顶部 text-bottom 文本底对齐 text-align 文本对齐 text-indent 文本缩进 white-space 空格 normal 正常 pre 保留 nowrap 不换行 display 显示 inline 内联 bloc 块 list-item 列表项 run-in 追加部分 inline-block 内嵌块 compact 紧凑 marker 标志 table 表格 inline-table 内嵌表格 table-row-group 表格行组 table-row 表格行 table-column 表格列 table-cell 表格单元格 table-captaion 表格标题 方框 width 宽度 height 高度 float 浮动 clear 清除 padding 内边距 margin 外边距 top 上 bottom 下 边框 style 样式 dotted 点划线 dashed 虚线 solid 实线 double 双线 groove 槽状 inset 凸状 outset 突出 列表 list-style-type 类型 disc 网点 circle 圆圈 square 方块 decimal 数字 lower-roman 小写罗马数字 upper-roman 大写罗马数字 lower-alpha 小写字母 list-style-image 项目符号图像 list-style-position 位置 inside 内 outside 外 定位 position 位置 absolute 绝对 fixed 固定 relative 相对 static 静态 visibility 显示 inherit 继承 visible 可见 hidden 隐藏 width 宽度 z-index 设置层数 overflow 溢出 placement 定位 clip 剪辑 扩展 page-break-before 之前 page-break-afetr 之后 auto 自动 always 总是 cursor 光标 filter 过滤器","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"css常用代码片段","slug":"css代码片段","date":"2014-06-25T12:21:17.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/06/25/css代码片段/","link":"","permalink":"http://yoursite.com/2014/06/25/css代码片段/","excerpt":"1、垂直对齐 如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑： 1234567.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性","text":"1、垂直对齐 如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑： 1234567.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的，Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性 2、伸展一个元素到窗口高度 在具体场景中，你可能想要将一个元素伸展到窗口高度，基本元素的调整只能调整容器的大小,因此要使一个元素伸展到窗口高度，我们需要伸展顶层元素：html和body: 1234html, body &#123; height: 100%;&#125; 然后将100%应用到任何元素的高 123div &#123; height: 100%;&#125; 3、基于文件格式使用不同的样式 为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片： 123456789101112131415a[href^=\"http://\"]&#123; padding-right: 20px; background: url(external.gif) no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"]&#123; padding-right: 20px; background: url(email.png) no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"]&#123; padding-right: 20px; background: url(pdf.png) no-repeat center right;&#125; 效果演示 4、创建跨浏览器的图像灰度 灰度有时看起来简约和优雅，能为网站呈现更深层次的色调。在示例中，我们将对一个SVG图像添加灰度过滤： 12345&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;filter id=&quot;grayscale&quot;&gt; &lt;feColorMatrix type=&quot;matrix&quot; values=&quot;0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0&quot;/&gt; &lt;/filter&gt;&lt;/svg&gt; 为了跨浏览器，会用到filter属性： 12345img &#123; filter: url(filters.svg#grayscale); /* Firefox 3.5+ */ filter: gray; /* IE6-9 */ -webkit-filter: grayscale(1); /* Google Chrome, Safari 6+ &amp; Opera 15+ */&#125; 5、背景渐变动画 CSS中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。 123456789button &#123; background-image: linear-gradient(#5187c4, #1c2f45); background-size: auto 200%; background-position: 0 100%; transition: background-position 0.5s;&#125; button:hover &#123; background-position: 0 0;&#125; 效果演示： 6、CSS：表格列宽自适用 对于表格，当谈到调整列宽时，是比较痛苦的。然后，这里有一个可以使用的技巧：给td元素添加white-space: nowrap;能让文本正确的换行 123td &#123; white-space: nowrap;&#125; 演示 7、只在一边或两边显示盒子阴影 如果你要一个盒阴影，试试这个技巧，能为任一边添加阴影。为了实现这个，首先定义一个有具体宽高的盒子，然后正确定位:after伪类。实现底边阴影的代码如下 123456789101112131415161718192021222324.box-shadow &#123; background-color: #FF8020; width: 160px; height: 90px; margin-top: -45px; margin-left: -80px; position: absolute; top: 50%; left: 50%;&#125;.box-shadow:after &#123; content: \"\"; width: 150px; height: 1px; margin-top: 88px; margin-left: -75px; display: block; position: absolute; left: 50%; z-index: -1; -webkit-box-shadow: 0px 0px 8px 2px #000000; -moz-box-shadow: 0px 0px 8px 2px #000000; box-shadow: 0px 0px 8px 2px #000000;&#125; 演示 8、包裹长文本 如果你碰到一个比自身容器长的文本，这个技巧对你很有用。在这个示例中，默认时，不管容器的宽度，文本都将水平填充。 简单的CSS代码就能在容器中调整文本： 1234pre &#123; white-space: pre-line; word-wrap: break-word;&#125; 效果看起来如下： 9、制造模糊文本 想要让文本模糊？可以使用color透明和text-shadow实现 1234.blurry-text &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; 演示 10、用CSS动画实现省略号动画 这个片段将帮助你制造一个ellipsis的动画，对于简单的加载状态是很有用的，而不用去使用gif图像。 123456789101112131415.loading:after &#123; overflow: hidden; display: inline-block; vertical-align: bottom; animation: ellipsis 2s infinite; content: \"\\2026\"; /* ascii code for the ellipsis character */&#125;@keyframes ellipsis &#123; from &#123; width: 2px; &#125; to &#123; width: 15px; &#125;&#125; 演示 11、样式重置 12345678910111213141516171819202122html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; outline: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;html &#123; height: 101%; &#125;body &#123; font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; &#125;article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125;ol, ul &#123; list-style: none; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125;strong &#123; font-weight: bold; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125;img &#123; border: 0; max-width: 100%; &#125;p &#123; font-size: 1.2em; line-height: 1.0em; color: #333; &#125; 12、典型的CSS清除浮动 1234.clearfix:after &#123; content: \".\"; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; &#125;.clearfix &#123; display: inline-block; &#125;html[xmlns] .clearfix &#123; display: block; &#125;* html .clearfix &#123; height: 1%; &#125; 13、新版清除浮动（2011） 1234.clearfix:before, .container:after &#123; content: \"\"; display: table; &#125;.clearfix:after &#123; clear: both; &#125;/* IE 6/7 */.clearfix &#123; zoom: 1; &#125; 14、跨浏览器的透明 123456.transparent &#123; filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */&#125; 15、CSS引用模板 123456789101112131415161718blockquote &#123; background: #f9f9f9; border-left: 10px solid #ccc; margin: 1.5em 10px; padding: .5em 10px; quotes: \"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";&#125;blockquote:before &#123; color: #ccc; content: open-quote; font-size: 4em; line-height: .1em; margin-right: .25em; vertical-align: -.4em;&#125;blockquote p &#123; display: inline;&#125; 16、个性圆角 1234567891011121314151617#container &#123; -webkit-border-radius: 4px 3px 6px 10px; -moz-border-radius: 4px 3px 6px 10px; -o-border-radius: 4px 3px 6px 10px; border-radius: 4px 3px 6px 10px;&#125;/* alternative syntax broken into each line */#container &#123; -webkit-border-top-left-radius: 4px; -webkit-border-top-right-radius: 3px; -webkit-border-bottom-right-radius: 6px; -webkit-border-bottom-left-radius: 10px; -moz-border-radius-topleft: 4px; -moz-border-radius-topright: 3px; -moz-border-radius-bottomright: 6px; -moz-border-radius-bottomleft: 10px;&#125; 17、通用媒体查询 12345678910111213141516171819202122232425262728293031323334353637/* Smartphones (portrait and landscape) ----------- */@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123; /* Styles */&#125;/* Smartphones (landscape) ----------- */@media only screen and (min-width : 321px) &#123; /* Styles */&#125;/* Smartphones (portrait) ----------- */@media only screen and (max-width : 320px) &#123; /* Styles */&#125;/* iPads (portrait and landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123; /* Styles */&#125;/* iPads (landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123; /* Styles */&#125;/* iPads (portrait) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123; /* Styles */&#125;/* Desktops and laptops ----------- */@media only screen and (min-width : 1224px) &#123; /* Styles */&#125;/* Large screens ----------- */@media only screen and (min-width : 1824px) &#123; /* Styles */&#125;/* iPhone 4 ----------- */@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) &#123; /* Styles */&#125; 18、现代字体栈 12345678910111213141516/* Times New Roman-based serif */font-family: Cambria, \"Hoefler Text\", Utopia, \"Liberation Serif\", \"Nimbus Roman No9 L Regular\", Times, \"Times New Roman\", serif;/* A modern Georgia-based serif */font-family: Constantia, \"Lucida Bright\", Lucidabright, \"Lucida Serif\", Lucida, \"DejaVu Serif,\" \"Bitstream Vera Serif\", \"Liberation Serif\", Georgia, serif;/*A more traditional Garamond-based serif */font-family: \"Palatino Linotype\", Palatino, Palladio, \"URW Palladio L\", \"Book Antiqua\", Baskerville, \"Bookman Old Style\", \"Bitstream Charter\", \"Nimbus Roman No9 L\", Garamond, \"Apple Garamond\", \"ITC Garamond Narrow\", \"New Century Schoolbook\", \"Century Schoolbook\", \"Century Schoolbook L\", Georgia, serif;/*The Helvetica/Arial-based sans serif */font-family: Frutiger, \"Frutiger Linotype\", Univers, Calibri, \"Gill Sans\", \"Gill Sans MT\", \"Myriad Pro\", Myriad, \"DejaVu Sans Condensed\", \"Liberation Sans\", \"Nimbus Sans L\", Tahoma, Geneva, \"Helvetica Neue\", Helvetica, Arial, sans-serif;/*The Verdana-based sans serif */font-family: Corbel, \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Liberation Sans\", Verdana, \"Verdana Ref\", sans-serif;/*The Trebuchet-based sans serif */font-family: \"Segoe UI\", Candara, \"Bitstream Vera Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Trebuchet MS\", Verdana, \"Verdana Ref\", sans-serif;/*The heavier \"Impact\" sans serif */font-family: Impact, Haettenschweiler, \"Franklin Gothic Bold\", Charcoal, \"Helvetica Inserat\", \"Bitstream Vera Sans Bold\", \"Arial Black\", sans-serif;/*The monospace */font-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace; 19、自定义文本选择 123::selection &#123; background: #e2eae2; &#125;::-moz-selection &#123; background: #e2eae2; &#125;::-webkit-selection &#123; background: #e2eae2; &#125; 20、为logo隐藏H1 1234567h1 &#123; text-indent: -9999px; margin: 0 auto; width: 320px; height: 85px; background: transparent url(\"images/logo.png\") no-repeat scroll;&#125; 21、图片边框偏光 12345678910img.polaroid &#123; background:#000; /*Change this to a background image or remove*/ border:solid #fff; border-width:6px 6px 20px 6px; box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */ -webkit-box-shadow:1px 1px 5px #333; -moz-box-shadow:1px 1px 5px #333; height:200px; /*Set to height of your image or desired div*/ width:200px; /*Set to width of your image or desired div*/&#125; 22、锚链接伪类 1234a:link &#123; color: blue; &#125;a:visited &#123; color: purple; &#125;a:hover &#123; color: red; &#125;a:active &#123; color: yellow; &#125; 23、奇特的CSS引用 1234567891011121314151617181920212223242526272829303132.has-pullquote:before &#123; /* Reset metrics. */ padding: 0; border: none; /* Content */ content: attr(data-pullquote); /* Pull out to the right, modular scale based margins. */ float: right; width: 320px; margin: 12px -140px 24px 36px; /* Baseline correction */ position: relative; top: 5px; /* Typography (30px line-height equals 25% incremental leading) */ font-size: 23px; line-height: 30px;&#125;.pullquote-adelle:before &#123; font-family: \"adelle-1\", \"adelle-2\"; font-weight: 100; top: 10px !important;&#125;.pullquote-helvetica:before &#123; font-family: \"Helvetica Neue\", Arial, sans-serif; font-weight: bold; top: 7px !important;&#125;.pullquote-facit:before &#123; font-family: \"facitweb-1\", \"facitweb-2\", Helvetica, Arial, sans-serif; font-weight: bold; top: 7px !important;&#125; 24、CSS3：全屏背景 1234567html &#123; background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover;&#125; 25、内容垂直居中 12345.container &#123; min-height: 6.5em; display: table-cell; vertical-align: middle;&#125; 26、强制出现垂直滚动条 1html &#123; height: 101% &#125; 27、CSS3渐变模板 123456789#colorbox &#123; background: #629721; background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721)); background-image: -webkit-linear-gradient(top, #83b842, #629721); background-image: -moz-linear-gradient(top, #83b842, #629721); background-image: -ms-linear-gradient(top, #83b842, #629721); background-image: -o-linear-gradient(top, #83b842, #629721); background-image: linear-gradient(top, #83b842, #629721);&#125; 28、@font-face模板 1234567891011@font-face &#123; font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125;body &#123; font-family: 'MyWebFont', Arial, sans-serif;&#125; 29、缝合CSS3元素 123456789101112131415161718192021222324252627282930313233p &#123; position:relative; z-index:1; padding: 10px; margin: 10px; font-size: 21px; line-height: 1.3em; color: #fff; background: #ff0030; -webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); -moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5); -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;&#125;p:before &#123; content: \"\"; position: absolute; z-index: -1; top: 3px; bottom: 3px; left :3px; right: 3px; border: 2px dashed #fff;&#125;p a &#123; color: #fff; text-decoration:none;&#125;p a:hover, p a:focus, p a:active &#123; text-decoration:underline;&#125; 30、CSS3 斑马线 123tbody tr:nth-child(odd) &#123; background-color: #ccc;&#125; 31、有趣的&amp; 12345.amp &#123; font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif; font-style: italic; font-weight: normal;&#125; 32、大字段落 12345678p:first-letter&#123; display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif;&#125; 33、内部CSS3 盒阴影 12345#mydiv &#123; -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000;&#125; 34、外部CSS3 盒阴影 12345#mydiv &#123; -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);&#125; 35、三角形列表项目符号 1234567891011121314151617ul &#123; margin: 0.75em 0; padding: 0 1em; list-style: none;&#125;li:before &#123; content: \"\"; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative;&#125; 36、固定宽度的居中布局 1234#page-wrap &#123; width: 800px; margin: 0 auto;&#125; 37、CSS3 列文本 123456789#columns-3 &#123; text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc;&#125; 38、CSS固定页脚 12345678910111213#footer &#123; position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444;&#125;/* IE 6 */* html #footer &#123; position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');&#125; 39、IE6的PNG透明修复 12345678910111213141516.bg &#123; width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png',sizingMethod='crop');&#125;/* 1px gif method */img, .png &#123; position: relative; behavior: expression((this.runtimeStyle.behavior=\"none\")&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == \"IMG\" &amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = \"none\", this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.src + \"', sizingMethod='image')\", this.src = \"images/transparent.gif\"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url(\"','').replace('\")',''), this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.origBg + \"', sizingMethod='crop')\", this.runtimeStyle.backgroundImage = \"none\")),this.pngSet=true));&#125; 40、跨浏览器设置最小高度 12345#container &#123; min-height: 550px; height: auto !important; height: 550px;&#125; 41、CSS3 鲜艳的输入 12345678910111213141516input[type=text], textarea &#123; -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd;&#125;input[type=text]:focus, textarea:focus &#123; box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1);&#125; 42、基于文件类型的链接样式 123456789101112131415/* external links */a[href^=\"http://\"] &#123; padding-right: 13px; background: url('external.gif') no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"] &#123; padding-right: 20px; background: url('email.png') no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"] &#123; padding-right: 18px; background: url('acrobat.png') no-repeat center right;&#125; 43、强制换行 1234567pre &#123; white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap; /* Mozilla, since 1999 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ word-wrap: break-word; /* Internet Explorer 5.5+ */&#125; 44、在可点击的项目上强制手型 123a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer &#123; cursor: pointer;&#125; 45、网页顶部盒阴影 123456789101112body:before &#123; content: \"\"; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;&#125; 46、CSS3对话气泡 123456789101112131415161718192021222324252627282930313233343536.chat-bubble &#123; background-color: #ededed; border: 2px solid #666; font-size: 35px; line-height: 1.3em; margin: 10px auto; padding: 10px; position: relative; text-align: center; width: 300px; -moz-border-radius: 20px; -webkit-border-radius: 20px; -moz-box-shadow: 0 0 5px #888; -webkit-box-shadow: 0 0 5px #888; font-family: 'Bangers', arial, serif; &#125;.chat-bubble-arrow-border &#123; border-color: #666 transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -42px; left: 30px;&#125;.chat-bubble-arrow &#123; border-color: #ededed transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -39px; left: 30px;&#125; 47、H1-H5默认样式 1234567891011121314151617181920212223h1,h2,h3,h4,h5&#123; color: #005a9c;&#125;h1&#123; font-size: 2.6em; line-height: 2.45em;&#125;h2&#123; font-size: 2.1em; line-height: 1.9em;&#125;h3&#123; font-size: 1.8em; line-height: 1.65em;&#125;h4&#123; font-size: 1.65em; line-height: 1.4em;&#125;h5&#123; font-size: 1.4em; line-height: 1.25em;&#125; 48、纯CSS背景噪音 1234body &#123; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==); background-color: #0094d0;&#125; 49、持久的列表排序 1234567891011121314151617181920ol.chapters &#123; list-style: none; margin-left: 0;&#125;ol.chapters &gt; li:before &#123; content: counter(chapter) \". \"; counter-increment: chapter; font-weight: bold; float: left; width: 40px;&#125;ol.chapters li &#123; clear: left;&#125;ol.start &#123; counter-reset: chapter;&#125;ol.continue &#123; counter-reset: chapter 11;&#125; 50、CSS悬浮提示文本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061a &#123; border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none;&#125;a:hover,a:focus &#123; color:#36c;&#125;a:active &#123; top:1px; &#125;/* Tooltip styling */a[data-tooltip]:after &#123; border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: \"\"; display: none; height: 0; width: 0; left: 25%; position: absolute;&#125;a[data-tooltip]:before &#123; background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125;a[data-tooltip]:hover:after &#123; display: block; top: -9px;&#125;a[data-tooltip]:hover:before &#123; display: block; top: -41px;&#125;a[data-tooltip]:active:after &#123; top: -10px;&#125;a[data-tooltip]:active:before &#123; top: -42px;&#125; 51、深灰色的圆形按钮 12345678910111213141516171819202122232425262728293031.graybtn &#123; -moz-box-shadow:inset 0px 1px 0px 0px #ffffff; -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff; box-shadow:inset 0px 1px 0px 0px #ffffff; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) ); background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1'); background-color:#ffffff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #dcdcdc; display:inline-block; color:#777777; font-family:arial; font-size:15px; font-weight:bold; padding:6px 24px; text-decoration:none; text-shadow:1px 1px 0px #ffffff;&#125;.graybtn:hover &#123; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) ); background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff'); background-color:#d1d1d1;&#125;.graybtn:active &#123; position:relative; top:1px;&#125; 52、在可打印的网页中显示URLs 12345@media print &#123; a:after &#123; content: \" [\" attr(href) \"] \"; &#125; &#125; 53、禁用移动Webkit的选择高亮 12345678body &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 54、CSS3 圆点图案 12345body &#123; background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px; background-size: 100px 100px;&#125; 55、CSS3 方格图案 1234567body &#123; background-color: white; background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black); background-size: 100px 100px; background-position: 0 0, 50px 50px;&#125; 56、Github的fork色带 1234567891011121314151617181920212223242526.ribbon &#123; background-color: #a00; overflow: hidden; /* top left corner */ position: absolute; left: -3em; top: 2.5em; /* 45 deg ccw rotation */ -moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); /* shadow */ -moz-box-shadow: 0 0 1em #888; -webkit-box-shadow: 0 0 1em #888;&#125;.ribbon a &#123; border: 1px solid #faa; color: #fff; display: block; font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif; margin: 0.05em 0 0.075em 0; padding: 0.5em 3.5em; text-align: center; text-decoration: none; /* shadow */ text-shadow: 0 0 0.5em #444;&#125; 57、CSS font属性缩写 123p &#123; font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;&#125; 58、论文页面的卷曲效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ul.box &#123; position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0; &#125;ul.box li &#123; position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; &#125;ul.box li:before,ul.box li:after &#123; content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg); &#125;ul.box li:after &#123; left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg); &#125; 59、鲜艳的锚链接 123456789101112131415161718192021222324a &#123; color: #00e;&#125;a:visited &#123; color: #551a8b;&#125;a:hover &#123; color: #06e;&#125;a:focus &#123; outline: thin dotted;&#125;a:hover, a:active &#123; outline: 0;&#125;a, a:visited, a:active &#123; text-decoration: none; color: #fff; -webkit-transition: all .3s ease-in-out;&#125;a:hover, .glow &#123; color: #ff0; text-shadow: 0 0 10px #ff0;&#125; 60、带CSS3特色的横幅显示 12345678910111213141516171819202122232425262728.featureBanner &#123; position: relative; margin: 20px&#125;.featureBanner:before &#123; content: \"Featured\"; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1;&#125;.featureBanner:after &#123; content: \"\"; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS块级元素和行内元素","slug":"CSS块级元素和行内元素","date":"2014-03-16T08:24:08.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2014/03/16/CSS块级元素和行内元素/","link":"","permalink":"http://yoursite.com/2014/03/16/CSS块级元素和行内元素/","excerpt":"HTML中的元素可分为两种类型：块级元素和行级元素。这些元素的类型是通过文档类型定义（DTD）来指明。块级元素：显示在一块内，会自动换行，元素会从上到下垂直排列，各自占一行，如p,ul,form,div等标签元素。行内元素：元素在一行内水平排列，高度由元素的内容决定，height属性不起作用，如span,input等元素。","text":"HTML中的元素可分为两种类型：块级元素和行级元素。这些元素的类型是通过文档类型定义（DTD）来指明。块级元素：显示在一块内，会自动换行，元素会从上到下垂直排列，各自占一行，如p,ul,form,div等标签元素。行内元素：元素在一行内水平排列，高度由元素的内容决定，height属性不起作用，如span,input等元素。 一、块级元素：block element 每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。 DIV 是最常用的块级元素，元素样式的display:block都是块级元素。它们总是以一个块的形式表现出来，并且跟同级的兄弟块依次竖直排列，左右撑满。 二、行内元素：inline element 也叫内联元素、内嵌元素等；行内元素一般都是基于语义级(semantic)的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的display : inline的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。 三、block（块）元素的特点: ①、总是在新行上开始；②、高度，行高以及外边距和内边距都可控制；③、宽度缺省是它的容器的100%，除非设定一个宽度。④、它可以容纳内联元素和其他块元素 四、inline元素的特点 ①、和其他元素都在一行上；②、高，行高及外边距和内边距不可改变；③、宽度就是它的文字或图片的宽度，不可改变④、内联元素只能容纳文本或者其他内联元素 对行内元素，需要注意如下: 设置宽度width 无效。 设置高度height 无效，可以通过line-height来设置。 设置margin只有左右margin有效，上下无效。设置padding只有左右padding有效，上下则无效。注意元素范围是增大了，但是对元素周围的内容是没影响的。 五、常见的块状元素 address – 地址blockquote – 块引用center – 举中对齐块dir – 目录列表div – 常用块级容易，也是CSS layout的主要标签dl – 定义列表fieldset – form控制组form – 交互表单h1 – 大标题h2 – 副标题h3 – 3级标题h4 – 4级标题h5 – 5级标题h6 – 6级标题hr – 水平分隔线isindex – input promptmenu – 菜单列表noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容noscript – 可选脚本内容（对于不支持script的浏览器显示此内容）ol – 有序表单p – 段落pre – 格式化文本table – 表格ul – 无序列表 六、常见的内联元素 a – 锚点abbr – 缩写acronym – 首字b – 粗体(不推荐)bdo – bidi overridebig – 大字体br – 换行cite – 引用code – 计算机代码(在引用源码的时候需要)dfn – 定义字段em – 强调font – 字体设定(不推荐)i – 斜体img – 图片input – 输入框kbd – 定义键盘文本label – 表格标签q – 短引用s – 中划线(不推荐)samp – 定义范例计算机代码select – 项目选择small – 小字体文本span – 常用内联容器，定义文本内区块strike – 中划线strong – 粗体强调sub – 下标sup – 上标textarea – 多行文本输入框tt – 电传文本u – 下划线 七，可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 八、行内元素与块级元素有什么不同 区别一： 块级：块级元素会独占一行，默认情况下宽度自动填满其父元素宽度 行内：行内元素不会独占一行，相邻的行内元素会排在同一行。其宽度随内容的变化而变化。 区别二： 块级：块级元素可以设置宽高 行内：行内元素不可以设置宽高 区别三： 块级：块级元素可以设置margin，padding 行内：行内元素水平方向的margin-left; margin-right; padding-left; padding-right;可以生效。但是竖直方向的margin-bottom; margin-top; padding-top; padding-bottom;却不能生效。 区别四： 块级：display:block; 行内：display:inline; 可以通过修改display属性来切换块级元素和行内元素","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"原生JS与jQuery操作DOM对比","slug":"js-and-jquery-dom-compare","date":"2011-01-14T03:30:43.000Z","updated":"2018-03-29T10:23:38.000Z","comments":true,"path":"2011/01/14/js-and-jquery-dom-compare/","link":"","permalink":"http://yoursite.com/2011/01/14/js-and-jquery-dom-compare/","excerpt":"一、创建元素节点 1.1 原生JS创建元素节点 1document.createElement(\"p\"); 1.2 jQuery创建元素节点","text":"一、创建元素节点 1.1 原生JS创建元素节点 1document.createElement(\"p\"); 1.2 jQuery创建元素节点 1$('&lt;p&gt;&lt;/p&gt;');` 二、创建并添加文本节点 2.1 原生JS创建文本节点 1`document.createTextNode(\"Text Content\"); 通常创建文本节点和创建元素节点配合使用，比如： 123var textEl = document.createTextNode(\"Hello World.\");var pEl = document.createElement(\"p\");pEl.appendChild(textEl); 2.2 jQuery创建并添加文本节点： 1var $p = $('&lt;p&gt;Hello World.&lt;/p&gt;'); 三、复制节点 3.1 原生JS复制节点: 1var newEl = pEl.cloneNode(true); ` true和false的区别： true ：克隆整个&#39;&lt;p&gt;Hello World.&lt;/p&gt;&#39;节点 false：只克隆&#39;&lt;p&gt;&lt;/p&gt;&#39; ，不克隆文本Hello World.&#39; 3.2 jQuery复制节点 1$newEl = $('#pEl').clone(true); 注意：克隆节点要避免`ID重复 四、 插入节点 4.1 原生JS向子节点列表的末尾添加新的子节点 1El.appendChild(newNode); 原生JS在节点的已有子节点之前插入一个新的子节点： 1El.insertBefore(newNode, targetNode); 4.2 在jQuery中，插入节点的方法比原生JS多的多 在匹配元素子节点列表结尾添加内容 1$('#El').append('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素子节点列表结尾 1$('&lt;p&gt;Hello World.&lt;/p&gt;').appendTo('#El'); 在匹配元素子节点列表开头添加内容 1$('#El').prepend('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素子节点列表开头 1$('&lt;p&gt;Hello World.&lt;/p&gt;').prependTo('#El'); 在匹配元素之前添加目标内容 1$('#El').before('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素之前 1$('&lt;p&gt;Hello World.&lt;/p&gt;').insertBefore('#El'); 在匹配元素之后添加目标内容 1$('#El').after('&lt;p&gt;Hello World.&lt;/p&gt;'); 把匹配元素添加到目标元素之后 1$('&lt;p&gt;Hello World.&lt;/p&gt;').insertAfter('#El'); 五、删除节点 5.1 原生JS删除节点 1El.parentNode.removeChild(El); 5.2 jQuery删除节点 1$('#El').remove(); 六、替换节点 6.1 原生JS替换节点 1El.repalceChild(newNode, oldNode); 注意：oldNode必须是parentEl真实存在的一个子节点 6.2 jQuery替换节点 1$('p').replaceWith('&lt;p&gt;Hello World.&lt;/p&gt;'); 七、设置属性/获取属性 7.1 原生JS设置属性/获取属性 1234imgEl.setAttribute(\"title\", \"logo\");imgEl.getAttribute(\"title\");checkboxEl.checked = true;checkboxEl.checked; 7.2 jQuery设置属性/获取属性: 1234$(\"#logo\").attr(&#123;\"title\": \"logo\"&#125;);$(\"#logo\").attr(\"title\");$(\"#checkbox\").prop(&#123;\"checked\": true&#125;);$(\"#checkbox\").prop(\"checked\");","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]}]}