<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>_sUper.LEE的个人空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-29T10:23:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>_sUper.LEE</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序一些常用方法</title>
    <link href="http://yoursite.com/2017/09/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/09/30/微信小程序方法/</id>
    <published>2017-09-30T03:16:12.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h4><hr><blockquote><p>最近一个月都在写小程序，有用到一些封装方法和深坑记录一下</p></blockquote><p>1.微信小程序路由跳转<code>navigateTo</code>封装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const parse = (query) =&gt; &#123;</span><br><span class="line">  return Object.keys(query).map(key =&gt; `$&#123;key&#125;=$&#123;query[key]&#125;`).join(&apos;&amp;&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  go(url, query = &#123;&#125;) &#123;</span><br><span class="line">    console.log(url)</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      wx.navigateTo(&#123;</span><br><span class="line">        url: `$&#123;url&#125;?$&#123;parse(query)&#125;`,</span><br><span class="line">        success: resolve,</span><br><span class="line">        fail: reject</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  replace(url, query = &#123;&#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      wx.redirectTo(&#123;</span><br><span class="line">        url: `$&#123;url&#125;?$&#123;parse(query)&#125;`,</span><br><span class="line">        success: resolve,</span><br><span class="line">        fail: reject</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  back(delta) &#123;</span><br><span class="line">    wx.navigateBack(&#123; delta &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>promise</code>封装<code>request</code>请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require(&apos;../plugins/es6-promise.js&apos;)</span><br><span class="line"></span><br><span class="line">function wxPromisify(fn) &#123;</span><br><span class="line">  return function (obj = &#123;&#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      obj.success = function (res) &#123;</span><br><span class="line">        //成功</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">      obj.fail = function (res) &#123;</span><br><span class="line">        //失败</span><br><span class="line">        reject(res)</span><br><span class="line">      &#125;</span><br><span class="line">      fn(obj)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//无论promise对象最后状态如何都会执行</span><br><span class="line">Promise.prototype.finally = function (callback) &#123;</span><br><span class="line">  let P = this.constructor;</span><br><span class="line">  return this.then(</span><br><span class="line">    value =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 微信请求get方法</span><br><span class="line"> * url</span><br><span class="line"> * data 以对象的格式传入</span><br><span class="line"> */</span><br><span class="line">function getRequest(url, data) &#123;</span><br><span class="line">  var getRequest = wxPromisify(wx.request)</span><br><span class="line">  return getRequest(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    data: data,</span><br><span class="line">    header: &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 微信请求post方法封装</span><br><span class="line"> * url</span><br><span class="line"> * data 以对象的格式传入</span><br><span class="line"> */</span><br><span class="line">function postRequest(url, data) &#123;</span><br><span class="line">  var postRequest = wxPromisify(wx.request)</span><br><span class="line">  return postRequest(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    data: data,</span><br><span class="line">    header: &#123;</span><br><span class="line">      &quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  postRequest: postRequest,</span><br><span class="line">  getRequest: getRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小程序不支持<code>promise</code>所以先引入<code>promise</code>库才行<br>3.<code>promise</code>封装<code>storage</code>请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">var Promise = require(&apos;../plugins/es6-promise.js&apos;)</span><br><span class="line"></span><br><span class="line">function wxPromisify(fn) &#123;</span><br><span class="line">  return function (obj = &#123;&#125;) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      obj.success = function (res) &#123;</span><br><span class="line">        //成功</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">      obj.fail = function (res) &#123;</span><br><span class="line">        //失败</span><br><span class="line">        reject(res)</span><br><span class="line">      &#125;</span><br><span class="line">      fn(obj)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//无论promise对象最后状态如何都会执行</span><br><span class="line">Promise.prototype.finally = function (callback) &#123;</span><br><span class="line">  let P = this.constructor;</span><br><span class="line">  return this.then(</span><br><span class="line">    value =&gt; P.resolve(callback()).then(() =&gt; value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">//异步设置storage</span><br><span class="line">function setStorage(keys, value) &#123;</span><br><span class="line">  wx.setStorage(&#123;</span><br><span class="line">    key: keys,</span><br><span class="line">    data: value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同步设置storage</span><br><span class="line">function setStorageSync(keys, value) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    wx.setStorageSync(kes, value)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异步获取stotage</span><br><span class="line">function getStorage(keys) &#123;</span><br><span class="line">  let getStorage = wxPromisify(wx.getStorage)</span><br><span class="line">  return getStorage(&#123;</span><br><span class="line">    key: keys</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同步获取storage</span><br><span class="line">function getStorageSync(keys) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var value = wx.getStorageSync(keys)</span><br><span class="line">    if (value) &#123;</span><br><span class="line">      // Do something with return value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    // Do something when catch error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除指定key storage</span><br><span class="line">function removeStorage(obj) &#123;</span><br><span class="line">  let removeStorage = wxPromisify(wx.removeStorage);</span><br><span class="line">  return removeStorage(&#123;</span><br><span class="line">    key: obj</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  setStorage,</span><br><span class="line">  setStorageSync,</span><br><span class="line">  getStorage,</span><br><span class="line">  getStorageSync,</span><br><span class="line">  removeStorage,</span><br><span class="line">  clearStorageSync: wx.clearStorageSync(),</span><br><span class="line">  clearStorage: wx.clearStorage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>项目中还遇到html转wxml用wxParse解决<a href="https://github.com/icindy/wxParse；" target="_blank" rel="noopener">https://github.com/icindy/wxParse；</a></li><li>微信小程序启动时，调用生命周期方法为：<code>onLaunch</code>方法<code>（app.js）</code>—<code>onShow</code>方法<code>（app.js）---onLoad</code>方法（首页面：<code>index.js</code>的<code>onLoad</code>方法）；所以如果在<code>app.js</code>里面去获取用户信息操作<code>token</code>，在<code>index</code>页面使用会出现异步还没获取到数据就执行,一般情况用<code>promise</code>就可以直接解决问题，稍微麻烦的一般使用<code>settimeout</code>去解决。</li><li>项目中还用上了<code>socket</code>实时更新数据，比较坑的地方就是小程序的<code>socket</code>只能连接60秒就断，可以让用户上拉刷新，试了定时器方法，但是由于会频繁的去操作<code>setData</code>考虑到性能问题并没有使用.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h4&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;最近一个月都在写小程序，有用到一些封装方法和深坑记录一下&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="Wechat" scheme="http://yoursite.com/categories/Wechat/"/>
    
    
      <category term="Wechat" scheme="http://yoursite.com/tags/Wechat/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router整理</title>
    <link href="http://yoursite.com/2017/09/12/vue-router%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/09/12/vue-router总结/</id>
    <published>2017-09-12T14:24:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>##VUE-ROUTER API文档</p><hr><p><br></p><h3 id="一-lt-router-link-gt"><a href="#一-lt-router-link-gt" class="headerlink" title="一.&lt;router-link&gt;"></a>一.<code>&lt;router-link&gt;</code></h3><p>1.<code>Props</code></p><ul><li><code>to</code><ul><li>类型:<code>string</code> | <code>Location</code></li><li><code>required</code><br>表示目标路由的链接。当被点击后，内部会立刻把<code>to</code>的值传到<code>router.push()</code>，所以这个值是可以一个字符串或者是描述目标位置的对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 字符串 --&gt;</span><br><span class="line"> &lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line"> &lt;!-- 渲染结果 --&gt;</span><br><span class="line"> &lt;a href=&quot;home&quot;&gt;Home&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span><br><span class="line"> &lt;router-link v-bind:to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;</span><br><span class="line"> &lt;router-link :to=&quot;&apos;home&apos;&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 同上 --&gt;</span><br><span class="line"> &lt;router-link :to=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 命名的路由 --&gt;</span><br><span class="line"> &lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;</span><br><span class="line"> &lt;router-link :to=&quot;&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;&quot;&gt;Register&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><code>to</code>可以是字符串或者表达式，动态设置需要加上<code>v-bind</code>或：  <code>path</code>路径 <code>params</code>传参 <code>query</code>问号后面的值。</p><ul><li><code>replace</code></li><li>类型:<code>boolean</code></li><li>默认值:<code>false</code><br>设置了<code>replace</code>的属性话，当点击时，会调用<code>router.replace()</code>而不是<code>router.push()</code><br>于是导航不会留下<code>history</code>记录。<br><code>&lt;router-link :to=&quot;{path: &#39;/home&#39;} replace&gt;&lt;/router-link&gt;&quot;</code></li><li><code>append</code></li><li>类型:<code>boolean</code></li><li>默认值:<code>false</code><br>设置<code>append</code>属性后，则在当前(相对)路径前添加基路径。例如，我们从/a导航到一个相对路径<code>b</code>，如果没有配置<code>append</code>，则路径为<code>/b</code>,如果赔了，则为<code>/a/b</code><br><code>&lt;router-link :to=&quot;{path : &quot;relative/path&quot; append} &lt;/router-link&gt;&quot;</code></li><li><code>tag</code><ul><li>类型: <code>string</code></li><li>默认值: <code>&quot;a&quot;</code><br>有时候想要 <code>&lt;router-link&gt;</code> 渲染成某种标签，例如 <code>&lt;li&gt;</code>。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt;</span><br><span class="line">&lt;!-- 渲染结果 --&gt;</span><br><span class="line">&lt;li&gt;foo&lt;/li&gt;</span><br></pre></td></tr></table></figure><ul><li><code>active-class</code></li><li>类型:<code>string</code></li><li>默认值:”<code>router-link-active</code>“<br>设置链接激活时使用的<code>css</code>类名。默认值可以通过路由的构造选项<code>linkActiveClass</code>来全局配置。</li><li><code>exact</code><ul><li>类型:<code>boolean</code></li><li>默认值:<code>false</code><br>“是否激活” 默认类名的依据是 <code>inclusive match</code> （全包含匹配）。 举个例子，如果当前的路径是 <code>/a</code> 开头的，那么 <code>&lt;router-link to=&quot;/a&quot;&gt;</code> 也会被设置 <code>CSS</code> 类名。</li></ul></li></ul><p>按照这个规则，<code>&lt;router-link to=&quot;/&quot;&gt;</code> 将会点亮各个路由！想要链接使用 “<code>exact</code> 匹配模式”，则使用 <code>exact</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/&quot; exact&gt;</span><br></pre></td></tr></table></figure><ul><li>events<ul><li>类型: string | Array<string></string></li><li>默认值: ‘click’<br>声明可以用来触发导航的时间。可以是一个字符串或是一个包含字符串的数组</li></ul></li></ul><h4 id="将”激活时的CSS类名”应用在外层元素"><a href="#将”激活时的CSS类名”应用在外层元素" class="headerlink" title="将”激活时的CSS类名”应用在外层元素"></a><strong>将”激活时的CSS类名”应用在外层元素</strong></h4><p>有时候我们要让 “激活时的CSS类名” 应用在外层元素，而不是 <code>&lt;a&gt;</code> 标签本身，那么可以用 <code>&lt;router-link&gt;</code> 渲染外层元素，包裹着内层的原生 <code>&lt;a&gt;</code> 标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link tag=&quot;li&quot; to=&quot;/foo&quot;&gt;</span><br><span class="line">  &lt;a&gt;/foo&lt;/a&gt;</span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>&lt;a&gt;</code> 将作为真实的链接（它会获得正确的 <code>href</code> 的），而 “激活时的CSS类名” 则设置到外层的<br><br><br><br></p><hr><h3 id="二-lt-router-view-gt"><a href="#二-lt-router-view-gt" class="headerlink" title="二.&lt;router-view&gt;"></a>二.<code>&lt;router-view&gt;</code></h3><p><code>&lt;router-view&gt;</code>组件是一个functional组件，渲染路径匹配到的视图组件。<code>&lt;router-view&gt;</code>渲染的组件还可以内嵌自己的<code>&lt;router-view&gt;</code>，根据嵌套的路径，渲染嵌套组件。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>name <ul><li>类型:string</li><li>默认值:”default”<br>如果<code>&lt;router-view&gt;</code>设置了名称，则会渲染对应的路由配置中comonents下的相应组件。查看命名视图中的列子。<h4 id="行为表现"><a href="#行为表现" class="headerlink" title="行为表现"></a>行为表现</h4>其他属性（非router-view使用的属性）都直接传给渲染的组件，很多时候，每个路由的数据都是包含在路由的参数中。<br>因为它也是一个组件，可以配合<code>&lt;transtion&gt;</code>和<code>&lt;keep-alive&gt;</code>使用，如果两者结合使用一定要保证在内层使用<code>&lt;keep-alive&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/keep-alive&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><br><br><br></p><hr><h3 id="三-路由信息对象"><a href="#三-路由信息对象" class="headerlink" title="三.路由信息对象"></a>三.路由信息对象</h3><p>一个route object（路由信息对象）表示当前激活的路由的状态信息，包含了当前的url解析得到的信息，还有url匹配到的route record （路由记录）</p><p>  route object是immutable（不可变）的，每次成功的导航后都会产生一个新的对象。</p><p>  route object出现在多个地方：</p><ul><li>组件内的<code>this.$route</code>和<code>$route watcher</code>回调（监测变化处理）；</li><li><code>router.match(location)</code>的返回值</li><li>导航钩子的参数:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">//ro 和 from 都是路由信息对象</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="路由信息对象的属性"><a href="#路由信息对象的属性" class="headerlink" title="路由信息对象的属性"></a>路由信息对象的属性</h3><ul><li>$route.path<ul><li>类型:string<br>  字符串，对应当前的路径，总是解析为绝对路径，如<code>&quot;/foo/bar&quot;</code>。</li></ul></li><li>$route.params<ul><li>类型:Object<br>一个key/value对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。</li></ul></li><li>$route.query<ul><li>类型：Object<br>一个key/value对象，表示URL查询参数。例如，对于路径/foo?user=1,则有<code>$route.query.user=1</code>,如果没有查询参数，则是一个空对象。</li></ul></li><li>$route.hash<ul><li>类型:string<br>当前路由的hash值（带#），如果没有hash值，则为空字符串。</li></ul></li><li>$route.fullPath<ul><li>类型:string<br>完成解析后的URL，包含查询参数和hash的完整路径。</li></ul></li><li>$route.matched<ul><li>类型:<code>Array&lt;RouteRecord&gt;</code><br>一个数组，包含当前路由的所有嵌套路径片段的路由记录。路由记录就是routes配置数组中的对象副本（还有在children数组）。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 下面的对象就是 route record</span><br><span class="line">    &#123; path: &apos;/foo&apos;, component: Foo,</span><br><span class="line">      children: [</span><br><span class="line">        // 这也是个 route record</span><br><span class="line">        &#123; path: &apos;bar&apos;, component: Bar &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当 URL 为 /foo/bar，<code>$route.matched</code> 将会是一个包含从上到下的所有对象（副本）。</p><ul><li>$route.name</li></ul><p>当前路由的名称，如果有的话。（查看 命名路由）<br><img src="http://otue68nu2.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170919105103.png" alt="enter image description here"><br><br><br><br></p><hr><h3 id="四-Router构造配置"><a href="#四-Router构造配置" class="headerlink" title="四.Router构造配置"></a>四.Router构造配置</h3><p><strong>routes</strong></p><ul><li>类型<code>Array&lt;RouteConfig&gt;</code><br>  RouteConfig的类型定义：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare type RouteConfig = &#123;</span><br><span class="line">  path: string;//路径</span><br><span class="line">  component?: Component;//组件</span><br><span class="line">  name?: string; // for named routes (命名路由)</span><br><span class="line">  components?: &#123; [name: string]: Component &#125;; // for named views (命名视图组件)</span><br><span class="line">  redirect?: string | Location | Function;//重定向</span><br><span class="line">  alias?: string | Array&lt;string&gt;;//别名</span><br><span class="line">  children?: Array&lt;RouteConfig&gt;; // for nested routes</span><br><span class="line">  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void;//全局route注册之前的钩子</span><br><span class="line">  meta?: any;//路由配置元信息meta字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>mode</strong></p><ul><li>类型:<code>string</code></li><li>默认值:<code>&quot;hash‘(浏览器环境) | &quot;abstract&quot;(Node.js环境)</code></li><li>可选值:<code>&quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;</code><br>  配置路由模式：<ul><li>hash:使用URL hash值来做路由，支持所有浏览器，包括不支持HTML5 History Api的浏览器</li><li>history:依赖HTML5 History API和服务器配置，查看<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">HTML5 History模式 </a></li><li>abstract:支持所有JavaScript运行环境，如Node.js服务器端。如果发现没有浏览器的API,路由会自动强制进入这个模式<br><strong>base</strong></li></ul></li><li>类型:string</li><li>默认值:”/“<br>应用的基路径。例如，如果整个单页面应用服务在<code>/app/</code>下，然后base就应该设为<code>&quot;/app/&quot;</code>。<br><strong>linkActiveClass</strong></li><li>类型:string</li><li>默认值:”router-link-active”<br>全局配置<router-link>的默认[激活cass类名]。参考router-link<br><strong>scrollBehavior</strong></router-link></li><li>类型:function<br>  签名：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  to: Route,</span><br><span class="line">  from: Route,</span><br><span class="line">  savedPosition?: &#123; x: number, y: number &#125;</span><br><span class="line">) =&gt; &#123; x: number, y: number &#125; | &#123; selector: string &#125; | ?&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>更多详情参考<a href="https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html" target="_blank" rel="noopener"> 滚动行为</a>.<br><br><br><br></p><hr><h3 id="五-Router实例"><a href="#五-Router实例" class="headerlink" title="五.Router实例"></a>五.Router实例</h3><p><strong>属性</strong><br>router.app</p><ul><li>类型:Vue instace<br>  配置了router的Vue根实例。</li></ul><p>route.mode</p><ul><li>类型:string<br>  路由使用的<a href="https://router.vuejs.org/zh-cn/api/options.html#mode" target="_blank" rel="noopener">模式</a>。 </li></ul><p>router.currentRoute</p><ul><li>类型:Route<br>当前路由对应的路由信息对象<a href="https://router.vuejs.org/zh-cn/api/route-object.html" target="_blank" rel="noopener">信息对象</a><br><strong>方法</strong></li><li>router.beforeEach(guard)路由加载之前</li><li>router.befireResolve(guard)此时异步组件已加载完成</li><li>router.afterEach(hood)<br>  增加全局的导航钩子</li><li>router.push(location,ONccomplete?,onAbort?)</li><li>router.replace(location,ONccomplete?,onAbort?)</li><li>router.go(n)</li><li>router.back()</li><li>router.forward()<br>动态的导航到一个新 url。</li><li>router.getMatchedComponents(location?)</li></ul><p>返回目标位置或是当前路由匹配的组件数组（是数组的定义/构造类，不是实例）。通常在服务端渲染的数据预加载时时候。</p><ul><li>router.resolve(location, current?, append?)<br>解析目标位置，返回包含如下属性的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  location: Location;</span><br><span class="line">  route: Route;</span><br><span class="line">  href: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>router.addRoutes(routes)</li></ul><p>动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。</p><ul><li>router.onReady(callback)</li></ul><p>添加一个会在第一次路由跳转完成时被调用的回调函数。此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染的时候。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##VUE-ROUTER API文档&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;一-lt-router-link-gt&quot;&gt;&lt;a href=&quot;#一-lt-router-link-gt&quot; class=&quot;headerlink&quot; title=&quot;一.&amp;lt;route
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue官网基础整理</title>
    <link href="http://yoursite.com/2017/09/12/vue%E5%AE%98%E7%BD%91%E6%80%BB%E7%BB%93.1/"/>
    <id>http://yoursite.com/2017/09/12/vue官网总结.1/</id>
    <published>2017-09-12T14:24:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>##VUE2.0总结</p><hr><h3 id="一-vue实例"><a href="#一-vue实例" class="headerlink" title="一.vue实例"></a>一.vue实例</h3><hr><p><strong>创建一个vue的实例</strong><br>每个vue应用都是通过vue函数创建的一个新的vue实例开始的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">//选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><hr><p><strong>数据与方法</strong><br>当一个Vue实例被创建时，它项Vue的响应式系统中加入了其data对象中能找到的缩影的属性。当这些数据的值发生改变是，视图将会产生’响应’，即匹配更新为新的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 我们的数据对象</span><br><span class="line">var data = &#123; a: 1 &#125;</span><br><span class="line">// 该对象被加入到一个 Vue 实例中</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line">// 他们引用相同的对象！</span><br><span class="line">vm.a === data.a // =&gt; true</span><br><span class="line">// 设置属性也会影响到原始数据</span><br><span class="line">vm.a = 2</span><br><span class="line">data.a // =&gt; 2</span><br><span class="line">// ... and vice-versa</span><br><span class="line">data.a = 3</span><br><span class="line">vm.a // =&gt; 3</span><br></pre></td></tr></table></figure><p>只有在data中存在的属性是响应式的，所以可以在一开始给data附一个初始值。<br>除了data属性，vue实例暴露了一些其他的方法和属性，他们加上了$前缀，以便与用户定义的属性区分开来，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; a: 1 &#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line">vm.$data === data // =&gt; true</span><br><span class="line">vm.$el === document.getElementById(&apos;example&apos;) // =&gt; true</span><br><span class="line">// $watch 是一个实例方法</span><br><span class="line">vm.$watch(&apos;a&apos;, function (newValue, oldValue) &#123;</span><br><span class="line">  // 这个回调将在 `vm.a` 改变后调用</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><p><strong>实例生命周期</strong><br><img src="https://cn.vuejs.org/images/lifecycle.png" alt="enter image description here"><br><a href="http://blog.csdn.net/qq_21439971/article/details/76502598详细链接" target="_blank" rel="noopener">http://blog.csdn.net/qq_21439971/article/details/76502598详细链接</a></p><ol><li><code>create</code> 和 <code>mounted</code></li></ol><p><code>beforecreated：el</code> 和 <code>data</code> 并未初始化<br><code>created</code>:完成了 <code>data</code> 数据的初始化，<code>el</code>没有<br><code>beforeMount</code>：完成了 <code>el</code> 和 <code>data</code> 初始化<br><code>mounted</code> ：完成挂载<br>另外在标红处，我们能发现el还是 <code></code>，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。到后面mounted挂载的时候再把值渲染进去。</p><ol start="2"><li>update</li></ol><p>我们单击页面中的“更新数据”按钮，将数据更新。下面就能看到data里的值被修改后，将会触发update的操作。<br>ps:注意beforeUpdate是指view层的数据变化前，不是data中的数据改变前触发。因为Vue是数据驱动的。注意观察弹窗就容易发现。</p><ol start="3"><li>destroy</li></ol><p>销毁完成后，我们再重新改变message的值，vue不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。因为这个Vue实例已经不存在了。<br>我们单击页面中的“销毁”按钮，将指定的Vue实例销毁。</p><p>三、生命周期总结<br><code>beforecreate</code> : 举个栗子：可以在这加个loading事件<br><code>created</code> ：在这结束loading，还做一些初始化，实现函数自执行<br><code>mounted</code> ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情<br><code>beforeDestory</code>： 你确认删除XX吗？ destoryed ：当前组件已被删除，清空相关内容</p><h3 id="二-模板语法"><a href="#二-模板语法" class="headerlink" title="二.模板语法"></a>二.模板语法</h3><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。<br>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。<br>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染 (render) 函数，使用可选的 JSX 语法。</p><hr><p><strong>插值</strong><br>1.<strong>文本</strong><br>数据绑定文本用Mustache”语法(双大括号)的文本插值:<br><code>&lt;span&gt;msg:&lt;/span&gt;</code><br>通过<code>v-once</code>指令可以一次性插值，当文本改变不会响应改变插值<br><code>&lt;span v-once&gt;msg:&lt;/span&gt;</code><br>2.<strong>原始HTML</strong><br>真正的html输出需要v-html<br><code>&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt;</code><br>3.<strong>特性</strong><br>mustache语法不能作用在html的特性上，需要使用v-bind,<br><code>&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</code><br>这同样适用于布尔类特性，如果求值结果是 falsy 的值，则该特性将会被删除：<br><code>&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</code><br>4.<strong>使用JavaScript表达式</strong><br>vue提供了完全的JavaScript表达式的支持。<br><strong>每个绑定的表达式只能是单个的表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class="line">&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt;</span><br><span class="line">//下面语句不会生效</span><br><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><p>5.<strong>指令</strong><br>指令是带有<code>v-</code>前缀的特殊属性。指令的职责是，当表达式的值改变是，将其产生的连带影响，响应式的作用于DOM。<br>例如:v-if  v-for v-bind 等等<br>6.<strong>参数</strong><br>一些指令能够接受一个参数，在指令的名称之后以冒号表示，例如:<br><code>&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</code><br>这里href是参数，告知v-bind指令将该元素的href属性与表达式的url绑定。<br>7.<strong>修饰符</strong><br>修饰符是以<code>.</code>半角句号指明的特殊后缀，用于指出一个指令应该以什么方式绑定，例如:.stop .prevent等等<br>8.<strong>缩写</strong><br><code>v-bind</code> 缩写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><code>v-on</code> 缩写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="三-计算属性和观察者"><a href="#三-计算属性和观察者" class="headerlink" title="三.计算属性和观察者"></a>三.计算属性和观察者</h3><hr><p><strong>计算属性</strong><br>模板的表达式只适用于简单的表达式，如果有更复杂的计算需要使用compute计算属性<br>1.<strong>基础例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // a computed getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` points to the vm instance</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.<strong>计算属性的缓存vs方法</strong><br>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">// in component</span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用计算属性会有缓存，因为计算属性是依赖缓存来进行缓存的。如果不需要缓存，用方法代替。<br>3.<strong>计算属性VS被观察的属性</strong><br>Vue.js 提供了一个方法 watch，它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。具体的用法可以直接看下面的示例，简单直接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line">&lt;span style=&quot;color:#006600;&quot;&gt;&lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">    &lt;input type=&quot;text&quot; v-model:value=&quot;childrens.name&quot; /&gt;  </span><br><span class="line">    &lt;input type=&quot;text&quot; v-model:value=&quot;lastName&quot; /&gt;  </span><br><span class="line">&lt;/div&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;     </span><br><span class="line">    var vm = new Vue( &#123;  </span><br><span class="line">        el: &apos;#app&apos;,  </span><br><span class="line">        data: &#123;  </span><br><span class="line">            childrens: &#123;  </span><br><span class="line">                name: &apos;小强&apos;,  </span><br><span class="line">                age: 20,  </span><br><span class="line">                sex: &apos;男&apos;  </span><br><span class="line">            &#125;,  </span><br><span class="line">            tdArray:[&quot;1&quot;,&quot;2&quot;],  </span><br><span class="line">            lastName:&quot;张三&quot;  </span><br><span class="line">        &#125;,  </span><br><span class="line">        watch:&#123;  </span><br><span class="line">            childrens:&#123;  </span><br><span class="line">                handler:function(val,oldval)&#123;  </span><br><span class="line">                    console.log(val.name)  </span><br><span class="line">                &#125;,  </span><br><span class="line">                deep:true//对象内部的属性监听，也叫深度监听  </span><br><span class="line">            &#125;,  </span><br><span class="line">            &apos;childrens.name&apos;:function(val,oldval)&#123;  </span><br><span class="line">                console.log(val+&quot;aaa&quot;)  </span><br><span class="line">            &#125;,//键路径必须加上引号  </span><br><span class="line">            lastName:function(val,oldval)&#123;  </span><br><span class="line">                console.log(this.lastName)  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,//以V-model绑定数据时使用的数据变化监测  </span><br><span class="line">    &#125; );  </span><br><span class="line">    vm.$watch(&quot;lastName&quot;,function(val,oldval)&#123;  </span><br><span class="line">        console.log(val)  </span><br><span class="line">    &#125;)//主动调用$watch方法来进行数据监测&lt;/span&gt;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>注意：数组的改变不需要使用深度watch。<br>4<strong>计算属性的setter</strong><br>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也相应地会被更新。</p><h3 id="四-Class与Style绑定"><a href="#四-Class与Style绑定" class="headerlink" title="四.Class与Style绑定"></a>四.Class与Style绑定</h3><hr><p><strong>绑定HTML Class</strong><br>1.<strong>对象语法</strong><br>可以通过v-bind:class一个对象动态切换class：<br><code>&lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</code><br>判断isActive是否为真值<br>也可以直接绑定一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &apos;text-danger&apos;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以绑定一个计算属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2<strong>数组语法</strong><br>我们可以把一个数组传给v-bind:class，以应用一个class列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &apos;active&apos;,</span><br><span class="line">  errorClass: &apos;text-danger&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：<br><code>&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;</code><br>如果你也想根据条件切换列表中的 class，可以用三元表达式：<br><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</code><br>此例始终添加 errorClass ，但是只有在 isActive 是 true 时添加 activeClass。<br>不过，当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法：<br><code>&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;</code></p><hr><p><strong>绑定内联样式</strong><br>1.<strong>对象语法</strong><br>v-bind:style 的对象语法十分直观——看着非常像 CSS，其实它是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或 (配合引号的) 短横分隔命名 (kebab-case)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &apos;red&apos;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接绑定到一个样式对象通常更好，让模板更清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: &apos;red&apos;,</span><br><span class="line">    fontSize: &apos;13px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对象语法常常结合返回对象的计算属性使用。<br>2.<strong>数组语法</strong></p><p>v-bind:style 的数组语法可以将多个样式对象应用到一个元素上：<br><code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code><br>3.<strong>自动添加前缀</strong></p><p>当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。<br>4.<strong>多重值</strong></p><p>从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：<br><code>&lt;div :style=&quot;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&quot;&gt;&lt;/div&gt;</code><br>这会渲染数组中最后一个被浏览器支持的值。在这个例子中，如果浏览器支持不带浏览器前缀的 flexbox，那么渲染结果会是 display: flex。</p><h3 id="五-条件渲染"><a href="#五-条件渲染" class="headerlink" title="五.条件渲染"></a>五.条件渲染</h3><hr><p>v-if</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br><span class="line">也可以用 v-else 添加一个 “else” 块：</span><br><span class="line">&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;No&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>还有 v-else 和 v-else-if<br>可以用key来管理可以复用的元素<br>使元素全部重新渲染</p><p>v-show<br>v-show只是切换元素的display属性，v-show渲染的元素始终会被渲染并保留在DOM中。<br>tips：v-if和v-for一起使用过的时候 v-for比v-if有更高的优先级</p><h3 id="六-列表渲染"><a href="#六-列表渲染" class="headerlink" title="六.列表渲染"></a>六.列表渲染</h3><hr><p>1.<strong>用v-for把一个数组对应为一组元素</strong><br>可以用 v-for item in items    (item,index) in items   或者 v-for of</p><p>对象遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>key</strong><br>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。<br>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)：</p><hr><p><strong>数组的更新监测</strong><br>1.<strong>变异方法</strong><br>vue数组的</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()<br>都会触发视图更新<br>2.<strong>替换数组</strong><br>变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组<br>3.<strong>注意事项</strong><br>1.利用索引直接设置一个项时，不会触犯状态更新<code>vm.items[indexOfItem] = newValue</code><br>2.改变数组长度时候也不会粗发状态更新。<br>第一个问题的解决办法2中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Vue.set</span><br><span class="line">Vue.set(example1.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">example1.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure><p>第二类问题可以使用splice</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example1.items.splice(newLength)</span><br></pre></td></tr></table></figure><hr><p>对象更改检测注意事项<br>还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：<br>已经创建的实例需要使用vue.set(object,key,value)方法向嵌套对象添加响应式属性。还可以使用vm.$set实例方法，它只是Vue.set的别名：<br>如果需要个已有的对象赋予多个新属性，比如使用Object.assign()或_extend().<br>不要像这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(this.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &apos;Vue Green&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>你应该这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.userProfile = Object.assign(&#123;&#125;, this.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &apos;Vue Green&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><p><strong>显示过滤/排序结果</strong><br>有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: function () &#123;</span><br><span class="line">    return this.numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个 method 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in even(numbers)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: function (numbers) &#123;</span><br><span class="line">    return numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="七-事件处理"><a href="#七-事件处理" class="headerlink" title="七.事件处理"></a>七.事件处理</h3><hr><p>可以用v-on监听事件和触发一些javascript代码。<br>如果需要访问原生的DOM事件。可以使用特殊变量$event把它传入方法：</p><hr><p><strong>事件修饰符</strong>.stop</p><ul><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>键值修饰符</strong><br>.enter<br>.tab<br>.delete (捕获“删除”和“退格”键)<br>.esc<br>.space<br>.up<br>.down<br>.left<br>.right</p><h3 id="八-表单输入绑定"><a href="#八-表单输入绑定" class="headerlink" title="八.表单输入绑定"></a>八.表单输入绑定</h3><hr><p><strong>基础用法</strong><br>可以使用v-model实现双向数据绑定</p><hr><p><strong>修饰符</strong><br>.lazy</p><p>在默认情况下，v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot; &gt;</span><br><span class="line">.number</span><br></pre></td></tr></table></figure><p>如果想自动将用户的输入值转为 Number 类型 (如果原值的转换结果为 NaN 则返回原值)，可以添加一个修饰符 number 给 v-model 来处理输入值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure><p>这通常很有用，因为在 type=”number” 时 HTML 中输入的值也总是会返回字符串类型。<br>.trim</p><p>如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br><span class="line">v-model 与组件</span><br></pre></td></tr></table></figure><h3 id="九-组件"><a href="#九-组件" class="headerlink" title="九.组件"></a>九.组件</h3><hr><p><strong>使用组件</strong><br>1.<strong>注册</strong><br>要注册一个全局组件可以使用Vue.component(tagName,options)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-conmponent&apos;,&#123;</span><br><span class="line">//选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>组件在注册之后，便可以在父实例的模块中以自定义元素 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 的形式使用。要确保在初始化根实例之前注册了组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 注册</span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 创建根实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.<strong>局部注册组件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Child = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  components: &#123;</span><br><span class="line">    // &lt;my-component&gt; 将只在父模板可用</span><br><span class="line">    &apos;my-component&apos;: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.<strong>data必须是函数</strong></p><p>4.<strong>组合组件</strong><br>组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。<br>在 Vue 中，父子组件的关系可以总结为 props down, events up。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。<br><img src="https://cn.vuejs.org/images/props-events.png" alt="enter image description here"></p><hr><p><strong>Props</strong><br>1.<strong>使用Props传递数据</strong><br>要让子组件使用父组件的数据，我们需要通过props选项。<br>子组件要显式地用 props 选项声明它期待获得的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // 声明 props</span><br><span class="line">  props: [&apos;message&apos;],</span><br><span class="line">  // 就像 data 一样，prop 可以用在模板内</span><br><span class="line">  // 同样也可以在 vm 实例中像“this.message”这样使用</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们可以这样向它传入一个普通字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure><hr><p>2.<strong>动态props</strong><br>在模板中，要动态地绑定父组件的数据到子模板的 props，与绑定到任何普通的 HTML 特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input v-model=&quot;parentMsg&quot;&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>使用 v-bind 的缩写语法通常更简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</span><br></pre></td></tr></table></figure><p>3.<code>单向数据流</code></p><p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。<br>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。<br>为什么我们会有修改 prop 中数据的冲动呢？通常是这两种原因：<br>prop 作为初始值传入后，子组件想把它当作局部数据来用；<br>prop 作为初始值传入，由子组件处理成其它数据输出。<br>对这两种原因，正确的应对方式是：<br>定义一个局部变量，并用 prop 的值初始化它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;initialCounter&apos;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123; counter: this.initialCounter &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个计算属性，处理 prop 的值并返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [&apos;size&apos;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>Prop 验证</strong></p><p>我们可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue 会发出警告。当组件给其他人使用时，这很有用。<br>要指定验证规格，需要用对象的形式，而不能用字符串数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;example&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 基础类型检测 (`null` 意思是任何类型都可以)</span><br><span class="line">    propA: Number,</span><br><span class="line">    // 多种类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // 必传且是字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 数字，有默认值</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // 数组/对象的默认值应当由一个工厂函数返回</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        return value &gt; 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>type 可以是下面原生构造器：<br>String<br>Number<br>Boolean<br>Function<br>Object<br>Array<br>Symbol<br>type 也可以是一个自定义构造器函数，使用 instanceof 检测。<br>当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 props 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。</p><hr><p><strong>自定义事件</strong><br>子组件和父组件通讯<br>每个 Vue 实例都实现了事件接口 (Events interface)，即：<br>使用 <code>$on(eventName)</code> 监听事件<br>使用 <code>$emit(eventName)</code> 触发事件<br><strong>绑定原生事件</strong><br>有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>使用插槽分发内容</strong>在使用组件时，我们常常要像这样组合它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;app&gt;</span><br><span class="line">  &lt;app-header&gt;&lt;/app-header&gt;</span><br><span class="line">  &lt;app-footer&gt;&lt;/app-footer&gt;</span><br><span class="line">&lt;/app&gt;</span><br></pre></td></tr></table></figure><p>注意两点：<br><code>&lt;app&gt;</code> 组件不知道它会收到什么内容。这是由使用 <code>&lt;app&gt;</code> 的父组件决定的。<br><code>&lt;app&gt;</code> 组件很可能有它自己的模板。<br>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发 (或“transclusion”如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API，参照了当前 Web 组件规范草案，使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。<br>编译作用域</p><p>在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;child-component&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/child-component&gt;</span><br></pre></td></tr></table></figure><p>message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：<br>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。<br>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 无效 --&gt;</span><br><span class="line">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</span><br></pre></td></tr></table></figure><p>假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。<br>如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;child-component&apos;, &#123;</span><br><span class="line">  // 有效，因为是在正确的作用域内</span><br><span class="line">  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      someChildProperty: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>类似地，分发内容是在父作用域内编译。<br>单个插槽</p><p>除非子组件模板包含至少一个 <code>&lt;slot&gt;</code> 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。<br>最初在 <code>&lt;slot&gt;</code> 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。<br>假定 my-component 组件有下面模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;我是子组件的标题&lt;/h2&gt;</span><br><span class="line">  &lt;slot&gt;</span><br><span class="line">    只有在没有要分发的内容时才会显示。</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>父组件模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;</span><br><span class="line">  &lt;my-component&gt;</span><br><span class="line">    &lt;p&gt;这是一些初始内容&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;这是更多的初始内容&lt;/p&gt;</span><br><span class="line">  &lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>渲染结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是子组件的标题&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;这是一些初始内容&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;这是更多的初始内容&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>具名插槽</p><p><code>&lt;slot&gt;</code> 元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。<br>仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。<br>例如，假定我们有一个 app-layout 组件，它的模板为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>父组件模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;app-layout&gt;</span><br><span class="line">  &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;主要内容的一个段落。&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;另一个主要段落。&lt;/p&gt;</span><br><span class="line">  &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;</span><br><span class="line">&lt;/app-layout&gt;</span><br></pre></td></tr></table></figure><p>渲染结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;p&gt;主要内容的一个段落。&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;另一个主要段落。&lt;/p&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;p&gt;这里有一些联系信息&lt;/p&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在组合组件时，内容分发 API 是非常有用的机制。</p><hr><p><strong>作用域插槽</strong><br>作用域插槽是一种特殊类型的插槽，用作使用一个 (能够传递数据到) 可重用模板替换已渲染元素。<br>在子组件中，只需将数据传递到插槽，就像你将 props 传递给组件一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;child&quot;&gt;</span><br><span class="line">  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在父级中，具有特殊属性 scope 的 <template> 元素必须存在，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 props 对象：</template></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;child&gt;</span><br><span class="line">    &lt;template scope=&quot;props&quot;&gt;</span><br><span class="line">      &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果我们渲染以上结果，得到的输出会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;span&gt;hello from parent&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;hello from child&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</span><br><span class="line">  &lt;!-- 作用域插槽也可以是具名的 --&gt;</span><br><span class="line">  &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/my-awesome-list&gt;</span><br></pre></td></tr></table></figure><p>列表组件的模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;slot name=&quot;item&quot;</span><br><span class="line">    v-for=&quot;item in items&quot;</span><br><span class="line">    :text=&quot;item.text&quot;&gt;</span><br><span class="line">    &lt;!-- 这里写入备用内容 --&gt;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>动态组件</strong><br>使用is动态绑定component<br><strong>keep-alive</strong><br>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=&quot;currentView&quot;&gt;</span><br><span class="line">    &lt;!-- 非活动组件将被缓存！ --&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>异步组件</p><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单，Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // Pass the component definition to the resolve callback</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123;</span><br><span class="line">  // 这个特殊的 require 语法告诉 webpack</span><br><span class="line">  // 自动将编译后的代码分割成不同的块，</span><br><span class="line">  // 这些块将通过 Ajax 请求自动下载。</span><br><span class="line">  require([&apos;./my-async-component&apos;], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  &apos;async-webpack-example&apos;,</span><br><span class="line">  () =&gt; import(&apos;./my-async-component&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当使用局部注册时，你也可以直接提供一个返回 Promise 的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">  components: &#123;</span><br><span class="line">    &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##VUE2.0总结&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一-vue实例&quot;&gt;&lt;a href=&quot;#一-vue实例&quot; class=&quot;headerlink&quot; title=&quot;一.vue实例&quot;&gt;&lt;/a&gt;一.vue实例&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;创建一个vue的实例&lt;/st
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>web开发中跨域解决方案</title>
    <link href="http://yoursite.com/2017/08/20/web%E5%BC%80%E5%8F%91%E4%B8%AD%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/08/20/web开发中跨域解决方案/</id>
    <published>2017-08-20T04:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="web开发中跨域解决方案"><a href="#web开发中跨域解决方案" class="headerlink" title="web开发中跨域解决方案"></a>web开发中跨域解决方案</h3><p><strong>什么是跨域？</strong><br>概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的</p><hr><p><strong>下面是具体的跨域情况详解</strong></p><table><thead><tr><th style="text-align:center">URL</th><th style="text-align:center">说明</th><th style="text-align:center">是否允许通信</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://www.a.com/a.js、http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/a.js、http://www.a.com/b.js</a></td><td style="text-align:center">同一域名下</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center"><a href="http://www.a.com/lab/a.js、http://www.a.com/script/b.js" target="_blank" rel="noopener">http://www.a.com/lab/a.js、http://www.a.com/script/b.js</a></td><td style="text-align:center">同一域名下不同文件夹</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center"><a href="http://www.a.com:8000/a.js、http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com:8000/a.js、http://www.a.com/b.js</a></td><td style="text-align:center">同一域名，不同端口</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.a.com/a.js、http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/a.js、http://www.a.com/b.js</a></td><td style="text-align:center">同一域名，不同协议</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.a.com/a.js、http://70.32.92.74/b.js" target="_blank" rel="noopener">http://www.a.com/a.js、http://70.32.92.74/b.js</a></td><td style="text-align:center">域名和域名对应ip</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.a.com/a.js、http://script.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/a.js、http://script.a.com/b.js</a></td><td style="text-align:center">主域相同，子域不同</td><td style="text-align:center">不允许（cookie也不允许）</td></tr><tr><td style="text-align:center"><a href="http://www.a.com/a.js、http://a.com/b.js" target="_blank" rel="noopener">http://www.a.com/a.js、http://a.com/b.js</a></td><td style="text-align:center">同一域名，不同二级域名（同上）</td><td style="text-align:center">不允许（cookie也不允许）</td></tr><tr><td style="text-align:center"><a href="http://www.cnblogs.com/a.js、http://www.a.com/b.js" target="_blank" rel="noopener">http://www.cnblogs.com/a.js、http://www.a.com/b.js</a></td><td style="text-align:center">不同域名</td><td style="text-align:center">不允许</td></tr></tbody></table><h4 id="一、document-domain跨域"><a href="#一、document-domain跨域" class="headerlink" title="一、document.domain跨域"></a>一、document.domain跨域</h4><hr><ul><li>原理：相同主域名不同子域名下的页面，可以设置<code>document.domain</code>让它们同域</li><li>限制：同域<code>document</code>提供的是页面间的互操作，需要载入iframe页面</li></ul><blockquote><p>下面几个域名下的页面都是可以通过document.domain跨域互操作的： <a href="http://a.com/foo" target="_blank" rel="noopener">http://a.com/foo</a>,<br><a href="http://b.a.com/bar" target="_blank" rel="noopener">http://b.a.com/bar</a>, <a href="http://c.a.com/bar。" target="_blank" rel="noopener">http://c.a.com/bar。</a><br>但只能以页面嵌套的方式来进行页面互操作，比如常见的iframe方式就可以完成页面嵌套</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// URL http://a.com/foo</span><br><span class="line">var ifr = document.createElement(&apos;iframe&apos;);</span><br><span class="line">ifr.src = &apos;http://b.a.com/bar&apos;; </span><br><span class="line">ifr.onload = function()&#123;</span><br><span class="line">    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    ifrdoc.getElementsById(&quot;foo&quot;).innerHTML);</span><br><span class="line">&#125;;</span><br><span class="line">ifr.style.display = &apos;none&apos;;</span><br><span class="line">document.body.appendChild(ifr);</span><br></pre></td></tr></table></figure><ul><li>上述代码所在的URL是<a href="http://a.com/foo，它对http://b.a.com/bar的DOM访问要求后者将" target="_blank" rel="noopener">http://a.com/foo，它对http://b.a.com/bar的DOM访问要求后者将</a> document.domain往上设置一级</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// URL http://b.a.com/bar</span><br><span class="line">document.domain = &apos;a.com&apos;</span><br></pre></td></tr></table></figure><ul><li>document.domain只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在Chrome中给出的错误是这样的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught DOMException: Failed to set the &apos;domain&apos; property on &apos;Document&apos;: &apos;baidu.com&apos; is not a suffix of &apos;b.a.com&apos;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="二、有src的标签"><a href="#二、有src的标签" class="headerlink" title="二、有src的标签"></a>二、有src的标签</h4><hr><ul><li>原理：所有具有<code>src</code>属性的HTML标签都是可以跨域的，包括<code>&lt;img&gt;, &lt;script&gt;</code></li><li>限制：需要创建一个<code>DOM</code>对象，只能用于<code>GET</code>方法</li></ul><blockquote><ul><li>在<code>document.body</code>中<code>append</code>一个具有<code>src</code>属性的<code>HTML</code>标签， <code>src</code>属性值指向的<code>URL</code>会以<code>GET</code>方法被访问，该访问是可以跨域的<br>其实样式表的<code>&lt;link&gt;</code>标签也是可以跨域的，只要是有<code>src</code>或<code>href</code>的<code>HTML</code>标签都有跨域的能力</li></ul></blockquote><ul><li>不同的HTML标签发送HTTP请求的时机不同，例如<code>&lt;img&gt;</code>在更改<code>src</code>属性时就会发送请求，而<code>script</code>, <code>iframe</code>, <code>link[rel=stylesheet]</code>只有在添加到<code>DOM</code>树之后才会发送<code>HTTP</code>请求：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &apos;http://some/picture&apos;;        // 发送HTTP请求</span><br><span class="line">var ifr = $(&apos;&lt;iframe&gt;&apos;, &#123;src: &apos;http://b.a.com/bar&apos;&#125;);</span><br><span class="line">$(&apos;body&apos;).append(ifr);                  // 发送HTTP请求</span><br></pre></td></tr></table></figure><p><br></p><h4 id="三、JSONP"><a href="#三、JSONP" class="headerlink" title="三、JSONP"></a>三、JSONP</h4><hr><ul><li>原理：<code>&lt;script&gt;</code>是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数</li><li>限制：需要创建一个<code>DOM</code>对象并且添加到<code>DOM</code>树，只能用于<code>GET</code>方法</li></ul><blockquote><p><code>JSONP</code>利用的是<code>&lt;script&gt;</code>可以跨域的特性，跨域URL返回的脚本不仅包含数据，还包含一个回调</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://b.a.com/foo</span><br><span class="line">var data = &#123;</span><br><span class="line">    foo: &apos;bar&apos;,</span><br><span class="line">    bar: &apos;foo&apos;</span><br><span class="line">&#125;;</span><br><span class="line">callback(data);</span><br></pre></td></tr></table></figure><ul><li>然后在我们在主站<a href="http://a.com中，可以这样来跨域获取http://b.a.com的数据：" target="_blank" rel="noopener">http://a.com中，可以这样来跨域获取http://b.a.com的数据：</a></li></ul><p>// URL: <a href="http://a.com/foo" target="_blank" rel="noopener">http://a.com/foo</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var callback = function(data)&#123;</span><br><span class="line">    // 处理跨域请求得到的数据</span><br><span class="line">&#125;;</span><br><span class="line">var script = $(&apos;&lt;script&gt;&apos;, &#123;src: &apos;http://b.a.com/bar&apos;&#125;);</span><br><span class="line">$(&apos;body&apos;).append(script);</span><br></pre></td></tr></table></figure><ul><li>其实<code>jQuery</code>已经封装了<code>JSONP</code>的使用，我们可以这样来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON( &quot;http://b.a.com/bar?callback=callback&quot;, function( data )&#123;</span><br><span class="line">    // 处理跨域请求得到的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><code>$.getJSON</code>与<code>$.get</code>的区别是前者会把<code>responseText</code>转换为<code>JSON</code>，而且当<code>URL</code>具有<code>callback</code>参数时， <code>jQuery</code>将会把它解释为一个<code>JSONP</code>请求，创建一个<code>&lt;script&gt;</code>标签来完成该请求</p></blockquote><p><br></p><h4 id="四、navigation-对象"><a href="#四、navigation-对象" class="headerlink" title="四、navigation 对象"></a>四、navigation 对象</h4><hr><ul><li>原理：<code>iframe</code>之间是共享<code>navigator</code>对象的，用它来传递信息</li><li>要求：IE6/7<blockquote><p>有些人注意到了IE6/7的一个漏洞：<code>iframe</code>之间的<code>window.navigator</code>对象是共享的。 我们可以把它作为一个<code>Messenger</code>，通过它来传递信息。比如一个简单的委托：</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// a.com</span><br><span class="line">navigation.onData()&#123;</span><br><span class="line">    // 数据到达的处理函数</span><br><span class="line">&#125;</span><br><span class="line">typeof navigation.getData === &apos;function&apos; </span><br><span class="line">    || navigation.getData()</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// b.com</span><br><span class="line">navigation.getData = function()&#123;</span><br><span class="line">    $.get(&apos;/path/under/b.com&apos;)</span><br><span class="line">        .success(function(data)&#123;</span><br><span class="line">            typeof navigation.onData === &apos;function&apos;</span><br><span class="line">                || navigation.onData(data)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与<code>document.navigator</code>类似，<code>window.name</code>也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递<code>Hash</code>（有些人叫锚点），这是因为每次浏览器打开一个<code>URL</code>时，<code>URL</code>后面的#xxx部分会保留下来，那么新的页面可以从这里获得上一个页面的数据<br><br></p></blockquote><h4 id="五、跨域资源共享（CORS）"><a href="#五、跨域资源共享（CORS）" class="headerlink" title="五、跨域资源共享（CORS）"></a>五、跨域资源共享（CORS）</h4><hr><ul><li>原理：服务器设置<code>Access-Control-Allow-OriginHTTP</code>响应头之后，浏览器将会允许跨域请求</li><li><p>限制：浏览器需要支持<code>HTML5</code>，可以支持<code>POST</code>，<code>PUT</code>等方法</p><blockquote><p>前面提到的跨域手段都是某种意义上的<code>Hack</code>， HTML5标准中提出的跨域资源共享<code>（Cross Origin Resource Share，CORS</code>）才是正道。 它支持其他的<code>HTTP</code>方法如<code>PUT</code>, <code>POST</code>等，可以从本质上解决跨域问题。</p></blockquote></li><li><p>例如，从<a href="http://a.com要访问http://b.com的数据，通常情况下`Chrome`会因跨域请求而报错" target="_blank" rel="noopener">http://a.com要访问http://b.com的数据，通常情况下`Chrome`会因跨域请求而报错</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://b.com. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://a.com&apos; is therefore not allowed access</span><br></pre></td></tr></table></figure><ul><li>错误原因是被请求资源没有设置<code>Access-Control-Allow-Origin</code>，所以我们在<code>b.com</code>的服务器中设置这个响应头字段即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *              # 允许所有域名访问，或者</span><br><span class="line">Access-Control-Allow-Origin: http://a.com   # 只允许所有域名访问</span><br></pre></td></tr></table></figure><p><br></p><h4 id="六、window-postMessage"><a href="#六、window-postMessage" class="headerlink" title="六、window.postMessage"></a>六、window.postMessage</h4><hr><ul><li>原理：<code>HTML5</code>允许窗口之间发送消息</li><li>限制：浏览器需要支持<code>HTML5</code>，获取窗口句柄后才能相互通信<blockquote><p>这是一个安全的跨域通信方法，<code>postMessage(message,targetOrigin)</code>也是<code>HTML5</code>引入的特性。 可以给任何一个<code>window</code>发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个<code>URL</code>但不相符，那么该事件不会被分发。看一个普通的使用方式吧</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://a.com/foo</span><br><span class="line">var win = window.open(&apos;http://b.com/bar&apos;);</span><br><span class="line">win.postMessage(&apos;Hello, bar!&apos;, &apos;http://b.com&apos;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://b.com/bar</span><br><span class="line">window.addEventListener(&apos;message&apos;,function(event) &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br></p><h4 id="七、访问控制安全的讨论"><a href="#七、访问控制安全的讨论" class="headerlink" title="七、访问控制安全的讨论"></a>七、访问控制安全的讨论</h4><hr><ul><li>在<code>HTML5</code>之前，<code>JSONP</code>已经成为跨域的事实标准了，<code>jQuery</code>都给出了支持。 值得注意的是它只是<code>Hack</code>，并没有产生额外的安全问题。 因为<code>JSONP</code>要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问</li><li>跨域的正道还是要使用<code>HTML5</code>提供的<code>CORS</code>头字段以及<code>window.postMessage</code>， 可以支持<code>POST,</code> <code>PUT</code>等<code>HTTP</code>方法，从机制上解决跨域问题。 值得注意的是<code>Access-Control-Allow-Origin</code>头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和<code>JSONP</code>是一样的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;web开发中跨域解决方案&quot;&gt;&lt;a href=&quot;#web开发中跨域解决方案&quot; class=&quot;headerlink&quot; title=&quot;web开发中跨域解决方案&quot;&gt;&lt;/a&gt;web开发中跨域解决方案&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;什么是跨域？&lt;/strong&gt;&lt;br&gt;概念如
      
    
    </summary>
    
      <category term="跨域" scheme="http://yoursite.com/categories/%E8%B7%A8%E5%9F%9F/"/>
    
    
      <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>14.js 中的那些最佳实践</title>
    <link href="http://yoursite.com/2017/06/20/nodejs%20%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/06/20/nodejs 中的那些最佳实践/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《js-中的那些最佳实践》"><a href="#《js-中的那些最佳实践》" class="headerlink" title="《js 中的那些最佳实践》"></a>《js 中的那些最佳实践》</h1><p><strong>这个章节需要大家帮忙补充，一次性想不完那么多</strong></p><hr><h3 id="JavaScript-语言精粹"><a href="#JavaScript-语言精粹" class="headerlink" title="JavaScript 语言精粹"></a>JavaScript 语言精粹</h3><p><a href="http://book.douban.com/subject/3590768/" target="_blank" rel="noopener">http://book.douban.com/subject/3590768/</a></p><p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson14/1.png" alt=""></p><p>这本书很薄，只有 155 页，但该讲的几乎都讲了。大家想办法搞来看看吧（我总不能很没节操地给个电子版 PDF 链接在这里吧）。</p><p>js 这门语言，水很浅。没有太复杂的地方可以钻，但特么的坑又多。</p><p>上面的那本书是一定要看的。这本书专注在讲 js 语法，其他 js 的书都过多地涉及了浏览器知识。</p><h3 id="JavaScript-之美"><a href="#JavaScript-之美" class="headerlink" title="JavaScript 之美"></a>JavaScript 之美</h3><ul><li>其一：<a href="http://fxck.it/post/72326363595" target="_blank" rel="noopener">http://fxck.it/post/72326363595</a></li><li>其二：<a href="http://fxck.it/post/73513189448" target="_blank" rel="noopener">http://fxck.it/post/73513189448</a></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>js 前端不懂有什么好办法，后端的话，很方便。</p><p>用 node 官方的 <code>util</code> 库，下面是直接从官网摘抄来的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyStream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(MyStream, events.EventEmitter);</span><br><span class="line"></span><br><span class="line">MyStream.prototype.write = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">"data"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> MyStream();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stream <span class="keyword">instanceof</span> events.EventEmitter); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(MyStream.super_ === events.EventEmitter); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received data: "'</span> + data + <span class="string">'"'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">stream.write(<span class="string">"It works!"</span>); <span class="comment">// Received data: "It works!"</span></span><br></pre></td></tr></table></figure><p>js 是面向对象的，但是是“基于原型的面向对象”，没有类。没有多重继承，没有接口。没有结构体，没有枚举类型。</p><p>但它的字面量哈希和 function 都足够灵活，拼拼凑凑，上面那些东西都能“模拟”着用。</p><p>说到没有类的这个问题，很多人总是要纠正其他人关于 js 原型的理解的。我觉得这是没有必要的。基于原型又不是很牛逼，ES6不是照样给出了 class 关键字吗。不管类还是原型都是为了抽象，烂的东西始终烂，不好理解的始终不好理解。</p><p>最近学习 ios 的 swift，看见里面有不少相比 objc 舒服的改进。比如 objc 的“方法调用”，学的是 smalltalk 那一套，那不叫方法调用，而是消息传递。结果 swift 里面不照样是方法调用的形式？</p><h3 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h3><p>用 eventproxy 和 async 已经能解决大部分问题。剩下的小部分问题，肯定是设计错误。：）</p><p>参见：</p><ul><li>《使用 eventproxy 控制并发》：<a href="https://github.com/alsotang/node-lessons/tree/master/lesson4" target="_blank" rel="noopener">https://github.com/alsotang/node-lessons/tree/master/lesson4</a></li><li>《使用 async 控制并发》：<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="noopener">https://github.com/alsotang/node-lessons/tree/master/lesson5</a></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>写 js 很少去定义类。Object 的便利在多数其他语言需要定义类的场景下都能直接用。</p><p>js 中，用好 Number，String，Array，Object 和 Function 就够了。有时用用 RegExp。</p><p>用于 js 这门语言本身的残废，大多数时候都采用“约定胜于配置”的思想来交互合作。</p><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>很常规，C 语言那套。</p><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p>C 语言那套。二进制操作并不会降低效率，V8 很聪明的。</p><h3 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h3><p>也就是帮一个对象的属性定义 get 和 set 方法，通过 <code>obj.value</code> 和 <code>obj.value=</code> 的形式来调用。</p><p>koa(<a href="http://koajs.com/" target="_blank" rel="noopener">http://koajs.com/</a> ) 把这套玩得炉火纯青。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>无</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>手动帮你需要转换的类型的类定义 <code>.toxxx</code> 方法，比如 <code>.toString</code>，<code>.toJSON</code>，<code>toNumber</code>。</p><p>js 的隐式类型转换用一次坑一次。</p><h3 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h3><p>在 js 中，务必使用 <code>===</code> 三个等于号来比较对象，或者自定义方法来比较，不要使用 <code>==</code>。</p><p>我最近做一个项目，从数据库中取出的数据，虽然应该是字符型的，但有时它们是 String 的表示，有时是 Number 的表示。为了省事，会有人直接用 <code>==</code> 来对它们进行比较。这种时候，建议在比较时，把它们都转成 String 类型，然后用 <code>===</code> 来比较。</p><p>比如 <code>var x = 31243; var y = &#39;31243&#39;</code>，比较时，这么做：<code>String(x) === String(y)</code></p><h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>随便弄。</p><p>function 构造函数、闭包、字面量哈希，都可以混在一起写，多少层都行，无限制。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>当无法接触一个类的源码，又想帮这个类新增方法的时候。操作它的 prototype 就好了。但不推荐！</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>js 中，匿名函数非常的方便，有效利用函数式编程的特性可以使人写代码时心情愉悦。</p><p>使用 lodash：<a href="https://lodash.com/docs" target="_blank" rel="noopener">https://lodash.com/docs</a></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>类型都经常忽略还泛型！every parammeter is 泛型 in js</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>类定义中，没有 public private 等关键词，都靠约定。而且经常有人突破约定。</p><p>有些 http 方面的库，时不时就去 stub 原生 http 库的方法，0.11 时的 node.js 完全不按章法出牌，所以很多这些库都出现兼容性问题。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>《解密设计模式-王垠》</p><p><a href="https://github.com/alsotang/node-lessons/blob/master/lesson14/%E8%A7%A3%E5%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8E%8B%E5%9E%A0.md" target="_blank" rel="noopener">https://github.com/alsotang/node-lessons/blob/master/lesson14/%E8%A7%A3%E5%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8E%8B%E5%9E%A0.md</a></p><h3 id="构建大型项目"><a href="#构建大型项目" class="headerlink" title="构建大型项目"></a>构建大型项目</h3><p>从 npm 上面寻找质量高的库，并用质量高的方式拼凑起来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《js-中的那些最佳实践》&quot;&gt;&lt;a href=&quot;#《js-中的那些最佳实践》&quot; class=&quot;headerlink&quot; title=&quot;《js 中的那些最佳实践》&quot;&gt;&lt;/a&gt;《js 中的那些最佳实践》&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;这个章节需要大家帮忙补充，一次性想不
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>18.何为 connect 中间件</title>
    <link href="http://yoursite.com/2017/06/20/%E4%BD%95%E4%B8%BA%20connect%20%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/06/20/何为 connect 中间件/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《何为-connect-中间件》"><a href="#《何为-connect-中间件》" class="headerlink" title="《何为 connect 中间件》"></a>《何为 connect 中间件》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>理解中间件的概念</li><li>了解 Connect 的实现</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol><li>原生 httpServer 遇到的问题</li><li>中间件思想</li><li>Connect 实现</li><li>Express 简介</li></ol><p>这是从 httpServer 到 Express 的升级过程。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>Nodejs 的经典 httpServer 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(requestHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'hello visitor!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>里面的函数 <code>requestHandler</code> 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。</p><p>通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 <code>hello visitor!</code>。</p><p>然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 检测请求中请求体是否存在，若存在则解析请求体；</span><br><span class="line">1. 查看请求体中的id是否存在，若存在则去数据库查询；</span><br><span class="line">1. 根据数据库结果返回约定的值；</span><br></pre></td></tr></table></figure><p>我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。</p><p>实现代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBody</span>(<span class="params">req, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据http协议从req中解析body</span></span><br><span class="line">  callback(<span class="literal">null</span>, body);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIdInDatabase</span>(<span class="params">body, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据body.id在Database中检测，返回结果</span></span><br><span class="line">  callback(<span class="literal">null</span>, dbResult);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnResult</span>(<span class="params">dbResult, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dbResult &amp;&amp; dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.end(<span class="string">'true'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'false'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(body, <span class="function"><span class="keyword">function</span>(<span class="params">err, dbResult</span>) </span>&#123;</span><br><span class="line">      returnResult(dbResult, res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解决方案解决了包含三个步骤的业务问题，出现了3个 <code>});</code> 还有3个 <code>err</code> 需要处理，上面的写法可以得达到预期效果。</p><p>然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 <code>});</code> 及30个 <code>err</code>异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 <strong>多次返回</strong> 或返回地方不对等问题，这就是 <strong>回调金字塔</strong> 问题了。</p><p>大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。</p><ul><li><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="noopener">EventProxy</a> —— 事件发布订阅模式(第四课讲到)</li><li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">BlueBird</a> —— Promise方案(第十七课讲到)</li><li><a href="https://github.com/caolan/async" target="_blank" rel="noopener">Async</a> —— 异步流程控制库(第五课讲到)</li><li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator</a> —— ES6原生Generator</li></ul><p>理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 <code>类似异步流程控制的思想</code> 。</p><p><a name="next"></a><br>关于异步流程控制库下面简要介绍下，或移步<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="noopener">@第五课</a>。<br>异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 <strong>顺序执行</strong> 。</p><p>callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数</p><p>我们动手实现一个类似的链式调用，其中 <code>funlist</code> 更名为 <code>middlewares</code>、<code>callback</code> 更名为 <code>next</code>，码如下：</p><p><a name="middlewares" comment="middlewares锚点"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middlewares = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      req.body = body;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(req.body.id, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      res.dbResult = rows;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.dbResult &amp;&amp; res.dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      res.end(<span class="string">'true'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.end(<span class="string">'false'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由middlewares链式调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.end(<span class="string">'error:'</span>, err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i&lt;middlewares.length) &#123;</span><br><span class="line">      middlewares[i++](req, res, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//触发第一个middleware</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面用middlewares+next完成了业务逻辑的 <code>链式调用</code>，而middlewares里的每个函数，都是一个 <code>中间件</code>。</p><p>整体思路是：</p><ol><li>将所有 <code>处理逻辑函数(中间件)</code> 存储在一个list中；</li><li>请求到达时 <code>循环调用</code> list中的 <code>处理逻辑函数(中间件)</code>；</li></ol><h1 id="Connect的实现"><a href="#Connect的实现" class="headerlink" title="Connect的实现"></a><a href="https://github.com/senchalabs/connect" target="_blank" rel="noopener">Connect</a>的实现</h1><p>Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。</p><p>Connect中主要有五个函数<br>PS: Connect的核心代码是200+行，建议对照<a href="https://github.com/senchalabs/connect/blob/master/index.js" target="_blank">源码</a>看下面的函数介绍。</p><table><thead><tr><th>函数名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>createServer</td><td style="text-align:center">包装httpServer形成app</td></tr><tr><td>listen</td><td style="text-align:center">监听端口函数</td></tr><tr><td>use</td><td style="text-align:center">向middlewares里面放入业务逻辑</td></tr><tr><td>handle</td><td style="text-align:center">上一章的requestHandler函数增强版</td></tr><tr><td>call</td><td style="text-align:center">业务逻辑的真正执行者</td></tr></tbody></table><h2 id="createServer"><a href="#createServer" class="headerlink" title="createServer()"></a>createServer()</h2><p><strong>输入</strong>:</p><p>无</p><p><strong>执行过程</strong>:</p><ol><li>app是一个函数对象(包含handle方法)</li><li>app具有Event所有属性(详见<a href="https://github.com/jaredhanson/utils-merge" target="_blank" rel="noopener">utils-merge</a>，十行代码)</li><li>app有route属性(路由)、和stack属性(用于存储中间件，类似上面的<a href="#middlewares">middlewares</a>)</li></ol><p><strong>输出</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     app is function(req, res, next) &#123;...&#125;;</span><br><span class="line">      |</span><br><span class="line">  +---+---+</span><br><span class="line">  |  has  |</span><br><span class="line">route   stack</span><br></pre></td></tr></table></figure><p>##app.use(route, fn)</p><p>作用是向stack中添加 <code>逻辑处理函数</code> (中间件)。</p><p><strong>输入</strong>:</p><ol><li>route 可省略，默认’/‘</li><li>fn 具体的业务处理逻辑</li></ol><p><strong>tips:</strong></p><p>上面的fn表示处理逻辑，它可以是</p><ol><li>一个普通的 <code>function(req,res[,next]){}</code>；</li><li>一个<a href="https://lodejs.org/api/http.html#http_class_http_server" target="_blank" rel="noopener">httpServer</a>；</li><li>另一个connect的app对象(<strong>sub app特性</strong>)；</li></ol><p>由于它们的本质都是 <code>处理逻辑</code>，都可以用一个 <code>function(req,res,next){}</code>将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。</p><p>如何将这三种分别转换为 function(req, res, next) {}的形式呢？</p><ol><li>不用转换；</li><li>httpServer的定义是“对事件’request’后handler的对象”，我们可以从httpServer.listeners(‘request’)中得到这个函数；</li><li>另一个connect对象，而connect()返回的app就是function(req, res, out) {}；</li></ol><p><strong>执行过程</strong>:</p><ol><li>将三种<code>处理逻辑</code>统一转换为<code>function(req,res,next){}</code>的形式表示。</li><li>把这个<code>处理逻辑</code>与route一起，放入<code>stack</code>中(存储处理逻辑，route用来匹配路由)</li></ol><p>核心代码片段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//route是路由路径，handle是一个`function(req, res, next) &#123;...&#125;`形式的业务逻辑</span></span><br><span class="line"><span class="keyword">this</span>.stack.push(&#123; <span class="attr">route</span>: path, <span class="attr">handle</span>: handle &#125;);</span><br></pre></td></tr></table></figure><p><strong>返回</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回自己，可以完成链式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p><strong>总结:</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(<span class="string">'/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.stack.push(&#123;<span class="attr">route</span>: <span class="string">'/api'</span>, <span class="attr">handle</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure><p>最后，app.stack里 <strong>顺序存储</strong> 了所有的 <strong>逻辑处理函数</strong> (中间件)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.stack = [function1, function2, function3, ... function30];</span><br></pre></td></tr></table></figure><h2 id="app-handle-req-res-out"><a href="#app-handle-req-res-out" class="headerlink" title="app.handle(req, res, out)"></a>app.handle(req, res, out)</h2><p>这个函数就是请求到达时，负责 <code>顺序调用</code> 我们存储在stack中的 <code>逻辑处理函数</code> (中间件)函数，类似上一章的requestHandler。</p><p><strong>输入:</strong></p><ol><li>req是Nodejs本身的可读流，不做过多介绍</li><li>res是Nodejs本身的可写流，不做过多介绍</li><li>out是为了Connect的 <strong>sub app特性</strong> 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心</li></ol><p><strong>处理过程:</strong></p><p>可以回头看一下上面的<a href="#middlewares">requestHandler函数</a>，handle的实现是这个函数的增强版</p><ol><li>取得stack(存储<code>逻辑处理函数</code>列表)，index(列表下标)</li><li>构建next函数，next的作用是执行下一个<code>逻辑处理函数</code></li><li>触发第一个next，触发链式调用</li></ol><p><strong>next函数实现:</strong></p><p>next函数实现在handle函数体内，用来<code>顺序执行处理逻辑</code>，它是异步流程控制库的核心，不明白它的作用请看<a href="#next">上面的异步流程控制库简介</a></p><p>path是请求路径，route是<code>逻辑处理函数</code>自带的属性。</p><ol><li>取得下一个<code>逻辑处理函数</code>;</li><li>若路由不匹配，跳过此逻辑;</li><li>若路由匹配<a href="#call">下面的call</a>执行匹配到的<code>逻辑处理函数</code></li></ol><p>tips: 跟上一章最后的代码一样，每个<code>逻辑处理函数</code>调用<code>next</code>来让后面的函数执行，存储在stack中的函数就实现了<code>链式调用</code>。不一定所有的函数都在返回的时候才调用<code>next</code>，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。</p><p>核心代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取下一个逻辑逻辑处理函数</span></span><br><span class="line"><span class="number">1</span>:  <span class="keyword">var</span> layer = stack[index++];</span><br><span class="line"><span class="comment">//不匹配时跳过</span></span><br><span class="line"><span class="number">2</span>:  <span class="keyword">if</span> (path.toLowerCase().substr(<span class="number">0</span>, route.length) !== route.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//匹配时执行</span></span><br><span class="line"><span class="number">3</span>:  call(layer.handle, route, err, req, res, next);</span><br></pre></td></tr></table></figure><p><strong>返回:</strong></p><p>无</p><p><strong>总结:</strong></p><p>画图总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">request come</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware1 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware2 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware3 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware4 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p><a name="call"></a></p><p>##call(handle, route, err, req, res, next)</p><blockquote><p>这里有个比较有趣的知识，<code>console.log(Function.length)</code>会返回函数定义的参数个数。值跟在函数体内执行<code>arguments.length</code>一样。</p></blockquote><p>Connect中规定<code>function(err, req, res, next) {}</code>形式为错误处理函数，<code>function(req, res, next) {}</code>为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。</p><p><strong>输入:</strong></p><table><thead><tr><th>参数名</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>handle</td><td style="text-align:center">逻辑处理函数</td></tr><tr><td>route</td><td style="text-align:center">路由</td></tr><tr><td>err</td><td style="text-align:center">是否发生过错误</td></tr><tr><td>req</td><td style="text-align:center">Nodejs对象</td></tr><tr><td>res</td><td style="text-align:center">Nodejs对象</td></tr><tr><td>next</td><td style="text-align:center">next函数</td></tr></tbody></table><p><strong>处理过程:</strong></p><ol><li>是否有错误，本次handle是否是错误处理函数;</li><li>若有错误且handle为错误处理函数，则执行handle，本函数返回;</li><li>若没错误且handle不是错误处理函数，则执行handle，本函数返回;</li><li>如果上面两个都不满足，不执行handle，本函数调用next，返回;</li></ol><p><strong>返回:</strong></p><p>无</p><p><strong>总结:</strong></p><p>call函数是一个执行者，根据当前<code>错误情况</code>和<code>handle类型</code>决定<code>是否执行</code>当前的handle。</p><p>##listen</p><p>创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口</p><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><p>##图解Connect</p><p>Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。</p><p>图形总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">request               app(out)</span><br><span class="line">   |                          yes</span><br><span class="line">   +------------------&gt;match?-----&gt;middleware1</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware2</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware3</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        out&lt;-----------+</span><br><span class="line">                         |</span><br><span class="line">   +---------------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure><p>##Connect的subapp特性</p><p>我们再看看Connect是怎么实现subapp的，比较有趣。</p><p>什么是subapp?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var sub_app = connect();</span><br><span class="line">var app = connect();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/route1&apos;, sub_app);</span><br><span class="line">// request path: &apos;/route1/route2&apos;</span><br><span class="line">// 由app接收到请求后，切割 path为&apos;/route2&apos;转交给sub_app的处理逻辑处理</span><br><span class="line">// 再由sub_app返回到app，由app继续向下执行处理逻辑</span><br></pre></td></tr></table></figure><p>结合上面的函数画图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request               app(out1)                 sub_app(out2)</span><br><span class="line">   |</span><br><span class="line">   +---------------&gt;middleware1     +------------&gt;middleware1</span><br><span class="line">                         |          |                 |</span><br><span class="line">                        next        |                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                    middleware2-----+            middleware2</span><br><span class="line">                                                      |</span><br><span class="line">                       next&lt;--------+                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                     middleware3    |            middleware3</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                        out1        |                out2</span><br><span class="line">                         |          |                 |</span><br><span class="line">   +---------------------+          +-----------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure><p>完成上面的sub_app只需要做到两点：</p><ol><li>从app的调用链进入到sub_app的调用链中;</li><li>从sub_app的逻辑回到app的调用链中;</li></ol><p>connect在handle函数中的第三个参数<code>out</code>为这个特性实现提供可能。<code>out</code>的特点是<code>在middlewares链式调用完成以后调用</code>。<strong>那么将app的next作为sub_app的out传入sub_app的handle中</strong>可以做到sub_app自己的业务逻辑处理完后调用<code>out</code>，即处理权回到了本app的<code>next</code>手里。</p><p>上面图中的<code>sub_app.out2===app.next</code>，所以能完成逻辑的交接和sub app调用。</p><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a><a href="https://github.com/strongloop/express" target="_blank" rel="noopener">Express</a></h1><p>大家都知道Express是Connect的升级版。</p><p>Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。</p><p>Express大概可以分为几个模块</p><table><thead><tr><th>模块</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>router</td><td style="text-align:center">路由模块是Connect升级版</td></tr><tr><td>request</td><td style="text-align:center">经过Express封装的req对象</td></tr><tr><td>response</td><td style="text-align:center">经过Express封装的res对象</td></tr><tr><td>application</td><td style="text-align:center">app上面的各种默认设置</td></tr></tbody></table><p>简要介绍一下每个模块</p><p>##Router</p><p>在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版</p><ol><li>正则匹配route;</li><li>进行将http的方法在route中分解开;</li></ol><p>##Request</p><p>在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是<br>req.param。</p><p>##Response</p><p>在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、<br>res.render、res.redirect、res.sendFile等等。</p><p>我们可以拓展它写一个res.sendPersonInfoById。</p><blockquote><p>关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑，<br>我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解<br>耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。</p></blockquote><p>##Application</p><p>除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。</p><p>##Express小结</p><p>Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express<br>本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、<br>connect-redis等。</p><p>实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析<br>body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑；<br><a href="https://github.com/koajs/koa" target="_blank" rel="noopener">Koa</a>用Generator方法解决回调问题；</p><p>我们应该也可以用事件、Promise的方式实现；</p><p>PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《何为-connect-中间件》&quot;&gt;&lt;a href=&quot;#《何为-connect-中间件》&quot; class=&quot;headerlink&quot; title=&quot;《何为 connect 中间件》&quot;&gt;&lt;/a&gt;《何为 connect 中间件》&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>11.作用域与闭包：this，var，(function () {})</title>
    <link href="http://yoursite.com/2017/06/20/node%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%EF%BC%9Athis%EF%BC%8Cvar%EF%BC%8C(function%20()%20%7B%7D)/"/>
    <id>http://yoursite.com/2017/06/20/node作用域与闭包：this，var，(function () {})/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《作用域与闭包：this，var，-function-》"><a href="#《作用域与闭包：this，var，-function-》" class="headerlink" title="《作用域与闭包：this，var，(function () {})》"></a>《作用域与闭包：this，var，(function () {})》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>无具体目标</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>理解 js 中 var 的作用域</li><li>了解闭包的概念</li><li>理解 this 的指向</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p><strong>es6中新增了 let 关键词，与块级作用域，相关知识参考： <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/let</a> </strong></p><h3 id="var-作用域"><a href="#var-作用域" class="headerlink" title="var 作用域"></a>var 作用域</h3><p>先来看个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"parent_name"</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> child = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"child_name"</span>;</span><br><span class="line">    <span class="keyword">var</span> childAge = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =&gt; child_name 13 0.3</span></span><br><span class="line">    <span class="built_in">console</span>.log(name, age, childAge);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  child();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// will throw Error</span></span><br><span class="line">  <span class="comment">// ReferenceError: childAge is not defined</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age, childAge);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">parent();</span><br></pre></td></tr></table></figure><p>直觉地，内部函数可以访问外部函数的变量，外部不能访问内部函数的变量。上面的例子中内部函数 child 可以访问变量 age，而外部函数 parent 不可以访问 child 中的变量 childAge，因此会抛出没有定义变量的异常。</p><p>有个重要的事，如果忘记var，那么变量就被声明为全局变量了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  value = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// 输出hello</span></span><br><span class="line"><span class="built_in">console</span>.log(global.value) <span class="comment">// 输出hello</span></span><br></pre></td></tr></table></figure><p>这个例子可以很正常的输出 <code>hello</code>，是因为 <code>value</code> 变量在定义时，没有使用 <code>var</code> 关键词，所以被定义成了全局变量。在 Node 中，全局变量会被定义在 <code>global</code> 对象下；在浏览器中，全局变量会被定义在 <code>window</code> 对象下。</p><p>如果你确实要定义一个全局变量的话，请显示地定义在 <code>global</code> 或者 <code>window</code> 对象上。</p><p>这类不小心定义全局变量的问题可以被 jshint 检测出来，如果你使用 sublime 编辑器的话，记得装一个 <code>SublimeLinter</code> 插件，这是插件支持多语言的语法错误检测，js 的检测是原生支持的。</p><p>JavaScript 中，变量的局部作用域是函数级别的。不同于 C 语言，在 C 语言中，作用域是块级别的。<br>JavaScript 中没有块级作用域。</p><p>js 中，函数中声明的变量在整个函数中都有定义。比如如下代码段，变量 i 和 value 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i 和 value。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//输出10</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);<span class="comment">//输出hello world</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>所以有种说法是：应该提前声明函数中需要用到的变量，即，在函数体的顶部声明可能用到的变量，这样就可以避免出现一些奇奇怪怪怪的 bug。</p><p>但我个人不喜欢遵守这一点，一般都是现用现声明的。这类错误的检测交给 jshint 来做就好了。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包这个概念，在函数式编程里很常见，简单的说，就是使内部函数可以访问定义在外部函数中的变量。</p><p>假如我们要实现一系列的函数：add10，add20，它们的定义是 <code>int add10(int n)</code>。</p><p>为此我们构造了一个名为 adder 的构造器，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> base = x;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + base;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add10 = adder(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add20 = adder(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add20(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>每次调用 adder 时，adder 都会返回一个函数给我们。我们传给 adder 的值，会保存在一个名为 base 的变量中。由于返回的函数在其中引用了 base 的值，于是 base 的引用计数被 +1。当返回函数不被垃圾回收时，则 base 也会一直存在。</p><p>我暂时想不出什么实用的例子来，如果想深入理解这块，可以看看这篇 <a href="http://coolshell.cn/articles/6731.html" target="_blank" rel="noopener">http://coolshell.cn/articles/6731.html</a></p><h4 id="闭包的一个坑"><a href="#闭包的一个坑" class="headerlink" title="闭包的一个坑"></a>闭包的一个坑</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个代码块会打印五个 <code>5</code> 出来，而我们预想的结果是打印 0 1 2 3 4。</p><p>之所以会这样，是因为 setTimeout 中的 i 是对外层 i 的引用。当 setTimeout 的代码被解释的时候，运行时只是记录了 i 的引用，而不是值。而当 setTimeout 被触发时，五个 setTimeout 中的 i 同时被取值，由于它们都指向了外层的同一个 i，而那个 i 的值在迭代完成时为 5，所以打印了五次 <code>5</code>。</p><p>为了得到我们预想的结果，我们可以把 i 赋值成一个局部的变量，从而摆脱外层迭代的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">idx</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(idx);</span><br><span class="line">    &#125;, <span class="number">5</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。</p><p>在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：</p><ul><li>有对象就指向调用对象</li><li>没调用对象就指向全局对象</li><li>用new构造就指向新对象</li><li>通过 apply 或 call 或 bind 来改变 this 的所指。</li></ul><p>1）函数有所属对象时：指向所属对象</p><p>函数有所属对象时，通常通过 <code>.</code> 表达式调用，这时 <code>this</code> 自然指向所属对象。比如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">value</span>: <span class="number">100</span>&#125;;</span><br><span class="line">myObject.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);  <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出 &#123; value: 100, getValue: [Function] &#125;，</span></span><br><span class="line">  <span class="comment">// 其实就是 myObject 对象本身</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.getValue()); <span class="comment">// =&gt; 100</span></span><br></pre></td></tr></table></figure><p><code>getValue()</code> 属于对象 <code>myObject</code>，并由 <code>myOjbect</code> 进行 <code>.</code> 调用，因此 <code>this</code> 指向对象 <code>myObject</code>。</p><p>2) 函数没有所属对象：指向全局对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">value</span>: <span class="number">100</span>&#125;;</span><br><span class="line">myObject.getValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value) <span class="comment">// =&gt; undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// 输出全局对象 global</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  foo();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.getValue()); <span class="comment">// =&gt; 100</span></span><br></pre></td></tr></table></figure><p>在上述代码块中，<code>foo</code> 函数虽然定义在 <code>getValue</code> 的函数体内，但实际上它既不属于 <code>getValue</code> 也不属于 <code>myObject</code>。<code>foo</code> 并没有被绑定在任何对象上，所以当调用时，它的 <code>this</code> 指针指向了全局对象 <code>global</code>。</p><p>据说这是个设计错误。</p><p>3）构造器中的 this：指向新对象</p><p>js 中，我们通过 <code>new</code> 关键词来调用构造函数，此时 this 会绑定在该新对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> SomeClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myCreate = <span class="keyword">new</span> SomeClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCreate.value); <span class="comment">// 输出100</span></span><br></pre></td></tr></table></figure><p>顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。</p><p>4) apply 和 call 调用以及 bind 绑定：指向绑定的对象</p><p>apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。</p><p>call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。</p><p>简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">value</span>: <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 全局变量 global</span></span><br><span class="line">foo.apply(myObject); <span class="comment">// &#123; value: 100 &#125;</span></span><br><span class="line">foo.call(myObject); <span class="comment">// &#123; value: 100 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newFoo = foo.bind(myObject);</span><br><span class="line">newFoo(); <span class="comment">// &#123; value: 100 &#125;</span></span><br></pre></td></tr></table></figure><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《作用域与闭包：this，var，-function-》&quot;&gt;&lt;a href=&quot;#《作用域与闭包：this，var，-function-》&quot; class=&quot;headerlink&quot; title=&quot;《作用域与闭包：this，var，(function () {})》&quot;&gt;
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>3.使用 superagent 与 cheerio 完成简单爬虫</title>
    <link href="http://yoursite.com/2017/06/20/node%E4%BD%BF%E7%94%A8%20superagent%20%E4%B8%8E%20cheerio%20%E5%AE%8C%E6%88%90%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2017/06/20/node使用 superagent 与 cheerio 完成简单爬虫/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《使用-superagent-与-cheerio-完成简单爬虫》"><a href="#《使用-superagent-与-cheerio-完成简单爬虫》" class="headerlink" title="《使用 superagent 与 cheerio 完成简单爬虫》"></a>《使用 superagent 与 cheerio 完成简单爬虫》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson3 项目，在其中编写代码。</p><p>当在浏览器中访问 <code>http://localhost:3000/</code> 时，输出 CNode(<a href="https://cnodejs.org/" target="_blank" rel="noopener">https://cnodejs.org/</a> ) 社区首页的所有帖子标题和链接，以 json 的形式。</p><p>输出示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"【公告】发招聘帖的同学留意一下这里"</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://cnodejs.org/topic/541ed2d05e28155f24676a12"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"发布一款 Sublime Text 下的 JavaScript 语法高亮插件"</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>访问 <code>http://localhost:3000/</code> 时，输出包括主题的作者，</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"【公告】发招聘帖的同学留意一下这里"</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://cnodejs.org/topic/541ed2d05e28155f24676a12"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"alsotang"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"发布一款 Sublime Text 下的 JavaScript 语法高亮插件"</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"otheruser"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习使用 superagent 抓取网页</li><li>学习使用 cheerio 分析网页</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>Node.js 总是吹牛逼说自己异步特性多么多么厉害，但是对于初学者来说，要找一个能好好利用异步的场景不容易。我想来想去，爬虫的场景就比较适合，没事就异步并发地爬几个网站玩玩。</p><p>本来想教大家怎么爬 github 的 api 的，但是 github 有 rate limit 的限制，所以只好牺牲一下 CNode 社区（国内最专业的 Node.js 开源技术社区），教大家怎么去爬它了。</p><p>我们这回需要用到三个依赖，分别是 express，superagent 和 cheerio。</p><p>先介绍一下，</p><p>superagent(<a href="http://visionmedia.github.io/superagent/" target="_blank" rel="noopener">http://visionmedia.github.io/superagent/</a> ) 是个 http 方面的库，可以发起 get 或 post 请求。</p><p>cheerio(<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">https://github.com/cheeriojs/cheerio</a> ) 大家可以理解成一个 Node.js 版的 jquery，用来从网页中以 css selector 取数据，使用方式跟 jquery 一样一样的。</p><p>还记得我们怎么新建一个项目吗？</p><ol><li>新建一个文件夹，进去之后 <code>npm init</code></li><li>安装依赖 <code>npm install --save PACKAGE_NAME</code></li><li>写应用逻辑</li></ol><p>我们应用的核心逻辑长这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用 superagent 去抓取 https://cnodejs.org/ 的内容</span></span><br><span class="line">  superagent.get(<span class="string">'https://cnodejs.org/'</span>)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, sres</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 常规的错误处理</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> next(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// sres.text 里面存储着网页的 html 内容，将它传给 cheerio.load 之后</span></span><br><span class="line">      <span class="comment">// 就可以得到一个实现了 jquery 接口的变量，我们习惯性地将它命名为 `$`</span></span><br><span class="line">      <span class="comment">// 剩下就都是 jquery 的内容了</span></span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(sres.text);</span><br><span class="line">      <span class="keyword">var</span> items = [];</span><br><span class="line">      $(<span class="string">'#topic_list .topic_title'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, element</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $element = $(element);</span><br><span class="line">        items.push(&#123;</span><br><span class="line">          title: $element.attr(<span class="string">'title'</span>),</span><br><span class="line">          href: $element.attr(<span class="string">'href'</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      res.send(items);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OK，一个简单的爬虫就是这么简单。这里我们还没有利用到 Node.js 的异步并发特性。不过下两章内容都是关于异步控制的。</p><p>记得好好看看 superagent 的 API，它把链式调用的风格玩到了极致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《使用-superagent-与-cheerio-完成简单爬虫》&quot;&gt;&lt;a href=&quot;#《使用-superagent-与-cheerio-完成简单爬虫》&quot; class=&quot;headerlink&quot; title=&quot;《使用 superagent 与 cheerio 完成简
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>12.线上部署：heroku</title>
    <link href="http://yoursite.com/2017/06/20/node%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2%EF%BC%9Aheroku/"/>
    <id>http://yoursite.com/2017/06/20/node线上部署：heroku/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《线上部署：heroku》"><a href="#《线上部署：heroku》" class="headerlink" title="《线上部署：heroku》"></a>《线上部署：heroku》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>将 <a href="https://github.com/Ricardo-Li/node-practice-2" target="_blank" rel="noopener">https://github.com/Ricardo-Li/node-practice-2</a> (这个项目已经被删了。参照 <a href="https://github.com/alsotang/node-lessons/tree/master/lesson3" target="_blank" rel="noopener">https://github.com/alsotang/node-lessons/tree/master/lesson3</a> 的代码自己操作一下吧。)这个项目部署上 heroku，成为一个线上项目</p><p>我部署的在这里 <a href="http://serene-falls-9294.herokuapp.com/" target="_blank" rel="noopener">http://serene-falls-9294.herokuapp.com/</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习 heroku 的线上部署(<a href="https://www.heroku.com/" target="_blank" rel="noopener">https://www.heroku.com/</a> )</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><h3 id="什么是-heroku"><a href="#什么是-heroku" class="headerlink" title="什么是 heroku"></a>什么是 heroku</h3><p>heroku 是弄 ruby 的 paas 起家，现在支持多种语言环境，更甚的是它强大的 add-on 服务。</p><p>paas 平台相信大家都不陌生。Google 有 gae，国内新浪有 sae。paas 平台相对 vps 来说，不需要你配置服务器，不需要装数据库，也不需要理会负载均衡。这一切都可以在平台上直接获取。</p><p>你只要专注自己的业务，把应用的逻辑写好，然后发布上去，应用自然就上线了。数据库方面，如果你用 mysql，那么你可以从平台商那里得到一个 mysql 的地址、账号和密码，直接连接就能用。如果应用的流量增大，需要横向拓展，则只用去到 paas 平台的管理页面，增大服务器实例的数量即可，负载均衡会自动帮你完成。</p><p>说起来，我之所以对于 web 开发产生兴趣也是因为当年 gae 的关系。那时候除了 gae 之外，没有别的 paas 平台，gae 是横空出世的。有款翻墙的软件，叫 gappproxy(<a href="https://code.google.com/p/gappproxy/" target="_blank" rel="noopener">https://code.google.com/p/gappproxy/</a> )——可以认为是 goagent 的前身——就是搭建在 gae 上面的，不仅快，而且免费。于是我就很想弄懂这样一个程序是如何开发的。好在 gappproxy 是开源的，于是我下了源码来看，那时候才大一，只学过 c，看到那些 python 代码就凌乱了。于是转头也去学 python，后来渐渐发现了 web 开发的乐趣，于是 ruby 和 node.js 也碰碰。后来 goagent 火起来了，我又去看了看它的代码，发现非常难看，就自己写了个 <a href="https://github.com/alsotang/keepagent" target="_blank" rel="noopener">https://github.com/alsotang/keepagent</a> 。不过现在回想起来，还是 goagent 的实现比较稳定以及效率高。</p><p>heroku 的免费额度还是足够的，对于 demo 应用来说，放上去是绰绰有余的。各位搞 web 开发的大学生朋友，一定要试着让你开发的项目尽可能早地去线上跑，这样你的项目可以被其他人看到，能够促使你更有热情地进行进一步开发。这回我们放的是 cnode 社区的爬虫上去，你其实可以试着为你们学院或者学校的新闻站点写个爬虫，提供 json api，然后去申请个微信公共平台，每天推送学院网站的新闻。这东西辅导员是有需求的，可以做个给他们用。</p><p>好了，我们先 clone <a href="https://github.com/Ricardo-Li/node-practice-2" target="_blank" rel="noopener">https://github.com/Ricardo-Li/node-practice-2</a> 这个项目。由于我们这回讲部署，所以代码就用现成的了，代码的内容就是 lesson 3（<a href="https://github.com/alsotang/node-lessons/tree/master/lesson3" target="_blank" rel="noopener">https://github.com/alsotang/node-lessons/tree/master/lesson3</a> ） 里面的那个爬虫。</p><p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/1.png" alt=""></p><p>clone 下来以后，我们去看看代码。代码中有两个特殊的地方，</p><p>一个是一个叫 Procfile 的文件，内容是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: node app.js</span><br></pre></td></tr></table></figure><p>一个是 app.js 里面，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.listen(process.env.PORT || <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>这两者都是为了部署 heroku 所做的。</p><p>大家有没有想过，当部署一个应用上 paas 平台以后，paas 要为我们干些什么？</p><p>首先，平台要有我们语言的运行时；</p><p>然后，对于 node.js 来说，它要帮我们安装 package.json 里面的依赖；</p><p>然后呢？然后需要启动我们的项目；</p><p>然后把外界的流量导入我们的项目，让我们的项目提供服务。</p><p>上面那两处特殊的地方，一个是启动项目的，一个是导流量的。</p><p>heroku 虽然能推测出你的应用是 node.js 应用，但它不懂你的主程序是哪个，所以我们提供了 Procfile 来指导它启动我们的程序。</p><p>而我们的程序，本来是监听 5000 端口的，但是 heroku 并不知道。当然，你也可以在 Procfile 中告诉 heroku，可如果大家都监听 5000 端口，这时候不就有冲突了吗？所以这个地方，heroku 使用了主动的策略，主动提供一个环境变量 <code>process.env.PORT</code> 来供我们监听。</p><p>这样的话，一个简单 app 的配置就完成了。</p><p>我们去 <a href="https://www.heroku.com/" target="_blank" rel="noopener">https://www.heroku.com/</a> 申请个账号，然后下载它的工具包 <a href="https://toolbelt.heroku.com/" target="_blank" rel="noopener">https://toolbelt.heroku.com/</a> ，然后再在命令行里面，通过 <code>heroku login</code> 来登录。</p><p>上述步骤完成后，我们进入 <code>node-practice-2</code> 的目录，执行 <code>heroku create</code>。这时候，heroku 会为我们随机取一个应用名字，并提供一个 git 仓库给我们。</p><p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/2.png" alt=""></p><p>接着，往 heroku 这个远端地址推送我们的 master 分支：</p><p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/3.png" alt=""></p><p>heroku 会自动检测出我们是 node.js 程序，并安装依赖，然后按照 Procfile 进行启动。</p><p>push 完成后，在命令键入 <code>heroku open</code>，则 heroku 会自动打开浏览器带我们去到相应的网址：</p><p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson12/4.png" alt=""></p><p>到此课程也就结束了。</p><p>随便聊聊 heroku 的 addon 吧。这个 addon 确实是个神奇的东西，反正在 heroku 之外我还没怎么见到这类概念。这些 addon 提供商，有些提供 redis 的服务，有些提供 mongodb，有些提供 mysql。你可以直接在 heroku 上面进行购买，然后 heroku 就会提供一段相应服务的地址和账号密码给你用来连接。</p><p>大家可以去 <a href="https://addons.heroku.com/" target="_blank" rel="noopener">https://addons.heroku.com/</a> 这个页面看看，玲琅满目各种应用可以方便接入。之所以这类服务有市场，也是因为亚马逊的 aws 非常牛逼。为什么这么说呢，因为网络速度啊。如果现在在国内，你在 ucloud 买个主机，然后用个阿里云的 rds，那么应用的响应速度会因为 mysql 连接的问题卡得动不了。但在 heroku 这里，提供商们，包括 heroku 自己，都是构建在 aws 上面，这样一来，各种服务的互通其实走的是内网，速度很可以接受，于是各种 addon 提供商就做起来了。</p><p>国内的话，其实在阿里云上面也可以考虑这么搞一搞。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《线上部署：heroku》&quot;&gt;&lt;a href=&quot;#《线上部署：heroku》&quot; class=&quot;headerlink&quot; title=&quot;《线上部署：heroku》&quot;&gt;&lt;/a&gt;《线上部署：heroku》&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; cla
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>7.浏览器端测试：mocha，chai，phantomjs</title>
    <link href="http://yoursite.com/2017/06/20/node%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%EF%BC%9Amocha%EF%BC%8Cchai%EF%BC%8Cphantomjs/"/>
    <id>http://yoursite.com/2017/06/20/node浏览器端测试：mocha，chai，phantomjs/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《浏览器端测试：mocha，chai，phantomjs》"><a href="#《浏览器端测试：mocha，chai，phantomjs》" class="headerlink" title="《浏览器端测试：mocha，chai，phantomjs》"></a>《浏览器端测试：mocha，chai，phantomjs》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson7 项目，在其中编写代码，我们暂时命名为 <em>vendor</em><br>根据下面的步骤，最终的项目结构应该长<a href="https://github.com/alsotang/node-lessons/tree/master/lesson7/vendor" target="_blank" rel="noopener">这样</a></p><p>这次我们测试的对象是上文提到的 fibonacci 函数</p><p>此函数的定义为 <code>int fibonacci(int n)</code></p><ul><li>当 n === 0 时，返回 0；n === 1时，返回 1;</li><li>n &gt; 1 时，返回 <code>fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)</code>，如 <code>fibonacci(10) === 55</code>;</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习使用测试框架 mocha 进行前端测试 : <a href="http://mochajs.org/" target="_blank" rel="noopener">http://mochajs.org/</a></li><li>了解全栈的断言库 chai: <a href="http://chaijs.com/" target="_blank" rel="noopener">http://chaijs.com/</a></li><li>了解 headless 浏览器 phantomjs: <a href="http://phantomjs.org/" target="_blank" rel="noopener">http://phantomjs.org/</a></li></ol><h3 id="前端脚本单元测试"><a href="#前端脚本单元测试" class="headerlink" title="前端脚本单元测试"></a>前端脚本单元测试</h3><p><a href="https://github.com/alsotang/node-lessons/tree/master/lesson6" target="_blank" rel="noopener">lesson6</a> 的内容都是针对后端环境中 node 的一些单元测试方案，出于应用健壮性的考量，针对前端 js 脚本的单元测试也非常重要。而前后端通吃，也是 mocha 的一大特点。</p><p>首先，前端脚本的单元测试主要有两个困难需要解决。</p><ol><li><p>运行环境应当在浏览器中，可以操纵浏览器的DOM对象，且可以随意定义执行时的 html 上下文。</p></li><li><p>测试结果应当可以直接反馈给 mocha，判断测试是否通过。</p></li></ol><h4 id="浏览器环境执行"><a href="#浏览器环境执行" class="headerlink" title="浏览器环境执行"></a>浏览器环境执行</h4><p>我们首先搭建一个测试原型，用 mocha 自带的脚手架可以自动生成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vendor            # 进入我们的项目文件夹</span><br><span class="line">npm i -g mocha       # 安装全局的 mocha 命令行工具</span><br><span class="line">mocha init .         # 生成脚手架</span><br></pre></td></tr></table></figure><p>mocha就会自动帮我们生成一个简单的测试原型, 目录结构如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── index.html       # 这是前端单元测试的入口</span><br><span class="line">├── mocha.css</span><br><span class="line">├── mocha.js</span><br><span class="line">└── tests.js         # 我们的单元测试代码将在这里编写</span><br></pre></td></tr></table></figure></p><p>其中 index.html 是单元测试的入口，tests.js 是我们的测试用例文件。</p><p>我们直接在 index.html 插入上述示例的 fibonacci 函数以及断言库 chaijs。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mocha"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://cdn.rawgit.com/chaijs/chai/master/chai.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在tests.js中写入对应测试用例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> should = chai.should();</span><br><span class="line">describe(<span class="string">'simple test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should equal 0 when n === 0'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.fibonacci(<span class="number">0</span>).should.equal(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这时打开index.html，可以发现测试结果，我们完成了浏览器端的脚本测试(注意我们调用了 <strong>window</strong> 对象)</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson7/1.png" alt=""></p><h4 id="测试反馈"><a href="#测试反馈" class="headerlink" title="测试反馈"></a>测试反馈</h4><p>mocha没有提供一个命令行的前端脚本测试环境(因为我们的脚本文件需要运行在浏览器环境中)，因此我们使用phantomjs帮助我们搭建一个模拟环境。不重复制造轮子，这里直接使用mocha-phantomjs帮助我们在命令行运行测试。</p><p>首先安装mocha-phanatomjs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g mocha-phantomjs</span><br></pre></td></tr></table></figure><p>然后在 index.html 的页面下加上这段兼容代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">mocha.run()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (<span class="built_in">window</span>.initMochaPhantomJS &amp;&amp; <span class="built_in">window</span>.location.search.indexOf(<span class="string">'skip'</span>) === <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="undefined">    initMochaPhantomJS()</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  mocha.ui(<span class="string">'bdd'</span>);</span></span><br><span class="line"><span class="undefined">  expect = chai.expect;</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  mocha.run();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时候, 我们在命令行中运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mocha-phantomjs index.html --ssl-protocol=any --ignore-ssl-errors=true</span><br></pre></td></tr></table></figure><p>结果展现是不是和后端代码测试很类似 :smile:</p><p>更进一步，我们可以直接在 package.json 的 scripts 中添加<br>(package.json 通过 <code>npm init</code> 生成，这里不再赘述)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "mocha-phantomjs index.html --ssl-protocol=any --ignore-ssl-errors=true"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>将mocha-phantomjs作为依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mocha-phantomjs --save-dev</span><br></pre></td></tr></table></figure><p>直接运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><p>至此,我们实现了前端脚本的单元测试，基于 phanatomjs 你几乎可以调用所有的浏览器方法，而 mocha-phanatomjs 也可以很便捷地将测试结果反馈到 mocha，便于后续的持续集成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《浏览器端测试：mocha，chai，phantomjs》&quot;&gt;&lt;a href=&quot;#《浏览器端测试：mocha，chai，phantomjs》&quot; class=&quot;headerlink&quot; title=&quot;《浏览器端测试：mocha，chai，phantomjs》&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>学习使用外部模块</title>
    <link href="http://yoursite.com/2017/06/20/node%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2017/06/20/node学习使用外部模块/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《学习使用外部模块》"><a href="#《学习使用外部模块》" class="headerlink" title="《学习使用外部模块》"></a>《学习使用外部模块》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson2 项目，在其中编写代码。</p><p>当在浏览器中访问 <code>http://localhost:3000/?q=alsotang</code> 时，输出 <code>alsotang</code> 的 md5 值，即 <code>bdd5e57b5c0040f9dc23d430846e68a3</code>。</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>访问 <code>http://localhost:3000/?q=alsotang</code> 时，输出 <code>alsotang</code> 的 sha1 值，即 <code>e3c766d71667567e18f77869c65cd62f6a1b9ab9</code>。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习 req.query 的用法</li><li>学习建立 package.json 来管理 Node.js 项目。</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>卧槽，不写 package.json 就写项目我觉得好不爽啊，所以这个 lesson2 我就得跟大家介绍一下 package.json 这个文件的用法了。</p><p>简单说来呢，这个 package.json 文件就是定义了项目的各种元信息，包括项目的名称，git repo 的地址，作者等等。最重要的是，其中定义了我们项目的依赖，这样这个项目在部署时，我们就不必将 <code>node_modules</code> 目录也上传到服务器，服务器在拿到我们的项目时，只需要执行 <code>npm install</code>，则 npm 会自动读取 package.json 中的依赖并安装在项目的 <code>node_modules</code> 下面，然后程序就可以在服务器上跑起来了。</p><p>本课程的每个 lesson 里面的示例代码都会带上一份 package.json，大家可以去看看它的大概样子。</p><p>我们来新建一个 lesson2 项目，并生成一份它的 package.json。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lesson2 &amp;&amp; cd lesson2</span><br><span class="line">$ npm init</span><br></pre></td></tr></table></figure><p>OK，这时会要求我们输入一些信息，乱填就好了，反正这个地方也不用填依赖关系。</p><p><code>npm init</code> 这个命令的作用就是帮我们互动式地生成一份最简单的 package.json 文件，<code>init</code> 是 <code>initialize</code> 的意思，初始化。</p><p>当乱填信息完毕之后，我们的目录下就会有个 package.json 文件了。</p><p>这时我们来安装依赖，这次的应用，我们依赖 <code>express</code> 和 <code>utility</code> 两个模块。</p><p><code>$ npm install express utility --save</code></p><p>这次的安装命令与上节课的命令有两点不同，一是没有指定 registry，没有指定的情况下，默认从 npm 官方安装，上次我们是从淘宝的源安装的。二是多了个 <code>--save</code> 参数，这个参数的作用，就是会在你安装依赖的同时，自动把这些依赖写入 package.json。命令执行完成之后，查看 package.json，会发现多了一个 <code>dependencies</code> 字段，如下图：</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/1.png" alt=""></p><p>这时查看 <code>node_modules</code> 目录，会发现有两个文件夹，分别是 express 和 utility</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/2.png" alt=""></p><p>我们开始写应用层的代码，建立一个 <code>app.js</code> 文件，复制以下代码进去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入依赖</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> utility = <span class="built_in">require</span>(<span class="string">'utility'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 express 实例</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从 req.query 中取出我们的 q 参数。</span></span><br><span class="line">  <span class="comment">// 如果是 post 传来的 body 数据，则是在 req.body 里面，不过 express 默认不处理 body 中的信息，需要引入 https://github.com/expressjs/body-parser 这个中间件才会处理，这个后面会讲到。</span></span><br><span class="line">  <span class="comment">// 如果分不清什么是 query，什么是 body 的话，那就需要补一下 http 的知识了</span></span><br><span class="line">  <span class="keyword">var</span> q = req.query.q;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 utility.md5 方法，得到 md5 之后的值</span></span><br><span class="line">  <span class="comment">// 之所以使用 utility 这个库来生成 md5 值，其实只是习惯问题。每个人都有自己习惯的技术堆栈，</span></span><br><span class="line">  <span class="comment">// 我刚入职阿里的时候跟着苏千和朴灵混，所以也混到了不少他们的技术堆栈，仅此而已。</span></span><br><span class="line">  <span class="comment">// utility 的 github 地址：https://github.com/node-modules/utility</span></span><br><span class="line">  <span class="comment">// 里面定义了很多常用且比较杂的辅助方法，可以去看看</span></span><br><span class="line">  <span class="keyword">var</span> md5Value = utility.md5(q);</span><br><span class="line"></span><br><span class="line">  res.send(md5Value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app is running at port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>OK，运行我们的程序</p><p><code>$ node app.js</code></p><p>访问 <code>http://localhost:3000/?q=alsotang</code>，完成。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>如果直接访问 <code>http://localhost:3000/</code> 会抛错</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson2/3.png" alt=""></p><p>可以看到，这个错误是从 <code>crypto.js</code> 中抛出的。</p><p>这是因为，当我们不传入 <code>q</code> 参数时，<code>req.query.q</code> 取到的值是 <code>undefined</code>，<code>utility.md5</code> 直接使用了这个空值，导致下层的 <code>crypto</code> 抛错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《学习使用外部模块》&quot;&gt;&lt;a href=&quot;#《学习使用外部模块》&quot; class=&quot;headerlink&quot; title=&quot;《学习使用外部模块》&quot;&gt;&lt;/a&gt;《学习使用外部模块》&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>17.使用 promise 替代回调函数</title>
    <link href="http://yoursite.com/2017/06/20/node%E4%BD%BF%E7%94%A8%20promise%20%E6%9B%BF%E4%BB%A3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/06/20/node使用 promise 替代回调函数/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《使用-promise-替代回调函数》"><a href="#《使用-promise-替代回调函数》" class="headerlink" title="《使用 promise 替代回调函数》"></a>《使用 promise 替代回调函数》</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>理解 Promise 概念，为什么需要 promise</li><li>学习 q 的 API，利用 q 来替代回调函数(<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a> )</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>第五课(<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="noopener">https://github.com/alsotang/node-lessons/tree/master/lesson5</a> )讲述了如何使用 async 来控制并发。async 的本质是一个流程控制。其实在异步编程中，还有一个更为经典的模型，叫做 Promise/Deferred 模型。</p><p>本节我们就来学习这个模型的代表实现：<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">q</a></p><p>首先，我们思考一个典型的异步编程模型，考虑这样一个题目：读取一个文件，在控制台输出这个文件内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'sample.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'sample01.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">fs.readFile(<span class="string">'sample02.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要是读取更多的文件呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'sample01.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">fs.readFile(<span class="string">'sample02.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">fs.readFile(<span class="string">'sample03.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">fs.readFile(<span class="string">'sample04.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码就是臭名昭著的邪恶金字塔(Pyramid of Doom)。可以使用async来改善这段代码，但是在本课中我们要用promise/defer来改善它。</p><h2 id="promise基本概念"><a href="#promise基本概念" class="headerlink" title="promise基本概念"></a>promise基本概念</h2><p>先学习promise的基本概念。</p><ul><li>promise只有三种状态，未完成，完成(fulfilled)和失败(rejected)。</li><li>promise的状态可以由未完成转换成完成，或者未完成转换成失败。</li><li>promise的状态转换只发生一次</li></ul><p>promise有一个then方法，then方法可以接受3个函数作为参数。前两个函数对应promise的两种状态fulfilled, rejected的回调函数。第三个函数用于处理进度信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promiseSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="comment">//当promise状态变成fulfilled时，调用此函数</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="comment">//当promise状态变成rejected时，调用此函数</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</span><br><span class="line"><span class="comment">//当返回进度信息时，调用此函数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>学习一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取初始promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInitialPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为promise设置三种状态的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getInitialPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(success);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(progress);</span><br><span class="line">&#125;);</span><br><span class="line">defer.notify(<span class="string">'in progress'</span>);<span class="comment">//控制台打印in progress</span></span><br><span class="line">defer.resolve(<span class="string">'resolve'</span>);   <span class="comment">//控制台打印resolve</span></span><br><span class="line">defer.reject(<span class="string">'reject'</span>);<span class="comment">//没有输出。promise的状态只能改变一次</span></span><br></pre></td></tr></table></figure><h2 id="promise的传递"><a href="#promise的传递" class="headerlink" title="promise的传递"></a>promise的传递</h2><p>then方法会返回一个promise，在下面这个例子中，我们用outputPromise指向then返回的promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span> (<span class="params">fulfilled</span>) </span>&#123;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">rejected</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在outputPromise就变成了受 <code>function(fulfilled)</code> 或者 <code>function(rejected)</code>控制状态的promise了。怎么理解这句话呢？</p><ul><li>当function(fulfilled)或者function(rejected)返回一个值，比如一个字符串，数组，对象等等，那么outputPromise的状态就会变成fulfilled。</li></ul><p>在下面这个例子中，我们可以看到，当我们把inputPromise的状态通过defer.resovle()变成fulfilled时，控制台输出fulfilled.</p><p>当我们把inputPromise的状态通过defer.reject()变成rejected，控制台输出rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * 将then返回的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由</span></span><br><span class="line"><span class="comment"> * 未完成改变为fulfilled</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'fulfilled'</span>;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'rejected'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印'fulfilled: fulfilled'。</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成rejected, 调用function(rejected), 控制台打印'rejected: rejected'。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject(); <span class="comment">//输出 fulfilled: rejected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve(); //输出 fulfilled: fulfilled</span></span><br></pre></td></tr></table></figure><ul><li>当function(fulfilled)或者function(rejected)抛出异常时，那么outputPromise的状态就会变成rejected</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * 将then返回的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * function(fulfilled) 和 function(rejected) 通过抛出异常将outputPromise的状态由</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fulfilled'</span>);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'rejected'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)。</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成rejected, 调用function(rejected)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject();     <span class="comment">//控制台打印 rejected [Error:rejected]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve(); //控制台打印 rejected [Error:fulfilled]</span></span><br></pre></td></tr></table></figure><ul><li>当function(fulfilled)或者function(rejected)返回一个promise时，outputPromise就会成为这个新的promise.</li></ul><p>这样做有什么意义呢? 主要在于聚合结果(Q.all)，管理延时，异常恢复等等</p><p>比如说我们想要读取一个文件的内容，然后把这些内容打印出来。可能会写出这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">fs.readFile(<span class="string">'test.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然而这样写是错误的，因为function(fulfilled)并没有返回任何值。需要下面的方式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * 将then返回的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * function(fulfilled)将新的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> myDefer = Q.defer();</span><br><span class="line">fs.readFile(<span class="string">'test.txt'</span>,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line">myDefer.resolve(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> myDefer.promise;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'rejected'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当outputPromise状态由未完成变成fulfil时，调用function(fulfilled)，控制台打印test.txt文件内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.reject();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.resolve(); <span class="comment">//控制台打印出 test.txt 的内容</span></span><br></pre></td></tr></table></figure><h2 id="方法传递"><a href="#方法传递" class="headerlink" title="方法传递"></a>方法传递</h2><p>方法传递有些类似于Java中的try和catch。当一个异常没有响应的捕获时，这个异常会接着往下传递。</p><p>方法传递的含义是当一个状态没有响应的回调函数，就会沿着then往下找。</p><ul><li>没有提供function(rejected)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>如果inputPromise的状态由未完成变成rejected, 此时对rejected的处理会由outputPromise来完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，这个rejected会传向outputPromise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'fulfilled'</span></span><br><span class="line">&#125;);</span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject(<span class="string">'inputpromise rejected'</span>); <span class="comment">//控制台打印rejected: inputpromise rejected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve();</span></span><br></pre></td></tr></table></figure><ul><li>没有提供function(fulfilled)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>如果inputPromise的状态由未完成变成fulfilled, 此时对fulfil的处理会由outputPromise来完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，传递给outputPromise</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * function(fulfilled)将新的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'rejected'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.reject('inputpromise rejected');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.resolve(<span class="string">'inputpromise fulfilled'</span>); <span class="comment">//控制台打印fulfilled: inputpromise fulfilled</span></span><br></pre></td></tr></table></figure><ul><li>可以使用fail(function(error))来专门针对错误处理，而不是使用then(null,function(error))</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().fail(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>看这个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfil时，调用then(function(fulfilled))</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用fail(function(error))</span></span><br><span class="line"><span class="comment"> * function(fulfilled)将新的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * 未完成改变为reject</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fulfilled;</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fail: '</span> + error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成rejected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">defer.reject(<span class="string">'inputpromise rejected'</span>);<span class="comment">//控制台打印fail: inputpromise rejected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将inputPromise的状态由未完成变成fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//defer.resolve('inputpromise fulfilled');</span></span><br></pre></td></tr></table></figure><ul><li>可以使用progress(function(progress))来专门针对进度信息进行处理，而不是使用 <code>then(function(success){},function(error){},function(progress){})</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取初始promise</span></span><br><span class="line"><span class="comment"> * @private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInitialPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为promise设置progress信息处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInitialPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).progress(<span class="function"><span class="keyword">function</span>(<span class="params">progress</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(progress);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">defer.notify(<span class="number">1</span>);</span><br><span class="line">defer.notify(<span class="number">2</span>); <span class="comment">//控制台打印1，2</span></span><br></pre></td></tr></table></figure><h2 id="promise链"><a href="#promise链" class="headerlink" title="promise链"></a>promise链</h2><p>promise链提供了一种让函数顺序执行的方法。</p><p>函数顺序执行是很重要的一个功能。比如知道用户名，需要根据用户名从数据库中找到相应的用户，然后将用户信息传给下一个函数进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个模拟数据库</span></span><br><span class="line"><span class="keyword">var</span> users = [&#123;<span class="string">'name'</span>:<span class="string">'andrew'</span>,<span class="string">'passwd'</span>:<span class="string">'password'</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> user;</span><br><span class="line">users.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(element.name === username) &#123;</span><br><span class="line">user = element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//promise链</span></span><br><span class="line">getUsername().then(<span class="function"><span class="keyword">function</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> getUser(username);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">defer.resolve(<span class="string">'andrew'</span>);</span><br></pre></td></tr></table></figure><p>我们通过两个then达到让函数顺序执行的目的。</p><p>then的数量其实是没有限制的。当然，then的数量过多，要手动把他们链接起来是很麻烦的。比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(initialVal).then(bar).then(baz).then(qux)</span><br></pre></td></tr></table></figure><p>这时我们需要用代码来动态制造promise链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [foo,bar,baz,qux]</span><br><span class="line"><span class="keyword">var</span> result = Q(initialVal)</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">result = result.then(func)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>当然，我们可以再简洁一点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [foo,bar,baz,qux]</span><br><span class="line">funcs.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,current</span>),<span class="title">Q</span>(<span class="params">initialVal</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> pre.then(current)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看一个具体的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="keyword">return</span> result+result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手动链接</span></span><br><span class="line">Q(<span class="string">'hello'</span>).then(foo).then(foo).then(foo); <span class="comment">//控制台输出： hello</span></span><br><span class="line"><span class="comment">//   hellohello</span></span><br><span class="line"><span class="comment">//   hellohellohello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态链接</span></span><br><span class="line"><span class="keyword">var</span> funcs = [foo,foo,foo];</span><br><span class="line"><span class="keyword">var</span> result = Q(<span class="string">'hello'</span>);</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">result = result.then(func);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//精简后的动态链接</span></span><br><span class="line">funcs.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,current</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> prev.then(current);</span><br><span class="line">&#125;,Q(<span class="string">'hello'</span>));</span><br></pre></td></tr></table></figure><p>对于promise链，最重要的是需要理解为什么这个链能够顺序执行。如果能够理解这点，那么以后自己写promise链可以说是轻车熟路啊。</p><h2 id="promise组合"><a href="#promise组合" class="headerlink" title="promise组合"></a>promise组合</h2><p>回到我们一开始读取文件内容的例子。如果现在让我们把它改写成promise链，是不是很简单呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>),</span><br><span class="line">fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">fs.readFile(fileName,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">defer.resolve();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手动链接</span></span><br><span class="line">printFileContent(<span class="string">'sample01.txt'</span>)()</span><br><span class="line">.then(printFileContent(<span class="string">'sample02.txt'</span>))</span><br><span class="line">.then(printFileContent(<span class="string">'sample03.txt'</span>))</span><br><span class="line">.then(printFileContent(<span class="string">'sample04.txt'</span>));   <span class="comment">//控制台顺序打印sample01到sample04的内容</span></span><br></pre></td></tr></table></figure><p>很有成就感是不是。然而如果仔细分析，我们会发现为什么要他们顺序执行呢，如果他们能够并行执行不是更好吗? 我们只需要在他们都执行完成之后，得到他们的执行结果就可以了。</p><p>我们可以通过Q.all([promise1,promise2…])将多个promise组合成一个promise返回。<br>注意：</p><ol><li>当all里面所有的promise都fulfil时，Q.all返回的promise状态变成fulfil</li><li>当任意一个promise被reject时，Q.all返回的promise状态立即变成reject</li></ol><p>我们来把上面读取文件内容的例子改成并行执行吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *读取文件内容</span></span><br><span class="line"><span class="comment"> *@private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line"><span class="comment">//Todo: 这段代码不够简洁。可以使用Q.denodeify来简化</span></span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">fs.readFile(fileName,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">defer.resolve(fileName + <span class="string">' success '</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">defer.reject(fileName + <span class="string">' fail '</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q.all([printFileContent(<span class="string">'sample01.txt'</span>),printFileContent(<span class="string">'sample02.txt'</span>),printFileContent(<span class="string">'sample03.txt'</span>),printFileContent(<span class="string">'sample04.txt'</span>)])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">success</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(success);</span><br><span class="line">&#125;); <span class="comment">//控制台打印各个文件内容 顺序不一定</span></span><br></pre></td></tr></table></figure><p>现在知道Q.all会在任意一个promise进入reject状态后立即进入reject状态。如果我们需要等到所有的promise都发生状态后(有的fulfil, 有的reject)，再转换Q.all的状态, 这时我们可以使用Q.allSettled</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>),</span><br><span class="line">fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *读取文件内容</span></span><br><span class="line"><span class="comment"> *@private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFileContent</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line"><span class="comment">//Todo: 这段代码不够简洁。可以使用Q.denodeify来简化</span></span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">fs.readFile(fileName,<span class="string">'utf8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!err &amp;&amp; data) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">defer.resolve(fileName + <span class="string">' success '</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">defer.reject(fileName + <span class="string">' fail '</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q.allSettled([printFileContent(<span class="string">'nosuchfile.txt'</span>),printFileContent(<span class="string">'sample02.txt'</span>),printFileContent(<span class="string">'sample03.txt'</span>),printFileContent(<span class="string">'sample04.txt'</span>)])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">results.forEach(</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(result.state);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="结束promise链"><a href="#结束promise链" class="headerlink" title="结束promise链"></a>结束promise链</h2><p>通常，对于一个promise链，有两种结束的方式。第一种方式是返回最后一个promise</p><p>如 <code>return foo().then(bar);</code></p><p>第二种方式就是通过done来结束promise链</p><p>如 <code>foo().then(bar).done()</code></p><p>为什么需要通过done来结束一个promise链呢? 如果在我们的链中有错误没有被处理，那么在一个正确结束的promise链中，这个没被处理的错误会通过异常抛出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *@private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params">msg,timeout,opt</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(msg);</span><br><span class="line"><span class="keyword">if</span>(opt)</span><br><span class="line">defer.reject(msg);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">defer.resolve(msg);</span><br><span class="line">&#125;,timeout);</span><br><span class="line"><span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *没有用done()结束的promise链</span></span><br><span class="line"><span class="comment"> *由于getPromse('2',2000,'opt')返回rejected, getPromise('3',1000)就没有执行</span></span><br><span class="line"><span class="comment"> *然后这个异常并没有任何提醒，是一个潜在的bug</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getPromise(<span class="string">'1'</span>,<span class="number">3000</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'2'</span>,<span class="number">2000</span>,<span class="string">'opt'</span>)&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'3'</span>,<span class="number">1000</span>)&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *用done()结束的promise链</span></span><br><span class="line"><span class="comment"> *有异常抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getPromise(<span class="string">'1'</span>,<span class="number">3000</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'2'</span>,<span class="number">2000</span>,<span class="string">'opt'</span>)&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> getPromise(<span class="string">'3'</span>,<span class="number">1000</span>)&#125;)</span><br><span class="line">.done();</span><br></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>当你理解完上面所有的知识点时，你就会正确高效的使用promise了。本节只是讲了promise的原理和几个基本的API，不过你掌握了这些之后，再去看q的文档，应该很容易就能理解各个api的意图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《使用-promise-替代回调函数》&quot;&gt;&lt;a href=&quot;#《使用-promise-替代回调函数》&quot; class=&quot;headerlink&quot; title=&quot;《使用 promise 替代回调函数》&quot;&gt;&lt;/a&gt;《使用 promise 替代回调函数》&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>1.搭建 Node.js 开发环境</title>
    <link href="http://yoursite.com/2017/06/20/%E6%90%AD%E5%BB%BA%20Node.js%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2017/06/20/搭建 Node.js 开发环境/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《搭建-Node-js-开发环境》"><a href="#《搭建-Node-js-开发环境》" class="headerlink" title="《搭建 Node.js 开发环境》"></a>《搭建 Node.js 开发环境》</h1><p>本课程假设大家都是在 Linux 或者 Mac 下面。至于使用 Windows 并坚持玩新技术的同学，我坚信他们一定有着过人的、甚至是不可告人的兼容性 bug 处理能力，所以这部分同学麻烦在课程无法继续时，自行兼容一下。</p><p>不久前公司刚发一台新 Mac 给我，所以我对于在新环境中安装 Node.js 的过程还是记忆犹新的。</p><p>其实这过程特别简单:</p><h3 id="先安装一个-nvm（-https-github-com-creationix-nvm-）"><a href="#先安装一个-nvm（-https-github-com-creationix-nvm-）" class="headerlink" title="先安装一个 nvm（ https://github.com/creationix/nvm ）"></a>先安装一个 nvm（ <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a> ）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash</span><br></pre></td></tr></table></figure><p>nvm 的全称是 <strong>Node Version Manager</strong>，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。</p><p>安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm</span><br></pre></td></tr></table></figure><p>当看到有输出时，则 nvm 安装成功。</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>使用 nvm 的命令安装 Node.js 最新稳定版，现在是 <code>v0.12.3</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install 0.12</span><br></pre></td></tr></table></figure><p>安装完成后，查看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls</span><br></pre></td></tr></table></figure><p>这时候可以看到自己安装的所有 Node.js 版本，输出应如下：</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson0/1.png" alt=""></p><p>（图1）</p><p>那个绿色小箭头的意思就是现在正在使用的版本，我这里是 <code>v0.10.29</code>。我还安装了 <code>v0.11.14</code>，但它并非我当前使用的版本。</p><p>如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 <code>0.12.x</code> 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm use 0.12</span><br></pre></td></tr></table></figure><p>然后再次查看，这时候小箭头应该出现了。</p><p>OK，我们在终端中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br></pre></td></tr></table></figure><p>REPL(read–eval–print loop) 应该就出来了，那我们就成功了。</p><p>随便敲两行命令玩玩吧。</p><p>比如 <code>&gt; while (true) {}</code>，这时你的 CPU 应该会飚高。</p><h3 id="完善安装"><a href="#完善安装" class="headerlink" title="完善安装"></a>完善安装</h3><p>上述过程完成后，有时会出现，当开启一个新的 shell 窗口时，找不到 node 命令的情况。</p><p>这种情况一般来自两个原因</p><p>一、shell 不知道 nvm 的存在</p><p>二、nvm 已经存在，但是没有 default 的 Node.js 版本可用。</p><p>解决方式：</p><p>一、检查 <code>~/.profile</code> 或者 <code>~/.bash_profile</code> 中有没有这样两句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR=&quot;/Users/YOURUSERNAME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</span><br></pre></td></tr></table></figure><p>没有的话，加进去。</p><p>这两句会在 bash 启动的时候被调用，然后注册 nvm 命令。</p><p>二、</p><p>调用</p><p><code>$ nvm ls</code></p><p>看看像不像上述图1中一样，有 default 的指向。</p><p>如果没有的话，执行</p><p><code>$ nvm alias default 0.12</code></p><p>再</p><p><code>$ nvm ls</code></p><p>看一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《搭建-Node-js-开发环境》&quot;&gt;&lt;a href=&quot;#《搭建-Node-js-开发环境》&quot; class=&quot;headerlink&quot; title=&quot;《搭建 Node.js 开发环境》&quot;&gt;&lt;/a&gt;《搭建 Node.js 开发环境》&lt;/h1&gt;&lt;p&gt;本课程假设大家都是在
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>2.一个最简单的 express 应用</title>
    <link href="http://yoursite.com/2017/06/20/%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%20express%20%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/06/20/一个最简单的 express 应用/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《一个最简单的-express-应用》"><a href="#《一个最简单的-express-应用》" class="headerlink" title="《一个最简单的 express 应用》"></a>《一个最简单的 express 应用》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 <code>http://localhost:3000/</code> 时，输出 <code>Hello World</code>。</p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>访问 <code>http://localhost:3000/</code> 时，输出 <code>你好，世界</code>。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。</li><li>框架 express 。学习新建 express 实例，并定义 routes ，产生输出。</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>按照惯例，我们来个 helloworld 入门。</p><h3 id="包管理器-npm"><a href="#包管理器-npm" class="headerlink" title="包管理器 npm"></a>包管理器 npm</h3><p>npm 可以自动管理包的依赖. 只需要安装你想要的包, 不必考虑这个包的依赖包.</p><p>在 PHP 中, 包管理使用的 <code>Composer</code>, python 中，包管理使用 <code>easy_install</code> 或者 <code>pip</code>，ruby 中我们使用 <code>gem</code>。而在 Node.js 中，对应就是 <code>npm</code>，npm 是 <code>Node.js Package Manager</code> 的意思。</p><h3 id="框架-Express"><a href="#框架-Express" class="headerlink" title="框架 Express"></a>框架 Express</h3><p>express 是 Node.js 应用最广泛的 web 框架，现在是 4.x 版本，它非常薄。跟 Rails 比起来，完全两个极端。</p><p>express 的官网是 <a href="http://expressjs.com/" target="_blank" rel="noopener">http://expressjs.com/</a> ，我常常上去看它的 API。</p><p>首先我们需要得到一个 express。</p><p>不同于 ruby 的 gem 装在全局，Node.js 的依赖是以项目为单位管理的，直接就安装在项目的 <code>node_modules</code> 目录下，而且每个依赖都可以有指定版本的其他依赖，这些依赖像一棵树一样。根据我自己的使用经验来说，npm 的体验在 pip 和 gem 之上。</p><p>OK，新建一个文件夹叫 lesson1 的，进去里面安装 express</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lesson1 &amp;&amp; cd lesson1</span><br><span class="line"># 这里没有从官方 npm 安装，而是使用了大淘宝的 npm 镜像</span><br><span class="line">$ npm install express --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装完成后，我们的 lesson1 目录下应该会出现一个 <code>node_modules</code> 文件夹，<code>ls</code> 看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls node_modules</span><br></pre></td></tr></table></figure><p>里面如果出现 express 文件夹则说明安装成功。</p><p>或者 npm命令提供更清晰直观的显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list</span><br></pre></td></tr></table></figure></p><p>我们继续应用程序的编写。</p><p>新建一个 app.js 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch app.js</span><br></pre></td></tr></table></figure><p>copy 进去这些代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这句的意思就是引入 `express` 模块，并将它赋予 `express` 这个变量等待使用。</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="comment">// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。</span></span><br><span class="line"><span class="comment">// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。</span></span><br><span class="line"><span class="comment">// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。</span></span><br><span class="line"><span class="comment">// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'app is listening at port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行</p><p><code>$ node app.js</code></p><p>这时候我们的 app 就跑起来了，终端中会输出 <code>app is listening at port 3000</code>。这时我们打开浏览器，访问 <code>http://localhost:3000/</code>，会出现 <code>Hello World</code>。如果没有出现的话，肯定是上述哪一步弄错了，自己调试一下。</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>在这个例子中，node代码监听了3000端口，用户通过访问<code>http://localhost:3000/</code> 得到了内容，为什么呢？</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口的作用：<code>通过端口来区分出同一电脑内不同应用或者进程，从而实现一条物理网线(通过分组交换技术-比如internet)同时链接多个程序</code><br><a href="http://en.wikipedia.org/wiki/Port_(computer_networking" target="_blank" rel="noopener">Port_(computer_networking)</a>)</p><p>端口号是一个 16位的 uint, 所以其范围为 1 to 65535 (对TCP来说, port 0 被保留，不能被使用. 对于UDP来说, source端的端口号是可选的， 为0时表示无端口).</p><p><code>app.listen(3000)</code>，进程就被打标，电脑接收到的3000端口的网络消息就会被发送给我们启动的这个进程</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p><a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">RFC1738</a> 定义的url格式笼统版本<code>&lt;scheme&gt;:&lt;scheme-specific-part&gt;</code>，<br>scheme有我们很熟悉的<code>http</code>、<code>https</code>、<code>ftp</code>，以及著名的<code>ed2k</code>，<code>thunder</code>。</p><p>通常我们熟悉的url定义成这个样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;</span><br></pre></td></tr></table></figure></p><p>用过ftp的估计能体会这么长的，网页上很少带auth信息，所以就精简成这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;</span><br></pre></td></tr></table></figure></p><p>在上面的例子中, scheme=http, host=localhost, port=3000, url-path=/, 再联想对照一下浏览器端<code>window.location</code>对象。<br>著名的<code>localhost</code>，你可以在电脑的hosts文件上找到</p><p><a href="http://en.wikipedia.org/wiki/URI_scheme" target="_blank" rel="noopener">在这篇文章中提到</a>： <code>URI schemes are frequently and incorrectly referred to as &quot;protocols&quot;, or specifically as URI protocols or URL protocols, since most were originally designed to be used with a particular protocol, and often have the same name</code>，比较认同这个观点，尤其是今天移动设备的时代里， android和ios的开发中大量使用uri作为跨app通讯通道，把scheme理解为协议略狭隘了。</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>在了解完端口和url之后，再去看例子代码，相信应该好理解很多。<br>有必要的话，还可以在解刨一下express的use逻辑，对峙<code>http.createServer</code>，相信还有火花，:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《一个最简单的-express-应用》&quot;&gt;&lt;a href=&quot;#《一个最简单的-express-应用》&quot; class=&quot;headerlink&quot; title=&quot;《一个最简单的 express 应用》&quot;&gt;&lt;/a&gt;《一个最简单的 express 应用》&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>9.正则表达式</title>
    <link href="http://yoursite.com/2017/06/20/node%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/06/20/node正则表达式/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《正则表达式》"><a href="#《正则表达式》" class="headerlink" title="《正则表达式》"></a>《正则表达式》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> web_development = <span class="string">"python php ruby javascript jsonp perhapsphpisoutdated"</span>;</span><br></pre></td></tr></table></figure><p>找出其中 包含 <code>p</code> 但不包含 <code>ph</code> 的所有单词，即</p><p><code>[ &#39;python&#39;, &#39;javascript&#39;, &#39;jsonp&#39; ]</code></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>正则表达式的使用</li><li>js 中的正则表达式与 pcre(<a href="http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions</a> ) 的区别</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>开始这门课之前，大家先去看两篇文章。</p><p>《正则表达式30分钟入门教程》：<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">http://deerchao.net/tutorials/regex/regex.htm</a></p><p>上面这篇介绍了正则表达式的基础知识，但是对于零宽断言没有展开来讲，零宽断言看下面这篇：</p><p>《正则表达式之：零宽断言不『消费』》：<a href="http://fxck.it/post/50558232873" target="_blank" rel="noopener">http://fxck.it/post/50558232873</a></p><p>好了。</p><p>在很久很久以前，有一门语言一度是字符串处理领域的王者，叫 perl。</p><p>伴随着 perl，有一个类似正则表达式的标准被实现了出来，叫 pcre：Perl Compatible Regular Expressions。</p><p>不遗憾的是，js 里面的正则与 pcre 不是兼容的。很多语言都这样。</p><p>如果需要测试你自己写的正则表达式，建议上这里：<a href="http://refiddle.com/" target="_blank" rel="noopener">http://refiddle.com/</a> ，可以所见即所得地调试。</p><p>接下来我们主要讲讲 js 中需要注意的地方，至于正则表达式的内容，上面那两篇文章足够学习了。</p><p>第一，</p><p>js 中，对于四种零宽断言，只支持 零宽度正预测先行断言 和 零宽度负预测先行断言 这两种。</p><p>第二，</p><p>js 中，正则表达式后面可以跟三个 flag，比如 <code>/something/igm</code>。</p><p>他们的意义分别是，</p><ul><li>i 的意义是不区分大小写</li><li>g 的意义是，匹配多个</li><li>m 的意义是，是 <code>^</code> 和 <code>$</code> 可以匹配<strong>每</strong>一行的开头。</li></ul><p>分别举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/a/.test(<span class="string">'A'</span>) <span class="comment">// =&gt; false</span></span><br><span class="line">/a/i.test(<span class="string">'A'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'hello hell hoo'</span>.match(<span class="regexp">/h.*?\b/</span>) <span class="comment">// =&gt; [ 'hello', index: 0, input: 'hello hell hoo' ]</span></span><br><span class="line"><span class="string">'hello hell hoo'</span>.match(<span class="regexp">/h.*?\b/g</span>) <span class="comment">// =&gt; [ 'hello', 'hell', 'hoo' ]</span></span><br><span class="line"></span><br><span class="line"><span class="string">'aaa\nbbb\nccc'</span>.match(<span class="regexp">/^[\s\S]*?$/g</span>) <span class="comment">// =&gt; [ 'aaa\nbbb\nccc' ]</span></span><br><span class="line"><span class="string">'aaa\nbbb\nccc'</span>.match(<span class="regexp">/^[\s\S]*?$/gm</span>) <span class="comment">// =&gt; [ 'aaa', 'bbb', 'ccc' ]</span></span><br></pre></td></tr></table></figure><p>与 m 意义相关的，还有 <code>\A</code>, <code>\Z</code> 和 <code>\z</code></p><p>他们的意义分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\A  字符串开头(类似^，但不受处理多行选项的影响)</span><br><span class="line">\Z  字符串结尾或行尾(不受处理多行选项的影响)</span><br><span class="line">\z  字符串结尾(类似$，但不受处理多行选项的影响)</span><br></pre></td></tr></table></figure><p>在 js 中，g flag 会影响 <code>String.prototype.match()</code> 和 <code>RegExp.prototype.exec()</code> 的行为</p><p><code>String.prototype.match()</code> 中，返回数据的格式会不一样，加 g 会返回数组，不加 g 则返回比较详细的信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">'hello hell'</span>.match(<span class="regexp">/h(.*?)\b/g</span>)</span><br><span class="line">[ <span class="string">'hello'</span>, <span class="string">'hell'</span> ]</span><br><span class="line"></span><br><span class="line">&gt; <span class="string">'hello hell'</span>.match(<span class="regexp">/h(.*?)\b/</span>)</span><br><span class="line">[ <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'ello'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello hell'</span> ]</span><br></pre></td></tr></table></figure><p><code>RegExp.prototype.exec()</code> 中，加 g 之后，如果你的正则不是字面量的正则，而是存储在变量中的话，特么的这个变量就会变得有记忆！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="regexp">/h(.*?)\b/g</span>.exec(<span class="string">'hello hell'</span>)</span><br><span class="line">[ <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'ello'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello hell'</span> ]</span><br><span class="line">&gt; <span class="regexp">/h(.*?)\b/g</span>.exec(<span class="string">'hello hell'</span>)</span><br><span class="line">[ <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'ello'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello hell'</span> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">var</span> re = <span class="regexp">/h(.*?)\b/g</span>;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; re.exec(<span class="string">'hello hell'</span>)</span><br><span class="line">[ <span class="string">'hello'</span>,</span><br><span class="line">  <span class="string">'ello'</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">'hello hell'</span> ]</span><br><span class="line">&gt; re.exec(<span class="string">'hello hell'</span>)</span><br><span class="line">[ <span class="string">'hell'</span>,</span><br><span class="line">  <span class="string">'ell'</span>,</span><br><span class="line">  index: <span class="number">6</span>,</span><br><span class="line">  input: <span class="string">'hello hell'</span> ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>第三，</p><p>大家知道，<code>.</code> 是不可以匹配 <code>\n</code> 的。如果我们想匹配的数据涉及到了跨行，比如下面这样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline = <span class="built_in">require</span>(<span class="string">'multiline'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = multiline.stripIndent(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    head</span></span><br></pre></td></tr></table></figure><pre><code>code code2 .code3<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>foot</code></pre><p>*/<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果我们想把两个 \`\`\` 中包含的内容取出来，应该怎么办？</span><br><span class="line"></span><br><span class="line">直接用 `.` 匹配不到 `\n`，所以我们需要找到一个原子，能匹配包括 `\n` 在内的所有字符。</span><br><span class="line"></span><br><span class="line">这个原子的惯用写法就是 `[\s\S]`</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">var match1 = text.match(/^```[\s\S]+?^```/gm);</span><br><span class="line">console.log(match1) // =&gt; [ &apos;```\ncode code2 code3```\n```&apos; ]</span><br><span class="line"></span><br><span class="line">// 这里有一种很骚的写法，[^] 与 [\s\S] 等价</span><br><span class="line">var match2 = text.match(/^```[^]+?^```/gm)</span><br><span class="line">console.log(match2) // =&gt; [ &apos;```\ncode code2 .code3```\n```&apos; ]</span><br></pre></td></tr></table></figure></p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《正则表达式》&quot;&gt;&lt;a href=&quot;#《正则表达式》&quot; class=&quot;headerlink&quot; title=&quot;《正则表达式》&quot;&gt;&lt;/a&gt;《正则表达式》&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>13.持续集成平台：travis</title>
    <link href="http://yoursite.com/2017/06/20/node%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B9%B3%E5%8F%B0%EF%BC%9Atravis/"/>
    <id>http://yoursite.com/2017/06/20/node持续集成平台：travis/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《持续集成平台：travis》"><a href="#《持续集成平台：travis》" class="headerlink" title="《持续集成平台：travis》"></a>《持续集成平台：travis》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>无明确目标</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习使用 travis-ci 对项目进行持续集成测试 (<a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a> )</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>首先来看看这个项目：<a href="https://github.com/Ricardo-Li/node-practice-3" target="_blank" rel="noopener">https://github.com/Ricardo-Li/node-practice-3</a></p><p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson13/1.png" alt=""></p><p>（图1）</p><p>类似这样的 badges，在很多项目中都可以看到。前者是告诉我们，这个项目的测试目前是通过的；后者是告诉我们，这个测试的行覆盖率是多少。行覆盖率当然是越多越好。测试的重要性我就不说了。</p><p>为什么要使用 travis 这样的平台，是因为它可以让你明白自己的项目在一个“空白环境”中，是否能正确运行；也可以让你知道，用不同的 Node.js 版本运行的话，有没有兼容性问题。</p><p>当你在自己的机器上跑测试的时候，你用着特定的 Node.js 版本，比如 0.10，如果测试过了，你也还是不懂在 0.11 下，你的测试能不能通过。你可以手动地切换 node 版本再跑一次，也可以选择让 travis 帮你把不同的 node 版本跑一次。而且有时候，我们 npm 安装了某个包，但却忘记将它写入 package.json 里面了，在自己的机器上，测试没问题，但当别的用户安装你的包时，会发现有依赖缺失。</p><p>travis 应该是把虚拟机的技术玩得比较好，它每次跑测试时，都会提供一个空白的环境。这个环境只有 Linux 基本的 <code>build-essential</code> 和 <code>wget</code>、<code>git</code> 那些依赖。连 Node.js 的运行时都是现跑现安装的。</p><p>travis 默认带有的那些依赖，都是每个用户的机器上都会有的，所以一旦你的应用在 travis 上面能够跑通，那么就不用担心别的用户安装不上了。</p><p>我们来讲讲接入 travis 的步骤。</p><p>travis 的价格是免费的，对于 github 上的开源项目来说。它默认当然不可能帮 github 的每个用户都跑测试，所以你需要去注册一下 travis，然后告诉它你需要开启集成测试的仓库。</p><p><img src="https://github.com/alsotang/node-lessons/blob/master/lesson13/2.png" alt=""></p><p>比如上图，可以看到我帮自己的 <code>alsohosts</code> 项目以及 <code>adsf</code> 项目开启了测试。</p><p>当你在 travis 授权了仓库之后，每当你 push 代码到 github，travis 都会自动帮你跑测试。</p><p>travis 通过授权，可以知道你的项目在什么地方，于是它就可以把项目 clone 过去。但问题又来了，它不懂你的测试怎么跑啊。用 <code>npm test</code> 还是 <code>make test</code> 还是 <code>jake test</code> 呢？</p><p>所以我们需要给出一些配置信息，配置信息以 <code>.travis.yml</code> 文件的形式放在项目根目录，比如一个简单的 <code>.travis.yml</code>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">'0.8'</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">'0.10'</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">'0.11'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span> <span class="string">make</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>这个文件传递的信息是：</p><ul><li>这是一个 node.js 应用</li><li>这个测试需要用 0.8、0.10 以及 0.11 三个版本来跑</li><li>跑测试的命令是 <code>make test</code></li></ul><p>将这个文件添加到项目的根目录下，再 push 上 github，这时候 travis 就会被触发了。</p><p>travis 接着会做的事情是：</p><ol><li>安装一个 node.js 运行时。由于我们指定了三个不同版本，于是 travis 会使用三个机器，分别安装三个版本的 node.js</li><li>这些机器在完成运行时安装后，会进入项目目录执行 <code>npm install</code> 来安装依赖。</li><li>当依赖安装完成后，执行我们指定的 script，在这里也就是 <code>make test</code></li></ol><p>如果测试通过的话，make 命令的返回码会是 0（如果不懂什么是返回码，则需要补补 shell 的知识），则测试通过；如果测试有不通过的 case，则返回码不会为 0，travis 则判断测试失败。</p><p>每一个 travis 上面的项目，都可以得到一个图片地址，这个地址上的图片会显示你项目当前的测试通过状态，把这个图片添加到自己项目的 README 中，就可以得到我们图1的那种逼格了。</p><p>对了，行覆盖率的那个 badge 是由一个叫 coveralls(<a href="https://coveralls.io/" target="_blank" rel="noopener">https://coveralls.io/</a> ) 的服务提供的。大家可以试着自己接入。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明:"></a>补充说明:</h2><p>如果你的应用有使用到数据库, 需要在 <code>.travis.yml</code> 中添加一些内容.</p><p>以 MongoDB 为例:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="string">mongodb</span></span><br></pre></td></tr></table></figure><p>其它数据库详细内容参考<a href="http://docs.travis-ci.com/user/database-setup/" target="_blank" rel="noopener">travis 官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《持续集成平台：travis》&quot;&gt;&lt;a href=&quot;#《持续集成平台：travis》&quot; class=&quot;headerlink&quot; title=&quot;《持续集成平台：travis》&quot;&gt;&lt;/a&gt;《持续集成平台：travis》&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>16.cookie 和 session</title>
    <link href="http://yoursite.com/2017/06/20/nodecookie%20%E5%92%8C%20session/"/>
    <id>http://yoursite.com/2017/06/20/nodecookie 和 session/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h1><p>众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？</p><p>比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步：</p><ul><li>服务器向客户端发送 cookie。<ul><li>通常使用 HTTP 协议规定的 set-cookie 头操作。</li><li>规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。</li></ul></li><li>浏览器将 cookie 保存。</li><li>每次请求浏览器都会将 cookie 发向服务器。</li></ul><p>其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种：</p><ul><li>path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。</li><li>expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。</li><li>secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</li><li>httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。</li></ul><h3 id="express-中的-cookie"><a href="#express-中的-cookie" class="headerlink" title="express 中的 cookie"></a>express 中的 cookie</h3><p>express 在 4.x 版本之后，session管理和cookies等许多模块都不再直接包含在express中，而是需要单独添加相应模块。</p><p>express4 中操作 cookie 使用 <code>cookie-parser</code> 模块(<a href="https://github.com/expressjs/cookie-parser" target="_blank" rel="noopener">https://github.com/expressjs/cookie-parser</a> )。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="comment">// 首先引入 cookie-parser 这个模块</span></span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 cookieParser 中间件，cookieParser(secret, options)</span></span><br><span class="line"><span class="comment">// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）</span></span><br><span class="line"><span class="comment">// options 传入上面介绍的 cookie 可选参数</span></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果请求中的 cookie 存在 isVisit, 则输出 cookie</span></span><br><span class="line">  <span class="comment">// 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟</span></span><br><span class="line">  <span class="keyword">if</span> (req.cookies.isVisit) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.cookies);</span><br><span class="line">    res.send(<span class="string">"再次欢迎访问"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.cookie(<span class="string">'isVisit'</span>, <span class="number">1</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span>&#125;);</span><br><span class="line">    res.send(<span class="string">"欢迎第一次访问"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。</p><p>session 的运作通过一个 <code>session_id</code> 来进行。<code>session_id</code> 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 <code>connect.sid</code> 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。</p><p>这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 <code>connect.sid</code> 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。</p><p>session 可以存放在 1）内存、2）cookie本身、3）redis 或 memcached 等缓存中，或者4）数据库中。线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题，下面会提到。</p><p>express 中操作 session 要用到 <code>express-session</code> (<a href="https://github.com/expressjs/session" target="_blank" rel="noopener">https://github.com/expressjs/session</a> ) 这个模块，主要的方法就是 <code>session(options)</code>，其中 options 中包含可选参数，主要有：</p><ul><li>name: 设置 cookie 中，保存 session 的字段名称，默认为 <code>connect.sid</code> 。</li><li>store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。</li><li>secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。</li><li>cookie: 设置存放 session id 的 cookie 的相关选项，默认为<ul><li>(default: { path: ‘/‘, httpOnly: true, secure: false, maxAge: null })</li></ul></li><li>genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 <code>uid2</code> 这个 npm 包。</li><li>rolling: 每个请求都重新设置一个 cookie，默认为 false。</li><li>resave: 即使 session 没有被修改，也保存 session 值，默认为 true。</li></ul><p>1） 在内存中存储 session</p><p><code>express-session</code> 默认使用内存来存 session，对于开发调试来说很方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="comment">// 首先引入 express-session 这个模块</span></span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照上面的解释，设置 session 的可选参数</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: <span class="string">'recommand 128 bytes random string'</span>, <span class="comment">// 建议使用 128 个字符的随机字符串</span></span><br><span class="line">  cookie: &#123; <span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span> &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查 session 中的 isVisit 字段</span></span><br><span class="line">  <span class="comment">// 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1。</span></span><br><span class="line">  <span class="keyword">if</span>(req.session.isVisit) &#123;</span><br><span class="line">    req.session.isVisit++;</span><br><span class="line">    res.send(<span class="string">'&lt;p&gt;第 '</span> + req.session.isVisit + <span class="string">'次来此页面&lt;/p&gt;'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.session.isVisit = <span class="number">1</span>;</span><br><span class="line">    res.send(<span class="string">"欢迎第一次来这里"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(req.session);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2） 在 redis 中存储 session</p><p>session 存放在内存中不方便进程间共享，因此可以使用 redis 等缓存来存储 session。</p><p>假设你的机器是 4 核的，你使用了 4 个进程在跑同一个 node web 服务，当用户访问进程1时，他被设置了一些数据当做 session 存在内存中。而下一次访问时，他被负载均衡到了进程2，则此时进程2的内存中没有他的信息，认为他是个新用户。这就会导致用户在我们服务中的状态不一致。</p><p>使用 redis 作为缓存，可以使用 <code>connect-redis</code> 模块(<a href="https://github.com/tj/connect-redis" target="_blank" rel="noopener">https://github.com/tj/connect-redis</a> )来得到 redis 连接实例，然后在 session 中设置存储方式为该实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">var</span> redisStore = <span class="built_in">require</span>(<span class="string">'connect-redis'</span>)(session);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  <span class="comment">// 假如你不想使用 redis 而想要使用 memcached 的话，代码改动也不会超过 5 行。</span></span><br><span class="line">  <span class="comment">// 这些 store 都遵循着统一的接口，凡是实现了那些接口的库，都可以作为 session 的 store 使用，比如都需要实现 .get(keyString) 和 .set(keyString, value) 方法。</span></span><br><span class="line">  <span class="comment">// 编写自己的 store 也很简单</span></span><br><span class="line">  store: <span class="keyword">new</span> redisStore(),</span><br><span class="line">  secret: <span class="string">'somesecrettoken'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(req.session.isVisit) &#123;</span><br><span class="line">    req.session.isVisit++;</span><br><span class="line">    res.send(<span class="string">'&lt;p&gt;第 '</span> + req.session.isVisit + <span class="string">'次来到此页面&lt;/p&gt;'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.session.isVisit = <span class="number">1</span>;</span><br><span class="line">    res.send(<span class="string">'欢迎第一次来这里'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以运行 <code>redis-cli</code> 查看结果，如图可以看到 redis 中缓存结果。</p><p><img src="https://github.com/Ricardo-Li/node-lessons/blob/master/lesson16/1.png" alt=""></p><h3 id="各种存储的利弊"><a href="#各种存储的利弊" class="headerlink" title="各种存储的利弊"></a>各种存储的利弊</h3><p>上面我们说到，session 的 store 有四个常用选项：1）内存 2）cookie 3）缓存 4）数据库</p><p>其中，开发环境存内存就好了。一般的小程序为了省事，如果不涉及状态共享的问题，用内存 session 也没问题。但内存 session 除了省事之外，没有别的好处。</p><p>cookie session 我们下面会提到，现在说说利弊。用 cookie session 的话，是不用担心状态共享问题的，因为 session 的 data 不是由服务器来保存，而是保存在用户浏览器端，每次用户访问时，都会主动带上他自己的信息。当然在这里，安全性之类的，只要遵照最佳实践来，也是有保证的。它的弊端是增大了数据量传输，利端是方便。</p><p>缓存方式是最常用的方式了，即快，又能共享状态。相比 cookie session 来说，当 session data 比较大的时候，可以节省网络传输。推荐使用。</p><p>数据库 session。除非你很熟悉这一块，知道自己要什么，否则还是老老实实用缓存吧。</p><h3 id="signedCookie"><a href="#signedCookie" class="headerlink" title="signedCookie"></a>signedCookie</h3><p>上面都是讲基础，现在讲一些专业点的。</p><p>上面有提到</p><blockquote><p>cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造</p></blockquote><p>其实不是这样的，那只是为了方便理解才那么写。要知道，计算机领域有个名词叫 <strong>签名</strong>，专业点说，叫 <strong>信息摘要算法</strong>。</p><p>比如我们现在面临着一个菜鸟开发的网站，他用 cookie 来记录登陆的用户凭证。相应的 cookie 长这样：<code>dotcom_user=alsotang</code>，它说明现在的用户是 alsotang 这个用户。如果我在浏览器中装个插件，把它改成 <code>dotcom_user=ricardo</code>，服务器一读取，就会误认为我是 ricardo。然后我就可以进行 ricardo 才能进行的操作了。之前 web 开发不成熟的时候，用这招甚至可以黑个网站下来，把 cookie 改成 <code>dotcom_user=admin</code> 就行了，唉，那是个玩黑客的黄金年代啊。</p><p>OK，现在我有一些数据，不想存在 session 中，想存在 cookie 中，怎么保证不被篡改呢？答案很简单，签个名。</p><p>假设我的服务器有个秘密字符串，是 <code>this_is_my_secret_and_fuck_you_all</code>，我为用户 cookie 的 <code>dotcom_user</code> 字段设置了个值 <code>alsotang</code>。cookie 本应是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">dotcom_user</span>: <span class="string">'alsotang'</span>&#125;</span><br></pre></td></tr></table></figure><p>这样的。</p><p>而如果我们签个名，比如把 <code>dotcom_user</code> 的值跟我的 secret_string 做个 sha1</p><p><code>sha1(&#39;this_is_my_secret_and_fuck_you_all&#39; + &#39;alsotang&#39;) === &#39;4850a42e3bc0d39c978770392cbd8dc2923e3d1d&#39;</code></p><p>然后把 cookie 变成这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  dotcom_user: <span class="string">'alsotang'</span>,</span><br><span class="line">  <span class="string">'dotcom_user.sig'</span>: <span class="string">'4850a42e3bc0d39c978770392cbd8dc2923e3d1d'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，用户就没法伪造信息了。一旦它更改了 cookie 中的信息，则服务器会发现 hash 校验的不一致。</p><p>毕竟他不懂我们的 secret_string 是什么，而暴力破解哈希值的成本太高。</p><h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie-session"></a>cookie-session</h3><p><del><br>上面一直提到 session 可以存在 cookie 中，现在来讲讲具体的思路。这里所涉及的专业名词叫做 对称加密。</del></p><p>假设我们想在用户的 cookie 中存 session data，使用一个名为 <code>session_data</code> 的字段。</p><p>存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sessionData = &#123;<span class="attr">username</span>: <span class="string">'alsotang'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">company</span>: <span class="string">'alibaba'</span>, <span class="attr">location</span>: <span class="string">'hangzhou'</span>&#125;</span><br></pre></td></tr></table></figure><p>这段信息的话，可以将 <code>sessionData</code> 与我们的 <code>secret_string</code> 一起做个对称加密，存到 cookie 的 <code>session_data</code> 字段中，只要你的 <code>secret_string</code> 足够长，那么攻击者也是无法获取实际 session 内容的。对称加密之后的内容对于攻击者来说相当于一段乱码。</p><p>而当用户下次访问时，我们就可以用 <code>secret_string</code> 来解密 <code>sessionData</code>，得到我们需要的 session data。</p><p>signedCookies 跟 cookie-session 还是有区别的：</p><p>1）是前者信息可见不可篡改，后者不可见也不可篡改</p><p>2）是前者一般是长期保存，而后者是 session cookie<br></p><p>cookie-session 的实现跟 signedCookies 差不多。</p><p>不过 cookie-session 我个人建议不要使用，有受到回放攻击的危险。</p><p>回放攻击指的是，比如一个用户，它现在有 100 积分，积分存在 session 中，session 保存在 cookie 中。他先复制下现在的这段 cookie，然后去发个帖子，扣掉了 20 积分，于是他就只有 80 积分了。而他现在可以将之前复制下的那段 cookie 再粘贴回去浏览器中，于是服务器在一些场景下会认为他又有了 100 积分。</p><p>如果避免这种攻击呢？这就需要引入一个第三方的手段来验证 cookie session，而验证所需的信息，一定不能存在 cookie 中。这么一来，避免了这种攻击后，使用 cookie session 的好处就荡然无存了。如果为了避免攻击而引入了缓存使用的话，那不如把 cookie session 也一起放进缓存中。</p><h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session cookie"></a>session cookie</h3><p>初学者容易犯的一个错误是，忘记了 session_id 在 cookie 中的存储方式是 session cookie。即，当用户一关闭浏览器，浏览器 cookie 中的 session_id 字段就会消失。</p><p>常见的场景就是在开发用户登陆状态保持时。</p><p>假如用户在之前登陆了你的网站，你在他对应的 session 中存了信息，当他关闭浏览器再次访问时，你还是不懂他是谁。所以我们要在 cookie 中，也保存一份关于用户身份的信息。</p><p>比如有这样一个用户</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">username</span>: <span class="string">'alsotang'</span>, <span class="attr">age</span>: <span class="number">22</span>, <span class="attr">company</span>: <span class="string">'alibaba'</span>, <span class="attr">location</span>: <span class="string">'hangzhou'</span>&#125;</span><br></pre></td></tr></table></figure><p>我们可以考虑把这四个字段的信息都存在 session 中，而在 cookie，我们用 signedCookies 来存个 username。</p><p>登陆的检验过程伪代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req.session.user) &#123;</span><br><span class="line">  <span class="comment">// 获取 user 并进行下一步</span></span><br><span class="line">  next()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.signedCookies[<span class="string">'username'</span>]) &#123;</span><br><span class="line">  <span class="comment">// 如果存在则从数据库中获取这个 username 的信息，并保存到 session 中</span></span><br><span class="line">  getuser(<span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">    req.session.user = user;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 当做为登陆用户处理</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="etag-当做-session，保存-http-会话"><a href="#etag-当做-session，保存-http-会话" class="headerlink" title="etag 当做 session，保存 http 会话"></a>etag 当做 session，保存 http 会话</h3><p>很黑客的一种玩法：<a href="https://cnodejs.org/topic/5212d82d0a746c580b43d948" target="_blank" rel="noopener">https://cnodejs.org/topic/5212d82d0a746c580b43d948</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cookie-和-session&quot;&gt;&lt;a href=&quot;#cookie-和-session&quot; class=&quot;headerlink&quot; title=&quot;cookie 和 session&quot;&gt;&lt;/a&gt;cookie 和 session&lt;/h1&gt;&lt;p&gt;众所周知，HTTP 是一个无
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>6.测试用例：mocha，should，istanbul</title>
    <link href="http://yoursite.com/2017/06/20/node%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%9Amocha%EF%BC%8Cshould%EF%BC%8Cistanbul/"/>
    <id>http://yoursite.com/2017/06/20/node测试用例：mocha，should，istanbul/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《测试用例：mocha，should，istanbul》"><a href="#《测试用例：mocha，should，istanbul》" class="headerlink" title="《测试用例：mocha，should，istanbul》"></a>《测试用例：mocha，should，istanbul》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson6 项目，在其中编写代码。</p><p>main.js: 其中有个 fibonacci 函数。fibonacci 的介绍见：<a href="http://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Fibonacci_number</a> 。</p><p>此函数的定义为 <code>int fibonacci(int n)</code></p><ul><li>当 n === 0 时，返回 0；n === 1时，返回 1;</li><li>n &gt; 1 时，返回 <code>fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)</code>，如 <code>fibonacci(10) === 55</code>;</li><li>n 不可大于10，否则抛错，因为 Node.js 的计算性能没那么强。</li><li>n 也不可小于 0，否则抛错，因为没意义。</li><li>n 不为数字时，抛错。</li></ul><p>test/main.test.js: 对 main 函数进行测试，并使行覆盖率和分支覆盖率都达到 100%。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习使用测试框架 mocha : <a href="http://mochajs.org/" target="_blank" rel="noopener">http://mochajs.org/</a></li><li>学习使用断言库 should : <a href="https://github.com/tj/should.js" target="_blank" rel="noopener">https://github.com/tj/should.js</a></li><li>学习使用测试率覆盖工具 istanbul : <a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="noopener">https://github.com/gotwarlost/istanbul</a></li><li>简单 Makefile 的编写 : <a href="http://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">http://blog.csdn.net/haoel/article/details/2886</a></li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>首先，作为一个 Node.js 项目，先执行 <code>npm init</code> 创建 package.json。</p><p>其次，建立我们的 main.js 文件，编写 <code>fibonacci</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">require</span>.main === <span class="built_in">module</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果是直接执行 main.js，则进入此处</span></span><br><span class="line">  <span class="comment">// 如果 main.js 被其他文件 require，则此处不会执行。</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="built_in">Number</span>(process.argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fibonacci('</span> + n + <span class="string">') is'</span>, fibonacci(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，这只是个简单的实现。</p><p>我们可以执行试试</p><p><code>$ node main.js 10</code></p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/1.png" alt=""></p><p>嗯，结果是 55，符合预期。</p><p>接下来我们开始测试驱动开发，现在简单的实现已经完成，那我们就对它进行一下简单测试吧。</p><p>我们先得把 main.js 里面的 fibonacci 暴露出来，这个简单。加一句</p><p><code>exports.fibonacci = fibonacci;</code>（要是看不懂这句就去补补 Node.js 的基础知识吧）</p><p>就好了。</p><p>然后我们在 <code>test/main.test.js</code> 中引用我们的 main.js，并开始一个简单的测试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: test/main.test.js</span></span><br><span class="line"><span class="keyword">var</span> main = <span class="built_in">require</span>(<span class="string">'../main'</span>);</span><br><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test/main.test.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should equal 55 when n === 10'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">10</span>).should.equal(<span class="number">55</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把测试先跑通，我们再讲这段测试代码的含义。</p><p>装个全局的 mocha: <code>$ npm install mocha -g</code>。</p><p><code>-g</code> 与 非<code>-g</code> 的区别，就是安装位置的区别，g 是 global 的意思。如果不加的话，则安装 mocha 在你的项目目录下面；如果加了，则这个 mocha 是安装在全局的，如果 mocha 有可执行命令的话，那么这个命令也会自动加入到你系统 $PATH 中的某个地方（在我的系统中，是这里 <code>/Users/alsotang/.nvm/v0.10.29/bin</code>）</p><p>在 lesson6 目录下，直接执行</p><p><code>$ mocha</code></p><p>输出应如下</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/2.png" alt=""></p><p>那么，代码中的 describe 和 it 是什么意思呢？其实就是 BDD 中的那些意思，把它们当做语法来记就好了。</p><p>大家来看看 nodeclub 中，关于 topicController 的测试文件：</p><p><a href="https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js" target="_blank" rel="noopener">https://github.com/cnodejs/nodeclub/blob/master/test/controllers/topic.test.js</a></p><p>这文件的内容没有超出之前课程的范围吧。</p><p><code>describe</code> 中的字符串，用来描述你要测的主体是什么；<code>it</code> 当中，描述具体的 case 内容。</p><p>而引入的那个 should 模块，是个断言库。玩过 ruby 的同学应该知道 <code>rspec</code>，rspec 它把测试框架和断言库的事情一起做了，而在 Node.js 中，这两样东西的作用分别是 mocha 和 should 在协作完成。</p><p>should 在 js 的 Object “基类”上注入了一个 <code>#should</code> 属性，这个属性中，又有着许许多多的属性可以被访问。</p><p>比如测试一个数是不是大于3，则是 <code>(5).should.above(3)</code>；测试一个字符串是否有着特定前缀：<code>&#39;foobar&#39;.should.startWith(&#39;foo&#39;);</code>。should.js API 在：<a href="https://github.com/tj/should.js" target="_blank" rel="noopener">https://github.com/tj/should.js</a></p><p>should.js 如果现在还是 version 3 的话，我倒是推荐大家去看看它的 API 和 源码；现在 should 是 version 4 了，API 丑得很，但为了不掉队，我还是一直用着它。我觉得 expect 麻烦，所以不用 expect，对了，expect 也是一个断言库：<a href="https://github.com/LearnBoost/expect.js/" target="_blank" rel="noopener">https://github.com/LearnBoost/expect.js/</a> 。</p><p>回到正题，还记得我们 fibonacci 函数的几个要求吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 当 n === 0 时，返回 0；n === 1时，返回 1;</span><br><span class="line">* n &gt; 1 时，返回 `fibonacci(n) === fibonacci(n-1) + fibonacci(n-2)`，如 `fibonacci(10) === 55`;</span><br><span class="line">* n 不可大于10，否则抛错，因为 Node.js 的计算性能没那么强。</span><br><span class="line">* n 也不可小于 0，否则抛错，因为没意义。</span><br><span class="line">* n 不为数字时，抛错。</span><br></pre></td></tr></table></figure><p>我们用测试用例来描述一下这几个要求，更新后的 main.test.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> main = <span class="built_in">require</span>(<span class="string">'../main'</span>);</span><br><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test/main.test.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should equal 0 when n === 0'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">0</span>).should.equal(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should equal 1 when n === 1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">1</span>).should.equal(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should equal 55 when n === 10'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    main.fibonacci(<span class="number">10</span>).should.equal(<span class="number">55</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should throw when n &gt; 10'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      main.fibonacci(<span class="number">11</span>);</span><br><span class="line">    &#125;).should.throw(<span class="string">'n should &lt;= 10'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should throw when n &lt; 0'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      main.fibonacci(<span class="number">-1</span>);</span><br><span class="line">    &#125;).should.throw(<span class="string">'n should &gt;= 0'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'should throw when n isnt Number'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      main.fibonacci(<span class="string">'呵呵'</span>);</span><br><span class="line">    &#125;).should.throw(<span class="string">'n should be a Number'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还是比较清晰的吧？</p><p>我们这时候跑一下 <code>$ mocha</code>，会发现后三个 case 都没过。</p><p>于是我们更新 fibonacci 的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'n should be a Number'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'n should &gt;= 0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'n should &lt;= 10'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再跑一次 <code>$ mocha</code>，就过了。这就是传说中的测试驱动开发：先把要达到的目的都描述清楚，然后让现有的程序跑不过 case，再修补程序，让 case 通过。</p><p>安装一个 istanbul : <code>$ npm i istanbul -g</code></p><p>执行 <code>$ istanbul cover _mocha</code></p><p>这会比直接使用 mocha 多一行覆盖率的输出，</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/3.png" alt=""></p><p>可以看到，我们其中的分支覆盖率是 91.67%，行覆盖率是 87.5%。</p><p>打开 <code>open coverage/lcov-report/index.html</code> 看看</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson6/4.png" alt=""></p><p>其实这覆盖率是 100% 的，24 25 两行没法测。</p><p>mocha 和 istanbul 的结合是相当无缝的，只要 mocha 跑得动，那么 istanbul 就接得进来。</p><p>到此这门课其实就完了，剩下要说的内容，都是些比较细节的。比较懒的同学可以踩坑了之后再回来看。</p><p>上面的课程，不完美的地方就在于 mocha 和 istanbul 版本依赖的问题，但为了不引入不必要的复杂性，所以上面就没提到这点了。</p><p>假设你有一个项目A，用到了 mocha 的 version 3，其他人有个项目B，用到了 mocha 的 version 10，那么如果你 <code>npm i mocha -g</code> 装的是 version 3 的话，你用 <code>$ mocha</code> 是不兼容B项目的。因为 mocha 版本改变之后，很可能语法也变了，对吧。</p><p>这时，跑测试用例的正确方法，应该是</p><ol><li><code>$ npm i mocha --save-dev</code>，装个 mocha 到项目目录中去</li><li><code>$ ./node_modules/.bin/mocha</code>，用刚才安装的这个特定版本的 mocha，来跑项目的测试代码。</li></ol><p><code>./node_modules/.bin</code> 这个目录下放着我们所有依赖自带的那些可执行文件。</p><p>每次输入这个很麻烦对吧？所以我们要引入 Makefile，让 Makefile 帮我们记住复杂的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">  ./node_modules/.bin/mocha</span><br><span class="line"></span><br><span class="line">cov test-cov:</span><br><span class="line">  ./node_modules/.bin/istanbul cover _mocha</span><br><span class="line"></span><br><span class="line">.PHONY: test cov test-cov</span><br></pre></td></tr></table></figure><p>这时，我们只需要调用 <code>make test</code> 或者 <code>make cov</code>，就可以跑我们相应的测试了。</p><p>至于 Makefile 怎么写？以及 .PHONY 是什么意思，请看这里：<a href="http://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">http://blog.csdn.net/haoel/article/details/2886</a> ，左耳朵耗子陈皓2004年的文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《测试用例：mocha，should，istanbul》&quot;&gt;&lt;a href=&quot;#《测试用例：mocha，should，istanbul》&quot; class=&quot;headerlink&quot; title=&quot;《测试用例：mocha，should，istanbul》&quot;&gt;&lt;/a&gt;《测
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>8.benchmark 怎么写</title>
    <link href="http://yoursite.com/2017/06/20/nodebenchmark%20%E6%80%8E%E4%B9%88%E5%86%99/"/>
    <id>http://yoursite.com/2017/06/20/nodebenchmark 怎么写/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《benchmark-怎么写》"><a href="#《benchmark-怎么写》" class="headerlink" title="《benchmark 怎么写》"></a>《benchmark 怎么写》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>有一个字符串 <code>var number = &#39;100&#39;</code>，我们要将它转换成 Number 类型的 100。</p><p>目前有三个选项：+, parseInt, Number</p><p>请测试哪个方法更快。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习使用 benchmark 库</li><li>学习使用 <a href="http://jsperf.com/" target="_blank" rel="noopener">http://jsperf.com/</a> 分享你的 benchmark</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>首先去弄个 benchmark 库，<a href="https://github.com/bestiejs/benchmark.js" target="_blank" rel="noopener">https://github.com/bestiejs/benchmark.js</a> 。</p><p><del> 这个库已经两年没有更新了，两年前发了个 1.0.0 版本，直到现在。 </del></p><p>这个库的最新版本是 2.1.0</p><p>用法也特别简单，照着官网的 copy 下来就好。</p><p>我们先来实现这三个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> int1 = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> int2 = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> int3 = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Number</span>(str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后照着官方的模板写 benchmark suite：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="string">'100'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加测试</span></span><br><span class="line">suite</span><br><span class="line">.add(<span class="string">'+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  int1(number);</span><br><span class="line">&#125;)</span><br><span class="line">.add(<span class="string">'parseInt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  int2(number);</span><br><span class="line">&#125;)</span><br><span class="line">.add(<span class="string">'Number'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  int3(number);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 每个测试跑完后，输出信息</span></span><br><span class="line">.on(<span class="string">'cycle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target));</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Fastest is '</span> + <span class="keyword">this</span>.filter(<span class="string">'fastest'</span>).map(<span class="string">'name'</span>));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里的 async 不是 mocha 测试那个 async 的意思，这个选项与它的时间计算有关，默认勾上就好了。</span></span><br><span class="line">.run(&#123; <span class="string">'async'</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>直接运行：</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson10/1.png" alt=""></p><p>可以看到，parseInt 是最快的。</p><h3 id="在线分享"><a href="#在线分享" class="headerlink" title="在线分享"></a>在线分享</h3><p>如果想要在线分享你的 js benchmark，用这个网站：<a href="http://jsperf.com/" target="_blank" rel="noopener">http://jsperf.com/</a> 。</p><p>比如我在上面测试 <code>Math.log</code> 的效率：</p><p><a href="http://jsperf.com/math-perf-alsotang" target="_blank" rel="noopener">http://jsperf.com/math-perf-alsotang</a></p><p>进入之后点击那个 <code>Run tests</code> 按钮，就可以在浏览器中看到它们的效率差异了，毕竟浏览器也是可以跑 js 的。</p><p>点击这里：<a href="http://jsperf.com/math-perf-alsotang/edit" target="_blank" rel="noopener">http://jsperf.com/math-perf-alsotang/edit</a> ，就可以看到这个 benchmark 是怎么配置的，很简单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《benchmark-怎么写》&quot;&gt;&lt;a href=&quot;#《benchmark-怎么写》&quot; class=&quot;headerlink&quot; title=&quot;《benchmark 怎么写》&quot;&gt;&lt;/a&gt;《benchmark 怎么写》&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>5.使用 async 控制并发</title>
    <link href="http://yoursite.com/2017/06/20/node%E4%BD%BF%E7%94%A8%20eventproxy%20%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2017/06/20/node使用 eventproxy 控制并发/</id>
    <published>2017-06-20T01:35:08.000Z</published>
    <updated>2018-03-29T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《使用-async-控制并发》"><a href="#《使用-async-控制并发》" class="headerlink" title="《使用 async 控制并发》"></a>《使用 async 控制并发》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>建立一个 lesson5 项目，在其中编写代码。</p><p>代码的入口是 <code>app.js</code>，当调用 <code>node app.js</code> 时，它会输出 CNode(<a href="https://cnodejs.org/" target="_blank" rel="noopener">https://cnodejs.org/</a> ) 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。</p><p>注意：与上节课不同，并发连接数需要控制在 5 个。</p><p>输出示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"【公告】发招聘帖的同学留意一下这里"</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://cnodejs.org/topic/541ed2d05e28155f24676a12"</span>,</span><br><span class="line">    <span class="string">"comment1"</span>: <span class="string">"呵呵呵呵"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"发布一款 Sublime Text 下的 JavaScript 语法高亮插件"</span>,</span><br><span class="line">    <span class="string">"href"</span>: <span class="string">"http://cnodejs.org/topic/54207e2efffeb6de3d61f68f"</span>,</span><br><span class="line">    <span class="string">"comment1"</span>: <span class="string">"沙发！"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>学习 async(<a href="https://github.com/caolan/async" target="_blank" rel="noopener">https://github.com/caolan/async</a> ) 的使用。这里有个详细的 async demo 演示：<a href="https://github.com/alsotang/async_demo" target="_blank" rel="noopener">https://github.com/alsotang/async_demo</a></li><li>学习使用 async 来控制并发连接数。</li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>lesson4 的代码其实是不完美的。为什么这么说，是因为在 lesson4 中，我们一次性发了 40 个并发请求出去，要知道，除去 CNode 的话，别的网站有可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的 IP 封掉。</p><p>我们在写爬虫的时候，如果有 1000 个链接要去爬，那么不可能同时发出 1000 个并发链接出去对不对？我们需要控制一下并发的数量，比如并发 10 个就好，然后慢慢抓完这 1000 个链接。</p><p>用 async 来做这件事很简单。</p><p>这次我们要介绍的是 async 的 <code>mapLimit(arr, limit, iterator, callback)</code> 接口。另外，还有个常用的控制并发连接数的接口是 <code>queue(worker, concurrency)</code>，大家可以去 <a href="https://github.com/caolan/async#queueworker-concurrency" target="_blank" rel="noopener">https://github.com/caolan/async#queueworker-concurrency</a> 看看说明。</p><p>这回我就不带大家爬网站了，我们来专注知识点：并发连接数控制。</p><p>对了，还有个问题是，什么时候用 eventproxy，什么时候使用 async 呢？它们不都是用来做异步流程控制的吗？</p><p>我的答案是：</p><p>当你需要去多个源(一般是小于 10 个)汇总数据的时候，用 eventproxy 方便；当你需要用到队列，需要控制并发数，或者你喜欢函数式编程思维时，使用 async。大部分场景是前者，所以我个人大部分时间是用 eventproxy 的。</p><p>正题开始。</p><p>首先，我们伪造一个 <code>fetchUrl(url, callback)</code> 函数，这个函数的作用就是，当你通过</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetchUrl(<span class="string">'http://www.baidu.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something with `content`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>调用它时，它会返回 <code>http://www.baidu.com</code> 的页面内容回来。</p><p>当然，我们这里的返回内容是假的，返回延时是随机的。并且在它被调用时，会告诉你它现在一共被多少个地方并发调用着。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发连接数的计数器</span></span><br><span class="line"><span class="keyword">var</span> concurrencyCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fetchUrl = <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// delay 的值在 2000 以内，是个随机的整数</span></span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">parseInt</span>((<span class="built_in">Math</span>.random() * <span class="number">10000000</span>) % <span class="number">2000</span>, <span class="number">10</span>);</span><br><span class="line">  concurrencyCount++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'现在的并发数是'</span>, concurrencyCount, <span class="string">'，正在抓取的是'</span>, url, <span class="string">'，耗时'</span> + delay + <span class="string">'毫秒'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    concurrencyCount--;</span><br><span class="line">    callback(<span class="literal">null</span>, url + <span class="string">' html content'</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们接着来伪造一组链接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">  urls.push(<span class="string">'http://datasource_'</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这组链接的长这样：</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson5/1.png" alt=""></p><p>接着，我们使用 <code>async.mapLimit</code> 来并发抓取，并获取结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(urls, <span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  fetchUrl(url, callback);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'final:'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行输出是这样的：</p><p><img src="https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson5/2.png" alt=""></p><p>可以看到，一开始，并发链接数是从 1 开始增长的，增长到 5 时，就不再增加。当其中有任务完成时，再继续抓取。并发连接数始终控制在 5 个。</p><p>完整代码请参见 app.js 文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《使用-async-控制并发》&quot;&gt;&lt;a href=&quot;#《使用-async-控制并发》&quot; class=&quot;headerlink&quot; title=&quot;《使用 async 控制并发》&quot;&gt;&lt;/a&gt;《使用 async 控制并发》&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="NodeJS" scheme="http://yoursite.com/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
</feed>
