<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>18.何为 connect 中间件 | _sUper.LEE的个人空间</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="NodeJS">
    <meta name="description" content="《何为 connect 中间件》目标 理解中间件的概念 了解 Connect 的实现  课程内容 原生 httpServer 遇到的问题 中间件思想 Connect 实现 Express 简介  这是从 httpServer 到 Express 的升级过程。 HTTPNodejs 的经典 httpServer 代码 1234567var http = require(&apos;http&apos;);var ser">
<meta name="keywords" content="NodeJS">
<meta property="og:type" content="article">
<meta property="og:title" content="18.何为 connect 中间件">
<meta property="og:url" content="http://yoursite.com/2017/06/20/何为 connect 中间件/index.html">
<meta property="og:site_name" content="_sUper.LEE的个人空间">
<meta property="og:description" content="《何为 connect 中间件》目标 理解中间件的概念 了解 Connect 的实现  课程内容 原生 httpServer 遇到的问题 中间件思想 Connect 实现 Express 简介  这是从 httpServer 到 Express 的升级过程。 HTTPNodejs 的经典 httpServer 代码 1234567var http = require(&apos;http&apos;);var ser">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-03-29T10:23:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="18.何为 connect 中间件">
<meta name="twitter:description" content="《何为 connect 中间件》目标 理解中间件的概念 了解 Connect 的实现  课程内容 原生 httpServer 遇到的问题 中间件思想 Connect 实现 Express 简介  这是从 httpServer 到 Express 的升级过程。 HTTPNodejs 的经典 httpServer 代码 1234567var http = require(&apos;http&apos;);var ser">
    
        <link rel="alternate" type="application/atom+xml" title="_sUper.LEE的个人空间" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>
    <style>
                .timeline #cloud-tie-wrapper{
            display: none;
        }
        body .page-content .timeline:before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            z-index: -1;
            width: 4px;
            height: 100%;
            margin-left: -2px;
            background: #dadada;
        }
        /* // 时间线 */
        body #busuanzi_container_page_pv{
            display: none!important;
        }
        body .comments{
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                padding: 42px 26px 0;
        }
        body .post-copyright .content{
                margin-bottom: 0em; 
            padding: 0px; 
        }
        body img{
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/3.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/logo.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">_sUper.LEE</h5>
          <a href="mailto:1213219813@qq.com" title="1213219813@qq.com" class="mail">1213219813@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tools"  >
                <i class="icon icon-lg icon-th-list"></i>
                工具资源
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
      
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">18.何为 connect 中间件</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="global.search_input_hint">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">18.何为 connect 中间件</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-06-20T01:35:08.000Z" itemprop="datePublished" class="page-time">
  2017-06-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/NodeJS/">NodeJS</a></li></ul>

            
        </h5>
    </div>

    

 
</header>
        <!-- //particles 
  <div id="particles-js"></div>
    <style type="text/css">
        #particles-js {
               position: absolute;
                top: 0;
                width: 100%;
                z-index: -1;
                /* background-color: #26AFE3; */
                left: 0;
                bottom: 0;
                right: 0;
        }
    </style> -->


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#《何为-connect-中间件》"><span class="post-toc-number">1.</span> <span class="post-toc-text">《何为 connect 中间件》</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#目标"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">目标</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#课程内容"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">课程内容</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#HTTP"><span class="post-toc-number">2.</span> <span class="post-toc-text">HTTP</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Connect的实现"><span class="post-toc-number">3.</span> <span class="post-toc-text">Connect的实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#createServer"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">createServer()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#app-handle-req-res-out"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">app.handle(req, res, out)</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Express"><span class="post-toc-number">4.</span> <span class="post-toc-text">Express</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#总结"><span class="post-toc-number">5.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-何为 connect 中间件"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">18.何为 connect 中间件</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-06-20 09:35:08" datetime="2017-06-20T01:35:08.000Z"  itemprop="datePublished">2017-06-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/NodeJS/">NodeJS</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="《何为-connect-中间件》"><a href="#《何为-connect-中间件》" class="headerlink" title="《何为 connect 中间件》"></a>《何为 connect 中间件》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>理解中间件的概念</li>
<li>了解 Connect 的实现</li>
</ol>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol>
<li>原生 httpServer 遇到的问题</li>
<li>中间件思想</li>
<li>Connect 实现</li>
<li>Express 简介</li>
</ol>
<p>这是从 httpServer 到 Express 的升级过程。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>Nodejs 的经典 httpServer 代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(requestHandler);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">'hello visitor!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>里面的函数 <code>requestHandler</code> 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。</p>
<p>通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 <code>hello visitor!</code>。</p>
<p>然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 检测请求中请求体是否存在，若存在则解析请求体；</span><br><span class="line">1. 查看请求体中的id是否存在，若存在则去数据库查询；</span><br><span class="line">1. 根据数据库结果返回约定的值；</span><br></pre></td></tr></table></figure>
<p>我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。</p>
<p>实现代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBody</span>(<span class="params">req, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据http协议从req中解析body</span></span><br><span class="line">  callback(<span class="literal">null</span>, body);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIdInDatabase</span>(<span class="params">body, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据body.id在Database中检测，返回结果</span></span><br><span class="line">  callback(<span class="literal">null</span>, dbResult);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnResult</span>(<span class="params">dbResult, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dbResult &amp;&amp; dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.end(<span class="string">'true'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end(<span class="string">'false'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(body, <span class="function"><span class="keyword">function</span>(<span class="params">err, dbResult</span>) </span>&#123;</span><br><span class="line">      returnResult(dbResult, res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的解决方案解决了包含三个步骤的业务问题，出现了3个 <code>});</code> 还有3个 <code>err</code> 需要处理，上面的写法可以得达到预期效果。</p>
<p>然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 <code>});</code> 及30个 <code>err</code>异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 <strong>多次返回</strong> 或返回地方不对等问题，这就是 <strong>回调金字塔</strong> 问题了。</p>
<p>大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。</p>
<ul>
<li><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="noopener">EventProxy</a> —— 事件发布订阅模式(第四课讲到)</li>
<li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">BlueBird</a> —— Promise方案(第十七课讲到)</li>
<li><a href="https://github.com/caolan/async" target="_blank" rel="noopener">Async</a> —— 异步流程控制库(第五课讲到)</li>
<li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator</a> —— ES6原生Generator</li>
</ul>
<p>理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 <code>类似异步流程控制的思想</code> 。</p>
<p><a name="next"></a><br>关于异步流程控制库下面简要介绍下，或移步<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="noopener">@第五课</a>。<br>异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 <strong>顺序执行</strong> 。</p>
<p>callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数</p>
<p>我们动手实现一个类似的链式调用，其中 <code>funlist</code> 更名为 <code>middlewares</code>、<code>callback</code> 更名为 <code>next</code>，码如下：</p>
<p><a name="middlewares" comment="middlewares锚点"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middlewares = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      req.body = body;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    checkIdInDatabase(req.body.id, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">      res.dbResult = rows;</span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.dbResult &amp;&amp; res.dbResult.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      res.end(<span class="string">'true'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.end(<span class="string">'false'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//由middlewares链式调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.end(<span class="string">'error:'</span>, err.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i&lt;middlewares.length) &#123;</span><br><span class="line">      middlewares[i++](req, res, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//触发第一个middleware</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面用middlewares+next完成了业务逻辑的 <code>链式调用</code>，而middlewares里的每个函数，都是一个 <code>中间件</code>。</p>
<p>整体思路是：</p>
<ol>
<li>将所有 <code>处理逻辑函数(中间件)</code> 存储在一个list中；</li>
<li>请求到达时 <code>循环调用</code> list中的 <code>处理逻辑函数(中间件)</code>；</li>
</ol>
<h1 id="Connect的实现"><a href="#Connect的实现" class="headerlink" title="Connect的实现"></a><a href="https://github.com/senchalabs/connect" target="_blank" rel="noopener">Connect</a>的实现</h1><p>Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。</p>
<p>Connect中主要有五个函数<br>PS: Connect的核心代码是200+行，建议对照<a href="https://github.com/senchalabs/connect/blob/master/index.js" target="_blank">源码</a>看下面的函数介绍。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>createServer</td>
<td style="text-align:center">包装httpServer形成app</td>
</tr>
<tr>
<td>listen</td>
<td style="text-align:center">监听端口函数</td>
</tr>
<tr>
<td>use</td>
<td style="text-align:center">向middlewares里面放入业务逻辑</td>
</tr>
<tr>
<td>handle</td>
<td style="text-align:center">上一章的requestHandler函数增强版</td>
</tr>
<tr>
<td>call</td>
<td style="text-align:center">业务逻辑的真正执行者</td>
</tr>
</tbody>
</table>
<h2 id="createServer"><a href="#createServer" class="headerlink" title="createServer()"></a>createServer()</h2><p><strong>输入</strong>:</p>
<p>无</p>
<p><strong>执行过程</strong>:</p>
<ol>
<li>app是一个函数对象(包含handle方法)</li>
<li>app具有Event所有属性(详见<a href="https://github.com/jaredhanson/utils-merge" target="_blank" rel="noopener">utils-merge</a>，十行代码)</li>
<li>app有route属性(路由)、和stack属性(用于存储中间件，类似上面的<a href="#middlewares">middlewares</a>)</li>
</ol>
<p><strong>输出</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     app is function(req, res, next) &#123;...&#125;;</span><br><span class="line">      |</span><br><span class="line">  +---+---+</span><br><span class="line">  |  has  |</span><br><span class="line">route   stack</span><br></pre></td></tr></table></figure>
<p>##app.use(route, fn)</p>
<p>作用是向stack中添加 <code>逻辑处理函数</code> (中间件)。</p>
<p><strong>输入</strong>:</p>
<ol>
<li>route 可省略，默认’/‘</li>
<li>fn 具体的业务处理逻辑</li>
</ol>
<p><strong>tips:</strong></p>
<p>上面的fn表示处理逻辑，它可以是</p>
<ol>
<li>一个普通的 <code>function(req,res[,next]){}</code>；</li>
<li>一个<a href="https://lodejs.org/api/http.html#http_class_http_server" target="_blank" rel="noopener">httpServer</a>；</li>
<li>另一个connect的app对象(<strong>sub app特性</strong>)；</li>
</ol>
<p>由于它们的本质都是 <code>处理逻辑</code>，都可以用一个 <code>function(req,res,next){}</code>将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。</p>
<p>如何将这三种分别转换为 function(req, res, next) {}的形式呢？</p>
<ol>
<li>不用转换；</li>
<li>httpServer的定义是“对事件’request’后handler的对象”，我们可以从httpServer.listeners(‘request’)中得到这个函数；</li>
<li>另一个connect对象，而connect()返回的app就是function(req, res, out) {}；</li>
</ol>
<p><strong>执行过程</strong>:</p>
<ol>
<li>将三种<code>处理逻辑</code>统一转换为<code>function(req,res,next){}</code>的形式表示。</li>
<li>把这个<code>处理逻辑</code>与route一起，放入<code>stack</code>中(存储处理逻辑，route用来匹配路由)</li>
</ol>
<p>核心代码片段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//route是路由路径，handle是一个`function(req, res, next) &#123;...&#125;`形式的业务逻辑</span></span><br><span class="line"><span class="keyword">this</span>.stack.push(&#123; <span class="attr">route</span>: path, <span class="attr">handle</span>: handle &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>返回</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回自己，可以完成链式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p><strong>总结:</strong>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(<span class="string">'/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.stack.push(&#123;<span class="attr">route</span>: <span class="string">'/api'</span>, <span class="attr">handle</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>最后，app.stack里 <strong>顺序存储</strong> 了所有的 <strong>逻辑处理函数</strong> (中间件)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.stack = [function1, function2, function3, ... function30];</span><br></pre></td></tr></table></figure>
<h2 id="app-handle-req-res-out"><a href="#app-handle-req-res-out" class="headerlink" title="app.handle(req, res, out)"></a>app.handle(req, res, out)</h2><p>这个函数就是请求到达时，负责 <code>顺序调用</code> 我们存储在stack中的 <code>逻辑处理函数</code> (中间件)函数，类似上一章的requestHandler。</p>
<p><strong>输入:</strong></p>
<ol>
<li>req是Nodejs本身的可读流，不做过多介绍</li>
<li>res是Nodejs本身的可写流，不做过多介绍</li>
<li>out是为了Connect的 <strong>sub app特性</strong> 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心</li>
</ol>
<p><strong>处理过程:</strong></p>
<p>可以回头看一下上面的<a href="#middlewares">requestHandler函数</a>，handle的实现是这个函数的增强版</p>
<ol>
<li>取得stack(存储<code>逻辑处理函数</code>列表)，index(列表下标)</li>
<li>构建next函数，next的作用是执行下一个<code>逻辑处理函数</code></li>
<li>触发第一个next，触发链式调用</li>
</ol>
<p><strong>next函数实现:</strong></p>
<p>next函数实现在handle函数体内，用来<code>顺序执行处理逻辑</code>，它是异步流程控制库的核心，不明白它的作用请看<a href="#next">上面的异步流程控制库简介</a></p>
<p>path是请求路径，route是<code>逻辑处理函数</code>自带的属性。</p>
<ol>
<li>取得下一个<code>逻辑处理函数</code>;</li>
<li>若路由不匹配，跳过此逻辑;</li>
<li>若路由匹配<a href="#call">下面的call</a>执行匹配到的<code>逻辑处理函数</code></li>
</ol>
<p>tips: 跟上一章最后的代码一样，每个<code>逻辑处理函数</code>调用<code>next</code>来让后面的函数执行，存储在stack中的函数就实现了<code>链式调用</code>。不一定所有的函数都在返回的时候才调用<code>next</code>，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。</p>
<p>核心代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取下一个逻辑逻辑处理函数</span></span><br><span class="line"><span class="number">1</span>:  <span class="keyword">var</span> layer = stack[index++];</span><br><span class="line"><span class="comment">//不匹配时跳过</span></span><br><span class="line"><span class="number">2</span>:  <span class="keyword">if</span> (path.toLowerCase().substr(<span class="number">0</span>, route.length) !== route.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//匹配时执行</span></span><br><span class="line"><span class="number">3</span>:  call(layer.handle, route, err, req, res, next);</span><br></pre></td></tr></table></figure>
<p><strong>返回:</strong></p>
<p>无</p>
<p><strong>总结:</strong></p>
<p>画图总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">request come</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware1 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware2 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware3 :  匹配路由，执行</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">middleware4 :  不匹配路由，skip</span><br><span class="line">     |</span><br><span class="line">     v</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p><a name="call"></a></p>
<p>##call(handle, route, err, req, res, next)</p>
<blockquote>
<p>这里有个比较有趣的知识，<code>console.log(Function.length)</code>会返回函数定义的参数个数。值跟在函数体内执行<code>arguments.length</code>一样。</p>
</blockquote>
<p>Connect中规定<code>function(err, req, res, next) {}</code>形式为错误处理函数，<code>function(req, res, next) {}</code>为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。</p>
<p><strong>输入:</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>handle</td>
<td style="text-align:center">逻辑处理函数</td>
</tr>
<tr>
<td>route</td>
<td style="text-align:center">路由</td>
</tr>
<tr>
<td>err</td>
<td style="text-align:center">是否发生过错误</td>
</tr>
<tr>
<td>req</td>
<td style="text-align:center">Nodejs对象</td>
</tr>
<tr>
<td>res</td>
<td style="text-align:center">Nodejs对象</td>
</tr>
<tr>
<td>next</td>
<td style="text-align:center">next函数</td>
</tr>
</tbody>
</table>
<p><strong>处理过程:</strong></p>
<ol>
<li>是否有错误，本次handle是否是错误处理函数;</li>
<li>若有错误且handle为错误处理函数，则执行handle，本函数返回;</li>
<li>若没错误且handle不是错误处理函数，则执行handle，本函数返回;</li>
<li>如果上面两个都不满足，不执行handle，本函数调用next，返回;</li>
</ol>
<p><strong>返回:</strong></p>
<p>无</p>
<p><strong>总结:</strong></p>
<p>call函数是一个执行者，根据当前<code>错误情况</code>和<code>handle类型</code>决定<code>是否执行</code>当前的handle。</p>
<p>##listen</p>
<p>创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口</p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>##图解Connect</p>
<p>Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。</p>
<p>图形总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">request               app(out)</span><br><span class="line">   |                          yes</span><br><span class="line">   +------------------&gt;match?-----&gt;middleware1</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware2</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        next&lt;----------+</span><br><span class="line">                         |</span><br><span class="line">                         v    yes</span><br><span class="line">                      match?------&gt;middleware3</span><br><span class="line">                         | no          |</span><br><span class="line">                         v             |</span><br><span class="line">                        out&lt;-----------+</span><br><span class="line">                         |</span><br><span class="line">   +---------------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure>
<p>##Connect的subapp特性</p>
<p>我们再看看Connect是怎么实现subapp的，比较有趣。</p>
<p>什么是subapp?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var sub_app = connect();</span><br><span class="line">var app = connect();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/route1&apos;, sub_app);</span><br><span class="line">// request path: &apos;/route1/route2&apos;</span><br><span class="line">// 由app接收到请求后，切割 path为&apos;/route2&apos;转交给sub_app的处理逻辑处理</span><br><span class="line">// 再由sub_app返回到app，由app继续向下执行处理逻辑</span><br></pre></td></tr></table></figure>
<p>结合上面的函数画图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request               app(out1)                 sub_app(out2)</span><br><span class="line">   |</span><br><span class="line">   +---------------&gt;middleware1     +------------&gt;middleware1</span><br><span class="line">                         |          |                 |</span><br><span class="line">                        next        |                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                    middleware2-----+            middleware2</span><br><span class="line">                                                      |</span><br><span class="line">                       next&lt;--------+                next</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                     middleware3    |            middleware3</span><br><span class="line">                         |          |                 |</span><br><span class="line">                         v          |                 v</span><br><span class="line">                        out1        |                out2</span><br><span class="line">                         |          |                 |</span><br><span class="line">   +---------------------+          +-----------------+</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">  end(response在处理过程中已经返回了)</span><br></pre></td></tr></table></figure>
<p>完成上面的sub_app只需要做到两点：</p>
<ol>
<li>从app的调用链进入到sub_app的调用链中;</li>
<li>从sub_app的逻辑回到app的调用链中;</li>
</ol>
<p>connect在handle函数中的第三个参数<code>out</code>为这个特性实现提供可能。<code>out</code>的特点是<code>在middlewares链式调用完成以后调用</code>。<strong>那么将app的next作为sub_app的out传入sub_app的handle中</strong>可以做到sub_app自己的业务逻辑处理完后调用<code>out</code>，即处理权回到了本app的<code>next</code>手里。</p>
<p>上面图中的<code>sub_app.out2===app.next</code>，所以能完成逻辑的交接和sub app调用。</p>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a><a href="https://github.com/strongloop/express" target="_blank" rel="noopener">Express</a></h1><p>大家都知道Express是Connect的升级版。</p>
<p>Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。</p>
<p>Express大概可以分为几个模块</p>
<table>
<thead>
<tr>
<th>模块</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>router</td>
<td style="text-align:center">路由模块是Connect升级版</td>
</tr>
<tr>
<td>request</td>
<td style="text-align:center">经过Express封装的req对象</td>
</tr>
<tr>
<td>response</td>
<td style="text-align:center">经过Express封装的res对象</td>
</tr>
<tr>
<td>application</td>
<td style="text-align:center">app上面的各种默认设置</td>
</tr>
</tbody>
</table>
<p>简要介绍一下每个模块</p>
<p>##Router</p>
<p>在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版</p>
<ol>
<li>正则匹配route;</li>
<li>进行将http的方法在route中分解开;</li>
</ol>
<p>##Request</p>
<p>在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是<br>req.param。</p>
<p>##Response</p>
<p>在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、<br>res.render、res.redirect、res.sendFile等等。</p>
<p>我们可以拓展它写一个res.sendPersonInfoById。</p>
<blockquote>
<p>关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑，<br>我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解<br>耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。</p>
</blockquote>
<p>##Application</p>
<p>除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。</p>
<p>##Express小结</p>
<p>Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express<br>本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、<br>connect-redis等。</p>
<p>实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析<br>body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑；<br><a href="https://github.com/koajs/koa" target="_blank" rel="noopener">Koa</a>用Generator方法解决回调问题；</p>
<p>我们应该也可以用事件、Promise的方式实现；</p>
<p>PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        

        
    </div>
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/logo.jpg" alt="_sUper.LEE">
            _sUper.LEE
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NodeJS/">NodeJS</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/06/20/何为 connect 中间件/&title=《18.何为 connect 中间件》 — _sUper.LEE的个人空间&pic=http://yoursite.com/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/06/20/何为 connect 中间件/&title=《18.何为 connect 中间件》 — _sUper.LEE的个人空间&source=LEE Blog" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/06/20/何为 connect 中间件/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《18.何为 connect 中间件》 — _sUper.LEE的个人空间&url=http://yoursite.com/2017/06/20/何为 connect 中间件/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/06/20/何为 connect 中间件/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/06/20/nodebenchmark 怎么写/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">8.benchmark 怎么写</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/06/20/node学习使用外部模块/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">学习使用外部模块</h4>
      </a>
    </div>
  
</nav>



    





<section class="comments" id="comments">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script src="http://v2.uyan.cc/code/uyan.js?uid=true"></script>
    <!-- UY END -->
</section>










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/ewm.png" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <!-- <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>footer.license</span>
        </p>
    </div> -->
    <div class="bottom">
        <p><span>_sUper.LEE &copy; 2015 - 2018</span>
            <span>
                
                <!-- Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a> -->
            </span>
        </p>
    </div>
  
</footer>

    </main>
    <div class="mask" id="mask">
  
</div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/06/20/何为 connect 中间件/&title=《18.何为 connect 中间件》 — _sUper.LEE的个人空间&pic=http://yoursite.com/img/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/06/20/何为 connect 中间件/&title=《18.何为 connect 中间件》 — _sUper.LEE的个人空间&source=LEE Blog" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/06/20/何为 connect 中间件/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《18.何为 connect 中间件》 — _sUper.LEE的个人空间&url=http://yoursite.com/2017/06/20/何为 connect 中间件/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/06/20/何为 connect 中间件/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3a3W7CMAwGUN7/pZm0W9Ty2W6nNTm5QgiaHCZ5/snrFa/37/p8ff7O5zr6/Oe3XncsDAyMxzLep+t84+Rp+c9x9Jnzs2FgYOzDyB+XbJbHw/MnJGfDwMDA6CV/1fwt+bEwMDAwegE3P1CvxMXAwMCoFrH5xr31R7U4BgbGAxmTwcDdr/9ovoGBgfGPGXcExGoqOV8YGBhrM/LLE0mI7A1Br2rAYWBgrMqoXonoBdBJUpi07TAwMHZjTIrMCTgJ94fJKAYGxjaMC8rIQdJZzfEwMDB2Y0RXGeLNesheIV3/KAYGxvMYvQ3yeWJ18pgPFaKzYWBgLMeoBse8BE2Om4fXL9/CwMBYjtG7HpE31PIQXG38YWBg7MaoNrl6l8MmY4AvbAwMjKUZ1SZa/k4vraymhs1eIAYGxqMY88FkL6WrBtYvTUAMDIylGZNjVceK1abbqF+IgYGxHKN3waKaLCYBN/8HMJpvYGBgPJBRLV+rrbTq+DMfi46qcAwMjIcw7uje5UletTwu/x0wMDAWYuRFYzLmrD75gitoGBgYSzOq44FeeC1clQhWdM0CAwNjIca7uJLErtr0nxS6h7fbMDAwFmJUw1y1cqw+M7+u0QvWGBgYz2X0gmzeGuuNAcpJJwYGxgaMq9pevYRyHvQxMDAwJmlcdbTZLKQxMDAwWltOBpl5Iw8DA2MfRnKI3sCg19bPL2RgYGDswJgUkNWLYsk4s9qSw8DAWJrxA4ZNDyyJG7zDAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


<!-- <script src="//unpkg.com/hexo-theme-material-indigo@latest/js/particles.min.js"></script>
<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/app.min.js"></script> -->
</body>
</html>
